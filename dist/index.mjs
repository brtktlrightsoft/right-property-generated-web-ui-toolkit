import * as React$1 from "react";
import React, { Component, Fragment, createContext, createElement, forwardRef, isValidElement, memo, startTransition, useCallback, useContext, useEffect, useId, useImperativeHandle, useInsertionEffect, useLayoutEffect, useMemo, useRef, useState, useTransition } from "react";
import { Fragment as Fragment$1, jsx, jsxs } from "react/jsx-runtime";
import * as ReactDOM$1 from "react-dom";
import ReactDOM, { createPortal, flushSync } from "react-dom";
var __create$7 = Object.create, __defProp$8 = Object.defineProperty, __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor, __getOwnPropNames$1 = Object.getOwnPropertyNames, __getProtoOf$1 = Object.getPrototypeOf, __hasOwnProp$8 = Object.prototype.hasOwnProperty, __esmMin = (m, x) => () => (m && (x = m(m = 0)), x), __commonJSMin = (m, x) => () => (x || m((x = { exports: {} }).exports, x), x.exports), __export = (m) => {
	let x = {};
	for (var S in m) __defProp$8(x, S, {
		get: m[S],
		enumerable: !0
	});
	return x;
}, __copyProps$1 = (m, x, S, C) => {
	if (x && typeof x == "object" || typeof x == "function") for (var T = __getOwnPropNames$1(x), D = 0, O = T.length, k; D < O; D++) k = T[D], !__hasOwnProp$8.call(m, k) && k !== S && __defProp$8(m, k, {
		get: ((m) => x[m]).bind(null, k),
		enumerable: !(C = __getOwnPropDesc$7(x, k)) || C.enumerable
	});
	return m;
}, __toESM$1 = (m, x, S) => (S = m == null ? {} : __create$7(__getProtoOf$1(m)), __copyProps$1(x || !m || !m.__esModule ? __defProp$8(S, "default", {
	value: m,
	enumerable: !0
}) : S, m)), __toCommonJS = (m) => __copyProps$1(__defProp$8({}, "__esModule", { value: !0 }), m), __require = /* @__PURE__ */ ((m) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(m, { get: (m, x) => (typeof require < "u" ? require : m)[x] }) : m)(function(m) {
	if (typeof require < "u") return require.apply(this, arguments);
	throw Error("Calling `require` for \"" + m + "\" in an environment that doesn't expose the `require` function.");
}), UiToolkitContext = createContext(null);
function UiToolkitProvider({ children: m, config: x }) {
	return /* @__PURE__ */ jsx(UiToolkitContext.Provider, {
		value: x,
		children: m
	});
}
function useUiToolkitConfig() {
	let m = useContext(UiToolkitContext);
	if (!m) throw Error("useUiToolkitConfig must be used within a UiToolkitProvider");
	return m;
}
function useUiToolkitConfigOptional() {
	return useContext(UiToolkitContext);
}
function useTranslation() {
	let m = useContext(UiToolkitContext);
	return {
		t: useCallback((x) => m && m.translations[x] || x, [m]),
		locale: m?.locale ?? "en"
	};
}
function useMainModuleResult() {
	let m = useContext(UiToolkitContext);
	if (!m) throw Error("useMainModuleResult must be used within a UiToolkitProvider");
	return m.mainModuleResult;
}
var PlotRepository = class {
	constructor() {
		this.config = null;
	}
	configure(m) {
		this.config = m;
	}
	getConfig() {
		if (!this.config) throw Error("PlotRepository is not configured. Either use UiToolkitProvider or call plotRepository.configure()");
		return this.config;
	}
	getAuthHeader() {
		let { accessToken: m } = this.getConfig();
		return m.startsWith("Bearer ") ? m : `Bearer ${m}`;
	}
	getBaseUrl() {
		let { apiUrl: m } = this.getConfig();
		return m.endsWith("/") ? m.slice(0, -1) : m;
	}
	async makeGET(m) {
		return (await fetch(`${this.getBaseUrl()}/${m}`, { headers: { Authorization: this.getAuthHeader() } })).json();
	}
	async makePOST(m, x) {
		return (await fetch(`${this.getBaseUrl()}/${m}`, {
			method: "POST",
			headers: {
				Authorization: this.getAuthHeader(),
				"Content-Type": "application/json"
			},
			body: JSON.stringify(x)
		})).json();
	}
	async fetchMain() {
		return this.makeGET("web/main");
	}
	async login(m) {
		return this.makeGET("web/main");
	}
	async fetchSitePlan() {
		return this.makeGET("web/availability/siteplan");
	}
	async fetchPlotsTableData() {
		return this.makeGET("web/availability/plots");
	}
	async fetchImage(m, x) {
		return this.makeGET(`asset/presignedurl/${m}?width=${x}&isThumbnail=false`);
	}
};
const plotRepository = new PlotRepository();
function createPlotRepository(m) {
	let x = new PlotRepository();
	return x.configure(m), x;
}
function usePlotRepository() {
	let m = useUiToolkitConfig();
	return useMemo(() => createPlotRepository(m), [m]);
}
function clamp$2(m, [x, S]) {
	return Math.min(S, Math.max(x, m));
}
typeof window < "u" && window.document && window.document.createElement;
function composeEventHandlers(m, x, { checkForDefaultPrevented: S = !0 } = {}) {
	return function(C) {
		if (m?.(C), S === !1 || !C.defaultPrevented) return x?.(C);
	};
}
function createContextScope(x, S = []) {
	let C = [];
	function T(S, T) {
		let D = React$1.createContext(T), O = C.length;
		C = [...C, T];
		let k = (S) => {
			let { scope: C, children: T, ...k } = S, A = C?.[x]?.[O] || D, j = React$1.useMemo(() => k, Object.values(k));
			return /* @__PURE__ */ jsx(A.Provider, {
				value: j,
				children: T
			});
		};
		k.displayName = S + "Provider";
		function A(C, k) {
			let A = k?.[x]?.[O] || D, j = React$1.useContext(A);
			if (j) return j;
			if (T !== void 0) return T;
			throw Error(`\`${C}\` must be used within \`${S}\``);
		}
		return [k, A];
	}
	let D = () => {
		let S = C.map((x) => React$1.createContext(x));
		return function(C) {
			let T = C?.[x] || S;
			return React$1.useMemo(() => ({ [`__scope${x}`]: {
				...C,
				[x]: T
			} }), [C, T]);
		};
	};
	return D.scopeName = x, [T, composeContextScopes(D, ...S)];
}
function composeContextScopes(...x) {
	let S = x[0];
	if (x.length === 1) return S;
	let C = () => {
		let C = x.map((m) => ({
			useScope: m(),
			scopeName: m.scopeName
		}));
		return function(x) {
			let T = C.reduce((m, { useScope: S, scopeName: C }) => {
				let T = S(x)[`__scope${C}`];
				return {
					...m,
					...T
				};
			}, {});
			return React$1.useMemo(() => ({ [`__scope${S.scopeName}`]: T }), [T]);
		};
	};
	return C.scopeName = S.scopeName, C;
}
function setRef(m, x) {
	if (typeof m == "function") return m(x);
	m != null && (m.current = x);
}
function composeRefs(...m) {
	return (x) => {
		let S = !1, C = m.map((m) => {
			let C = setRef(m, x);
			return !S && typeof C == "function" && (S = !0), C;
		});
		if (S) return () => {
			for (let x = 0; x < C.length; x++) {
				let S = C[x];
				typeof S == "function" ? S() : setRef(m[x], null);
			}
		};
	};
}
function useComposedRefs(...x) {
	return React$1.useCallback(composeRefs(...x), x);
}
/* @__NO_SIDE_EFFECTS__ */
function createSlot(x) {
	let S = /* @__PURE__ */ createSlotClone(x), C = React$1.forwardRef((x, C) => {
		let { children: T, ...D } = x, O = React$1.Children.toArray(T), k = O.find(isSlottable);
		if (k) {
			let x = k.props.children, T = O.map((S) => S === k ? React$1.Children.count(x) > 1 ? React$1.Children.only(null) : React$1.isValidElement(x) ? x.props.children : null : S);
			return /* @__PURE__ */ jsx(S, {
				...D,
				ref: C,
				children: React$1.isValidElement(x) ? React$1.cloneElement(x, void 0, T) : null
			});
		}
		return /* @__PURE__ */ jsx(S, {
			...D,
			ref: C,
			children: T
		});
	});
	return C.displayName = `${x}.Slot`, C;
}
/* @__NO_SIDE_EFFECTS__ */
function createSlotClone(x) {
	let S = React$1.forwardRef((x, S) => {
		let { children: C, ...T } = x;
		if (React$1.isValidElement(C)) {
			let x = getElementRef(C), D = mergeProps(T, C.props);
			return C.type !== React$1.Fragment && (D.ref = S ? composeRefs(S, x) : x), React$1.cloneElement(C, D);
		}
		return React$1.Children.count(C) > 1 ? React$1.Children.only(null) : null;
	});
	return S.displayName = `${x}.SlotClone`, S;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(x) {
	return React$1.isValidElement(x) && typeof x.type == "function" && "__radixId" in x.type && x.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(m, x) {
	let S = { ...x };
	for (let C in x) {
		let T = m[C], D = x[C];
		/^on[A-Z]/.test(C) ? T && D ? S[C] = (...m) => {
			let x = D(...m);
			return T(...m), x;
		} : T && (S[C] = T) : C === "style" ? S[C] = {
			...T,
			...D
		} : C === "className" && (S[C] = [T, D].filter(Boolean).join(" "));
	}
	return {
		...m,
		...S
	};
}
function getElementRef(m) {
	let x = Object.getOwnPropertyDescriptor(m.props, "ref")?.get, S = x && "isReactWarning" in x && x.isReactWarning;
	return S ? m.ref : (x = Object.getOwnPropertyDescriptor(m, "ref")?.get, S = x && "isReactWarning" in x && x.isReactWarning, S ? m.props.ref : m.props.ref || m.ref);
}
function createCollection(m) {
	let S = m + "CollectionProvider", [C, T] = createContextScope(S), [D, O] = C(S, {
		collectionRef: { current: null },
		itemMap: /* @__PURE__ */ new Map()
	}), k = (m) => {
		let { scope: S, children: C } = m, T = React.useRef(null), O = React.useRef(/* @__PURE__ */ new Map()).current;
		return /* @__PURE__ */ jsx(D, {
			scope: S,
			itemMap: O,
			collectionRef: T,
			children: C
		});
	};
	k.displayName = S;
	let A = m + "CollectionSlot", j = /* @__PURE__ */ createSlot(A), M = React.forwardRef((m, x) => {
		let { scope: S, children: C } = m;
		return /* @__PURE__ */ jsx(j, {
			ref: useComposedRefs(x, O(A, S).collectionRef),
			children: C
		});
	});
	M.displayName = A;
	let N = m + "CollectionItemSlot", P = "data-radix-collection-item", F = /* @__PURE__ */ createSlot(N), I = React.forwardRef((m, S) => {
		let { scope: C, children: T, ...D } = m, k = React.useRef(null), A = useComposedRefs(S, k), j = O(N, C);
		return React.useEffect(() => (j.itemMap.set(k, {
			ref: k,
			...D
		}), () => void j.itemMap.delete(k))), /* @__PURE__ */ jsx(F, {
			[P]: "",
			ref: A,
			children: T
		});
	});
	I.displayName = N;
	function L(S) {
		let C = O(m + "CollectionConsumer", S);
		return React.useCallback(() => {
			let m = C.collectionRef.current;
			if (!m) return [];
			let x = Array.from(m.querySelectorAll(`[${P}]`));
			return Array.from(C.itemMap.values()).sort((m, S) => x.indexOf(m.ref.current) - x.indexOf(S.ref.current));
		}, [C.collectionRef, C.itemMap]);
	}
	return [
		{
			Provider: k,
			Slot: M,
			ItemSlot: I
		},
		L,
		T
	];
}
var DirectionContext = React$1.createContext(void 0);
function useDirection(x) {
	let S = React$1.useContext(DirectionContext);
	return x || S || "ltr";
}
var Primitive = [
	"a",
	"button",
	"div",
	"form",
	"h2",
	"h3",
	"img",
	"input",
	"label",
	"li",
	"nav",
	"ol",
	"p",
	"select",
	"span",
	"svg",
	"ul"
].reduce((x, S) => {
	let C = /* @__PURE__ */ createSlot(`Primitive.${S}`), T = React$1.forwardRef((m, x) => {
		let { asChild: T, ...D } = m, O = T ? C : S;
		return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ jsx(O, {
			...D,
			ref: x
		});
	});
	return T.displayName = `Primitive.${S}`, {
		...x,
		[S]: T
	};
}, {});
function dispatchDiscreteCustomEvent(m, x) {
	m && ReactDOM$1.flushSync(() => m.dispatchEvent(x));
}
function useCallbackRef(x) {
	let S = React$1.useRef(x);
	return React$1.useEffect(() => {
		S.current = x;
	}), React$1.useMemo(() => (...m) => S.current?.(...m), []);
}
function useEscapeKeydown(x, S = globalThis?.document) {
	let C = useCallbackRef(x);
	React$1.useEffect(() => {
		let m = (m) => {
			m.key === "Escape" && C(m);
		};
		return S.addEventListener("keydown", m, { capture: !0 }), () => S.removeEventListener("keydown", m, { capture: !0 });
	}, [C, S]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer", CONTEXT_UPDATE = "dismissableLayer.update", POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", FOCUS_OUTSIDE = "dismissableLayer.focusOutside", originalBodyPointerEvents, DismissableLayerContext = React$1.createContext({
	layers: /* @__PURE__ */ new Set(),
	layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
	branches: /* @__PURE__ */ new Set()
}), DismissableLayer = React$1.forwardRef((x, S) => {
	let { disableOutsidePointerEvents: C = !1, onEscapeKeyDown: T, onPointerDownOutside: D, onFocusOutside: O, onInteractOutside: k, onDismiss: A, ...j } = x, M = React$1.useContext(DismissableLayerContext), [N, P] = React$1.useState(null), F = N?.ownerDocument ?? globalThis?.document, [, I] = React$1.useState({}), L = useComposedRefs(S, (m) => P(m)), R = Array.from(M.layers), [z] = [...M.layersWithOutsidePointerEventsDisabled].slice(-1), B = R.indexOf(z), H = N ? R.indexOf(N) : -1, U = M.layersWithOutsidePointerEventsDisabled.size > 0, W = H >= B, K = usePointerDownOutside((m) => {
		let x = m.target, S = [...M.branches].some((m) => m.contains(x));
		!W || S || (D?.(m), k?.(m), m.defaultPrevented || A?.());
	}, F), q = useFocusOutside((m) => {
		let x = m.target;
		[...M.branches].some((m) => m.contains(x)) || (O?.(m), k?.(m), m.defaultPrevented || A?.());
	}, F);
	return useEscapeKeydown((m) => {
		H === M.layers.size - 1 && (T?.(m), !m.defaultPrevented && A && (m.preventDefault(), A()));
	}, F), React$1.useEffect(() => {
		if (N) return C && (M.layersWithOutsidePointerEventsDisabled.size === 0 && (originalBodyPointerEvents = F.body.style.pointerEvents, F.body.style.pointerEvents = "none"), M.layersWithOutsidePointerEventsDisabled.add(N)), M.layers.add(N), dispatchUpdate(), () => {
			C && M.layersWithOutsidePointerEventsDisabled.size === 1 && (F.body.style.pointerEvents = originalBodyPointerEvents);
		};
	}, [
		N,
		F,
		C,
		M
	]), React$1.useEffect(() => () => {
		N && (M.layers.delete(N), M.layersWithOutsidePointerEventsDisabled.delete(N), dispatchUpdate());
	}, [N, M]), React$1.useEffect(() => {
		let m = () => I({});
		return document.addEventListener(CONTEXT_UPDATE, m), () => document.removeEventListener(CONTEXT_UPDATE, m);
	}, []), /* @__PURE__ */ jsx(Primitive.div, {
		...j,
		ref: L,
		style: {
			pointerEvents: U ? W ? "auto" : "none" : void 0,
			...x.style
		},
		onFocusCapture: composeEventHandlers(x.onFocusCapture, q.onFocusCapture),
		onBlurCapture: composeEventHandlers(x.onBlurCapture, q.onBlurCapture),
		onPointerDownCapture: composeEventHandlers(x.onPointerDownCapture, K.onPointerDownCapture)
	});
});
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch", DismissableLayerBranch = React$1.forwardRef((x, S) => {
	let C = React$1.useContext(DismissableLayerContext), T = React$1.useRef(null), D = useComposedRefs(S, T);
	return React$1.useEffect(() => {
		let m = T.current;
		if (m) return C.branches.add(m), () => {
			C.branches.delete(m);
		};
	}, [C.branches]), /* @__PURE__ */ jsx(Primitive.div, {
		...x,
		ref: D
	});
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(x, S = globalThis?.document) {
	let C = useCallbackRef(x), T = React$1.useRef(!1), D = React$1.useRef(() => {});
	return React$1.useEffect(() => {
		let m = (m) => {
			if (m.target && !T.current) {
				let x = function() {
					handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, C, T, { discrete: !0 });
				}, T = { originalEvent: m };
				m.pointerType === "touch" ? (S.removeEventListener("click", D.current), D.current = x, S.addEventListener("click", D.current, { once: !0 })) : x();
			} else S.removeEventListener("click", D.current);
			T.current = !1;
		}, x = window.setTimeout(() => {
			S.addEventListener("pointerdown", m);
		}, 0);
		return () => {
			window.clearTimeout(x), S.removeEventListener("pointerdown", m), S.removeEventListener("click", D.current);
		};
	}, [S, C]), { onPointerDownCapture: () => T.current = !0 };
}
function useFocusOutside(x, S = globalThis?.document) {
	let C = useCallbackRef(x), T = React$1.useRef(!1);
	return React$1.useEffect(() => {
		let m = (m) => {
			m.target && !T.current && handleAndDispatchCustomEvent(FOCUS_OUTSIDE, C, { originalEvent: m }, { discrete: !1 });
		};
		return S.addEventListener("focusin", m), () => S.removeEventListener("focusin", m);
	}, [S, C]), {
		onFocusCapture: () => T.current = !0,
		onBlurCapture: () => T.current = !1
	};
}
function dispatchUpdate() {
	let m = new CustomEvent(CONTEXT_UPDATE);
	document.dispatchEvent(m);
}
function handleAndDispatchCustomEvent(m, x, S, { discrete: C }) {
	let T = S.originalEvent.target, D = new CustomEvent(m, {
		bubbles: !1,
		cancelable: !0,
		detail: S
	});
	x && T.addEventListener(m, x, { once: !0 }), C ? dispatchDiscreteCustomEvent(T, D) : T.dispatchEvent(D);
}
var count$1 = 0;
function useFocusGuards() {
	React$1.useEffect(() => {
		let m = document.querySelectorAll("[data-radix-focus-guard]");
		return document.body.insertAdjacentElement("afterbegin", m[0] ?? createFocusGuard()), document.body.insertAdjacentElement("beforeend", m[1] ?? createFocusGuard()), count$1++, () => {
			count$1 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((m) => m.remove()), count$1--;
		};
	}, []);
}
function createFocusGuard() {
	let m = document.createElement("span");
	return m.setAttribute("data-radix-focus-guard", ""), m.tabIndex = 0, m.style.outline = "none", m.style.opacity = "0", m.style.position = "fixed", m.style.pointerEvents = "none", m;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount", AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount", EVENT_OPTIONS = {
	bubbles: !1,
	cancelable: !0
}, FOCUS_SCOPE_NAME = "FocusScope", FocusScope = React$1.forwardRef((x, S) => {
	let { loop: C = !1, trapped: T = !1, onMountAutoFocus: D, onUnmountAutoFocus: O, ...k } = x, [A, j] = React$1.useState(null), M = useCallbackRef(D), N = useCallbackRef(O), P = React$1.useRef(null), F = useComposedRefs(S, (m) => j(m)), I = React$1.useRef({
		paused: !1,
		pause() {
			this.paused = !0;
		},
		resume() {
			this.paused = !1;
		}
	}).current;
	React$1.useEffect(() => {
		if (T) {
			let m = function(m) {
				if (I.paused || !A) return;
				let x = m.target;
				A.contains(x) ? P.current = x : focus(P.current, { select: !0 });
			}, x = function(m) {
				if (I.paused || !A) return;
				let x = m.relatedTarget;
				x !== null && (A.contains(x) || focus(P.current, { select: !0 }));
			}, S = function(m) {
				if (document.activeElement === document.body) for (let x of m) x.removedNodes.length > 0 && focus(A);
			};
			document.addEventListener("focusin", m), document.addEventListener("focusout", x);
			let C = new MutationObserver(S);
			return A && C.observe(A, {
				childList: !0,
				subtree: !0
			}), () => {
				document.removeEventListener("focusin", m), document.removeEventListener("focusout", x), C.disconnect();
			};
		}
	}, [
		T,
		A,
		I.paused
	]), React$1.useEffect(() => {
		if (A) {
			focusScopesStack.add(I);
			let m = document.activeElement;
			if (!A.contains(m)) {
				let x = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
				A.addEventListener(AUTOFOCUS_ON_MOUNT, M), A.dispatchEvent(x), x.defaultPrevented || (focusFirst(removeLinks(getTabbableCandidates(A)), { select: !0 }), document.activeElement === m && focus(A));
			}
			return () => {
				A.removeEventListener(AUTOFOCUS_ON_MOUNT, M), setTimeout(() => {
					let x = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
					A.addEventListener(AUTOFOCUS_ON_UNMOUNT, N), A.dispatchEvent(x), x.defaultPrevented || focus(m ?? document.body, { select: !0 }), A.removeEventListener(AUTOFOCUS_ON_UNMOUNT, N), focusScopesStack.remove(I);
				}, 0);
			};
		}
	}, [
		A,
		M,
		N,
		I
	]);
	let L = React$1.useCallback((m) => {
		if (!C && !T || I.paused) return;
		let x = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, S = document.activeElement;
		if (x && S) {
			let x = m.currentTarget, [T, D] = getTabbableEdges(x);
			T && D ? !m.shiftKey && S === D ? (m.preventDefault(), C && focus(T, { select: !0 })) : m.shiftKey && S === T && (m.preventDefault(), C && focus(D, { select: !0 })) : S === x && m.preventDefault();
		}
	}, [
		C,
		T,
		I.paused
	]);
	return /* @__PURE__ */ jsx(Primitive.div, {
		tabIndex: -1,
		...k,
		ref: F,
		onKeyDown: L
	});
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(m, { select: x = !1 } = {}) {
	let S = document.activeElement;
	for (let C of m) if (focus(C, { select: x }), document.activeElement !== S) return;
}
function getTabbableEdges(m) {
	let x = getTabbableCandidates(m);
	return [findVisible(x, m), findVisible(x.reverse(), m)];
}
function getTabbableCandidates(m) {
	let x = [], S = document.createTreeWalker(m, NodeFilter.SHOW_ELEMENT, { acceptNode: (m) => {
		let x = m.tagName === "INPUT" && m.type === "hidden";
		return m.disabled || m.hidden || x ? NodeFilter.FILTER_SKIP : m.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	} });
	for (; S.nextNode();) x.push(S.currentNode);
	return x;
}
function findVisible(m, x) {
	for (let S of m) if (!isHidden(S, { upTo: x })) return S;
}
function isHidden(m, { upTo: x }) {
	if (getComputedStyle(m).visibility === "hidden") return !0;
	for (; m;) {
		if (x !== void 0 && m === x) return !1;
		if (getComputedStyle(m).display === "none") return !0;
		m = m.parentElement;
	}
	return !1;
}
function isSelectableInput(m) {
	return m instanceof HTMLInputElement && "select" in m;
}
function focus(m, { select: x = !1 } = {}) {
	if (m && m.focus) {
		let S = document.activeElement;
		m.focus({ preventScroll: !0 }), m !== S && isSelectableInput(m) && x && m.select();
	}
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
	let m = [];
	return {
		add(x) {
			let S = m[0];
			x !== S && S?.pause(), m = arrayRemove(m, x), m.unshift(x);
		},
		remove(x) {
			m = arrayRemove(m, x), m[0]?.resume();
		}
	};
}
function arrayRemove(m, x) {
	let S = [...m], C = S.indexOf(x);
	return C !== -1 && S.splice(C, 1), S;
}
function removeLinks(m) {
	return m.filter((m) => m.tagName !== "A");
}
var useLayoutEffect2 = globalThis?.document ? React$1.useLayoutEffect : () => {}, useReactId = React$1.useId || (() => void 0), count = 0;
function useId$1(x) {
	let [S, C] = React$1.useState(useReactId());
	return useLayoutEffect2(() => {
		x || C((m) => m ?? String(count++));
	}, [x]), x || (S ? `radix-${S}` : "");
}
var sides = [
	"top",
	"right",
	"bottom",
	"left"
], min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (m) => ({
	x: m,
	y: m
}), oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
}, oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp$3(m, x, S) {
	return max(m, min(x, S));
}
function evaluate(m, x) {
	return typeof m == "function" ? m(x) : m;
}
function getSide(m) {
	return m.split("-")[0];
}
function getAlignment(m) {
	return m.split("-")[1];
}
function getOppositeAxis(m) {
	return m === "x" ? "y" : "x";
}
function getAxisLength(m) {
	return m === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(m) {
	return yAxisSides.has(getSide(m)) ? "y" : "x";
}
function getAlignmentAxis(m) {
	return getOppositeAxis(getSideAxis(m));
}
function getAlignmentSides(m, x, S) {
	S === void 0 && (S = !1);
	let C = getAlignment(m), T = getAlignmentAxis(m), D = getAxisLength(T), O = T === "x" ? C === (S ? "end" : "start") ? "right" : "left" : C === "start" ? "bottom" : "top";
	return x.reference[D] > x.floating[D] && (O = getOppositePlacement(O)), [O, getOppositePlacement(O)];
}
function getExpandedPlacements(m) {
	let x = getOppositePlacement(m);
	return [
		getOppositeAlignmentPlacement(m),
		x,
		getOppositeAlignmentPlacement(x)
	];
}
function getOppositeAlignmentPlacement(m) {
	return m.replace(/start|end/g, (m) => oppositeAlignmentMap[m]);
}
var lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(m, x, S) {
	switch (m) {
		case "top":
		case "bottom": return S ? x ? rlPlacement : lrPlacement : x ? lrPlacement : rlPlacement;
		case "left":
		case "right": return x ? tbPlacement : btPlacement;
		default: return [];
	}
}
function getOppositeAxisPlacements(m, x, S, C) {
	let T = getAlignment(m), D = getSideList(getSide(m), S === "start", C);
	return T && (D = D.map((m) => m + "-" + T), x && (D = D.concat(D.map(getOppositeAlignmentPlacement)))), D;
}
function getOppositePlacement(m) {
	return m.replace(/left|right|bottom|top/g, (m) => oppositeSideMap[m]);
}
function expandPaddingObject(m) {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...m
	};
}
function getPaddingObject(m) {
	return typeof m == "number" ? {
		top: m,
		right: m,
		bottom: m,
		left: m
	} : expandPaddingObject(m);
}
function rectToClientRect(m) {
	let { x, y: S, width: C, height: T } = m;
	return {
		width: C,
		height: T,
		top: S,
		left: x,
		right: x + C,
		bottom: S + T,
		x,
		y: S
	};
}
function computeCoordsFromPlacement(m, x, S) {
	let { reference: C, floating: T } = m, D = getSideAxis(x), O = getAlignmentAxis(x), k = getAxisLength(O), A = getSide(x), j = D === "y", M = C.x + C.width / 2 - T.width / 2, N = C.y + C.height / 2 - T.height / 2, P = C[k] / 2 - T[k] / 2, F;
	switch (A) {
		case "top":
			F = {
				x: M,
				y: C.y - T.height
			};
			break;
		case "bottom":
			F = {
				x: M,
				y: C.y + C.height
			};
			break;
		case "right":
			F = {
				x: C.x + C.width,
				y: N
			};
			break;
		case "left":
			F = {
				x: C.x - T.width,
				y: N
			};
			break;
		default: F = {
			x: C.x,
			y: C.y
		};
	}
	switch (getAlignment(x)) {
		case "start":
			F[O] -= P * (S && j ? -1 : 1);
			break;
		case "end":
			F[O] += P * (S && j ? -1 : 1);
			break;
	}
	return F;
}
var computePosition$1 = async (m, x, S) => {
	let { placement: C = "bottom", strategy: T = "absolute", middleware: D = [], platform: O } = S, k = D.filter(Boolean), A = await (O.isRTL == null ? void 0 : O.isRTL(x)), j = await O.getElementRects({
		reference: m,
		floating: x,
		strategy: T
	}), { x: M, y: N } = computeCoordsFromPlacement(j, C, A), P = C, F = {}, I = 0;
	for (let S = 0; S < k.length; S++) {
		let { name: D, fn: L } = k[S], { x: R, y: z, data: B, reset: H } = await L({
			x: M,
			y: N,
			initialPlacement: C,
			placement: P,
			strategy: T,
			middlewareData: F,
			rects: j,
			platform: O,
			elements: {
				reference: m,
				floating: x
			}
		});
		M = R ?? M, N = z ?? N, F = {
			...F,
			[D]: {
				...F[D],
				...B
			}
		}, H && I <= 50 && (I++, typeof H == "object" && (H.placement && (P = H.placement), H.rects && (j = H.rects === !0 ? await O.getElementRects({
			reference: m,
			floating: x,
			strategy: T
		}) : H.rects), {x: M, y: N} = computeCoordsFromPlacement(j, P, A)), S = -1);
	}
	return {
		x: M,
		y: N,
		placement: P,
		strategy: T,
		middlewareData: F
	};
};
async function detectOverflow$1(m, x) {
	x === void 0 && (x = {});
	let { x: S, y: C, platform: T, rects: D, elements: O, strategy: k } = m, { boundary: A = "clippingAncestors", rootBoundary: j = "viewport", elementContext: M = "floating", altBoundary: N = !1, padding: P = 0 } = evaluate(x, m), F = getPaddingObject(P), I = O[N ? M === "floating" ? "reference" : "floating" : M], L = rectToClientRect(await T.getClippingRect({
		element: await (T.isElement == null ? void 0 : T.isElement(I)) ?? !0 ? I : I.contextElement || await (T.getDocumentElement == null ? void 0 : T.getDocumentElement(O.floating)),
		boundary: A,
		rootBoundary: j,
		strategy: k
	})), R = M === "floating" ? {
		x: S,
		y: C,
		width: D.floating.width,
		height: D.floating.height
	} : D.reference, z = await (T.getOffsetParent == null ? void 0 : T.getOffsetParent(O.floating)), B = await (T.isElement == null ? void 0 : T.isElement(z)) && await (T.getScale == null ? void 0 : T.getScale(z)) || {
		x: 1,
		y: 1
	}, H = rectToClientRect(T.convertOffsetParentRelativeRectToViewportRelativeRect ? await T.convertOffsetParentRelativeRectToViewportRelativeRect({
		elements: O,
		rect: R,
		offsetParent: z,
		strategy: k
	}) : R);
	return {
		top: (L.top - H.top + F.top) / B.y,
		bottom: (H.bottom - L.bottom + F.bottom) / B.y,
		left: (L.left - H.left + F.left) / B.x,
		right: (H.right - L.right + F.right) / B.x
	};
}
var arrow$2 = (m) => ({
	name: "arrow",
	options: m,
	async fn(x) {
		let { x: S, y: C, placement: T, rects: D, platform: O, elements: k, middlewareData: A } = x, { element: j, padding: M = 0 } = evaluate(m, x) || {};
		if (j == null) return {};
		let N = getPaddingObject(M), P = {
			x: S,
			y: C
		}, F = getAlignmentAxis(T), I = getAxisLength(F), L = await O.getDimensions(j), R = F === "y", z = R ? "top" : "left", B = R ? "bottom" : "right", H = R ? "clientHeight" : "clientWidth", U = D.reference[I] + D.reference[F] - P[F] - D.floating[I], W = P[F] - D.reference[F], G = await (O.getOffsetParent == null ? void 0 : O.getOffsetParent(j)), K = G ? G[H] : 0;
		(!K || !await (O.isElement == null ? void 0 : O.isElement(G))) && (K = k.floating[H] || D.floating[I]);
		let q = U / 2 - W / 2, J = K / 2 - L[I] / 2 - 1, Y = min(N[z], J), X = min(N[B], J), Z = Y, sH = K - L[I] - X, Q = K / 2 - L[I] / 2 + q, cH = clamp$3(Z, Q, sH), lH = !A.arrow && getAlignment(T) != null && Q !== cH && D.reference[I] / 2 - (Q < Z ? Y : X) - L[I] / 2 < 0, uH = lH ? Q < Z ? Q - Z : Q - sH : 0;
		return {
			[F]: P[F] + uH,
			data: {
				[F]: cH,
				centerOffset: Q - cH - uH,
				...lH && { alignmentOffset: uH }
			},
			reset: lH
		};
	}
}), flip$2 = function(m) {
	return m === void 0 && (m = {}), {
		name: "flip",
		options: m,
		async fn(x) {
			var S;
			let { placement: C, middlewareData: T, rects: D, initialPlacement: O, platform: k, elements: A } = x, { mainAxis: j = !0, crossAxis: M = !0, fallbackPlacements: N, fallbackStrategy: P = "bestFit", fallbackAxisSideDirection: F = "none", flipAlignment: I = !0, ...L } = evaluate(m, x);
			if ((S = T.arrow) != null && S.alignmentOffset) return {};
			let R = getSide(C), z = getSideAxis(O), B = getSide(O) === O, H = await (k.isRTL == null ? void 0 : k.isRTL(A.floating)), U = N || (B || !I ? [getOppositePlacement(O)] : getExpandedPlacements(O)), W = F !== "none";
			!N && W && U.push(...getOppositeAxisPlacements(O, I, F, H));
			let G = [O, ...U], K = await detectOverflow$1(x, L), q = [], J = T.flip?.overflows || [];
			if (j && q.push(K[R]), M) {
				let m = getAlignmentSides(C, D, H);
				q.push(K[m[0]], K[m[1]]);
			}
			if (J = [...J, {
				placement: C,
				overflows: q
			}], !q.every((m) => m <= 0)) {
				let m = (T.flip?.index || 0) + 1, x = G[m];
				if (x && (!(M === "alignment" && z !== getSideAxis(x)) || J.every((m) => getSideAxis(m.placement) === z ? m.overflows[0] > 0 : !0))) return {
					data: {
						index: m,
						overflows: J
					},
					reset: { placement: x }
				};
				let S = J.filter((m) => m.overflows[0] <= 0).sort((m, x) => m.overflows[1] - x.overflows[1])[0]?.placement;
				if (!S) switch (P) {
					case "bestFit": {
						let m = J.filter((m) => {
							if (W) {
								let x = getSideAxis(m.placement);
								return x === z || x === "y";
							}
							return !0;
						}).map((m) => [m.placement, m.overflows.filter((m) => m > 0).reduce((m, x) => m + x, 0)]).sort((m, x) => m[1] - x[1])[0]?.[0];
						m && (S = m);
						break;
					}
					case "initialPlacement":
						S = O;
						break;
				}
				if (C !== S) return { reset: { placement: S } };
			}
			return {};
		}
	};
};
function getSideOffsets(m, x) {
	return {
		top: m.top - x.height,
		right: m.right - x.width,
		bottom: m.bottom - x.height,
		left: m.left - x.width
	};
}
function isAnySideFullyClipped(m) {
	return sides.some((x) => m[x] >= 0);
}
var hide$2 = function(m) {
	return m === void 0 && (m = {}), {
		name: "hide",
		options: m,
		async fn(x) {
			let { rects: S } = x, { strategy: C = "referenceHidden", ...T } = evaluate(m, x);
			switch (C) {
				case "referenceHidden": {
					let m = getSideOffsets(await detectOverflow$1(x, {
						...T,
						elementContext: "reference"
					}), S.reference);
					return { data: {
						referenceHiddenOffsets: m,
						referenceHidden: isAnySideFullyClipped(m)
					} };
				}
				case "escaped": {
					let m = getSideOffsets(await detectOverflow$1(x, {
						...T,
						altBoundary: !0
					}), S.floating);
					return { data: {
						escapedOffsets: m,
						escaped: isAnySideFullyClipped(m)
					} };
				}
				default: return {};
			}
		}
	};
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(m, x) {
	let { placement: S, platform: C, elements: T } = m, D = await (C.isRTL == null ? void 0 : C.isRTL(T.floating)), O = getSide(S), k = getAlignment(S), A = getSideAxis(S) === "y", j = originSides.has(O) ? -1 : 1, M = D && A ? -1 : 1, N = evaluate(x, m), { mainAxis: P, crossAxis: F, alignmentAxis: I } = typeof N == "number" ? {
		mainAxis: N,
		crossAxis: 0,
		alignmentAxis: null
	} : {
		mainAxis: N.mainAxis || 0,
		crossAxis: N.crossAxis || 0,
		alignmentAxis: N.alignmentAxis
	};
	return k && typeof I == "number" && (F = k === "end" ? I * -1 : I), A ? {
		x: F * M,
		y: P * j
	} : {
		x: P * j,
		y: F * M
	};
}
var offset$2 = function(m) {
	return m === void 0 && (m = 0), {
		name: "offset",
		options: m,
		async fn(x) {
			var S;
			let { x: C, y: T, placement: D, middlewareData: O } = x, k = await convertValueToCoords(x, m);
			return D === O.offset?.placement && (S = O.arrow) != null && S.alignmentOffset ? {} : {
				x: C + k.x,
				y: T + k.y,
				data: {
					...k,
					placement: D
				}
			};
		}
	};
}, shift$2 = function(m) {
	return m === void 0 && (m = {}), {
		name: "shift",
		options: m,
		async fn(x) {
			let { x: S, y: C, placement: T } = x, { mainAxis: D = !0, crossAxis: O = !1, limiter: k = { fn: (m) => {
				let { x, y: S } = m;
				return {
					x,
					y: S
				};
			} }, ...A } = evaluate(m, x), j = {
				x: S,
				y: C
			}, M = await detectOverflow$1(x, A), N = getSideAxis(getSide(T)), P = getOppositeAxis(N), F = j[P], I = j[N];
			if (D) {
				let m = P === "y" ? "top" : "left", x = P === "y" ? "bottom" : "right", S = F + M[m], C = F - M[x];
				F = clamp$3(S, F, C);
			}
			if (O) {
				let m = N === "y" ? "top" : "left", x = N === "y" ? "bottom" : "right", S = I + M[m], C = I - M[x];
				I = clamp$3(S, I, C);
			}
			let L = k.fn({
				...x,
				[P]: F,
				[N]: I
			});
			return {
				...L,
				data: {
					x: L.x - S,
					y: L.y - C,
					enabled: {
						[P]: D,
						[N]: O
					}
				}
			};
		}
	};
}, limitShift$2 = function(m) {
	return m === void 0 && (m = {}), {
		options: m,
		fn(x) {
			let { x: S, y: C, placement: T, rects: D, middlewareData: O } = x, { offset: k = 0, mainAxis: A = !0, crossAxis: j = !0 } = evaluate(m, x), M = {
				x: S,
				y: C
			}, N = getSideAxis(T), P = getOppositeAxis(N), F = M[P], I = M[N], L = evaluate(k, x), R = typeof L == "number" ? {
				mainAxis: L,
				crossAxis: 0
			} : {
				mainAxis: 0,
				crossAxis: 0,
				...L
			};
			if (A) {
				let m = P === "y" ? "height" : "width", x = D.reference[P] - D.floating[m] + R.mainAxis, S = D.reference[P] + D.reference[m] - R.mainAxis;
				F < x ? F = x : F > S && (F = S);
			}
			if (j) {
				let m = P === "y" ? "width" : "height", x = originSides.has(getSide(T)), S = D.reference[N] - D.floating[m] + (x && O.offset?.[N] || 0) + (x ? 0 : R.crossAxis), C = D.reference[N] + D.reference[m] + (x ? 0 : O.offset?.[N] || 0) - (x ? R.crossAxis : 0);
				I < S ? I = S : I > C && (I = C);
			}
			return {
				[P]: F,
				[N]: I
			};
		}
	};
}, size$2 = function(m) {
	return m === void 0 && (m = {}), {
		name: "size",
		options: m,
		async fn(x) {
			var S, C;
			let { placement: T, rects: D, platform: O, elements: k } = x, { apply: A = () => {}, ...j } = evaluate(m, x), M = await detectOverflow$1(x, j), N = getSide(T), P = getAlignment(T), F = getSideAxis(T) === "y", { width: I, height: L } = D.floating, R, z;
			N === "top" || N === "bottom" ? (R = N, z = P === (await (O.isRTL == null ? void 0 : O.isRTL(k.floating)) ? "start" : "end") ? "left" : "right") : (z = N, R = P === "end" ? "top" : "bottom");
			let B = L - M.top - M.bottom, H = I - M.left - M.right, U = min(L - M[R], B), W = min(I - M[z], H), G = !x.middlewareData.shift, K = U, q = W;
			if ((S = x.middlewareData.shift) != null && S.enabled.x && (q = H), (C = x.middlewareData.shift) != null && C.enabled.y && (K = B), G && !P) {
				let m = max(M.left, 0), x = max(M.right, 0), S = max(M.top, 0), C = max(M.bottom, 0);
				F ? q = I - 2 * (m !== 0 || x !== 0 ? m + x : max(M.left, M.right)) : K = L - 2 * (S !== 0 || C !== 0 ? S + C : max(M.top, M.bottom));
			}
			await A({
				...x,
				availableWidth: q,
				availableHeight: K
			});
			let J = await O.getDimensions(k.floating);
			return I !== J.width || L !== J.height ? { reset: { rects: !0 } } : {};
		}
	};
};
function hasWindow() {
	return typeof window < "u";
}
function getNodeName(m) {
	return isNode$2(m) ? (m.nodeName || "").toLowerCase() : "#document";
}
function getWindow$2(m) {
	var x;
	return (m == null || (x = m.ownerDocument) == null ? void 0 : x.defaultView) || window;
}
function getDocumentElement(m) {
	return ((isNode$2(m) ? m.ownerDocument : m.document) || window.document)?.documentElement;
}
function isNode$2(m) {
	return hasWindow() ? m instanceof Node || m instanceof getWindow$2(m).Node : !1;
}
function isElement$1(m) {
	return hasWindow() ? m instanceof Element || m instanceof getWindow$2(m).Element : !1;
}
function isHTMLElement$2(m) {
	return hasWindow() ? m instanceof HTMLElement || m instanceof getWindow$2(m).HTMLElement : !1;
}
function isShadowRoot(m) {
	return !hasWindow() || typeof ShadowRoot > "u" ? !1 : m instanceof ShadowRoot || m instanceof getWindow$2(m).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(m) {
	let { overflow: x, overflowX: S, overflowY: C, display: T } = getComputedStyle$3(m);
	return /auto|scroll|overlay|hidden|clip/.test(x + C + S) && !invalidOverflowDisplayValues.has(T);
}
var tableElements = /* @__PURE__ */ new Set([
	"table",
	"td",
	"th"
]);
function isTableElement(m) {
	return tableElements.has(getNodeName(m));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(m) {
	return topLayerSelectors.some((x) => {
		try {
			return m.matches(x);
		} catch {
			return !1;
		}
	});
}
var transformProperties = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective"
], willChangeValues = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective",
	"filter"
], containValues = [
	"paint",
	"layout",
	"strict",
	"content"
];
function isContainingBlock(m) {
	let x = isWebKit(), S = isElement$1(m) ? getComputedStyle$3(m) : m;
	return transformProperties.some((m) => S[m] ? S[m] !== "none" : !1) || (S.containerType ? S.containerType !== "normal" : !1) || !x && (S.backdropFilter ? S.backdropFilter !== "none" : !1) || !x && (S.filter ? S.filter !== "none" : !1) || willChangeValues.some((m) => (S.willChange || "").includes(m)) || containValues.some((m) => (S.contain || "").includes(m));
}
function getContainingBlock(m) {
	let x = getParentNode(m);
	for (; isHTMLElement$2(x) && !isLastTraversableNode(x);) {
		if (isContainingBlock(x)) return x;
		if (isTopLayer(x)) return null;
		x = getParentNode(x);
	}
	return null;
}
function isWebKit() {
	return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set([
	"html",
	"body",
	"#document"
]);
function isLastTraversableNode(m) {
	return lastTraversableNodeNames.has(getNodeName(m));
}
function getComputedStyle$3(m) {
	return getWindow$2(m).getComputedStyle(m);
}
function getNodeScroll(m) {
	return isElement$1(m) ? {
		scrollLeft: m.scrollLeft,
		scrollTop: m.scrollTop
	} : {
		scrollLeft: m.scrollX,
		scrollTop: m.scrollY
	};
}
function getParentNode(m) {
	if (getNodeName(m) === "html") return m;
	let x = m.assignedSlot || m.parentNode || isShadowRoot(m) && m.host || getDocumentElement(m);
	return isShadowRoot(x) ? x.host : x;
}
function getNearestOverflowAncestor(m) {
	let x = getParentNode(m);
	return isLastTraversableNode(x) ? m.ownerDocument ? m.ownerDocument.body : m.body : isHTMLElement$2(x) && isOverflowElement(x) ? x : getNearestOverflowAncestor(x);
}
function getOverflowAncestors(m, x, S) {
	x === void 0 && (x = []), S === void 0 && (S = !0);
	let C = getNearestOverflowAncestor(m), T = C === m.ownerDocument?.body, D = getWindow$2(C);
	if (T) {
		let m = getFrameElement$1(D);
		return x.concat(D, D.visualViewport || [], isOverflowElement(C) ? C : [], m && S ? getOverflowAncestors(m) : []);
	}
	return x.concat(C, getOverflowAncestors(C, [], S));
}
function getFrameElement$1(m) {
	return m.parent && Object.getPrototypeOf(m.parent) ? m.frameElement : null;
}
function getCssDimensions(m) {
	let x = getComputedStyle$3(m), S = parseFloat(x.width) || 0, C = parseFloat(x.height) || 0, T = isHTMLElement$2(m), D = T ? m.offsetWidth : S, O = T ? m.offsetHeight : C, k = round(S) !== D || round(C) !== O;
	return k && (S = D, C = O), {
		width: S,
		height: C,
		$: k
	};
}
function unwrapElement(m) {
	return isElement$1(m) ? m : m.contextElement;
}
function getScale$1(m) {
	let x = unwrapElement(m);
	if (!isHTMLElement$2(x)) return createCoords(1);
	let S = x.getBoundingClientRect(), { width: C, height: T, $: D } = getCssDimensions(x), O = (D ? round(S.width) : S.width) / C, k = (D ? round(S.height) : S.height) / T;
	return (!O || !Number.isFinite(O)) && (O = 1), (!k || !Number.isFinite(k)) && (k = 1), {
		x: O,
		y: k
	};
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(m) {
	let x = getWindow$2(m);
	return !isWebKit() || !x.visualViewport ? noOffsets : {
		x: x.visualViewport.offsetLeft,
		y: x.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(m, x, S) {
	return x === void 0 && (x = !1), !S || x && S !== getWindow$2(m) ? !1 : x;
}
function getBoundingClientRect(m, x, S, C) {
	x === void 0 && (x = !1), S === void 0 && (S = !1);
	let T = m.getBoundingClientRect(), D = unwrapElement(m), O = createCoords(1);
	x && (C ? isElement$1(C) && (O = getScale$1(C)) : O = getScale$1(m));
	let k = shouldAddVisualOffsets(D, S, C) ? getVisualOffsets(D) : createCoords(0), A = (T.left + k.x) / O.x, j = (T.top + k.y) / O.y, M = T.width / O.x, N = T.height / O.y;
	if (D) {
		let m = getWindow$2(D), x = C && isElement$1(C) ? getWindow$2(C) : C, S = m, T = getFrameElement$1(S);
		for (; T && C && x !== S;) {
			let m = getScale$1(T), x = T.getBoundingClientRect(), C = getComputedStyle$3(T), D = x.left + (T.clientLeft + parseFloat(C.paddingLeft)) * m.x, O = x.top + (T.clientTop + parseFloat(C.paddingTop)) * m.y;
			A *= m.x, j *= m.y, M *= m.x, N *= m.y, A += D, j += O, S = getWindow$2(T), T = getFrameElement$1(S);
		}
	}
	return rectToClientRect({
		width: M,
		height: N,
		x: A,
		y: j
	});
}
function getWindowScrollBarX(m, x) {
	let S = getNodeScroll(m).scrollLeft;
	return x ? x.left + S : getBoundingClientRect(getDocumentElement(m)).left + S;
}
function getHTMLOffset(m, x) {
	let S = m.getBoundingClientRect();
	return {
		x: S.left + x.scrollLeft - getWindowScrollBarX(m, S),
		y: S.top + x.scrollTop
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(m) {
	let { elements: x, rect: S, offsetParent: C, strategy: T } = m, D = T === "fixed", O = getDocumentElement(C), k = x ? isTopLayer(x.floating) : !1;
	if (C === O || k && D) return S;
	let A = {
		scrollLeft: 0,
		scrollTop: 0
	}, j = createCoords(1), M = createCoords(0), N = isHTMLElement$2(C);
	if ((N || !N && !D) && ((getNodeName(C) !== "body" || isOverflowElement(O)) && (A = getNodeScroll(C)), isHTMLElement$2(C))) {
		let m = getBoundingClientRect(C);
		j = getScale$1(C), M.x = m.x + C.clientLeft, M.y = m.y + C.clientTop;
	}
	let P = O && !N && !D ? getHTMLOffset(O, A) : createCoords(0);
	return {
		width: S.width * j.x,
		height: S.height * j.y,
		x: S.x * j.x - A.scrollLeft * j.x + M.x + P.x,
		y: S.y * j.y - A.scrollTop * j.y + M.y + P.y
	};
}
function getClientRects(m) {
	return Array.from(m.getClientRects());
}
function getDocumentRect(m) {
	let x = getDocumentElement(m), S = getNodeScroll(m), C = m.ownerDocument.body, T = max(x.scrollWidth, x.clientWidth, C.scrollWidth, C.clientWidth), D = max(x.scrollHeight, x.clientHeight, C.scrollHeight, C.clientHeight), O = -S.scrollLeft + getWindowScrollBarX(m), k = -S.scrollTop;
	return getComputedStyle$3(C).direction === "rtl" && (O += max(x.clientWidth, C.clientWidth) - T), {
		width: T,
		height: D,
		x: O,
		y: k
	};
}
var SCROLLBAR_MAX = 25;
function getViewportRect(m, x) {
	let S = getWindow$2(m), C = getDocumentElement(m), T = S.visualViewport, D = C.clientWidth, O = C.clientHeight, k = 0, A = 0;
	if (T) {
		D = T.width, O = T.height;
		let m = isWebKit();
		(!m || m && x === "fixed") && (k = T.offsetLeft, A = T.offsetTop);
	}
	let j = getWindowScrollBarX(C);
	if (j <= 0) {
		let m = C.ownerDocument, x = m.body, S = getComputedStyle(x), T = m.compatMode === "CSS1Compat" && parseFloat(S.marginLeft) + parseFloat(S.marginRight) || 0, O = Math.abs(C.clientWidth - x.clientWidth - T);
		O <= SCROLLBAR_MAX && (D -= O);
	} else j <= SCROLLBAR_MAX && (D += j);
	return {
		width: D,
		height: O,
		x: k,
		y: A
	};
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(m, x) {
	let S = getBoundingClientRect(m, !0, x === "fixed"), C = S.top + m.clientTop, T = S.left + m.clientLeft, D = isHTMLElement$2(m) ? getScale$1(m) : createCoords(1);
	return {
		width: m.clientWidth * D.x,
		height: m.clientHeight * D.y,
		x: T * D.x,
		y: C * D.y
	};
}
function getClientRectFromClippingAncestor(m, x, S) {
	let C;
	if (x === "viewport") C = getViewportRect(m, S);
	else if (x === "document") C = getDocumentRect(getDocumentElement(m));
	else if (isElement$1(x)) C = getInnerBoundingClientRect(x, S);
	else {
		let S = getVisualOffsets(m);
		C = {
			x: x.x - S.x,
			y: x.y - S.y,
			width: x.width,
			height: x.height
		};
	}
	return rectToClientRect(C);
}
function hasFixedPositionAncestor(m, x) {
	let S = getParentNode(m);
	return S === x || !isElement$1(S) || isLastTraversableNode(S) ? !1 : getComputedStyle$3(S).position === "fixed" || hasFixedPositionAncestor(S, x);
}
function getClippingElementAncestors(m, x) {
	let S = x.get(m);
	if (S) return S;
	let C = getOverflowAncestors(m, [], !1).filter((m) => isElement$1(m) && getNodeName(m) !== "body"), T = null, D = getComputedStyle$3(m).position === "fixed", O = D ? getParentNode(m) : m;
	for (; isElement$1(O) && !isLastTraversableNode(O);) {
		let x = getComputedStyle$3(O), S = isContainingBlock(O);
		!S && x.position === "fixed" && (T = null), (D ? !S && !T : !S && x.position === "static" && T && absoluteOrFixed.has(T.position) || isOverflowElement(O) && !S && hasFixedPositionAncestor(m, O)) ? C = C.filter((m) => m !== O) : T = x, O = getParentNode(O);
	}
	return x.set(m, C), C;
}
function getClippingRect(m) {
	let { element: x, boundary: S, rootBoundary: C, strategy: T } = m, D = [...S === "clippingAncestors" ? isTopLayer(x) ? [] : getClippingElementAncestors(x, this._c) : [].concat(S), C], O = D[0], k = D.reduce((m, S) => {
		let C = getClientRectFromClippingAncestor(x, S, T);
		return m.top = max(C.top, m.top), m.right = min(C.right, m.right), m.bottom = min(C.bottom, m.bottom), m.left = max(C.left, m.left), m;
	}, getClientRectFromClippingAncestor(x, O, T));
	return {
		width: k.right - k.left,
		height: k.bottom - k.top,
		x: k.left,
		y: k.top
	};
}
function getDimensions(m) {
	let { width: x, height: S } = getCssDimensions(m);
	return {
		width: x,
		height: S
	};
}
function getRectRelativeToOffsetParent(m, x, S) {
	let C = isHTMLElement$2(x), T = getDocumentElement(x), D = S === "fixed", O = getBoundingClientRect(m, !0, D, x), k = {
		scrollLeft: 0,
		scrollTop: 0
	}, A = createCoords(0);
	function j() {
		A.x = getWindowScrollBarX(T);
	}
	if (C || !C && !D) if ((getNodeName(x) !== "body" || isOverflowElement(T)) && (k = getNodeScroll(x)), C) {
		let m = getBoundingClientRect(x, !0, D, x);
		A.x = m.x + x.clientLeft, A.y = m.y + x.clientTop;
	} else T && j();
	D && !C && T && j();
	let M = T && !C && !D ? getHTMLOffset(T, k) : createCoords(0);
	return {
		x: O.left + k.scrollLeft - A.x - M.x,
		y: O.top + k.scrollTop - A.y - M.y,
		width: O.width,
		height: O.height
	};
}
function isStaticPositioned(m) {
	return getComputedStyle$3(m).position === "static";
}
function getTrueOffsetParent(m, x) {
	if (!isHTMLElement$2(m) || getComputedStyle$3(m).position === "fixed") return null;
	if (x) return x(m);
	let S = m.offsetParent;
	return getDocumentElement(m) === S && (S = S.ownerDocument.body), S;
}
function getOffsetParent(m, x) {
	let S = getWindow$2(m);
	if (isTopLayer(m)) return S;
	if (!isHTMLElement$2(m)) {
		let x = getParentNode(m);
		for (; x && !isLastTraversableNode(x);) {
			if (isElement$1(x) && !isStaticPositioned(x)) return x;
			x = getParentNode(x);
		}
		return S;
	}
	let C = getTrueOffsetParent(m, x);
	for (; C && isTableElement(C) && isStaticPositioned(C);) C = getTrueOffsetParent(C, x);
	return C && isLastTraversableNode(C) && isStaticPositioned(C) && !isContainingBlock(C) ? S : C || getContainingBlock(m) || S;
}
var getElementRects = async function(m) {
	let x = this.getOffsetParent || getOffsetParent, S = this.getDimensions, C = await S(m.floating);
	return {
		reference: getRectRelativeToOffsetParent(m.reference, await x(m.floating), m.strategy),
		floating: {
			x: 0,
			y: 0,
			width: C.width,
			height: C.height
		}
	};
};
function isRTL(m) {
	return getComputedStyle$3(m).direction === "rtl";
}
var platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale: getScale$1,
	isElement: isElement$1,
	isRTL
};
function rectsAreEqual(m, x) {
	return m.x === x.x && m.y === x.y && m.width === x.width && m.height === x.height;
}
function observeMove(m, x) {
	let S = null, C, T = getDocumentElement(m);
	function D() {
		var m;
		clearTimeout(C), (m = S) == null || m.disconnect(), S = null;
	}
	function O(k, A) {
		k === void 0 && (k = !1), A === void 0 && (A = 1), D();
		let j = m.getBoundingClientRect(), { left: M, top: N, width: P, height: F } = j;
		if (k || x(), !P || !F) return;
		let I = floor(N), L = floor(T.clientWidth - (M + P)), R = floor(T.clientHeight - (N + F)), z = floor(M), B = {
			rootMargin: -I + "px " + -L + "px " + -R + "px " + -z + "px",
			threshold: max(0, min(1, A)) || 1
		}, H = !0;
		function U(x) {
			let S = x[0].intersectionRatio;
			if (S !== A) {
				if (!H) return O();
				S ? O(!1, S) : C = setTimeout(() => {
					O(!1, 1e-7);
				}, 1e3);
			}
			S === 1 && !rectsAreEqual(j, m.getBoundingClientRect()) && O(), H = !1;
		}
		try {
			S = new IntersectionObserver(U, {
				...B,
				root: T.ownerDocument
			});
		} catch {
			S = new IntersectionObserver(U, B);
		}
		S.observe(m);
	}
	return O(!0), D;
}
function autoUpdate(m, x, S, C) {
	C === void 0 && (C = {});
	let { ancestorScroll: T = !0, ancestorResize: D = !0, elementResize: O = typeof ResizeObserver == "function", layoutShift: k = typeof IntersectionObserver == "function", animationFrame: A = !1 } = C, j = unwrapElement(m), M = T || D ? [...j ? getOverflowAncestors(j) : [], ...getOverflowAncestors(x)] : [];
	M.forEach((m) => {
		T && m.addEventListener("scroll", S, { passive: !0 }), D && m.addEventListener("resize", S);
	});
	let N = j && k ? observeMove(j, S) : null, P = -1, F = null;
	O && (F = new ResizeObserver((m) => {
		let [C] = m;
		C && C.target === j && F && (F.unobserve(x), cancelAnimationFrame(P), P = requestAnimationFrame(() => {
			var m;
			(m = F) == null || m.observe(x);
		})), S();
	}), j && !A && F.observe(j), F.observe(x));
	let I, L = A ? getBoundingClientRect(m) : null;
	A && R();
	function R() {
		let x = getBoundingClientRect(m);
		L && !rectsAreEqual(L, x) && S(), L = x, I = requestAnimationFrame(R);
	}
	return S(), () => {
		var m;
		M.forEach((m) => {
			T && m.removeEventListener("scroll", S), D && m.removeEventListener("resize", S);
		}), N?.(), (m = F) == null || m.disconnect(), F = null, A && cancelAnimationFrame(I);
	};
}
var offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, arrow$1 = arrow$2, limitShift$1 = limitShift$2, computePosition = (m, x, S) => {
	let C = /* @__PURE__ */ new Map(), T = {
		platform,
		...S
	}, D = {
		...T.platform,
		_c: C
	};
	return computePosition$1(m, x, {
		...T,
		platform: D
	});
}, index = typeof document < "u" ? useLayoutEffect : function() {};
function deepEqual$1(m, x) {
	if (m === x) return !0;
	if (typeof m != typeof x) return !1;
	if (typeof m == "function" && m.toString() === x.toString()) return !0;
	let S, C, T;
	if (m && x && typeof m == "object") {
		if (Array.isArray(m)) {
			if (S = m.length, S !== x.length) return !1;
			for (C = S; C-- !== 0;) if (!deepEqual$1(m[C], x[C])) return !1;
			return !0;
		}
		if (T = Object.keys(m), S = T.length, S !== Object.keys(x).length) return !1;
		for (C = S; C-- !== 0;) if (!{}.hasOwnProperty.call(x, T[C])) return !1;
		for (C = S; C-- !== 0;) {
			let S = T[C];
			if (!(S === "_owner" && m.$$typeof) && !deepEqual$1(m[S], x[S])) return !1;
		}
		return !0;
	}
	return m !== m && x !== x;
}
function getDPR(m) {
	return typeof window > "u" ? 1 : (m.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(m, x) {
	let S = getDPR(m);
	return Math.round(x * S) / S;
}
function useLatestRef(x) {
	let S = React$1.useRef(x);
	return index(() => {
		S.current = x;
	}), S;
}
function useFloating(x) {
	x === void 0 && (x = {});
	let { placement: S = "bottom", strategy: C = "absolute", middleware: T = [], platform: D, elements: { reference: O, floating: k } = {}, transform: A = !0, whileElementsMounted: j, open: M } = x, [N, P] = React$1.useState({
		x: 0,
		y: 0,
		strategy: C,
		placement: S,
		middlewareData: {},
		isPositioned: !1
	}), [F, I] = React$1.useState(T);
	deepEqual$1(F, T) || I(T);
	let [L, R] = React$1.useState(null), [z, B] = React$1.useState(null), H = React$1.useCallback((m) => {
		m !== K.current && (K.current = m, R(m));
	}, []), U = React$1.useCallback((m) => {
		m !== J.current && (J.current = m, B(m));
	}, []), W = O || L, G = k || z, K = React$1.useRef(null), J = React$1.useRef(null), Y = React$1.useRef(N), X = j != null, Z = useLatestRef(j), sH = useLatestRef(D), Q = useLatestRef(M), cH = React$1.useCallback(() => {
		if (!K.current || !J.current) return;
		let m = {
			placement: S,
			strategy: C,
			middleware: F
		};
		sH.current && (m.platform = sH.current), computePosition(K.current, J.current, m).then((m) => {
			let x = {
				...m,
				isPositioned: Q.current !== !1
			};
			lH.current && !deepEqual$1(Y.current, x) && (Y.current = x, ReactDOM$1.flushSync(() => {
				P(x);
			}));
		});
	}, [
		F,
		S,
		C,
		sH,
		Q
	]);
	index(() => {
		M === !1 && Y.current.isPositioned && (Y.current.isPositioned = !1, P((m) => ({
			...m,
			isPositioned: !1
		})));
	}, [M]);
	let lH = React$1.useRef(!1);
	index(() => (lH.current = !0, () => {
		lH.current = !1;
	}), []), index(() => {
		if (W && (K.current = W), G && (J.current = G), W && G) {
			if (Z.current) return Z.current(W, G, cH);
			cH();
		}
	}, [
		W,
		G,
		cH,
		Z,
		X
	]);
	let uH = React$1.useMemo(() => ({
		reference: K,
		floating: J,
		setReference: H,
		setFloating: U
	}), [H, U]), dH = React$1.useMemo(() => ({
		reference: W,
		floating: G
	}), [W, G]), fH = React$1.useMemo(() => {
		let m = {
			position: C,
			left: 0,
			top: 0
		};
		if (!dH.floating) return m;
		let x = roundByDPR(dH.floating, N.x), S = roundByDPR(dH.floating, N.y);
		return A ? {
			...m,
			transform: "translate(" + x + "px, " + S + "px)",
			...getDPR(dH.floating) >= 1.5 && { willChange: "transform" }
		} : {
			position: C,
			left: x,
			top: S
		};
	}, [
		C,
		A,
		dH.floating,
		N.x,
		N.y
	]);
	return React$1.useMemo(() => ({
		...N,
		update: cH,
		refs: uH,
		elements: dH,
		floatingStyles: fH
	}), [
		N,
		cH,
		uH,
		dH,
		fH
	]);
}
var arrow$1$1 = (m) => {
	function x(m) {
		return {}.hasOwnProperty.call(m, "current");
	}
	return {
		name: "arrow",
		options: m,
		fn(S) {
			let { element: C, padding: T } = typeof m == "function" ? m(S) : m;
			return C && x(C) ? C.current == null ? {} : arrow$1({
				element: C.current,
				padding: T
			}).fn(S) : C ? arrow$1({
				element: C,
				padding: T
			}).fn(S) : {};
		}
	};
}, offset = (m, x) => ({
	...offset$1(m),
	options: [m, x]
}), shift = (m, x) => ({
	...shift$1(m),
	options: [m, x]
}), limitShift = (m, x) => ({
	...limitShift$1(m),
	options: [m, x]
}), flip = (m, x) => ({
	...flip$1(m),
	options: [m, x]
}), size = (m, x) => ({
	...size$1(m),
	options: [m, x]
}), hide = (m, x) => ({
	...hide$1(m),
	options: [m, x]
}), arrow = (m, x) => ({
	...arrow$1$1(m),
	options: [m, x]
}), NAME$1 = "Arrow", Arrow$3 = React$1.forwardRef((m, x) => {
	let { children: S, width: C = 10, height: T = 5, ...D } = m;
	return /* @__PURE__ */ jsx(Primitive.svg, {
		...D,
		ref: x,
		width: C,
		height: T,
		viewBox: "0 0 30 10",
		preserveAspectRatio: "none",
		children: m.asChild ? S : /* @__PURE__ */ jsx("polygon", { points: "0,0 30,0 15,10" })
	});
});
Arrow$3.displayName = NAME$1;
var Root = Arrow$3;
function useSize(x) {
	let [S, C] = React$1.useState(void 0);
	return useLayoutEffect2(() => {
		if (x) {
			C({
				width: x.offsetWidth,
				height: x.offsetHeight
			});
			let m = new ResizeObserver((m) => {
				if (!Array.isArray(m) || !m.length) return;
				let S = m[0], T, D;
				if ("borderBoxSize" in S) {
					let m = S.borderBoxSize, x = Array.isArray(m) ? m[0] : m;
					T = x.inlineSize, D = x.blockSize;
				} else T = x.offsetWidth, D = x.offsetHeight;
				C({
					width: T,
					height: D
				});
			});
			return m.observe(x, { box: "border-box" }), () => m.unobserve(x);
		} else C(void 0);
	}, [x]), S;
}
var POPPER_NAME = "Popper", [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME), [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME), Popper = (x) => {
	let { __scopePopper: S, children: C } = x, [T, D] = React$1.useState(null);
	return /* @__PURE__ */ jsx(PopperProvider, {
		scope: S,
		anchor: T,
		onAnchorChange: D,
		children: C
	});
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor", PopperAnchor = React$1.forwardRef((x, S) => {
	let { __scopePopper: C, virtualRef: T, ...D } = x, O = usePopperContext(ANCHOR_NAME, C), k = React$1.useRef(null), A = useComposedRefs(S, k), j = React$1.useRef(null);
	return React$1.useEffect(() => {
		let m = j.current;
		j.current = T?.current || k.current, m !== j.current && O.onAnchorChange(j.current);
	}), T ? null : /* @__PURE__ */ jsx(Primitive.div, {
		...D,
		ref: A
	});
});
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$1 = "PopperContent", [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1), PopperContent = React$1.forwardRef((x, S) => {
	let { __scopePopper: C, side: T = "bottom", sideOffset: D = 0, align: O = "center", alignOffset: k = 0, arrowPadding: A = 0, avoidCollisions: j = !0, collisionBoundary: M = [], collisionPadding: N = 0, sticky: P = "partial", hideWhenDetached: F = !1, updatePositionStrategy: I = "optimized", onPlaced: L, ...R } = x, z = usePopperContext(CONTENT_NAME$1, C), [B, H] = React$1.useState(null), U = useComposedRefs(S, (m) => H(m)), [W, K] = React$1.useState(null), q = useSize(W), J = q?.width ?? 0, Y = q?.height ?? 0, X = T + (O === "center" ? "" : "-" + O), Z = typeof N == "number" ? N : {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...N
	}, sH = Array.isArray(M) ? M : [M], Q = sH.length > 0, cH = {
		padding: Z,
		boundary: sH.filter(isNotNull$2),
		altBoundary: Q
	}, { refs: lH, floatingStyles: uH, placement: dH, isPositioned: fH, middlewareData: pH } = useFloating({
		strategy: "fixed",
		placement: X,
		whileElementsMounted: (...m) => autoUpdate(...m, { animationFrame: I === "always" }),
		elements: { reference: z.anchor },
		middleware: [
			offset({
				mainAxis: D + Y,
				alignmentAxis: k
			}),
			j && shift({
				mainAxis: !0,
				crossAxis: !1,
				limiter: P === "partial" ? limitShift() : void 0,
				...cH
			}),
			j && flip({ ...cH }),
			size({
				...cH,
				apply: ({ elements: m, rects: x, availableWidth: S, availableHeight: C }) => {
					let { width: T, height: D } = x.reference, O = m.floating.style;
					O.setProperty("--radix-popper-available-width", `${S}px`), O.setProperty("--radix-popper-available-height", `${C}px`), O.setProperty("--radix-popper-anchor-width", `${T}px`), O.setProperty("--radix-popper-anchor-height", `${D}px`);
				}
			}),
			W && arrow({
				element: W,
				padding: A
			}),
			transformOrigin({
				arrowWidth: J,
				arrowHeight: Y
			}),
			F && hide({
				strategy: "referenceHidden",
				...cH
			})
		]
	}), [mH, hH] = getSideAndAlignFromPlacement(dH), gH = useCallbackRef(L);
	useLayoutEffect2(() => {
		fH && gH?.();
	}, [fH, gH]);
	let $ = pH.arrow?.x, _H = pH.arrow?.y, vH = pH.arrow?.centerOffset !== 0, [yH, bH] = React$1.useState();
	return useLayoutEffect2(() => {
		B && bH(window.getComputedStyle(B).zIndex);
	}, [B]), /* @__PURE__ */ jsx("div", {
		ref: lH.setFloating,
		"data-radix-popper-content-wrapper": "",
		style: {
			...uH,
			transform: fH ? uH.transform : "translate(0, -200%)",
			minWidth: "max-content",
			zIndex: yH,
			"--radix-popper-transform-origin": [pH.transformOrigin?.x, pH.transformOrigin?.y].join(" "),
			...pH.hide?.referenceHidden && {
				visibility: "hidden",
				pointerEvents: "none"
			}
		},
		dir: x.dir,
		children: /* @__PURE__ */ jsx(PopperContentProvider, {
			scope: C,
			placedSide: mH,
			onArrowChange: K,
			arrowX: $,
			arrowY: _H,
			shouldHideArrow: vH,
			children: /* @__PURE__ */ jsx(Primitive.div, {
				"data-side": mH,
				"data-align": hH,
				...R,
				ref: U,
				style: {
					...R.style,
					animation: fH ? void 0 : "none"
				}
			})
		})
	});
});
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow", OPPOSITE_SIDE = {
	top: "bottom",
	right: "left",
	bottom: "top",
	left: "right"
}, PopperArrow = React$1.forwardRef(function(m, x) {
	let { __scopePopper: S, ...C } = m, T = useContentContext(ARROW_NAME$1, S), D = OPPOSITE_SIDE[T.placedSide];
	return /* @__PURE__ */ jsx("span", {
		ref: T.onArrowChange,
		style: {
			position: "absolute",
			left: T.arrowX,
			top: T.arrowY,
			[D]: 0,
			transformOrigin: {
				top: "",
				right: "0 0",
				bottom: "center 0",
				left: "100% 0"
			}[T.placedSide],
			transform: {
				top: "translateY(100%)",
				right: "translateY(50%) rotate(90deg) translateX(-50%)",
				bottom: "rotate(180deg)",
				left: "translateY(50%) rotate(-90deg) translateX(50%)"
			}[T.placedSide],
			visibility: T.shouldHideArrow ? "hidden" : void 0
		},
		children: /* @__PURE__ */ jsx(Root, {
			...C,
			ref: x,
			style: {
				...C.style,
				display: "block"
			}
		})
	});
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull$2(m) {
	return m !== null;
}
var transformOrigin = (m) => ({
	name: "transformOrigin",
	options: m,
	fn(x) {
		let { placement: S, rects: C, middlewareData: T } = x, D = T.arrow?.centerOffset !== 0, O = D ? 0 : m.arrowWidth, k = D ? 0 : m.arrowHeight, [A, j] = getSideAndAlignFromPlacement(S), M = {
			start: "0%",
			center: "50%",
			end: "100%"
		}[j], N = (T.arrow?.x ?? 0) + O / 2, P = (T.arrow?.y ?? 0) + k / 2, F = "", I = "";
		return A === "bottom" ? (F = D ? M : `${N}px`, I = `${-k}px`) : A === "top" ? (F = D ? M : `${N}px`, I = `${C.floating.height + k}px`) : A === "right" ? (F = `${-k}px`, I = D ? M : `${P}px`) : A === "left" && (F = `${C.floating.width + k}px`, I = D ? M : `${P}px`), { data: {
			x: F,
			y: I
		} };
	}
});
function getSideAndAlignFromPlacement(m) {
	let [x, S = "center"] = m.split("-");
	return [x, S];
}
var Root2$1 = Popper, Anchor = PopperAnchor, Content = PopperContent, Arrow$2 = PopperArrow, PORTAL_NAME$1 = "Portal", Portal = React$1.forwardRef((x, S) => {
	let { container: C, ...T } = x, [D, O] = React$1.useState(!1);
	useLayoutEffect2(() => O(!0), []);
	let k = C || D && globalThis?.document?.body;
	return k ? ReactDOM.createPortal(/* @__PURE__ */ jsx(Primitive.div, {
		...T,
		ref: S
	}), k) : null;
});
Portal.displayName = PORTAL_NAME$1;
var useInsertionEffect$1 = React$1.useInsertionEffect || useLayoutEffect2;
function useControllableState({ prop: x, defaultProp: S, onChange: C = () => {}, caller: T }) {
	let [D, O, k] = useUncontrolledState({
		defaultProp: S,
		onChange: C
	}), A = x !== void 0, j = A ? x : D;
	{
		let S = React$1.useRef(x !== void 0);
		React$1.useEffect(() => {
			let m = S.current;
			if (m !== A) {
				let x = m ? "controlled" : "uncontrolled", S = A ? "controlled" : "uncontrolled";
				console.warn(`${T} is changing from ${x} to ${S}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
			}
			S.current = A;
		}, [A, T]);
	}
	return [j, React$1.useCallback((m) => {
		if (A) {
			let S = isFunction(m) ? m(x) : m;
			S !== x && k.current?.(S);
		} else O(m);
	}, [
		A,
		x,
		O,
		k
	])];
}
function useUncontrolledState({ defaultProp: x, onChange: S }) {
	let [C, T] = React$1.useState(x), D = React$1.useRef(C), O = React$1.useRef(S);
	return useInsertionEffect$1(() => {
		O.current = S;
	}, [S]), React$1.useEffect(() => {
		D.current !== C && (O.current?.(C), D.current = C);
	}, [C, D]), [
		C,
		T,
		O
	];
}
function isFunction(m) {
	return typeof m == "function";
}
function usePrevious(x) {
	let S = React$1.useRef({
		value: x,
		previous: x
	});
	return React$1.useMemo(() => (S.current.value !== x && (S.current.previous = S.current.value, S.current.value = x), S.current.previous), [x]);
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
	position: "absolute",
	border: 0,
	width: 1,
	height: 1,
	padding: 0,
	margin: -1,
	overflow: "hidden",
	clip: "rect(0, 0, 0, 0)",
	whiteSpace: "nowrap",
	wordWrap: "normal"
}), NAME = "VisuallyHidden", VisuallyHidden = React$1.forwardRef((m, x) => /* @__PURE__ */ jsx(Primitive.span, {
	...m,
	ref: x,
	style: {
		...VISUALLY_HIDDEN_STYLES,
		...m.style
	}
}));
VisuallyHidden.displayName = NAME;
var getDefaultParent = function(m) {
	return typeof document > "u" ? null : (Array.isArray(m) ? m[0] : m).ownerDocument.body;
}, counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {}, lockCount = 0, unwrapHost = function(m) {
	return m && (m.host || unwrapHost(m.parentNode));
}, correctTargets = function(m, x) {
	return x.map(function(x) {
		if (m.contains(x)) return x;
		var S = unwrapHost(x);
		return S && m.contains(S) ? S : (console.error("aria-hidden", x, "in not contained inside", m, ". Doing nothing"), null);
	}).filter(function(m) {
		return !!m;
	});
}, applyAttributeToOthers = function(m, x, S, C) {
	var T = correctTargets(x, Array.isArray(m) ? m : [m]);
	markerMap[S] || (markerMap[S] = /* @__PURE__ */ new WeakMap());
	var D = markerMap[S], O = [], k = /* @__PURE__ */ new Set(), A = new Set(T), j = function(m) {
		!m || k.has(m) || (k.add(m), j(m.parentNode));
	};
	T.forEach(j);
	var M = function(m) {
		!m || A.has(m) || Array.prototype.forEach.call(m.children, function(m) {
			if (k.has(m)) M(m);
			else try {
				var x = m.getAttribute(C), T = x !== null && x !== "false", A = (counterMap.get(m) || 0) + 1, j = (D.get(m) || 0) + 1;
				counterMap.set(m, A), D.set(m, j), O.push(m), A === 1 && T && uncontrolledNodes.set(m, !0), j === 1 && m.setAttribute(S, "true"), T || m.setAttribute(C, "true");
			} catch (x) {
				console.error("aria-hidden: cannot operate on ", m, x);
			}
		});
	};
	return M(x), k.clear(), lockCount++, function() {
		O.forEach(function(m) {
			var x = counterMap.get(m) - 1, T = D.get(m) - 1;
			counterMap.set(m, x), D.set(m, T), x || (uncontrolledNodes.has(m) || m.removeAttribute(C), uncontrolledNodes.delete(m)), T || m.removeAttribute(S);
		}), lockCount--, lockCount || (counterMap = /* @__PURE__ */ new WeakMap(), counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {});
	};
}, hideOthers = function(m, x, S) {
	S === void 0 && (S = "data-aria-hidden");
	var C = Array.from(Array.isArray(m) ? m : [m]), T = x || getDefaultParent(m);
	return T ? (C.push.apply(C, Array.from(T.querySelectorAll("[aria-live], script"))), applyAttributeToOthers(C, T, S, "aria-hidden")) : function() {
		return null;
	};
}, __assign = function() {
	return __assign = Object.assign || function(m) {
		for (var x, S = 1, C = arguments.length; S < C; S++) for (var T in x = arguments[S], x) Object.prototype.hasOwnProperty.call(x, T) && (m[T] = x[T]);
		return m;
	}, __assign.apply(this, arguments);
};
function __rest(m, x) {
	var S = {};
	for (var C in m) Object.prototype.hasOwnProperty.call(m, C) && x.indexOf(C) < 0 && (S[C] = m[C]);
	if (m != null && typeof Object.getOwnPropertySymbols == "function") for (var T = 0, C = Object.getOwnPropertySymbols(m); T < C.length; T++) x.indexOf(C[T]) < 0 && Object.prototype.propertyIsEnumerable.call(m, C[T]) && (S[C[T]] = m[C[T]]);
	return S;
}
function __spreadArray(m, x, S) {
	if (S || arguments.length === 2) for (var C = 0, T = x.length, D; C < T; C++) (D || !(C in x)) && (D ||= Array.prototype.slice.call(x, 0, C), D[C] = x[C]);
	return m.concat(D || Array.prototype.slice.call(x));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(m, x) {
	return typeof m == "function" ? m(x) : m && (m.current = x), m;
}
function useCallbackRef$1(m, x) {
	var S = useState(function() {
		return {
			value: m,
			callback: x,
			facade: {
				get current() {
					return S.value;
				},
				set current(m) {
					var x = S.value;
					x !== m && (S.value = m, S.callback(m, x));
				}
			}
		};
	})[0];
	return S.callback = x, S.facade;
}
var useIsomorphicLayoutEffect$4 = typeof window < "u" ? React$1.useLayoutEffect : React$1.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(m, x) {
	var S = useCallbackRef$1(x || null, function(x) {
		return m.forEach(function(m) {
			return assignRef$1(m, x);
		});
	});
	return useIsomorphicLayoutEffect$4(function() {
		var x = currentValues.get(S);
		if (x) {
			var C = new Set(x), T = new Set(m), D = S.current;
			C.forEach(function(m) {
				T.has(m) || assignRef$1(m, null);
			}), T.forEach(function(m) {
				C.has(m) || assignRef$1(m, D);
			});
		}
		currentValues.set(S, m);
	}, [m]), S;
}
function ItoI(m) {
	return m;
}
function innerCreateMedium(m, x) {
	x === void 0 && (x = ItoI);
	var S = [], C = !1;
	return {
		read: function() {
			if (C) throw Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
			return S.length ? S[S.length - 1] : m;
		},
		useMedium: function(m) {
			var T = x(m, C);
			return S.push(T), function() {
				S = S.filter(function(m) {
					return m !== T;
				});
			};
		},
		assignSyncMedium: function(m) {
			for (C = !0; S.length;) {
				var x = S;
				S = [], x.forEach(m);
			}
			S = {
				push: function(x) {
					return m(x);
				},
				filter: function() {
					return S;
				}
			};
		},
		assignMedium: function(m) {
			C = !0;
			var x = [];
			if (S.length) {
				var T = S;
				S = [], T.forEach(m), x = S;
			}
			var D = function() {
				var S = x;
				x = [], S.forEach(m);
			}, O = function() {
				return Promise.resolve().then(D);
			};
			O(), S = {
				push: function(m) {
					x.push(m), O();
				},
				filter: function(m) {
					return x = x.filter(m), S;
				}
			};
		}
	};
}
function createSidecarMedium(m) {
	m === void 0 && (m = {});
	var x = innerCreateMedium(null);
	return x.options = __assign({
		async: !0,
		ssr: !1
	}, m), x;
}
var SideCar = function(x) {
	var S = x.sideCar, C = __rest(x, ["sideCar"]);
	if (!S) throw Error("Sidecar: please provide `sideCar` property to import the right car");
	var T = S.read();
	if (!T) throw Error("Sidecar medium not found");
	return React$1.createElement(T, __assign({}, C));
};
SideCar.isSideCarExport = !0;
function exportSidecar(m, x) {
	return m.useMedium(x), SideCar;
}
var effectCar = createSidecarMedium(), nothing = function() {}, RemoveScroll = React$1.forwardRef(function(x, S) {
	var C = React$1.useRef(null), T = React$1.useState({
		onScrollCapture: nothing,
		onWheelCapture: nothing,
		onTouchMoveCapture: nothing
	}), D = T[0], O = T[1], k = x.forwardProps, A = x.children, j = x.className, M = x.removeScrollBar, N = x.enabled, P = x.shards, F = x.sideCar, I = x.noRelative, L = x.noIsolation, R = x.inert, z = x.allowPinchZoom, B = x.as, H = B === void 0 ? "div" : B, U = x.gapMode, W = __rest(x, [
		"forwardProps",
		"children",
		"className",
		"removeScrollBar",
		"enabled",
		"shards",
		"sideCar",
		"noRelative",
		"noIsolation",
		"inert",
		"allowPinchZoom",
		"as",
		"gapMode"
	]), G = F, K = useMergeRefs([C, S]), q = __assign(__assign({}, W), D);
	return React$1.createElement(React$1.Fragment, null, N && React$1.createElement(G, {
		sideCar: effectCar,
		removeScrollBar: M,
		shards: P,
		noRelative: I,
		noIsolation: L,
		inert: R,
		setCallbacks: O,
		allowPinchZoom: !!z,
		lockRef: C,
		gapMode: U
	}), k ? React$1.cloneElement(React$1.Children.only(A), __assign(__assign({}, q), { ref: K })) : React$1.createElement(H, __assign({}, q, {
		className: j,
		ref: K
	}), A));
});
RemoveScroll.defaultProps = {
	enabled: !0,
	removeScrollBar: !0,
	inert: !1
}, RemoveScroll.classNames = {
	fullWidth: fullWidthClassName,
	zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
	if (currentNonce) return currentNonce;
	if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function makeStyleTag() {
	if (!document) return null;
	var m = document.createElement("style");
	m.type = "text/css";
	var x = getNonce();
	return x && m.setAttribute("nonce", x), m;
}
function injectStyles(m, x) {
	m.styleSheet ? m.styleSheet.cssText = x : m.appendChild(document.createTextNode(x));
}
function insertStyleTag(m) {
	(document.head || document.getElementsByTagName("head")[0]).appendChild(m);
}
var stylesheetSingleton = function() {
	var m = 0, x = null;
	return {
		add: function(S) {
			m == 0 && (x = makeStyleTag()) && (injectStyles(x, S), insertStyleTag(x)), m++;
		},
		remove: function() {
			m--, !m && x && (x.parentNode && x.parentNode.removeChild(x), x = null);
		}
	};
}, styleHookSingleton = function() {
	var x = stylesheetSingleton();
	return function(S, C) {
		React$1.useEffect(function() {
			return x.add(S), function() {
				x.remove();
			};
		}, [S && C]);
	};
}, styleSingleton = function() {
	var m = styleHookSingleton();
	return function(x) {
		var S = x.styles, C = x.dynamic;
		return m(S, C), null;
	};
}, zeroGap = {
	left: 0,
	top: 0,
	right: 0,
	gap: 0
}, parse$2 = function(m) {
	return parseInt(m || "", 10) || 0;
}, getOffset = function(m) {
	var x = window.getComputedStyle(document.body), S = x[m === "padding" ? "paddingLeft" : "marginLeft"], C = x[m === "padding" ? "paddingTop" : "marginTop"], T = x[m === "padding" ? "paddingRight" : "marginRight"];
	return [
		parse$2(S),
		parse$2(C),
		parse$2(T)
	];
}, getGapWidth = function(m) {
	if (m === void 0 && (m = "margin"), typeof window > "u") return zeroGap;
	var x = getOffset(m), S = document.documentElement.clientWidth, C = window.innerWidth;
	return {
		left: x[0],
		top: x[1],
		right: x[2],
		gap: Math.max(0, C - S + x[2] - x[0])
	};
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles$1 = function(m, x, S, C) {
	var T = m.left, D = m.top, O = m.right, k = m.gap;
	return S === void 0 && (S = "margin"), `
  .${noScrollbarsClassName} {
   overflow: hidden ${C};
   padding-right: ${k}px ${C};
  }
  body[${lockAttribute}] {
    overflow: hidden ${C};
    overscroll-behavior: contain;
    ${[
		x && `position: relative ${C};`,
		S === "margin" && `
    padding-left: ${T}px;
    padding-top: ${D}px;
    padding-right: ${O}px;
    margin-left:0;
    margin-top:0;
    margin-right: ${k}px ${C};
    `,
		S === "padding" && `padding-right: ${k}px ${C};`
	].filter(Boolean).join("")}
  }
  
  .${zeroRightClassName} {
    right: ${k}px ${C};
  }
  
  .${fullWidthClassName} {
    margin-right: ${k}px ${C};
  }
  
  .${zeroRightClassName} .${zeroRightClassName} {
    right: 0 ${C};
  }
  
  .${fullWidthClassName} .${fullWidthClassName} {
    margin-right: 0 ${C};
  }
  
  body[${lockAttribute}] {
    ${removedBarSizeVariable}: ${k}px;
  }
`;
}, getCurrentUseCounter = function() {
	var m = parseInt(document.body.getAttribute("data-scroll-locked") || "0", 10);
	return isFinite(m) ? m : 0;
}, useLockAttribute = function() {
	React$1.useEffect(function() {
		return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
			var m = getCurrentUseCounter() - 1;
			m <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, m.toString());
		};
	}, []);
}, RemoveScrollBar = function(x) {
	var S = x.noRelative, C = x.noImportant, T = x.gapMode, D = T === void 0 ? "margin" : T;
	useLockAttribute();
	var O = React$1.useMemo(function() {
		return getGapWidth(D);
	}, [D]);
	return React$1.createElement(Style, { styles: getStyles$1(O, !S, D, C ? "" : "!important") });
}, passiveSupported = !1;
if (typeof window < "u") try {
	var options$1 = Object.defineProperty({}, "passive", { get: function() {
		return passiveSupported = !0, !0;
	} });
	window.addEventListener("test", options$1, options$1), window.removeEventListener("test", options$1, options$1);
} catch {
	passiveSupported = !1;
}
var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function(m) {
	return m.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(m, x) {
	if (!(m instanceof Element)) return !1;
	var S = window.getComputedStyle(m);
	return S[x] !== "hidden" && !(S.overflowY === S.overflowX && !alwaysContainsScroll(m) && S[x] === "visible");
}, elementCouldBeVScrolled = function(m) {
	return elementCanBeScrolled(m, "overflowY");
}, elementCouldBeHScrolled = function(m) {
	return elementCanBeScrolled(m, "overflowX");
}, locationCouldBeScrolled = function(m, x) {
	var S = x.ownerDocument, C = x;
	do {
		if (typeof ShadowRoot < "u" && C instanceof ShadowRoot && (C = C.host), elementCouldBeScrolled(m, C)) {
			var T = getScrollVariables(m, C);
			if (T[1] > T[2]) return !0;
		}
		C = C.parentNode;
	} while (C && C !== S.body);
	return !1;
}, getVScrollVariables = function(m) {
	return [
		m.scrollTop,
		m.scrollHeight,
		m.clientHeight
	];
}, getHScrollVariables = function(m) {
	return [
		m.scrollLeft,
		m.scrollWidth,
		m.clientWidth
	];
}, elementCouldBeScrolled = function(m, x) {
	return m === "v" ? elementCouldBeVScrolled(x) : elementCouldBeHScrolled(x);
}, getScrollVariables = function(m, x) {
	return m === "v" ? getVScrollVariables(x) : getHScrollVariables(x);
}, getDirectionFactor = function(m, x) {
	return m === "h" && x === "rtl" ? -1 : 1;
}, handleScroll = function(m, x, S, C, T) {
	var D = getDirectionFactor(m, window.getComputedStyle(x).direction), O = D * C, k = S.target, A = x.contains(k), j = !1, M = O > 0, N = 0, P = 0;
	do {
		if (!k) break;
		var F = getScrollVariables(m, k), I = F[0], L = F[1] - F[2] - D * I;
		(I || L) && elementCouldBeScrolled(m, k) && (N += L, P += I);
		var R = k.parentNode;
		k = R && R.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? R.host : R;
	} while (!A && k !== document.body || A && (x.contains(k) || x === k));
	return (M && (T && Math.abs(N) < 1 || !T && O > N) || !M && (T && Math.abs(P) < 1 || !T && -O > P)) && (j = !0), j;
}, getTouchXY = function(m) {
	return "changedTouches" in m ? [m.changedTouches[0].clientX, m.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(m) {
	return [m.deltaX, m.deltaY];
}, extractRef = function(m) {
	return m && "current" in m ? m.current : m;
}, deltaCompare = function(m, x) {
	return m[0] === x[0] && m[1] === x[1];
}, generateStyle = function(m) {
	return `
  .block-interactivity-${m} {pointer-events: none;}
  .allow-interactivity-${m} {pointer-events: all;}
`;
}, idCounter = 0, lockStack = [];
function RemoveScrollSideCar(x) {
	var S = React$1.useRef([]), C = React$1.useRef([0, 0]), T = React$1.useRef(), D = React$1.useState(idCounter++)[0], O = React$1.useState(styleSingleton)[0], k = React$1.useRef(x);
	React$1.useEffect(function() {
		k.current = x;
	}, [x]), React$1.useEffect(function() {
		if (x.inert) {
			document.body.classList.add(`block-interactivity-${D}`);
			var m = __spreadArray([x.lockRef.current], (x.shards || []).map(extractRef), !0).filter(Boolean);
			return m.forEach(function(m) {
				return m.classList.add(`allow-interactivity-${D}`);
			}), function() {
				document.body.classList.remove(`block-interactivity-${D}`), m.forEach(function(m) {
					return m.classList.remove(`allow-interactivity-${D}`);
				});
			};
		}
	}, [
		x.inert,
		x.lockRef.current,
		x.shards
	]);
	var A = React$1.useCallback(function(m, x) {
		if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey) return !k.current.allowPinchZoom;
		var S = getTouchXY(m), D = C.current, O = "deltaX" in m ? m.deltaX : D[0] - S[0], A = "deltaY" in m ? m.deltaY : D[1] - S[1], j, M = m.target, N = Math.abs(O) > Math.abs(A) ? "h" : "v";
		if ("touches" in m && N === "h" && M.type === "range") return !1;
		var P = window.getSelection(), F = P && P.anchorNode;
		if (F && (F === M || F.contains(M))) return !1;
		var I = locationCouldBeScrolled(N, M);
		if (!I) return !0;
		if (I ? j = N : (j = N === "v" ? "h" : "v", I = locationCouldBeScrolled(N, M)), !I) return !1;
		if (!T.current && "changedTouches" in m && (O || A) && (T.current = j), !j) return !0;
		var L = T.current || j;
		return handleScroll(L, x, m, L === "h" ? O : A, !0);
	}, []), j = React$1.useCallback(function(m) {
		var x = m;
		if (!(!lockStack.length || lockStack[lockStack.length - 1] !== O)) {
			var C = "deltaY" in x ? getDeltaXY(x) : getTouchXY(x), T = S.current.filter(function(m) {
				return m.name === x.type && (m.target === x.target || x.target === m.shadowParent) && deltaCompare(m.delta, C);
			})[0];
			if (T && T.should) {
				x.cancelable && x.preventDefault();
				return;
			}
			if (!T) {
				var D = (k.current.shards || []).map(extractRef).filter(Boolean).filter(function(m) {
					return m.contains(x.target);
				});
				(D.length > 0 ? A(x, D[0]) : !k.current.noIsolation) && x.cancelable && x.preventDefault();
			}
		}
	}, []), M = React$1.useCallback(function(m, x, C, T) {
		var D = {
			name: m,
			delta: x,
			target: C,
			should: T,
			shadowParent: getOutermostShadowParent(C)
		};
		S.current.push(D), setTimeout(function() {
			S.current = S.current.filter(function(m) {
				return m !== D;
			});
		}, 1);
	}, []), N = React$1.useCallback(function(m) {
		C.current = getTouchXY(m), T.current = void 0;
	}, []), P = React$1.useCallback(function(m) {
		M(m.type, getDeltaXY(m), m.target, A(m, x.lockRef.current));
	}, []), F = React$1.useCallback(function(m) {
		M(m.type, getTouchXY(m), m.target, A(m, x.lockRef.current));
	}, []);
	React$1.useEffect(function() {
		return lockStack.push(O), x.setCallbacks({
			onScrollCapture: P,
			onWheelCapture: P,
			onTouchMoveCapture: F
		}), document.addEventListener("wheel", j, nonPassive), document.addEventListener("touchmove", j, nonPassive), document.addEventListener("touchstart", N, nonPassive), function() {
			lockStack = lockStack.filter(function(m) {
				return m !== O;
			}), document.removeEventListener("wheel", j, nonPassive), document.removeEventListener("touchmove", j, nonPassive), document.removeEventListener("touchstart", N, nonPassive);
		};
	}, []);
	var I = x.removeScrollBar, L = x.inert;
	return React$1.createElement(React$1.Fragment, null, L ? React$1.createElement(O, { styles: generateStyle(D) }) : null, I ? React$1.createElement(RemoveScrollBar, {
		noRelative: x.noRelative,
		gapMode: x.gapMode
	}) : null);
}
function getOutermostShadowParent(m) {
	for (var x = null; m !== null;) m instanceof ShadowRoot && (x = m.host, m = m.host), m = m.parentNode;
	return x;
}
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar), ReactRemoveScroll = React$1.forwardRef(function(x, S) {
	return React$1.createElement(RemoveScroll, __assign({}, x, {
		ref: S,
		sideCar: sidecar_default
	}));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll, OPEN_KEYS = [
	" ",
	"Enter",
	"ArrowUp",
	"ArrowDown"
], SELECTION_KEYS = [" ", "Enter"], SELECT_NAME = "Select", [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME), [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [createCollectionScope, createPopperScope]), usePopperScope = createPopperScope(), [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME), [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME), Select$1 = (x) => {
	let { __scopeSelect: S, children: C, open: T, defaultOpen: D, onOpenChange: O, value: k, defaultValue: A, onValueChange: j, dir: M, name: N, autoComplete: P, disabled: F, required: I, form: L } = x, R = usePopperScope(S), [z, B] = React$1.useState(null), [H, U] = React$1.useState(null), [W, q] = React$1.useState(!1), J = useDirection(M), [Y, X] = useControllableState({
		prop: T,
		defaultProp: D ?? !1,
		onChange: O,
		caller: SELECT_NAME
	}), [Z, sH] = useControllableState({
		prop: k,
		defaultProp: A,
		onChange: j,
		caller: SELECT_NAME
	}), Q = React$1.useRef(null), cH = z ? L || !!z.closest("form") : !0, [lH, uH] = React$1.useState(/* @__PURE__ */ new Set()), dH = Array.from(lH).map((m) => m.props.value).join(";");
	return /* @__PURE__ */ jsx(Root2$1, {
		...R,
		children: /* @__PURE__ */ jsxs(SelectProvider, {
			required: I,
			scope: S,
			trigger: z,
			onTriggerChange: B,
			valueNode: H,
			onValueNodeChange: U,
			valueNodeHasChildren: W,
			onValueNodeHasChildrenChange: q,
			contentId: useId$1(),
			value: Z,
			onValueChange: sH,
			open: Y,
			onOpenChange: X,
			dir: J,
			triggerPointerDownPosRef: Q,
			disabled: F,
			children: [/* @__PURE__ */ jsx(Collection.Provider, {
				scope: S,
				children: /* @__PURE__ */ jsx(SelectNativeOptionsProvider, {
					scope: x.__scopeSelect,
					onNativeOptionAdd: React$1.useCallback((m) => {
						uH((x) => new Set(x).add(m));
					}, []),
					onNativeOptionRemove: React$1.useCallback((m) => {
						uH((x) => {
							let S = new Set(x);
							return S.delete(m), S;
						});
					}, []),
					children: C
				})
			}), cH ? /* @__PURE__ */ jsxs(SelectBubbleInput, {
				"aria-hidden": !0,
				required: I,
				tabIndex: -1,
				name: N,
				autoComplete: P,
				value: Z,
				onChange: (m) => sH(m.target.value),
				disabled: F,
				form: L,
				children: [Z === void 0 ? /* @__PURE__ */ jsx("option", { value: "" }) : null, Array.from(lH)]
			}, dH) : null]
		})
	});
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME = "SelectTrigger", SelectTrigger$1 = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, disabled: T = !1, ...D } = x, O = usePopperScope(C), k = useSelectContext(TRIGGER_NAME, C), A = k.disabled || T, j = useComposedRefs(S, k.onTriggerChange), M = useCollection(C), N = React$1.useRef("touch"), [P, F, I] = useTypeaheadSearch((m) => {
		let x = M().filter((m) => !m.disabled), S = findNextItem(x, m, x.find((m) => m.value === k.value));
		S !== void 0 && k.onValueChange(S.value);
	}), L = (m) => {
		A || (k.onOpenChange(!0), I()), m && (k.triggerPointerDownPosRef.current = {
			x: Math.round(m.pageX),
			y: Math.round(m.pageY)
		});
	};
	return /* @__PURE__ */ jsx(Anchor, {
		asChild: !0,
		...O,
		children: /* @__PURE__ */ jsx(Primitive.button, {
			type: "button",
			role: "combobox",
			"aria-controls": k.contentId,
			"aria-expanded": k.open,
			"aria-required": k.required,
			"aria-autocomplete": "none",
			dir: k.dir,
			"data-state": k.open ? "open" : "closed",
			disabled: A,
			"data-disabled": A ? "" : void 0,
			"data-placeholder": shouldShowPlaceholder(k.value) ? "" : void 0,
			...D,
			ref: j,
			onClick: composeEventHandlers(D.onClick, (m) => {
				m.currentTarget.focus(), N.current !== "mouse" && L(m);
			}),
			onPointerDown: composeEventHandlers(D.onPointerDown, (m) => {
				N.current = m.pointerType;
				let x = m.target;
				x.hasPointerCapture(m.pointerId) && x.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && m.pointerType === "mouse" && (L(m), m.preventDefault());
			}),
			onKeyDown: composeEventHandlers(D.onKeyDown, (m) => {
				let x = P.current !== "";
				!(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && F(m.key), !(x && m.key === " ") && OPEN_KEYS.includes(m.key) && (L(), m.preventDefault());
			})
		})
	});
});
SelectTrigger$1.displayName = TRIGGER_NAME;
var VALUE_NAME = "SelectValue", SelectValue$1 = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, className: C, style: T, children: D, placeholder: O = "", ...k } = m, A = useSelectContext(VALUE_NAME, S), { onValueNodeHasChildrenChange: j } = A, M = D !== void 0, N = useComposedRefs(x, A.onValueNodeChange);
	return useLayoutEffect2(() => {
		j(M);
	}, [j, M]), /* @__PURE__ */ jsx(Primitive.span, {
		...k,
		ref: N,
		style: { pointerEvents: "none" },
		children: shouldShowPlaceholder(A.value) ? /* @__PURE__ */ jsx(Fragment$1, { children: O }) : D
	});
});
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon", SelectIcon = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, children: C, ...T } = m;
	return /* @__PURE__ */ jsx(Primitive.span, {
		"aria-hidden": !0,
		...T,
		ref: x,
		children: C || ""
	});
});
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME = "SelectPortal", SelectPortal = (m) => /* @__PURE__ */ jsx(Portal, {
	asChild: !0,
	...m
});
SelectPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "SelectContent", SelectContent$1 = React$1.forwardRef((x, S) => {
	let C = useSelectContext(CONTENT_NAME, x.__scopeSelect), [T, D] = React$1.useState();
	if (useLayoutEffect2(() => {
		D(new DocumentFragment());
	}, []), !C.open) {
		let m = T;
		return m ? ReactDOM$1.createPortal(/* @__PURE__ */ jsx(SelectContentProvider, {
			scope: x.__scopeSelect,
			children: /* @__PURE__ */ jsx(Collection.Slot, {
				scope: x.__scopeSelect,
				children: /* @__PURE__ */ jsx("div", { children: x.children })
			})
		}), m) : null;
	}
	return /* @__PURE__ */ jsx(SelectContentImpl, {
		...x,
		ref: S
	});
});
SelectContent$1.displayName = CONTENT_NAME;
var CONTENT_MARGIN = 10, [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME), CONTENT_IMPL_NAME = "SelectContentImpl", Slot = /* @__PURE__ */ createSlot("SelectContent.RemoveScroll"), SelectContentImpl = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, position: T = "item-aligned", onCloseAutoFocus: D, onEscapeKeyDown: O, onPointerDownOutside: k, side: A, sideOffset: j, align: M, alignOffset: N, arrowPadding: P, collisionBoundary: F, collisionPadding: I, sticky: L, hideWhenDetached: R, avoidCollisions: z, ...B } = x, H = useSelectContext(CONTENT_NAME, C), [U, W] = React$1.useState(null), [K, q] = React$1.useState(null), J = useComposedRefs(S, (m) => W(m)), [Y, X] = React$1.useState(null), [Z, sH] = React$1.useState(null), Q = useCollection(C), [cH, lH] = React$1.useState(!1), uH = React$1.useRef(!1);
	React$1.useEffect(() => {
		if (U) return hideOthers(U);
	}, [U]), useFocusGuards();
	let dH = React$1.useCallback((m) => {
		let [x, ...S] = Q().map((m) => m.ref.current), [C] = S.slice(-1), T = document.activeElement;
		for (let S of m) if (S === T || (S?.scrollIntoView({ block: "nearest" }), S === x && K && (K.scrollTop = 0), S === C && K && (K.scrollTop = K.scrollHeight), S?.focus(), document.activeElement !== T)) return;
	}, [Q, K]), fH = React$1.useCallback(() => dH([Y, U]), [
		dH,
		Y,
		U
	]);
	React$1.useEffect(() => {
		cH && fH();
	}, [cH, fH]);
	let { onOpenChange: pH, triggerPointerDownPosRef: mH } = H;
	React$1.useEffect(() => {
		if (U) {
			let m = {
				x: 0,
				y: 0
			}, x = (x) => {
				m = {
					x: Math.abs(Math.round(x.pageX) - (mH.current?.x ?? 0)),
					y: Math.abs(Math.round(x.pageY) - (mH.current?.y ?? 0))
				};
			}, S = (S) => {
				m.x <= 10 && m.y <= 10 ? S.preventDefault() : U.contains(S.target) || pH(!1), document.removeEventListener("pointermove", x), mH.current = null;
			};
			return mH.current !== null && (document.addEventListener("pointermove", x), document.addEventListener("pointerup", S, {
				capture: !0,
				once: !0
			})), () => {
				document.removeEventListener("pointermove", x), document.removeEventListener("pointerup", S, { capture: !0 });
			};
		}
	}, [
		U,
		pH,
		mH
	]), React$1.useEffect(() => {
		let m = () => pH(!1);
		return window.addEventListener("blur", m), window.addEventListener("resize", m), () => {
			window.removeEventListener("blur", m), window.removeEventListener("resize", m);
		};
	}, [pH]);
	let [hH, gH] = useTypeaheadSearch((m) => {
		let x = Q().filter((m) => !m.disabled), S = findNextItem(x, m, x.find((m) => m.ref.current === document.activeElement));
		S && setTimeout(() => S.ref.current.focus());
	}), $ = React$1.useCallback((m, x, S) => {
		let C = !uH.current && !S;
		(H.value !== void 0 && H.value === x || C) && (X(m), C && (uH.current = !0));
	}, [H.value]), _H = React$1.useCallback(() => U?.focus(), [U]), vH = React$1.useCallback((m, x, S) => {
		let C = !uH.current && !S;
		(H.value !== void 0 && H.value === x || C) && sH(m);
	}, [H.value]), yH = T === "popper" ? SelectPopperPosition : SelectItemAlignedPosition, bH = yH === SelectPopperPosition ? {
		side: A,
		sideOffset: j,
		align: M,
		alignOffset: N,
		arrowPadding: P,
		collisionBoundary: F,
		collisionPadding: I,
		sticky: L,
		hideWhenDetached: R,
		avoidCollisions: z
	} : {};
	return /* @__PURE__ */ jsx(SelectContentProvider, {
		scope: C,
		content: U,
		viewport: K,
		onViewportChange: q,
		itemRefCallback: $,
		selectedItem: Y,
		onItemLeave: _H,
		itemTextRefCallback: vH,
		focusSelectedItem: fH,
		selectedItemText: Z,
		position: T,
		isPositioned: cH,
		searchRef: hH,
		children: /* @__PURE__ */ jsx(Combination_default, {
			as: Slot,
			allowPinchZoom: !0,
			children: /* @__PURE__ */ jsx(FocusScope, {
				asChild: !0,
				trapped: H.open,
				onMountAutoFocus: (m) => {
					m.preventDefault();
				},
				onUnmountAutoFocus: composeEventHandlers(D, (m) => {
					H.trigger?.focus({ preventScroll: !0 }), m.preventDefault();
				}),
				children: /* @__PURE__ */ jsx(DismissableLayer, {
					asChild: !0,
					disableOutsidePointerEvents: !0,
					onEscapeKeyDown: O,
					onPointerDownOutside: k,
					onFocusOutside: (m) => m.preventDefault(),
					onDismiss: () => H.onOpenChange(!1),
					children: /* @__PURE__ */ jsx(yH, {
						role: "listbox",
						id: H.contentId,
						"data-state": H.open ? "open" : "closed",
						dir: H.dir,
						onContextMenu: (m) => m.preventDefault(),
						...B,
						...bH,
						onPlaced: () => lH(!0),
						ref: J,
						style: {
							display: "flex",
							flexDirection: "column",
							outline: "none",
							...B.style
						},
						onKeyDown: composeEventHandlers(B.onKeyDown, (m) => {
							let x = m.ctrlKey || m.altKey || m.metaKey;
							if (m.key === "Tab" && m.preventDefault(), !x && m.key.length === 1 && gH(m.key), [
								"ArrowUp",
								"ArrowDown",
								"Home",
								"End"
							].includes(m.key)) {
								let x = Q().filter((m) => !m.disabled).map((m) => m.ref.current);
								if (["ArrowUp", "End"].includes(m.key) && (x = x.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(m.key)) {
									let S = m.target, C = x.indexOf(S);
									x = x.slice(C + 1);
								}
								setTimeout(() => dH(x)), m.preventDefault();
							}
						})
					})
				})
			})
		})
	});
});
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition", SelectItemAlignedPosition = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, onPlaced: T, ...D } = x, O = useSelectContext(CONTENT_NAME, C), k = useSelectContentContext(CONTENT_NAME, C), [A, j] = React$1.useState(null), [M, N] = React$1.useState(null), P = useComposedRefs(S, (m) => N(m)), F = useCollection(C), I = React$1.useRef(!1), L = React$1.useRef(!0), { viewport: R, selectedItem: z, selectedItemText: B, focusSelectedItem: H } = k, U = React$1.useCallback(() => {
		if (O.trigger && O.valueNode && A && M && R && z && B) {
			let m = O.trigger.getBoundingClientRect(), x = M.getBoundingClientRect(), S = O.valueNode.getBoundingClientRect(), C = B.getBoundingClientRect();
			if (O.dir !== "rtl") {
				let T = C.left - x.left, D = S.left - T, O = m.left - D, k = m.width + O, j = Math.max(k, x.width), M = window.innerWidth - CONTENT_MARGIN, N = clamp$2(D, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, M - j)]);
				A.style.minWidth = k + "px", A.style.left = N + "px";
			} else {
				let T = x.right - C.right, D = window.innerWidth - S.right - T, O = window.innerWidth - m.right - D, k = m.width + O, j = Math.max(k, x.width), M = window.innerWidth - CONTENT_MARGIN, N = clamp$2(D, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, M - j)]);
				A.style.minWidth = k + "px", A.style.right = N + "px";
			}
			let D = F(), k = window.innerHeight - CONTENT_MARGIN * 2, j = R.scrollHeight, N = window.getComputedStyle(M), P = parseInt(N.borderTopWidth, 10), L = parseInt(N.paddingTop, 10), H = parseInt(N.borderBottomWidth, 10), U = parseInt(N.paddingBottom, 10), W = P + L + j + U + H, G = Math.min(z.offsetHeight * 5, W), K = window.getComputedStyle(R), q = parseInt(K.paddingTop, 10), J = parseInt(K.paddingBottom, 10), Y = m.top + m.height / 2 - CONTENT_MARGIN, X = k - Y, Z = z.offsetHeight / 2, sH = z.offsetTop + Z, Q = P + L + sH, cH = W - Q;
			if (Q <= Y) {
				let m = D.length > 0 && z === D[D.length - 1].ref.current;
				A.style.bottom = "0px";
				let x = M.clientHeight - R.offsetTop - R.offsetHeight, S = Q + Math.max(X, Z + (m ? J : 0) + x + H);
				A.style.height = S + "px";
			} else {
				let m = D.length > 0 && z === D[0].ref.current;
				A.style.top = "0px";
				let x = Math.max(Y, P + R.offsetTop + (m ? q : 0) + Z) + cH;
				A.style.height = x + "px", R.scrollTop = Q - Y + R.offsetTop;
			}
			A.style.margin = `${CONTENT_MARGIN}px 0`, A.style.minHeight = G + "px", A.style.maxHeight = k + "px", T?.(), requestAnimationFrame(() => I.current = !0);
		}
	}, [
		F,
		O.trigger,
		O.valueNode,
		A,
		M,
		R,
		z,
		B,
		O.dir,
		T
	]);
	useLayoutEffect2(() => U(), [U]);
	let [W, K] = React$1.useState();
	return useLayoutEffect2(() => {
		M && K(window.getComputedStyle(M).zIndex);
	}, [M]), /* @__PURE__ */ jsx(SelectViewportProvider, {
		scope: C,
		contentWrapper: A,
		shouldExpandOnScrollRef: I,
		onScrollButtonChange: React$1.useCallback((m) => {
			m && L.current === !0 && (U(), H?.(), L.current = !1);
		}, [U, H]),
		children: /* @__PURE__ */ jsx("div", {
			ref: j,
			style: {
				display: "flex",
				flexDirection: "column",
				position: "fixed",
				zIndex: W
			},
			children: /* @__PURE__ */ jsx(Primitive.div, {
				...D,
				ref: P,
				style: {
					boxSizing: "border-box",
					maxHeight: "100%",
					...D.style
				}
			})
		})
	});
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition", SelectPopperPosition = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, align: C = "start", collisionPadding: T = CONTENT_MARGIN, ...D } = m;
	return /* @__PURE__ */ jsx(Content, {
		...usePopperScope(S),
		...D,
		ref: x,
		align: C,
		collisionPadding: T,
		style: {
			boxSizing: "border-box",
			...D.style,
			"--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
			"--radix-select-content-available-width": "var(--radix-popper-available-width)",
			"--radix-select-content-available-height": "var(--radix-popper-available-height)",
			"--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
			"--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
		}
	});
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {}), VIEWPORT_NAME = "SelectViewport", SelectViewport = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, nonce: T, ...D } = x, O = useSelectContentContext(VIEWPORT_NAME, C), k = useSelectViewportContext(VIEWPORT_NAME, C), A = useComposedRefs(S, O.onViewportChange), j = React$1.useRef(0);
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("style", {
		dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" },
		nonce: T
	}), /* @__PURE__ */ jsx(Collection.Slot, {
		scope: C,
		children: /* @__PURE__ */ jsx(Primitive.div, {
			"data-radix-select-viewport": "",
			role: "presentation",
			...D,
			ref: A,
			style: {
				position: "relative",
				flex: 1,
				overflow: "hidden auto",
				...D.style
			},
			onScroll: composeEventHandlers(D.onScroll, (m) => {
				let x = m.currentTarget, { contentWrapper: S, shouldExpandOnScrollRef: C } = k;
				if (C?.current && S) {
					let m = Math.abs(j.current - x.scrollTop);
					if (m > 0) {
						let C = window.innerHeight - CONTENT_MARGIN * 2, T = parseFloat(S.style.minHeight), D = parseFloat(S.style.height), O = Math.max(T, D);
						if (O < C) {
							let T = O + m, D = Math.min(C, T), k = T - D;
							S.style.height = D + "px", S.style.bottom === "0px" && (x.scrollTop = k > 0 ? k : 0, S.style.justifyContent = "flex-end");
						}
					}
				}
				j.current = x.scrollTop;
			})
		})
	})] });
});
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup", [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME), SelectGroup$1 = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, ...C } = m, T = useId$1();
	return /* @__PURE__ */ jsx(SelectGroupContextProvider, {
		scope: S,
		id: T,
		children: /* @__PURE__ */ jsx(Primitive.div, {
			role: "group",
			"aria-labelledby": T,
			...C,
			ref: x
		})
	});
});
SelectGroup$1.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel", SelectLabel$1 = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, ...C } = m, T = useSelectGroupContext(LABEL_NAME, S);
	return /* @__PURE__ */ jsx(Primitive.div, {
		id: T.id,
		...C,
		ref: x
	});
});
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem", [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME), SelectItem$1 = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, value: T, disabled: D = !1, textValue: O, ...k } = x, A = useSelectContext(ITEM_NAME, C), j = useSelectContentContext(ITEM_NAME, C), M = A.value === T, [N, P] = React$1.useState(O ?? ""), [F, I] = React$1.useState(!1), L = useComposedRefs(S, (m) => j.itemRefCallback?.(m, T, D)), R = useId$1(), z = React$1.useRef("touch"), B = () => {
		D || (A.onValueChange(T), A.onOpenChange(!1));
	};
	if (T === "") throw Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
	return /* @__PURE__ */ jsx(SelectItemContextProvider, {
		scope: C,
		value: T,
		disabled: D,
		textId: R,
		isSelected: M,
		onItemTextChange: React$1.useCallback((m) => {
			P((x) => x || (m?.textContent ?? "").trim());
		}, []),
		children: /* @__PURE__ */ jsx(Collection.ItemSlot, {
			scope: C,
			value: T,
			disabled: D,
			textValue: N,
			children: /* @__PURE__ */ jsx(Primitive.div, {
				role: "option",
				"aria-labelledby": R,
				"data-highlighted": F ? "" : void 0,
				"aria-selected": M && F,
				"data-state": M ? "checked" : "unchecked",
				"aria-disabled": D || void 0,
				"data-disabled": D ? "" : void 0,
				tabIndex: D ? void 0 : -1,
				...k,
				ref: L,
				onFocus: composeEventHandlers(k.onFocus, () => I(!0)),
				onBlur: composeEventHandlers(k.onBlur, () => I(!1)),
				onClick: composeEventHandlers(k.onClick, () => {
					z.current !== "mouse" && B();
				}),
				onPointerUp: composeEventHandlers(k.onPointerUp, () => {
					z.current === "mouse" && B();
				}),
				onPointerDown: composeEventHandlers(k.onPointerDown, (m) => {
					z.current = m.pointerType;
				}),
				onPointerMove: composeEventHandlers(k.onPointerMove, (m) => {
					z.current = m.pointerType, D ? j.onItemLeave?.() : z.current === "mouse" && m.currentTarget.focus({ preventScroll: !0 });
				}),
				onPointerLeave: composeEventHandlers(k.onPointerLeave, (m) => {
					m.currentTarget === document.activeElement && j.onItemLeave?.();
				}),
				onKeyDown: composeEventHandlers(k.onKeyDown, (m) => {
					j.searchRef?.current !== "" && m.key === " " || (SELECTION_KEYS.includes(m.key) && B(), m.key === " " && m.preventDefault());
				})
			})
		})
	});
});
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText", SelectItemText = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, className: T, style: D, ...O } = x, k = useSelectContext(ITEM_TEXT_NAME, C), A = useSelectContentContext(ITEM_TEXT_NAME, C), j = useSelectItemContext(ITEM_TEXT_NAME, C), M = useSelectNativeOptionsContext(ITEM_TEXT_NAME, C), [N, P] = React$1.useState(null), F = useComposedRefs(S, (m) => P(m), j.onItemTextChange, (m) => A.itemTextRefCallback?.(m, j.value, j.disabled)), I = N?.textContent, L = React$1.useMemo(() => /* @__PURE__ */ jsx("option", {
		value: j.value,
		disabled: j.disabled,
		children: I
	}, j.value), [
		j.disabled,
		j.value,
		I
	]), { onNativeOptionAdd: R, onNativeOptionRemove: z } = M;
	return useLayoutEffect2(() => (R(L), () => z(L)), [
		R,
		z,
		L
	]), /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Primitive.span, {
		id: j.textId,
		...O,
		ref: F
	}), j.isSelected && k.valueNode && !k.valueNodeHasChildren ? ReactDOM$1.createPortal(O.children, k.valueNode) : null] });
});
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator", SelectItemIndicator = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, ...C } = m;
	return useSelectItemContext(ITEM_INDICATOR_NAME, S).isSelected ? /* @__PURE__ */ jsx(Primitive.span, {
		"aria-hidden": !0,
		...C,
		ref: x
	}) : null;
});
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton", SelectScrollUpButton$1 = React$1.forwardRef((x, S) => {
	let C = useSelectContentContext(SCROLL_UP_BUTTON_NAME, x.__scopeSelect), T = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, x.__scopeSelect), [D, O] = React$1.useState(!1), k = useComposedRefs(S, T.onScrollButtonChange);
	return useLayoutEffect2(() => {
		if (C.viewport && C.isPositioned) {
			let m = function() {
				O(x.scrollTop > 0);
			}, x = C.viewport;
			return m(), x.addEventListener("scroll", m), () => x.removeEventListener("scroll", m);
		}
	}, [C.viewport, C.isPositioned]), D ? /* @__PURE__ */ jsx(SelectScrollButtonImpl, {
		...x,
		ref: k,
		onAutoScroll: () => {
			let { viewport: m, selectedItem: x } = C;
			m && x && (m.scrollTop -= x.offsetHeight);
		}
	}) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton", SelectScrollDownButton$1 = React$1.forwardRef((x, S) => {
	let C = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, x.__scopeSelect), T = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, x.__scopeSelect), [D, O] = React$1.useState(!1), k = useComposedRefs(S, T.onScrollButtonChange);
	return useLayoutEffect2(() => {
		if (C.viewport && C.isPositioned) {
			let m = function() {
				let m = x.scrollHeight - x.clientHeight;
				O(Math.ceil(x.scrollTop) < m);
			}, x = C.viewport;
			return m(), x.addEventListener("scroll", m), () => x.removeEventListener("scroll", m);
		}
	}, [C.viewport, C.isPositioned]), D ? /* @__PURE__ */ jsx(SelectScrollButtonImpl, {
		...x,
		ref: k,
		onAutoScroll: () => {
			let { viewport: m, selectedItem: x } = C;
			m && x && (m.scrollTop += x.offsetHeight);
		}
	}) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = React$1.forwardRef((x, S) => {
	let { __scopeSelect: C, onAutoScroll: T, ...D } = x, O = useSelectContentContext("SelectScrollButton", C), k = React$1.useRef(null), A = useCollection(C), j = React$1.useCallback(() => {
		k.current !== null && (window.clearInterval(k.current), k.current = null);
	}, []);
	return React$1.useEffect(() => () => j(), [j]), useLayoutEffect2(() => {
		A().find((m) => m.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
	}, [A]), /* @__PURE__ */ jsx(Primitive.div, {
		"aria-hidden": !0,
		...D,
		ref: S,
		style: {
			flexShrink: 0,
			...D.style
		},
		onPointerDown: composeEventHandlers(D.onPointerDown, () => {
			k.current === null && (k.current = window.setInterval(T, 50));
		}),
		onPointerMove: composeEventHandlers(D.onPointerMove, () => {
			O.onItemLeave?.(), k.current === null && (k.current = window.setInterval(T, 50));
		}),
		onPointerLeave: composeEventHandlers(D.onPointerLeave, () => {
			j();
		})
	});
}), SEPARATOR_NAME = "SelectSeparator", SelectSeparator$1 = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, ...C } = m;
	return /* @__PURE__ */ jsx(Primitive.div, {
		"aria-hidden": !0,
		...C,
		ref: x
	});
});
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow", SelectArrow = React$1.forwardRef((m, x) => {
	let { __scopeSelect: S, ...C } = m, T = usePopperScope(S), D = useSelectContext(ARROW_NAME, S), O = useSelectContentContext(ARROW_NAME, S);
	return D.open && O.position === "popper" ? /* @__PURE__ */ jsx(Arrow$2, {
		...T,
		...C,
		ref: x
	}) : null;
});
SelectArrow.displayName = ARROW_NAME;
var BUBBLE_INPUT_NAME = "SelectBubbleInput", SelectBubbleInput = React$1.forwardRef(({ __scopeSelect: x, value: S, ...C }, T) => {
	let D = React$1.useRef(null), O = useComposedRefs(T, D), k = usePrevious(S);
	return React$1.useEffect(() => {
		let m = D.current;
		if (!m) return;
		let x = window.HTMLSelectElement.prototype, C = Object.getOwnPropertyDescriptor(x, "value").set;
		if (k !== S && C) {
			let x = new Event("change", { bubbles: !0 });
			C.call(m, S), m.dispatchEvent(x);
		}
	}, [k, S]), /* @__PURE__ */ jsx(Primitive.select, {
		...C,
		style: {
			...VISUALLY_HIDDEN_STYLES,
			...C.style
		},
		ref: O,
		defaultValue: S
	});
});
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(m) {
	return m === "" || m === void 0;
}
function useTypeaheadSearch(x) {
	let S = useCallbackRef(x), C = React$1.useRef(""), T = React$1.useRef(0), D = React$1.useCallback((m) => {
		let x = C.current + m;
		S(x), (function m(x) {
			C.current = x, window.clearTimeout(T.current), x !== "" && (T.current = window.setTimeout(() => m(""), 1e3));
		})(x);
	}, [S]), O = React$1.useCallback(() => {
		C.current = "", window.clearTimeout(T.current);
	}, []);
	return React$1.useEffect(() => () => window.clearTimeout(T.current), []), [
		C,
		D,
		O
	];
}
function findNextItem(m, x, S) {
	let C = x.length > 1 && Array.from(x).every((m) => m === x[0]) ? x[0] : x, T = S ? m.indexOf(S) : -1, D = wrapArray(m, Math.max(T, 0));
	C.length === 1 && (D = D.filter((m) => m !== S));
	let O = D.find((m) => m.textValue.toLowerCase().startsWith(C.toLowerCase()));
	return O === S ? void 0 : O;
}
function wrapArray(m, x) {
	return m.map((S, C) => m[(x + C) % m.length]);
}
var Root2 = Select$1, Trigger = SelectTrigger$1, Value = SelectValue$1, Icon$2 = SelectIcon, Portal$1 = SelectPortal, Content2 = SelectContent$1, Viewport = SelectViewport, Group$1 = SelectGroup$1, Label$1 = SelectLabel$1, Item$1 = SelectItem$1, ItemText = SelectItemText, ItemIndicator = SelectItemIndicator, ScrollUpButton = SelectScrollUpButton$1, ScrollDownButton = SelectScrollDownButton$1, Separator = SelectSeparator$1, toKebabCase$1 = (m) => m.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), toCamelCase = (m) => m.replace(/^([A-Z])|[\s-_]+(\w)/g, (m, x, S) => S ? S.toUpperCase() : x.toLowerCase()), toPascalCase = (m) => {
	let x = toCamelCase(m);
	return x.charAt(0).toUpperCase() + x.slice(1);
}, mergeClasses$1 = (...m) => m.filter((m, x, S) => !!m && m.trim() !== "" && S.indexOf(m) === x).join(" ").trim(), hasA11yProp = (m) => {
	for (let x in m) if (x.startsWith("aria-") || x === "role" || x === "title") return !0;
}, defaultAttributes$2 = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	strokeWidth: 2,
	strokeLinecap: "round",
	strokeLinejoin: "round"
}, Icon$1 = forwardRef(({ color: m = "currentColor", size: x = 24, strokeWidth: S = 2, absoluteStrokeWidth: C, className: T = "", children: O, iconNode: k, ...A }, j) => createElement("svg", {
	ref: j,
	...defaultAttributes$2,
	width: x,
	height: x,
	stroke: m,
	strokeWidth: C ? Number(S) * 24 / Number(x) : S,
	className: mergeClasses$1("lucide", T),
	...!O && !hasA11yProp(A) && { "aria-hidden": "true" },
	...A
}, [...k.map(([m, x]) => createElement(m, x)), ...Array.isArray(O) ? O : [O]])), createLucideIcon$1 = (m, x) => {
	let S = forwardRef(({ className: S, ...C }, T) => createElement(Icon$1, {
		ref: T,
		iconNode: x,
		className: mergeClasses$1(`lucide-${toKebabCase$1(toPascalCase(m))}`, `lucide-${m}`, S),
		...C
	}));
	return S.displayName = toPascalCase(m), S;
}, Check = createLucideIcon$1("check", [["path", {
	d: "M20 6 9 17l-5-5",
	key: "1gmf2c"
}]]), ChevronDown$1 = createLucideIcon$1("chevron-down", [["path", {
	d: "m6 9 6 6 6-6",
	key: "qrunsl"
}]]), ChevronUp$1 = createLucideIcon$1("chevron-up", [["path", {
	d: "m18 15-6-6-6 6",
	key: "153udz"
}]]);
function cn(...m) {
	return m.filter(Boolean).join(" ");
}
function formatCurrency(m, x, S, C, T, D) {
	if (!S && !D) return "";
	if (!m) return "N/A";
	let O = Math.round(m * 100) / 100, k = x === null ? "decimal" : x ?? "currency", A = {
		style: k,
		minimumFractionDigits: 0,
		maximumFractionDigits: 0
	};
	return k === "currency" && (A.currency = C || "GBP"), O.toLocaleString(T, A);
}
const toLowerKebabCase = (m) => {
	let x = {
		: "c",
		: "g",
		: "i",
		: "o",
		: "s",
		: "u",
		: "c",
		: "g",
		: "i",
		: "o",
		: "s",
		: "u"
	};
	return m.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[]/g, (m) => x[m] ?? m).toLowerCase().replace(/ /g, "-");
}, generatePlotUrl = async (m, x, S, C, T, D, O, k) => {
	let A = [
		x,
		S,
		C,
		T,
		D
	], j = document.documentElement.lang, M = j === "en" ? "/" : `/${j}/`;
	return A.forEach((m, x) => {
		m && (M += `${toLowerKebabCase(m)}${x + 1 == A.length ? "" : "-"}`);
	}), `${M}${k ? "-" + k + "-bedrooms" : ""}${O ? "-" + toLowerKebabCase(O) : ""}/${m}`;
};
function Select({ ...m }) {
	return /* @__PURE__ */ jsx(Root2, {
		"data-slot": "select",
		...m
	});
}
function SelectGroup({ ...m }) {
	return /* @__PURE__ */ jsx(Group$1, {
		"data-slot": "select-group",
		...m
	});
}
function SelectValue({ ...m }) {
	return /* @__PURE__ */ jsx(Value, {
		"data-slot": "select-value",
		...m
	});
}
function SelectTrigger({ className: m, size: x = "default", children: S, ...C }) {
	return /* @__PURE__ */ jsxs(Trigger, {
		"data-slot": "select-trigger",
		"data-size": x,
		className: cn("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", m),
		...C,
		children: [S, /* @__PURE__ */ jsx(Icon$2, {
			asChild: !0,
			children: /* @__PURE__ */ jsx(ChevronDown$1, { className: "size-4 opacity-50" })
		})]
	});
}
function SelectContent({ className: m, children: x, position: S = "popper", align: C = "center", ...T }) {
	return /* @__PURE__ */ jsx(Portal$1, { children: /* @__PURE__ */ jsxs(Content2, {
		"data-slot": "select-content",
		className: cn("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", S === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", m),
		position: S,
		align: C,
		...T,
		children: [
			/* @__PURE__ */ jsx(SelectScrollUpButton, {}),
			/* @__PURE__ */ jsx(Viewport, {
				className: cn("p-1", S === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"),
				children: x
			}),
			/* @__PURE__ */ jsx(SelectScrollDownButton, {})
		]
	}) });
}
function SelectLabel({ className: m, ...x }) {
	return /* @__PURE__ */ jsx(Label$1, {
		"data-slot": "select-label",
		className: cn("text-muted-foreground px-2 py-1.5 text-xs", m),
		...x
	});
}
function SelectItem({ className: m, children: x, ...S }) {
	return /* @__PURE__ */ jsxs(Item$1, {
		"data-slot": "select-item",
		className: cn("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", m),
		...S,
		children: [/* @__PURE__ */ jsx("span", {
			className: "absolute right-2 flex size-3.5 items-center justify-center",
			children: /* @__PURE__ */ jsx(ItemIndicator, { children: /* @__PURE__ */ jsx(Check, { className: "size-4" }) })
		}), /* @__PURE__ */ jsx(ItemText, { children: x })]
	});
}
function SelectSeparator({ className: m, ...x }) {
	return /* @__PURE__ */ jsx(Separator, {
		"data-slot": "select-separator",
		className: cn("bg-border pointer-events-none -mx-1 my-1 h-px", m),
		...x
	});
}
function SelectScrollUpButton({ className: m, ...x }) {
	return /* @__PURE__ */ jsx(ScrollUpButton, {
		"data-slot": "select-scroll-up-button",
		className: cn("flex cursor-default items-center justify-center py-1", m),
		...x,
		children: /* @__PURE__ */ jsx(ChevronUp$1, { className: "size-4" })
	});
}
function SelectScrollDownButton({ className: m, ...x }) {
	return /* @__PURE__ */ jsx(ScrollDownButton, {
		"data-slot": "select-scroll-down-button",
		className: cn("flex cursor-default items-center justify-center py-1", m),
		...x,
		children: /* @__PURE__ */ jsx(ChevronDown$1, { className: "size-4" })
	});
}
var require_flat = /* @__PURE__ */ __commonJSMin(((m, x) => {
	x.exports = T, T.flatten = T, T.unflatten = D;
	function S(m) {
		return m && m.constructor && typeof m.constructor.isBuffer == "function" && m.constructor.isBuffer(m);
	}
	function C(m) {
		return m;
	}
	function T(m, x) {
		x ||= {};
		let T = x.delimiter || ".", D = x.maxDepth, O = x.transformKey || C, k = {};
		function A(m, C, j) {
			j ||= 1, Object.keys(m).forEach(function(M) {
				let N = m[M], P = x.safe && Array.isArray(N), F = Object.prototype.toString.call(N), I = S(N), L = F === "[object Object]" || F === "[object Array]", R = C ? C + T + O(M) : O(M);
				if (!P && !I && L && Object.keys(N).length && (!x.maxDepth || j < D)) return A(N, R, j + 1);
				k[R] = N;
			});
		}
		return A(m), k;
	}
	function D(m, x) {
		x ||= {};
		let O = x.delimiter || ".", k = x.overwrite || !1, A = x.transformKey || C, j = {};
		if (S(m) || Object.prototype.toString.call(m) !== "[object Object]") return m;
		function M(m) {
			let S = Number(m);
			return isNaN(S) || m.indexOf(".") !== -1 || x.object ? m : S;
		}
		function N(m, x, S) {
			return Object.keys(S).reduce(function(x, C) {
				return x[m + O + C] = S[C], x;
			}, x);
		}
		function P(m) {
			let x = Object.prototype.toString.call(m), S = x === "[object Array]", C = x === "[object Object]";
			if (m) {
				if (S) return !m.length;
				if (C) return !Object.keys(m).length;
			} else return !0;
		}
		return m = Object.keys(m).reduce(function(S, C) {
			let D = Object.prototype.toString.call(m[C]);
			return !(D === "[object Object]" || D === "[object Array]") || P(m[C]) ? (S[C] = m[C], S) : N(C, S, T(m[C], x));
		}, {}), Object.keys(m).forEach(function(S) {
			let C = S.split(O).map(A), T = M(C.shift()), N = M(C[0]), P = j;
			for (; N !== void 0;) {
				if (T === "__proto__") return;
				let m = Object.prototype.toString.call(P[T]), S = m === "[object Object]" || m === "[object Array]";
				if (!k && !S && P[T] !== void 0) return;
				(k && !S || !k && P[T] == null) && (P[T] = typeof N == "number" && !x.object ? [] : {}), P = P[T], C.length > 0 && (T = M(C.shift()), N = M(C[0]));
			}
			P[T] = D(m[S], x);
		}), j;
	}
})), require_fast_deep_equal = /* @__PURE__ */ __commonJSMin(((m, x) => {
	x.exports = function m(x, S) {
		if (x === S) return !0;
		if (x && S && typeof x == "object" && typeof S == "object") {
			if (x.constructor !== S.constructor) return !1;
			var C, T, D;
			if (Array.isArray(x)) {
				if (C = x.length, C != S.length) return !1;
				for (T = C; T-- !== 0;) if (!m(x[T], S[T])) return !1;
				return !0;
			}
			if (x.constructor === RegExp) return x.source === S.source && x.flags === S.flags;
			if (x.valueOf !== Object.prototype.valueOf) return x.valueOf() === S.valueOf();
			if (x.toString !== Object.prototype.toString) return x.toString() === S.toString();
			if (D = Object.keys(x), C = D.length, C !== Object.keys(S).length) return !1;
			for (T = C; T-- !== 0;) if (!Object.prototype.hasOwnProperty.call(S, D[T])) return !1;
			for (T = C; T-- !== 0;) {
				var O = D[T];
				if (!m(x[O], S[O])) return !1;
			}
			return !0;
		}
		return x !== x && S !== S;
	};
})), import_flat = /* @__PURE__ */ __toESM$1(require_flat(), 1), import_fast_deep_equal$1 = /* @__PURE__ */ __toESM$1(require_fast_deep_equal(), 1), import_fast_deep_equal$2 = /* @__PURE__ */ __toESM$1(require_fast_deep_equal(), 1), __create$6 = Object.create, __defProp$7 = Object.defineProperty, __defProps$6 = Object.defineProperties, __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor, __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors, __getOwnPropNames = Object.getOwnPropertyNames, __getOwnPropSymbols$7 = Object.getOwnPropertySymbols, __getProtoOf = Object.getPrototypeOf, __hasOwnProp$7 = Object.prototype.hasOwnProperty, __propIsEnum$7 = Object.prototype.propertyIsEnumerable, __defNormalProp$7 = (m, x, S) => x in m ? __defProp$7(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$7.call(x, S) && __defNormalProp$7(m, S, x[S]);
	if (__getOwnPropSymbols$7) for (var S of __getOwnPropSymbols$7(x)) __propIsEnum$7.call(x, S) && __defNormalProp$7(m, S, x[S]);
	return m;
}, __spreadProps = (m, x) => __defProps$6(m, __getOwnPropDescs$6(x)), __objRest = (m, x) => {
	var S = {};
	for (var C in m) __hasOwnProp$7.call(m, C) && x.indexOf(C) < 0 && (S[C] = m[C]);
	if (m != null && __getOwnPropSymbols$7) for (var C of __getOwnPropSymbols$7(m)) x.indexOf(C) < 0 && __propIsEnum$7.call(m, C) && (S[C] = m[C]);
	return S;
}, __esm = (m, x) => function() {
	return m && (x = (0, m[__getOwnPropNames(m)[0]])(m = 0)), x;
}, __commonJS = (m, x) => function() {
	return x || (0, m[__getOwnPropNames(m)[0]])((x = { exports: {} }).exports, x), x.exports;
}, __copyProps = (m, x, S, C) => {
	if (x && typeof x == "object" || typeof x == "function") for (let T of __getOwnPropNames(x)) !__hasOwnProp$7.call(m, T) && T !== S && __defProp$7(m, T, {
		get: () => x[T],
		enumerable: !(C = __getOwnPropDesc$6(x, T)) || C.enumerable
	});
	return m;
}, __toESM = (m, x, S) => (S = m == null ? {} : __create$6(__getProtoOf(m)), __copyProps(x || !m || !m.__esModule ? __defProp$7(S, "default", {
	value: m,
	enumerable: !0
}) : S, m)), __async = (m, x, S) => new Promise((C, T) => {
	var D = (m) => {
		try {
			k(S.next(m));
		} catch (m) {
			T(m);
		}
	}, O = (m) => {
		try {
			k(S.throw(m));
		} catch (m) {
			T(m);
		}
	}, k = (m) => m.done ? C(m.value) : Promise.resolve(m.value).then(D, O);
	k((S = S.apply(m, x)).next());
}), init_react_import = __esm({ "../tsup-config/react-import.js"() {} });
init_react_import(), init_react_import(), init_react_import();
var defaultSlots = (m, x) => Object.keys(x).reduce((m, S) => x[S].type === "slot" ? __spreadValues({ [S]: [] }, m) : m, m), isPromise = (m) => !!m && typeof m.then == "function", flatten = (m) => m.reduce((m, x) => __spreadValues(__spreadValues({}, m), x), {}), containsPromise = (m) => m.some(isPromise), walkField = ({ value: m, fields: x, mappers: S, propKey: C = "", propPath: T = "", id: D = "", config: O, recurseSlots: k = !1 }) => {
	let A = x[C]?.type, j = S[A];
	if (j && A === "slot") {
		let A = m || [], M = k ? A.map((m) => {
			let x = O.components[m.type];
			if (!x) throw Error(`Could not find component config for ${m.type}`);
			let C = x.fields ?? {};
			return walkField({
				value: __spreadProps(__spreadValues({}, m), { props: defaultSlots(m.props, C) }),
				fields: C,
				mappers: S,
				id: m.props.id,
				config: O,
				recurseSlots: k
			});
		}) : A;
		return containsPromise(M) ? Promise.all(M) : j({
			value: M,
			parentId: D,
			propName: T,
			field: x[C],
			propPath: T
		});
	} else if (j && x[C]) return j({
		value: m,
		parentId: D,
		propName: C,
		field: x[C],
		propPath: T
	});
	if (m && typeof m == "object") if (Array.isArray(m)) {
		let A = x[C]?.type === "array" ? x[C].arrayFields : null;
		if (!A) return m;
		let j = m.map((m, x) => walkField({
			value: m,
			fields: A,
			mappers: S,
			propKey: C,
			propPath: `${T}[${x}]`,
			id: D,
			config: O,
			recurseSlots: k
		}));
		return containsPromise(j) ? Promise.all(j) : j;
	} else if ("$$typeof" in m) return m;
	else return walkObject({
		value: m,
		fields: x[C]?.type === "object" ? x[C].objectFields : x,
		mappers: S,
		id: D,
		getPropPath: (m) => `${T}.${m}`,
		config: O,
		recurseSlots: k
	});
	return m;
}, walkObject = ({ value: m, fields: x, mappers: S, id: C, getPropPath: T, config: D, recurseSlots: O }) => {
	let k = Object.entries(m).map(([m, k]) => {
		let A = walkField({
			value: k,
			fields: x,
			mappers: S,
			propKey: m,
			propPath: T(m),
			id: C,
			config: D,
			recurseSlots: O
		});
		return isPromise(A) ? A.then((x) => ({ [m]: x })) : { [m]: A };
	}, {});
	return containsPromise(k) ? Promise.all(k).then(flatten) : flatten(k);
};
function mapFields(m, x, S, C = !1) {
	let T = "type" in m ? m.type : "root", D = T === "root" ? S.root : S.components?.[T], O = walkObject({
		value: defaultSlots(m.props ?? {}, D?.fields ?? {}),
		fields: D?.fields ?? {},
		mappers: x,
		id: m.props ? m.props.id ?? "root" : "root",
		getPropPath: (m) => m,
		config: S,
		recurseSlots: C
	});
	return isPromise(O) ? O.then((x) => __spreadProps(__spreadValues({}, m), { props: x })) : __spreadProps(__spreadValues({}, m), { props: O });
}
function walkTree(m, x, S) {
	let C = (m) => mapFields(m, { slot: ({ value: m, parentId: x, propName: C }) => {
		let T = m;
		return S(T, {
			parentId: x,
			propName: C
		}) ?? T;
	} }, x, !0);
	if ("props" in m) return C(m);
	let T = m, D = T.zones ?? {}, O = T.content.map(C);
	return {
		root: C(T.root),
		content: S(O, {
			parentId: "root",
			propName: "default-zone"
		}) ?? O,
		zones: Object.keys(D).reduce((m, x) => __spreadProps(__spreadValues({}, m), { [x]: D[x].map(C) }), {})
	};
}
init_react_import(), init_react_import(), init_react_import();
var defaultViewports = [
	{
		width: 360,
		height: "auto",
		icon: "Smartphone",
		label: "Small"
	},
	{
		width: 768,
		height: "auto",
		icon: "Tablet",
		label: "Medium"
	},
	{
		width: 1280,
		height: "auto",
		icon: "Monitor",
		label: "Large"
	}
], defaultAppState = {
	data: {
		content: [],
		root: {},
		zones: {}
	},
	ui: {
		leftSideBarVisible: !0,
		rightSideBarVisible: !0,
		arrayState: {},
		itemSelector: null,
		componentList: {},
		isDragging: !1,
		previewMode: "edit",
		viewports: {
			current: {
				width: defaultViewports[0].width,
				height: defaultViewports[0].height || "auto"
			},
			options: [],
			controlsVisible: !0
		},
		field: { focus: null }
	},
	indexes: {
		nodes: {},
		zones: {}
	}
};
init_react_import(), init_react_import(), init_react_import(), init_react_import();
var rootAreaId = "root", rootZone = "default-zone", rootDroppableId = `${rootAreaId}:${rootZone}`, getZoneId$1 = (m) => m ? m && m.indexOf(":") > -1 ? m.split(":") : [rootDroppableId, m] : [];
function forRelatedZones(m, x, S, C = []) {
	Object.entries(x.zones || {}).forEach(([x, T]) => {
		let [D] = getZoneId$1(x);
		D === m.props.id && S(C, x, T);
	});
}
init_react_import(), init_react_import();
var stripSlots = (m, x) => mapFields(m, { slot: () => null }, x), { flatten: flatten2, unflatten } = import_flat.default, flattenNode = (m, x) => __spreadProps(__spreadValues({}, m), { props: flatten2(stripSlots(m, x).props) }), expandNode = (m) => {
	let x = unflatten(m.props);
	return __spreadProps(__spreadValues({}, m), { props: x });
};
function walkAppState(m, x, S = (m) => m, C = (m) => m) {
	let T = {}, D = {}, O = {}, k = (m, x, C, T, O) => {
		let [k] = x.split(":"), A = (S(C, x, T) ?? C) || [], [M, N] = x.split(":"), P = `${O || k}:${N}`, F = A.map((x, S) => j(x, [...m, P], S));
		return D[P] = {
			contentIds: F.map((m) => m.props.id),
			type: T
		}, [P, F];
	}, A = (x, S, C) => {
		forRelatedZones(x, m.data, (m, x, C) => {
			let [D, O] = k(m, x, C, "dropzone", S);
			T[D] = O;
		}, C);
	}, j = (m, S, T) => {
		let D = C(m, S, T);
		if (!D) return m;
		let j = D.props.id, M = __spreadProps(__spreadValues({}, mapFields(D, { slot: ({ value: m, parentId: x, propPath: C }) => {
			let T = m, [D, O] = k(S, `${x}:${C}`, T, "slot", x);
			return O;
		} }, x).props), { id: j });
		A(m, j, S);
		let N = __spreadProps(__spreadValues({}, m), { props: M }), P = S[S.length - 1], [F, I] = P ? P.split(":") : [null, ""];
		O[j] = {
			data: N,
			flatData: flattenNode(N, x),
			path: S,
			parentId: F,
			zone: I
		};
		let L = __spreadProps(__spreadValues({}, N), { props: __spreadValues({}, N.props) });
		return M.id === "root" && (delete L.type, delete L.props.id), L;
	}, M = m.data.zones || {}, [N, P] = k([], rootDroppableId, m.data.content, "root"), F = P, I = Object.keys(T);
	Object.keys(M || {}).forEach((m) => {
		let [x] = m.split(":");
		if (I.includes(m)) return;
		let [S, C] = k([rootDroppableId], m, M[m], "dropzone", x);
		T[m] = C;
	}, T);
	let L = j({
		type: "root",
		props: __spreadProps(__spreadValues({}, m.data.root.props ?? m.data.root), { id: "root" })
	}, [], -1), R = __spreadProps(__spreadValues({}, m.data.root), { props: L.props });
	return __spreadProps(__spreadValues({}, m), {
		data: {
			root: R,
			content: F,
			zones: __spreadValues(__spreadValues({}, m.data.zones), T)
		},
		indexes: {
			nodes: __spreadValues(__spreadValues({}, m.indexes.nodes), O),
			zones: __spreadValues(__spreadValues({}, m.indexes.zones), D)
		}
	});
}
init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import();
var getChanged = (m, x) => m ? Object.keys(m.props || {}).reduce((S, C) => {
	let T = m?.props || {}, D = x?.props || {};
	return __spreadProps(__spreadValues({}, S), { [C]: !(0, import_fast_deep_equal$1.default)(D[C], T[C]) });
}, {}) : {}, cache = { lastChange: {} }, resolveComponentData = (m, x, ...S) => __async(void 0, [
	m,
	x,
	...S
], function* (m, x, S = {}, C, T, D = "replace") {
	let O = "type" in m && m.type !== "root" ? x.components[m.type] : x.root, k = __spreadValues({}, m), A = O?.resolveData && m.props, j = "id" in m.props ? m.props.id : "root";
	if (A) {
		let { item: x = null, resolved: T = {} } = cache.lastChange[j] || {};
		if (D !== "force" && m && (0, import_fast_deep_equal$2.default)(m, x)) return {
			node: T,
			didChange: !1
		};
		let A = getChanged(m, x);
		C && C(m);
		let { props: M, readOnly: N = {} } = yield O.resolveData(m, {
			changed: A,
			lastData: x,
			metadata: __spreadValues(__spreadValues({}, S), O.metadata),
			trigger: D
		});
		k.props = __spreadValues(__spreadValues({}, m.props), M), Object.keys(N).length && (k.readOnly = N);
	}
	let M = yield mapFields(k, { slot: (m) => __async(void 0, [m], function* ({ value: m }) {
		let O = m;
		return yield Promise.all(O.map((m) => __async(void 0, null, function* () {
			return (yield resolveComponentData(m, x, S, C, T, D)).node;
		})));
	}) }, x);
	return A && T && T(k), cache.lastChange[j] = {
		item: m,
		resolved: M
	}, {
		node: M,
		didChange: !(0, import_fast_deep_equal$2.default)(m, M)
	};
});
init_react_import(), init_react_import();
var setupZone = (m, x) => {
	if (x === rootDroppableId) return m;
	let S = __spreadProps(__spreadValues({}, m), { zones: m.zones ? __spreadValues({}, m.zones) : {} });
	return S.zones[x] = S.zones[x] || [], S;
};
init_react_import();
function useFieldTransforms(m, x, S, C, T) {
	let D = useMemo(() => Object.keys(S).reduce((m, x) => {
		let D = x;
		return __spreadProps(__spreadValues({}, m), { [D]: (m) => {
			var x = m, { parentId: O } = x, k = __objRest(x, ["parentId"]);
			let A = k.propPath.replace(/\[\d+\]/g, "[*]"), j = C?.[k.propPath] || C?.[A] || T || !1, M = S[D];
			return M?.(__spreadProps(__spreadValues({}, k), {
				isReadOnly: j,
				componentId: O
			}));
		} });
	}, {}), [
		S,
		C,
		T
	]), O = useMemo(() => mapFields(x, D, m).props, [
		m,
		x,
		D
	]);
	return useMemo(() => __spreadValues(__spreadValues({}, x.props), O), [x.props, O]);
}
init_react_import();
var getSlotTransform = (m, x = m) => ({ slot: ({ value: S, propName: C, field: T, isReadOnly: D }) => {
	let O = D ? x : m;
	return (m) => O(__spreadProps(__spreadValues({
		allow: T?.type === "slot" ? T.allow : [],
		disallow: T?.type === "slot" ? T.disallow : []
	}, m), {
		zone: C,
		content: S
	}));
} });
init_react_import();
function useSlots(m, x, S, C = S, T, D) {
	return useFieldTransforms(m, x, getSlotTransform(S, C), T, D);
}
init_react_import();
var SlotRenderPure = (m) => /* @__PURE__ */ jsx(SlotRender, __spreadValues({}, m)), Item = ({ config: m, item: x, metadata: S }) => {
	let C = m.components[x.type], T = useSlots(m, x, (x) => /* @__PURE__ */ jsx(SlotRenderPure, __spreadProps(__spreadValues({}, x), {
		config: m,
		metadata: S
	})));
	return /* @__PURE__ */ jsx(C.render, __spreadProps(__spreadValues({}, T), { puck: __spreadProps(__spreadValues({}, T.puck), { metadata: S || {} }) }));
}, SlotRender = forwardRef(function({ className: m, style: x, content: S, config: C, metadata: T }, D) {
	return /* @__PURE__ */ jsx("div", {
		className: m,
		style: x,
		ref: D,
		children: S.map((m) => C.components[m.type] ? /* @__PURE__ */ jsx(Item, {
			config: C,
			item: m,
			metadata: T
		}, m.props.id) : null)
	});
}), getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
	if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues)) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
	return getRandomValues(rnds8);
}
var byteToHex = [];
for (let m = 0; m < 256; ++m) byteToHex.push((m + 256).toString(16).slice(1));
function unsafeStringify(m, x = 0) {
	return byteToHex[m[x + 0]] + byteToHex[m[x + 1]] + byteToHex[m[x + 2]] + byteToHex[m[x + 3]] + "-" + byteToHex[m[x + 4]] + byteToHex[m[x + 5]] + "-" + byteToHex[m[x + 6]] + byteToHex[m[x + 7]] + "-" + byteToHex[m[x + 8]] + byteToHex[m[x + 9]] + "-" + byteToHex[m[x + 10]] + byteToHex[m[x + 11]] + byteToHex[m[x + 12]] + byteToHex[m[x + 13]] + byteToHex[m[x + 14]] + byteToHex[m[x + 15]];
}
var native_default = { randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
function v4(m, x, S) {
	if (native_default.randomUUID && !x && !m) return native_default.randomUUID();
	m ||= {};
	let C = m.random || (m.rng || rng)();
	if (C[6] = C[6] & 15 | 64, C[8] = C[8] & 63 | 128, x) {
		S ||= 0;
		for (let m = 0; m < 16; ++m) x[S + m] = C[m];
		return x;
	}
	return unsafeStringify(C);
}
var v4_default = v4, createStoreImpl = (m) => {
	let x, S = /* @__PURE__ */ new Set(), C = (m, C) => {
		let T = typeof m == "function" ? m(x) : m;
		if (!Object.is(T, x)) {
			let m = x;
			x = C ?? (typeof T != "object" || !T) ? T : Object.assign({}, x, T), S.forEach((S) => S(x, m));
		}
	}, T = () => x, D = {
		setState: C,
		getState: T,
		getInitialState: () => O,
		subscribe: (m) => (S.add(m), () => S.delete(m))
	}, O = x = m(C, T, D);
	return D;
}, createStore = ((m) => m ? createStoreImpl(m) : createStoreImpl), identity$1 = (m) => m;
function useStore(m, S = identity$1) {
	let C = React.useSyncExternalStore(m.subscribe, React.useCallback(() => S(m.getState()), [m, S]), React.useCallback(() => S(m.getInitialState()), [m, S]));
	return React.useDebugValue(C), C;
}
var createImpl = (m) => {
	let x = createStore(m), S = (m) => useStore(x, m);
	return Object.assign(S, x), S;
}, create = ((m) => m ? createImpl(m) : createImpl), subscribeWithSelector = (m) => (x, S, C) => {
	let T = C.subscribe;
	return C.subscribe = ((m, x, S) => {
		let D = m;
		if (x) {
			let T = S?.equalityFn || Object.is, O = m(C.getState());
			D = (S) => {
				let C = m(S);
				if (!T(O, C)) {
					let m = O;
					x(O = C, m);
				}
			}, S?.fireImmediately && x(O, O);
		}
		return T(D);
	}), m(x, S, C);
}, i = Symbol.for("preact-signals");
function t() {
	if (s > 1) s--;
	else {
		for (var m, x = !1; h !== void 0;) {
			var S = h;
			for (h = void 0, f++; S !== void 0;) {
				var C = S.o;
				if (S.o = void 0, S.f &= -3, !(8 & S.f) && c$1(S)) try {
					S.c();
				} catch (S) {
					x ||= (m = S, !0);
				}
				S = C;
			}
		}
		if (f = 0, s--, x) throw m;
	}
}
function r(m) {
	if (s > 0) return m();
	s++;
	try {
		return m();
	} finally {
		t();
	}
}
var o = void 0;
function n(m) {
	var x = o;
	o = void 0;
	try {
		return m();
	} finally {
		o = x;
	}
}
var h = void 0, s = 0, f = 0, v = 0;
function e(m) {
	if (o !== void 0) {
		var x = m.n;
		if (x === void 0 || x.t !== o) return x = {
			i: 0,
			S: m,
			p: o.s,
			n: void 0,
			t: o,
			e: void 0,
			x: void 0,
			r: x
		}, o.s !== void 0 && (o.s.n = x), o.s = x, m.n = x, 32 & o.f && m.S(x), x;
		if (x.i === -1) return x.i = 0, x.n !== void 0 && (x.n.p = x.p, x.p !== void 0 && (x.p.n = x.n), x.p = o.s, x.n = void 0, o.s.n = x, o.s = x), x;
	}
}
function u(m, x) {
	this.v = m, this.i = 0, this.n = void 0, this.t = void 0, this.W = x?.watched, this.Z = x?.unwatched, this.name = x?.name;
}
u.prototype.brand = i, u.prototype.h = function() {
	return !0;
}, u.prototype.S = function(m) {
	var x = this, S = this.t;
	S !== m && m.e === void 0 && (m.x = S, this.t = m, S === void 0 ? n(function() {
		var m;
		(m = x.W) == null || m.call(x);
	}) : S.e = m);
}, u.prototype.U = function(m) {
	var x = this;
	if (this.t !== void 0) {
		var S = m.e, C = m.x;
		S !== void 0 && (S.x = C, m.e = void 0), C !== void 0 && (C.e = S, m.x = void 0), m === this.t && (this.t = C, C === void 0 && n(function() {
			var m;
			(m = x.Z) == null || m.call(x);
		}));
	}
}, u.prototype.subscribe = function(m) {
	var x = this;
	return E(function() {
		var S = x.value, C = o;
		o = void 0;
		try {
			m(S);
		} finally {
			o = C;
		}
	}, { name: "sub" });
}, u.prototype.valueOf = function() {
	return this.value;
}, u.prototype.toString = function() {
	return this.value + "";
}, u.prototype.toJSON = function() {
	return this.value;
}, u.prototype.peek = function() {
	var m = o;
	o = void 0;
	try {
		return this.value;
	} finally {
		o = m;
	}
}, Object.defineProperty(u.prototype, "value", {
	get: function() {
		var m = e(this);
		return m !== void 0 && (m.i = this.i), this.v;
	},
	set: function(m) {
		if (m !== this.v) {
			if (f > 100) throw Error("Cycle detected");
			this.v = m, this.i++, v++, s++;
			try {
				for (var x = this.t; x !== void 0; x = x.x) x.t.N();
			} finally {
				t();
			}
		}
	}
});
function d(m, x) {
	return new u(m, x);
}
function c$1(m) {
	for (var x = m.s; x !== void 0; x = x.n) if (x.S.i !== x.i || !x.S.h() || x.S.i !== x.i) return !0;
	return !1;
}
function a(m) {
	for (var x = m.s; x !== void 0; x = x.n) {
		var S = x.S.n;
		if (S !== void 0 && (x.r = S), x.S.n = x, x.i = -1, x.n === void 0) {
			m.s = x;
			break;
		}
	}
}
function l(m) {
	for (var x = m.s, S = void 0; x !== void 0;) {
		var C = x.p;
		x.i === -1 ? (x.S.U(x), C !== void 0 && (C.n = x.n), x.n !== void 0 && (x.n.p = C)) : S = x, x.S.n = x.r, x.r !== void 0 && (x.r = void 0), x = C;
	}
	m.s = S;
}
function y(m, x) {
	u.call(this, void 0), this.x = m, this.s = void 0, this.g = v - 1, this.f = 4, this.W = x?.watched, this.Z = x?.unwatched, this.name = x?.name;
}
y.prototype = new u(), y.prototype.h = function() {
	if (this.f &= -3, 1 & this.f) return !1;
	if ((36 & this.f) == 32 || (this.f &= -5, this.g === v)) return !0;
	if (this.g = v, this.f |= 1, this.i > 0 && !c$1(this)) return this.f &= -2, !0;
	var m = o;
	try {
		a(this), o = this;
		var x = this.x();
		(16 & this.f || this.v !== x || this.i === 0) && (this.v = x, this.f &= -17, this.i++);
	} catch (m) {
		this.v = m, this.f |= 16, this.i++;
	}
	return o = m, l(this), this.f &= -2, !0;
}, y.prototype.S = function(m) {
	if (this.t === void 0) {
		this.f |= 36;
		for (var x = this.s; x !== void 0; x = x.n) x.S.S(x);
	}
	u.prototype.S.call(this, m);
}, y.prototype.U = function(m) {
	if (this.t !== void 0 && (u.prototype.U.call(this, m), this.t === void 0)) {
		this.f &= -33;
		for (var x = this.s; x !== void 0; x = x.n) x.S.U(x);
	}
}, y.prototype.N = function() {
	if (!(2 & this.f)) {
		this.f |= 6;
		for (var m = this.t; m !== void 0; m = m.x) m.t.N();
	}
}, Object.defineProperty(y.prototype, "value", { get: function() {
	if (1 & this.f) throw Error("Cycle detected");
	var m = e(this);
	if (this.h(), m !== void 0 && (m.i = this.i), 16 & this.f) throw this.v;
	return this.v;
} });
function w(m, x) {
	return new y(m, x);
}
function _(m) {
	var x = m.u;
	if (m.u = void 0, typeof x == "function") {
		s++;
		var S = o;
		o = void 0;
		try {
			x();
		} catch (x) {
			throw m.f &= -2, m.f |= 8, b(m), x;
		} finally {
			o = S, t();
		}
	}
}
function b(m) {
	for (var x = m.s; x !== void 0; x = x.n) x.S.U(x);
	m.x = void 0, m.s = void 0, _(m);
}
function g(m) {
	if (o !== this) throw Error("Out-of-order effect");
	l(this), o = m, this.f &= -2, 8 & this.f && b(this), t();
}
function p(m, x) {
	this.x = m, this.u = void 0, this.s = void 0, this.o = void 0, this.f = 32, this.name = x?.name;
}
p.prototype.c = function() {
	var m = this.S();
	try {
		if (8 & this.f || this.x === void 0) return;
		var x = this.x();
		typeof x == "function" && (this.u = x);
	} finally {
		m();
	}
}, p.prototype.S = function() {
	if (1 & this.f) throw Error("Cycle detected");
	this.f |= 1, this.f &= -9, _(this), a(this), s++;
	var m = o;
	return o = this, g.bind(this, m);
}, p.prototype.N = function() {
	2 & this.f || (this.f |= 2, this.o = h, h = this);
}, p.prototype.d = function() {
	this.f |= 8, 1 & this.f || b(this);
}, p.prototype.dispose = function() {
	this.d();
};
function E(m, x) {
	var S = new p(m, x);
	try {
		S.c();
	} catch (m) {
		throw S.d(), m;
	}
	var C = S.d.bind(S);
	return C[Symbol.dispose] = C, C;
}
var __create$5 = Object.create, __defProp$6 = Object.defineProperty, __defProps$5 = Object.defineProperties, __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor, __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$6 = Object.getOwnPropertySymbols, __hasOwnProp$6 = Object.prototype.hasOwnProperty, __propIsEnum$6 = Object.prototype.propertyIsEnumerable, __knownSymbol$5 = (m, x) => (x = Symbol[m]) ? x : Symbol.for("Symbol." + m), __typeError$6 = (m) => {
	throw TypeError(m);
}, __defNormalProp$6 = (m, x, S) => x in m ? __defProp$6(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$7 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$6.call(x, S) && __defNormalProp$6(m, S, x[S]);
	if (__getOwnPropSymbols$6) for (var S of __getOwnPropSymbols$6(x)) __propIsEnum$6.call(x, S) && __defNormalProp$6(m, S, x[S]);
	return m;
}, __spreadProps$6 = (m, x) => __defProps$5(m, __getOwnPropDescs$5(x)), __name$3 = (m, x) => __defProp$6(m, "name", {
	value: x,
	configurable: !0
}), __decoratorStart$5 = (m) => [
	,
	,
	,
	__create$5(m?.[__knownSymbol$5("metadata")] ?? null)
], __decoratorStrings$5 = [
	"class",
	"method",
	"getter",
	"setter",
	"accessor",
	"field",
	"value",
	"get",
	"set"
], __expectFn$5 = (m) => m !== void 0 && typeof m != "function" ? __typeError$6("Function expected") : m, __decoratorContext$5 = (m, x, S, C, T) => ({
	kind: __decoratorStrings$5[m],
	name: x,
	metadata: C,
	addInitializer: (m) => S._ ? __typeError$6("Already initialized") : T.push(__expectFn$5(m || null))
}), __decoratorMetadata$5 = (m, x) => __defNormalProp$6(x, __knownSymbol$5("metadata"), m[3]), __runInitializers$5 = (m, x, S, C) => {
	for (var T = 0, D = m[x >> 1], O = D && D.length; T < O; T++) x & 1 ? D[T].call(S) : C = D[T].call(S, C);
	return C;
}, __decorateElement$5 = (m, x, S, C, T, D) => {
	var O, k, A, j, M, N = x & 7, P = !!(x & 8), F = !!(x & 16), I = N > 3 ? m.length + 1 : N ? P ? 1 : 2 : 0, L = __decoratorStrings$5[N + 5], R = N > 3 && (m[I - 1] = []), z = m[I] || (m[I] = []), B = N && (!F && !P && (T = T.prototype), N < 5 && (N > 3 || !F) && __getOwnPropDesc$5(N < 4 ? T : {
		get [S]() {
			return __privateGet$6(this, D);
		},
		set [S](m) {
			return __privateSet$6(this, D, m);
		}
	}, S));
	N ? F && N < 4 && __name$3(D, (N > 2 ? "set " : N > 1 ? "get " : "") + S) : __name$3(T, S);
	for (var H = C.length - 1; H >= 0; H--) j = __decoratorContext$5(N, S, A = {}, m[3], z), N && (j.static = P, j.private = F, M = j.access = { has: F ? (m) => __privateIn$3(T, m) : (m) => S in m }, N ^ 3 && (M.get = F ? (m) => (N ^ 1 ? __privateGet$6 : __privateMethod$4)(m, T, N ^ 4 ? D : B.get) : (m) => m[S]), N > 2 && (M.set = F ? (m, x) => __privateSet$6(m, T, x, N ^ 4 ? D : B.set) : (m, x) => m[S] = x)), k = (0, C[H])(N ? N < 4 ? F ? D : B[L] : N > 4 ? void 0 : {
		get: B.get,
		set: B.set
	} : T, j), A._ = 1, N ^ 4 || k === void 0 ? __expectFn$5(k) && (N > 4 ? R.unshift(k) : N ? F ? D = k : B[L] = k : T = k) : typeof k != "object" || !k ? __typeError$6("Object expected") : (__expectFn$5(O = k.get) && (B.get = O), __expectFn$5(O = k.set) && (B.set = O), __expectFn$5(O = k.init) && R.unshift(O));
	return N || __decoratorMetadata$5(m, T), B && __defProp$6(T, S, B), F ? N ^ 4 ? D : B : T;
}, __accessCheck$6 = (m, x, S) => x.has(m) || __typeError$6("Cannot " + S), __privateIn$3 = (m, x) => Object(x) === x ? m.has(x) : __typeError$6("Cannot use the \"in\" operator on this value"), __privateGet$6 = (m, x, S) => (__accessCheck$6(m, x, "read from private field"), S ? S.call(m) : x.get(m)), __privateAdd$6 = (m, x, S) => x.has(m) ? __typeError$6("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet$6 = (m, x, S, C) => (__accessCheck$6(m, x, "write to private field"), C ? C.call(m, S) : x.set(m, S), S), __privateMethod$4 = (m, x, S) => (__accessCheck$6(m, x, "access private method"), S);
function computed(m, x) {
	if (x) {
		let S;
		return w(() => {
			let C = m();
			return C && S && x(S, C) ? S : (S = C, C);
		});
	}
	return w(m);
}
function deepEqual(m, x) {
	if (Object.is(m, x)) return !0;
	if (m === null || x === null) return !1;
	if (typeof m == "function" && typeof x == "function") return m === x;
	if (m instanceof Set && x instanceof Set) {
		if (m.size !== x.size) return !1;
		for (let S of m) if (!x.has(S)) return !1;
		return !0;
	}
	if (Array.isArray(m)) return !Array.isArray(x) || m.length !== x.length ? !1 : !m.some((m, S) => !deepEqual(m, x[S]));
	if (typeof m == "object" && typeof x == "object") {
		let S = Object.keys(m), C = Object.keys(x);
		return S.length === C.length ? !S.some((S) => !deepEqual(m[S], x[S])) : !1;
	}
	return !1;
}
function reactive({ get: m }, x) {
	return {
		init(m) {
			return d(m);
		},
		get() {
			return m.call(this).value;
		},
		set(x) {
			let S = m.call(this);
			S.peek() !== x && (S.value = x);
		}
	};
}
function derived(m, x) {
	let S = /* @__PURE__ */ new WeakMap();
	return function() {
		let x = S.get(this);
		return x || (x = computed(m.bind(this)), S.set(this, x)), x.value;
	};
}
function enumerable(m = !0) {
	return function(x, S) {
		S.addInitializer(function() {
			let x = S.kind === "field" || S.static ? this : Object.getPrototypeOf(this), C = Object.getOwnPropertyDescriptor(x, S.name);
			C && Object.defineProperty(x, S.name, __spreadProps$6(__spreadValues$7({}, C), { enumerable: m }));
		});
	};
}
function effects(...m) {
	let x = m.map(E);
	return () => x.forEach((m) => m());
}
var _previous_dec, _initial_dec, _current_dec$1, _current_dec2, _previous_dec2, _initial_dec2 = [reactive], _init$5, _initial, _a$3, initial_get, initial_set, _ValueHistory_instances, _previous, _b$1, previous_get, previous_set, _current, _c$2, current_get, current_set;
_previous_dec2 = [reactive], _current_dec2 = [reactive], _current_dec$1 = [enumerable()], _initial_dec = [enumerable()], _previous_dec = [enumerable()];
var ValueHistory = class {
	constructor(m, x = Object.is) {
		this.defaultValue = m, this.equals = x, __runInitializers$5(_init$5, 5, this), __privateAdd$6(this, _ValueHistory_instances), __privateAdd$6(this, _initial, __runInitializers$5(_init$5, 8, this)), __runInitializers$5(_init$5, 11, this), __privateAdd$6(this, _previous, __runInitializers$5(_init$5, 12, this)), __runInitializers$5(_init$5, 15, this), __privateAdd$6(this, _current, __runInitializers$5(_init$5, 16, this)), __runInitializers$5(_init$5, 19, this), this.reset = this.reset.bind(this), this.reset();
	}
	get current() {
		return __privateGet$6(this, _ValueHistory_instances, current_get);
	}
	get initial() {
		return __privateGet$6(this, _ValueHistory_instances, initial_get);
	}
	get previous() {
		return __privateGet$6(this, _ValueHistory_instances, previous_get);
	}
	set current(m) {
		let x = n(() => __privateGet$6(this, _ValueHistory_instances, current_get));
		m && x && this.equals(x, m) || r(() => {
			__privateGet$6(this, _ValueHistory_instances, initial_get) || __privateSet$6(this, _ValueHistory_instances, m, initial_set), __privateSet$6(this, _ValueHistory_instances, x, previous_set), __privateSet$6(this, _ValueHistory_instances, m, current_set);
		});
	}
	reset(m = this.defaultValue) {
		r(() => {
			__privateSet$6(this, _ValueHistory_instances, void 0, previous_set), __privateSet$6(this, _ValueHistory_instances, m, initial_set), __privateSet$6(this, _ValueHistory_instances, m, current_set);
		});
	}
};
_init$5 = __decoratorStart$5(null), _initial = /* @__PURE__ */ new WeakMap(), _ValueHistory_instances = /* @__PURE__ */ new WeakSet(), _previous = /* @__PURE__ */ new WeakMap(), _current = /* @__PURE__ */ new WeakMap(), _a$3 = __decorateElement$5(_init$5, 20, "#initial", _initial_dec2, _ValueHistory_instances, _initial), initial_get = _a$3.get, initial_set = _a$3.set, _b$1 = __decorateElement$5(_init$5, 20, "#previous", _previous_dec2, _ValueHistory_instances, _previous), previous_get = _b$1.get, previous_set = _b$1.set, _c$2 = __decorateElement$5(_init$5, 20, "#current", _current_dec2, _ValueHistory_instances, _current), current_get = _c$2.get, current_set = _c$2.set, __decorateElement$5(_init$5, 2, "current", _current_dec$1, ValueHistory), __decorateElement$5(_init$5, 2, "initial", _initial_dec, ValueHistory), __decorateElement$5(_init$5, 2, "previous", _previous_dec, ValueHistory), __decoratorMetadata$5(_init$5, ValueHistory);
function snapshot(m) {
	return n(() => {
		let x = {};
		for (let S in m) x[S] = m[S];
		return x;
	});
}
var _store, WeakStore = class {
	constructor() {
		__privateAdd$6(this, _store, /* @__PURE__ */ new WeakMap());
	}
	get(m, x) {
		return m ? __privateGet$6(this, _store).get(m)?.get(x) : void 0;
	}
	set(m, x, S) {
		if (m) return __privateGet$6(this, _store).has(m) || __privateGet$6(this, _store).set(m, /* @__PURE__ */ new Map()), __privateGet$6(this, _store).get(m)?.set(x, S);
	}
	clear(m) {
		return m ? __privateGet$6(this, _store).get(m)?.clear() : void 0;
	}
};
_store = /* @__PURE__ */ new WeakMap();
var __create$4 = Object.create, __defProp$5 = Object.defineProperty, __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor, __getOwnPropSymbols$5 = Object.getOwnPropertySymbols, __hasOwnProp$5 = Object.prototype.hasOwnProperty, __propIsEnum$5 = Object.prototype.propertyIsEnumerable, __knownSymbol$4 = (m, x) => (x = Symbol[m]) ? x : Symbol.for("Symbol." + m), __typeError$5 = (m) => {
	throw TypeError(m);
}, __pow = Math.pow, __defNormalProp$5 = (m, x, S) => x in m ? __defProp$5(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$6 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$5.call(x, S) && __defNormalProp$5(m, S, x[S]);
	if (__getOwnPropSymbols$5) for (var S of __getOwnPropSymbols$5(x)) __propIsEnum$5.call(x, S) && __defNormalProp$5(m, S, x[S]);
	return m;
}, __name$2 = (m, x) => __defProp$5(m, "name", {
	value: x,
	configurable: !0
}), __decoratorStart$4 = (m) => [
	,
	,
	,
	__create$4(m?.[__knownSymbol$4("metadata")] ?? null)
], __decoratorStrings$4 = [
	"class",
	"method",
	"getter",
	"setter",
	"accessor",
	"field",
	"value",
	"get",
	"set"
], __expectFn$4 = (m) => m !== void 0 && typeof m != "function" ? __typeError$5("Function expected") : m, __decoratorContext$4 = (m, x, S, C, T) => ({
	kind: __decoratorStrings$4[m],
	name: x,
	metadata: C,
	addInitializer: (m) => S._ ? __typeError$5("Already initialized") : T.push(__expectFn$4(m || null))
}), __decoratorMetadata$4 = (m, x) => __defNormalProp$5(x, __knownSymbol$4("metadata"), m[3]), __runInitializers$4 = (m, x, S, C) => {
	for (var T = 0, D = m[x >> 1], O = D && D.length; T < O; T++) x & 1 ? D[T].call(S) : C = D[T].call(S, C);
	return C;
}, __decorateElement$4 = (m, x, S, C, T, D) => {
	var O, k, A, j, M, N = x & 7, P = !!(x & 8), F = !!(x & 16), I = N > 3 ? m.length + 1 : N ? P ? 1 : 2 : 0, L = __decoratorStrings$4[N + 5], R = N > 3 && (m[I - 1] = []), z = m[I] || (m[I] = []), B = N && (!F && !P && (T = T.prototype), N < 5 && (N > 3 || !F) && __getOwnPropDesc$4(N < 4 ? T : {
		get [S]() {
			return __privateGet$5(this, D);
		},
		set [S](m) {
			return __privateSet$5(this, D, m);
		}
	}, S));
	N ? F && N < 4 && __name$2(D, (N > 2 ? "set " : N > 1 ? "get " : "") + S) : __name$2(T, S);
	for (var H = C.length - 1; H >= 0; H--) j = __decoratorContext$4(N, S, A = {}, m[3], z), N && (j.static = P, j.private = F, M = j.access = { has: F ? (m) => __privateIn$2(T, m) : (m) => S in m }, N ^ 3 && (M.get = F ? (m) => (N ^ 1 ? __privateGet$5 : __privateMethod$3)(m, T, N ^ 4 ? D : B.get) : (m) => m[S]), N > 2 && (M.set = F ? (m, x) => __privateSet$5(m, T, x, N ^ 4 ? D : B.set) : (m, x) => m[S] = x)), k = (0, C[H])(N ? N < 4 ? F ? D : B[L] : N > 4 ? void 0 : {
		get: B.get,
		set: B.set
	} : T, j), A._ = 1, N ^ 4 || k === void 0 ? __expectFn$4(k) && (N > 4 ? R.unshift(k) : N ? F ? D = k : B[L] = k : T = k) : typeof k != "object" || !k ? __typeError$5("Object expected") : (__expectFn$4(O = k.get) && (B.get = O), __expectFn$4(O = k.set) && (B.set = O), __expectFn$4(O = k.init) && R.unshift(O));
	return N || __decoratorMetadata$4(m, T), B && __defProp$5(T, S, B), F ? N ^ 4 ? D : B : T;
}, __accessCheck$5 = (m, x, S) => x.has(m) || __typeError$5("Cannot " + S), __privateIn$2 = (m, x) => Object(x) === x ? m.has(x) : __typeError$5("Cannot use the \"in\" operator on this value"), __privateGet$5 = (m, x, S) => (__accessCheck$5(m, x, "read from private field"), S ? S.call(m) : x.get(m)), __privateAdd$5 = (m, x, S) => x.has(m) ? __typeError$5("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet$5 = (m, x, S, C) => (__accessCheck$5(m, x, "write to private field"), C ? C.call(m, S) : x.set(m, S), S), __privateMethod$3 = (m, x, S) => (__accessCheck$5(m, x, "access private method"), S), Point = class m {
	constructor(m, x) {
		this.x = m, this.y = x;
	}
	static delta(x, S) {
		return new m(x.x - S.x, x.y - S.y);
	}
	static distance(m, x) {
		return Math.hypot(m.x - x.x, m.y - x.y);
	}
	static equals(m, x) {
		return m.x === x.x && m.y === x.y;
	}
	static from({ x, y: S }) {
		return new m(x, S);
	}
}, Rectangle = class m {
	constructor(m, x, S, C) {
		this.left = m, this.top = x, this.width = S, this.height = C, this.scale = {
			x: 1,
			y: 1
		};
	}
	get inverseScale() {
		return {
			x: 1 / this.scale.x,
			y: 1 / this.scale.y
		};
	}
	translate(x, S) {
		let { top: C, left: T, width: D, height: O, scale: k } = this, A = new m(T + x, C + S, D, O);
		return A.scale = __spreadValues$6({}, k), A;
	}
	get boundingRectangle() {
		let { width: m, height: x, left: S, top: C, right: T, bottom: D } = this;
		return {
			width: m,
			height: x,
			left: S,
			top: C,
			right: T,
			bottom: D
		};
	}
	get center() {
		let { left: m, top: x, right: S, bottom: C } = this;
		return new Point((m + S) / 2, (x + C) / 2);
	}
	get area() {
		let { width: m, height: x } = this;
		return m * x;
	}
	equals(x) {
		if (!(x instanceof m)) return !1;
		let { left: S, top: C, width: T, height: D } = this;
		return S === x.left && C === x.top && T === x.width && D === x.height;
	}
	containsPoint(m) {
		let { top: x, left: S, bottom: C, right: T } = this;
		return x <= m.y && m.y <= C && S <= m.x && m.x <= T;
	}
	intersectionArea(x) {
		return x instanceof m ? rectangleRectangleIntersection(this, x) : 0;
	}
	intersectionRatio(m) {
		let { area: x } = this, S = this.intersectionArea(m);
		return S / (m.area + x - S);
	}
	get bottom() {
		let { top: m, height: x } = this;
		return m + x;
	}
	get right() {
		let { left: m, width: x } = this;
		return m + x;
	}
	get aspectRatio() {
		let { width: m, height: x } = this;
		return m / x;
	}
	get corners() {
		return [
			{
				x: this.left,
				y: this.top
			},
			{
				x: this.right,
				y: this.top
			},
			{
				x: this.left,
				y: this.bottom
			},
			{
				x: this.right,
				y: this.bottom
			}
		];
	}
	static from({ top: x, left: S, width: C, height: T }) {
		return new m(S, x, C, T);
	}
	static delta(m, x, S = {
		x: "center",
		y: "center"
	}) {
		let C = (m, x) => {
			let C = S[x], T = x === "x" ? m.left : m.top, D = x === "x" ? m.width : m.height;
			return C == "start" ? T : C == "end" ? T + D : T + D / 2;
		};
		return Point.delta({
			x: C(m, "x"),
			y: C(m, "y")
		}, {
			x: C(x, "x"),
			y: C(x, "y")
		});
	}
	static intersectionRatio(x, S) {
		return m.from(x).intersectionRatio(m.from(S));
	}
};
function rectangleRectangleIntersection(m, x) {
	let S = Math.max(x.top, m.top), C = Math.max(x.left, m.left), T = Math.min(x.left + x.width, m.left + m.width), D = Math.min(x.top + x.height, m.top + m.height), O = T - C, k = D - S;
	return C < T && S < D ? O * k : 0;
}
var _direction_dec$1, _delta_dec$1, _a$2, _timestamp$1, _init$4, Position$1 = class extends (_a$2 = ValueHistory, _delta_dec$1 = [derived], _direction_dec$1 = [derived], _a$2) {
	constructor(m) {
		let x = Point.from(m);
		super(x, (m, x) => Point.equals(m, x)), __runInitializers$4(_init$4, 5, this), __privateAdd$5(this, _timestamp$1, 0), this.velocity = {
			x: 0,
			y: 0
		};
	}
	get delta() {
		return Point.delta(this.current, this.initial);
	}
	get direction() {
		let { current: m, previous: x } = this;
		if (!x) return null;
		let S = {
			x: m.x - x.x,
			y: m.y - x.y
		};
		return !S.x && !S.y ? null : Math.abs(S.x) > Math.abs(S.y) ? S.x > 0 ? "right" : "left" : S.y > 0 ? "down" : "up";
	}
	get current() {
		return super.current;
	}
	set current(m) {
		let { current: x } = this, S = Point.from(m), C = {
			x: S.x - x.x,
			y: S.y - x.y
		}, T = Date.now(), D = T - __privateGet$5(this, _timestamp$1), O = (m) => Math.round(m / D * 100);
		r(() => {
			__privateSet$5(this, _timestamp$1, T), this.velocity = {
				x: O(C.x),
				y: O(C.y)
			}, super.current = S;
		});
	}
	reset(m = this.defaultValue) {
		super.reset(Point.from(m)), this.velocity = {
			x: 0,
			y: 0
		};
	}
};
_init$4 = __decoratorStart$4(_a$2), _timestamp$1 = /* @__PURE__ */ new WeakMap(), __decorateElement$4(_init$4, 2, "delta", _delta_dec$1, Position$1), __decorateElement$4(_init$4, 2, "direction", _direction_dec$1, Position$1), __decoratorMetadata$4(_init$4, Position$1);
function exceedsDistance({ x: m, y: x }, S) {
	let C = Math.abs(m), T = Math.abs(x);
	return typeof S == "number" ? Math.sqrt(__pow(C, 2) + __pow(T, 2)) > S : "x" in S && "y" in S ? C > S.x && T > S.y : "x" in S ? C > S.x : "y" in S ? T > S.y : !1;
}
var Axis$1 = /* @__PURE__ */ ((m) => (m.Horizontal = "x", m.Vertical = "y", m))(Axis$1 || {}), Axes = Object.values(Axis$1), __create$3 = Object.create, __defProp$4 = Object.defineProperty, __defProps$4 = Object.defineProperties, __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor, __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$4 = Object.getOwnPropertySymbols, __hasOwnProp$4 = Object.prototype.hasOwnProperty, __propIsEnum$4 = Object.prototype.propertyIsEnumerable, __knownSymbol$3 = (m, x) => (x = Symbol[m]) ? x : Symbol.for("Symbol." + m), __typeError$4 = (m) => {
	throw TypeError(m);
}, __defNormalProp$4 = (m, x, S) => x in m ? __defProp$4(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$5 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$4.call(x, S) && __defNormalProp$4(m, S, x[S]);
	if (__getOwnPropSymbols$4) for (var S of __getOwnPropSymbols$4(x)) __propIsEnum$4.call(x, S) && __defNormalProp$4(m, S, x[S]);
	return m;
}, __spreadProps$5 = (m, x) => __defProps$4(m, __getOwnPropDescs$4(x)), __name$1 = (m, x) => __defProp$4(m, "name", {
	value: x,
	configurable: !0
}), __objRest$4 = (m, x) => {
	var S = {};
	for (var C in m) __hasOwnProp$4.call(m, C) && x.indexOf(C) < 0 && (S[C] = m[C]);
	if (m != null && __getOwnPropSymbols$4) for (var C of __getOwnPropSymbols$4(m)) x.indexOf(C) < 0 && __propIsEnum$4.call(m, C) && (S[C] = m[C]);
	return S;
}, __decoratorStart$3 = (m) => [
	,
	,
	,
	__create$3(m?.[__knownSymbol$3("metadata")] ?? null)
], __decoratorStrings$3 = [
	"class",
	"method",
	"getter",
	"setter",
	"accessor",
	"field",
	"value",
	"get",
	"set"
], __expectFn$3 = (m) => m !== void 0 && typeof m != "function" ? __typeError$4("Function expected") : m, __decoratorContext$3 = (m, x, S, C, T) => ({
	kind: __decoratorStrings$3[m],
	name: x,
	metadata: C,
	addInitializer: (m) => S._ ? __typeError$4("Already initialized") : T.push(__expectFn$3(m || null))
}), __decoratorMetadata$3 = (m, x) => __defNormalProp$4(x, __knownSymbol$3("metadata"), m[3]), __runInitializers$3 = (m, x, S, C) => {
	for (var T = 0, D = m[x >> 1], O = D && D.length; T < O; T++) x & 1 ? D[T].call(S) : C = D[T].call(S, C);
	return C;
}, __decorateElement$3 = (m, x, S, C, T, D) => {
	var O, k, A, j, M, N = x & 7, P = !!(x & 8), F = !!(x & 16), I = N > 3 ? m.length + 1 : N ? P ? 1 : 2 : 0, L = __decoratorStrings$3[N + 5], R = N > 3 && (m[I - 1] = []), z = m[I] || (m[I] = []), B = N && (!F && !P && (T = T.prototype), N < 5 && (N > 3 || !F) && __getOwnPropDesc$3(N < 4 ? T : {
		get [S]() {
			return __privateGet$4(this, D);
		},
		set [S](m) {
			return __privateSet$4(this, D, m);
		}
	}, S));
	N ? F && N < 4 && __name$1(D, (N > 2 ? "set " : N > 1 ? "get " : "") + S) : __name$1(T, S);
	for (var H = C.length - 1; H >= 0; H--) j = __decoratorContext$3(N, S, A = {}, m[3], z), N && (j.static = P, j.private = F, M = j.access = { has: F ? (m) => __privateIn$1(T, m) : (m) => S in m }, N ^ 3 && (M.get = F ? (m) => (N ^ 1 ? __privateGet$4 : __privateMethod$2)(m, T, N ^ 4 ? D : B.get) : (m) => m[S]), N > 2 && (M.set = F ? (m, x) => __privateSet$4(m, T, x, N ^ 4 ? D : B.set) : (m, x) => m[S] = x)), k = (0, C[H])(N ? N < 4 ? F ? D : B[L] : N > 4 ? void 0 : {
		get: B.get,
		set: B.set
	} : T, j), A._ = 1, N ^ 4 || k === void 0 ? __expectFn$3(k) && (N > 4 ? R.unshift(k) : N ? F ? D = k : B[L] = k : T = k) : typeof k != "object" || !k ? __typeError$4("Object expected") : (__expectFn$3(O = k.get) && (B.get = O), __expectFn$3(O = k.set) && (B.set = O), __expectFn$3(O = k.init) && R.unshift(O));
	return N || __decoratorMetadata$3(m, T), B && __defProp$4(T, S, B), F ? N ^ 4 ? D : B : T;
}, __accessCheck$4 = (m, x, S) => x.has(m) || __typeError$4("Cannot " + S), __privateIn$1 = (m, x) => Object(x) === x ? m.has(x) : __typeError$4("Cannot use the \"in\" operator on this value"), __privateGet$4 = (m, x, S) => (__accessCheck$4(m, x, "read from private field"), S ? S.call(m) : x.get(m)), __privateAdd$4 = (m, x, S) => x.has(m) ? __typeError$4("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet$4 = (m, x, S, C) => (__accessCheck$4(m, x, "write to private field"), C ? C.call(m, S) : x.set(m, S), S), __privateMethod$2 = (m, x, S) => (__accessCheck$4(m, x, "access private method"), S);
function configure(m, x) {
	return {
		plugin: m,
		options: x
	};
}
function configurator(m) {
	return (x) => configure(m, x);
}
function descriptor(m) {
	return typeof m == "function" ? {
		plugin: m,
		options: void 0
	} : m;
}
var _disabled_dec = [reactive], _init$3, _disabled, _cleanupFunctions$1, Plugin = class {
	constructor(m, x) {
		this.manager = m, this.options = x, __privateAdd$4(this, _disabled, __runInitializers$3(_init$3, 8, this, !1)), __runInitializers$3(_init$3, 11, this), __privateAdd$4(this, _cleanupFunctions$1, /* @__PURE__ */ new Set());
	}
	enable() {
		this.disabled = !1;
	}
	disable() {
		this.disabled = !0;
	}
	isDisabled() {
		return n(() => this.disabled);
	}
	configure(m) {
		this.options = m;
	}
	registerEffect(m) {
		let x = E(m.bind(this));
		return __privateGet$4(this, _cleanupFunctions$1).add(x), x;
	}
	destroy() {
		__privateGet$4(this, _cleanupFunctions$1).forEach((m) => m());
	}
	static configure(m) {
		return configure(this, m);
	}
};
_init$3 = __decoratorStart$3(null), _disabled = /* @__PURE__ */ new WeakMap(), _cleanupFunctions$1 = /* @__PURE__ */ new WeakMap(), __decorateElement$3(_init$3, 4, "disabled", _disabled_dec, Plugin, _disabled), __decoratorMetadata$3(_init$3, Plugin);
var CorePlugin = class extends Plugin {}, _previousValues, PluginRegistry = class {
	constructor(m) {
		this.manager = m, this.instances = /* @__PURE__ */ new Map(), __privateAdd$4(this, _previousValues, []);
	}
	get values() {
		return Array.from(this.instances.values());
	}
	set values(m) {
		let x = m.map(descriptor).reduceRight((m, x) => m.some(({ plugin: m }) => m === x.plugin) ? m : [x, ...m], []), S = x.map(({ plugin: m }) => m);
		for (let m of __privateGet$4(this, _previousValues)) if (!S.includes(m)) {
			if (m.prototype instanceof CorePlugin) continue;
			this.unregister(m);
		}
		for (let { plugin: m, options: S } of x) this.register(m, S);
		__privateSet$4(this, _previousValues, S);
	}
	get(m) {
		return this.instances.get(m);
	}
	register(m, x) {
		let S = this.instances.get(m);
		if (S) return S.options !== x && (S.options = x), S;
		let C = new m(this.manager, x);
		return this.instances.set(m, C), C;
	}
	unregister(m) {
		let x = this.instances.get(m);
		x && (x.destroy(), this.instances.delete(m));
	}
	destroy() {
		for (let m of this.instances.values()) m.destroy();
		this.instances.clear();
	}
};
_previousValues = /* @__PURE__ */ new WeakMap();
function sortCollisions(m, x) {
	return m.priority === x.priority ? m.type === x.type ? x.value - m.value : x.type - m.type : x.priority - m.priority;
}
var DEFAULT_VALUE = [], _previousCoordinates, _collisions, CollisionObserver = class extends Plugin {
	constructor(m) {
		super(m), __privateAdd$4(this, _previousCoordinates), __privateAdd$4(this, _collisions), this.computeCollisions = this.computeCollisions.bind(this), __privateSet$4(this, _collisions, d(DEFAULT_VALUE)), this.destroy = effects(() => {
			let m = this.computeCollisions(), x = n(() => this.manager.dragOperation.position.current);
			if (m !== DEFAULT_VALUE) {
				let m = __privateGet$4(this, _previousCoordinates);
				if (__privateSet$4(this, _previousCoordinates, x), m && x.x == m.x && x.y == m.y) return;
			} else __privateSet$4(this, _previousCoordinates, void 0);
			__privateGet$4(this, _collisions).value = m;
		}, () => {
			let { dragOperation: m } = this.manager;
			m.status.initialized && this.forceUpdate();
		});
	}
	forceUpdate(m = !0) {
		n(() => {
			m ? __privateGet$4(this, _collisions).value = this.computeCollisions() : __privateSet$4(this, _previousCoordinates, void 0);
		});
	}
	computeCollisions(m, x) {
		let { registry: S, dragOperation: C } = this.manager, { source: T, shape: D, status: O } = C;
		if (!O.initialized || !D) return DEFAULT_VALUE;
		let k = [], A = [];
		for (let D of m ?? S.droppables) {
			if (D.disabled || T && !D.accepts(T)) continue;
			let m = x ?? D.collisionDetector;
			if (!m) continue;
			A.push(D), D.shape;
			let S = n(() => m({
				droppable: D,
				dragOperation: C
			}));
			S && (D.collisionPriority != null && (S.priority = D.collisionPriority), k.push(S));
		}
		return A.length === 0 ? DEFAULT_VALUE : (k.sort(sortCollisions), k);
	}
	get collisions() {
		return __privateGet$4(this, _collisions).value;
	}
};
_previousCoordinates = /* @__PURE__ */ new WeakMap(), _collisions = /* @__PURE__ */ new WeakMap();
var Monitor$1 = class {
	constructor() {
		this.registry = /* @__PURE__ */ new Map();
	}
	addEventListener(m, x) {
		let { registry: S } = this, C = new Set(S.get(m));
		return C.add(x), S.set(m, C), () => this.removeEventListener(m, x);
	}
	removeEventListener(m, x) {
		let { registry: S } = this, C = new Set(S.get(m));
		C.delete(x), S.set(m, C);
	}
	dispatch(m, ...x) {
		let { registry: S } = this, C = S.get(m);
		if (C) for (let m of C) m(...x);
	}
}, DragDropMonitor = class extends Monitor$1 {
	constructor(m) {
		super(), this.manager = m;
	}
	dispatch(m, x) {
		let S = [x, this.manager];
		super.dispatch(m, ...S);
	}
};
function defaultPreventable(m, x = !0) {
	let S = !1;
	return __spreadProps$5(__spreadValues$5({}, m), {
		cancelable: x,
		get defaultPrevented() {
			return S;
		},
		preventDefault() {
			x && (S = !0);
		}
	});
}
var CollisionNotifier = class extends CorePlugin {
	constructor(m) {
		super(m);
		let x = (m, x) => m.map(({ id: m }) => m).join("") === x.map(({ id: m }) => m).join(""), S = [];
		this.destroy = effects(() => {
			let { dragOperation: x, collisionObserver: C } = m;
			x.status.initializing && (S = [], C.enable());
		}, () => {
			let { collisionObserver: C, monitor: T } = m, { collisions: D } = C;
			if (C.isDisabled()) return;
			let O = defaultPreventable({ collisions: D });
			if (T.dispatch("collision", O), O.defaultPrevented || x(D, S)) return;
			S = D;
			let [k] = D;
			n(() => {
				k?.id !== m.dragOperation.target?.id && (C.disable(), m.actions.setDropTarget(k?.id).then(() => {
					C.enable();
				}));
			});
		});
	}
}, CollisionPriority = /* @__PURE__ */ ((m) => (m[m.Lowest = 0] = "Lowest", m[m.Low = 1] = "Low", m[m.Normal = 2] = "Normal", m[m.High = 3] = "High", m[m.Highest = 4] = "Highest", m))(CollisionPriority || {}), CollisionType = /* @__PURE__ */ ((m) => (m[m.Collision = 0] = "Collision", m[m.ShapeIntersection = 1] = "ShapeIntersection", m[m.PointerIntersection = 2] = "PointerIntersection", m))(CollisionType || {}), _dropped_dec, _dragging_dec, _initialized_dec, _initializing_dec, _idle_dec, _current_dec, _value_dec = [reactive], _init2$1, _value;
_current_dec = [derived], _idle_dec = [derived], _initializing_dec = [derived], _initialized_dec = [derived], _dragging_dec = [derived], _dropped_dec = [derived];
var Status = class {
	constructor() {
		__runInitializers$3(_init2$1, 5, this), __privateAdd$4(this, _value, __runInitializers$3(_init2$1, 8, this, "idle")), __runInitializers$3(_init2$1, 11, this);
	}
	get current() {
		return this.value;
	}
	get idle() {
		return this.value === "idle";
	}
	get initializing() {
		return this.value === "initializing";
	}
	get initialized() {
		let { value: m } = this;
		return m !== "idle" && m !== "initialization-pending";
	}
	get dragging() {
		return this.value === "dragging";
	}
	get dropped() {
		return this.value === "dropped";
	}
	set(m) {
		this.value = m;
	}
};
_init2$1 = __decoratorStart$3(null), _value = /* @__PURE__ */ new WeakMap(), __decorateElement$3(_init2$1, 4, "value", _value_dec, Status, _value), __decorateElement$3(_init2$1, 2, "current", _current_dec, Status), __decorateElement$3(_init2$1, 2, "idle", _idle_dec, Status), __decorateElement$3(_init2$1, 2, "initializing", _initializing_dec, Status), __decorateElement$3(_init2$1, 2, "initialized", _initialized_dec, Status), __decorateElement$3(_init2$1, 2, "dragging", _dragging_dec, Status), __decorateElement$3(_init2$1, 2, "dropped", _dropped_dec, Status), __decoratorMetadata$3(_init2$1, Status);
var DragActions = class {
	constructor(m) {
		this.manager = m;
	}
	setDragSource(m) {
		let { dragOperation: x } = this.manager;
		x.sourceIdentifier = typeof m == "string" || typeof m == "number" ? m : m.id;
	}
	setDropTarget(m) {
		return n(() => {
			let { dragOperation: x } = this.manager, S = m ?? null;
			if (x.targetIdentifier === S) return Promise.resolve(!1);
			x.targetIdentifier = S;
			let C = defaultPreventable({ operation: x.snapshot() });
			return x.status.dragging && this.manager.monitor.dispatch("dragover", C), this.manager.renderer.rendering.then(() => C.defaultPrevented);
		});
	}
	start(m) {
		return n(() => {
			let { dragOperation: x } = this.manager;
			if (m.source != null && this.setDragSource(m.source), !x.source) throw Error("Cannot start a drag operation without a drag source");
			if (!x.status.idle) throw Error("Cannot start a drag operation while another is active");
			let S = new AbortController(), { event: C, coordinates: T } = m;
			r(() => {
				x.status.set("initialization-pending"), x.shape = null, x.canceled = !1, x.activatorEvent = C ?? null, x.position.reset(T);
			});
			let D = defaultPreventable({ operation: x.snapshot() });
			return this.manager.monitor.dispatch("beforedragstart", D), D.defaultPrevented ? (x.reset(), S.abort(), S) : (x.status.set("initializing"), x.controller = S, this.manager.renderer.rendering.then(() => {
				if (S.signal.aborted) return;
				let { status: m } = x;
				m.current === "initializing" && (x.status.set("dragging"), this.manager.monitor.dispatch("dragstart", {
					nativeEvent: C,
					operation: x.snapshot(),
					cancelable: !1
				}));
			}), S);
		});
	}
	move(m) {
		return n(() => {
			let { dragOperation: x } = this.manager, { status: S, controller: C } = x;
			if (!S.dragging || !C || C.signal.aborted) return;
			let T = defaultPreventable({
				nativeEvent: m.event,
				operation: x.snapshot(),
				by: m.by,
				to: m.to
			}, m.cancelable ?? !0);
			(m.propagate ?? !0) && this.manager.monitor.dispatch("dragmove", T), queueMicrotask(() => {
				if (T.defaultPrevented) return;
				let S = m.to ?? {
					x: x.position.current.x + (m.by?.x ?? 0),
					y: x.position.current.y + (m.by?.y ?? 0)
				};
				x.position.current = S;
			});
		});
	}
	stop(m = {}) {
		return n(() => {
			let { dragOperation: x } = this.manager, { controller: S } = x;
			if (!S || S.signal.aborted) return;
			let C, T = () => {
				let m = {
					resume: () => {},
					abort: () => {}
				};
				return C = new Promise((x, S) => {
					m.resume = x, m.abort = S;
				}), m;
			};
			S.abort();
			let D = () => {
				this.manager.renderer.rendering.then(() => {
					x.status.set("dropped");
					let m = n(() => x.source?.status === "dropping"), C = () => {
						x.controller === S && (x.controller = void 0), x.reset();
					};
					if (m) {
						let { source: m } = x, S = E(() => {
							m?.status === "idle" && (S(), C());
						});
					} else this.manager.renderer.rendering.then(C);
				});
			};
			x.canceled = m.canceled ?? !1, this.manager.monitor.dispatch("dragend", {
				nativeEvent: m.event,
				operation: x.snapshot(),
				canceled: m.canceled ?? !1,
				suspend: T
			}), C ? C.then(D).catch(() => x.reset()) : D();
		});
	}
}, _disabled_dec2, _data_dec, _id_dec, _manager_dec = [reactive], _init3$1, _manager, _id, _data, _disabled2;
_id_dec = [reactive], _data_dec = [reactive], _disabled_dec2 = [reactive];
var Entity = class {
	constructor(m, x) {
		__privateAdd$4(this, _manager, __runInitializers$3(_init3$1, 8, this)), __runInitializers$3(_init3$1, 11, this), __privateAdd$4(this, _id, __runInitializers$3(_init3$1, 12, this)), __runInitializers$3(_init3$1, 15, this), __privateAdd$4(this, _data, __runInitializers$3(_init3$1, 16, this)), __runInitializers$3(_init3$1, 19, this), __privateAdd$4(this, _disabled2, __runInitializers$3(_init3$1, 20, this)), __runInitializers$3(_init3$1, 23, this);
		let { effects: S, id: C, data: T = {}, disabled: D = !1, register: O = !0 } = m, k = C;
		this.manager = x, this.id = C, this.data = T, this.disabled = D, this.effects = () => [() => {
			let { id: m, manager: x } = this;
			if (m !== k) return x?.registry.register(this), () => x?.registry.unregister(this);
		}, ...S?.() ?? []], this.register = this.register.bind(this), this.unregister = this.unregister.bind(this), this.destroy = this.destroy.bind(this), x && O && queueMicrotask(this.register);
	}
	register() {
		return this.manager?.registry.register(this);
	}
	unregister() {
		var m;
		(m = this.manager) == null || m.registry.unregister(this);
	}
	destroy() {
		var m;
		(m = this.manager) == null || m.registry.unregister(this);
	}
};
_init3$1 = __decoratorStart$3(null), _manager = /* @__PURE__ */ new WeakMap(), _id = /* @__PURE__ */ new WeakMap(), _data = /* @__PURE__ */ new WeakMap(), _disabled2 = /* @__PURE__ */ new WeakMap(), __decorateElement$3(_init3$1, 4, "manager", _manager_dec, Entity, _manager), __decorateElement$3(_init3$1, 4, "id", _id_dec, Entity, _id), __decorateElement$3(_init3$1, 4, "data", _data_dec, Entity, _data), __decorateElement$3(_init3$1, 4, "disabled", _disabled_dec2, Entity, _disabled2), __decoratorMetadata$3(_init3$1, Entity);
var EntityRegistry = class {
	constructor() {
		this.map = d(/* @__PURE__ */ new Map()), this.cleanupFunctions = /* @__PURE__ */ new WeakMap(), this.register = (m, x) => {
			let S = this.map.peek(), C = S.get(m), T = () => this.unregister(m, x);
			if (C === x) return T;
			C && (this.cleanupFunctions.get(C)?.(), this.cleanupFunctions.delete(C));
			let D = new Map(S);
			D.set(m, x), this.map.value = D;
			let O = effects(...x.effects());
			return this.cleanupFunctions.set(x, O), T;
		}, this.unregister = (m, x) => {
			let S = this.map.peek();
			if (S.get(m) !== x) return;
			this.cleanupFunctions.get(x)?.(), this.cleanupFunctions.delete(x);
			let C = new Map(S);
			C.delete(m), this.map.value = C;
		};
	}
	[Symbol.iterator]() {
		return this.map.peek().values();
	}
	get value() {
		return this.map.value.values();
	}
	has(m) {
		return this.map.value.has(m);
	}
	get(m) {
		return this.map.value.get(m);
	}
	destroy() {
		for (let m of this) this.cleanupFunctions.get(m)?.(), m.destroy();
		this.map.value = /* @__PURE__ */ new Map();
	}
}, _isDragSource_dec, _isDragging_dec, _isDropping_dec, _status_dec, _modifiers_dec, _type_dec, _c$1, _init4$1, _type, _modifiers, _status, Draggable$1 = class extends (_c$1 = Entity, _type_dec = [reactive], _modifiers_dec = [reactive], _status_dec = [reactive], _isDropping_dec = [derived], _isDragging_dec = [derived], _isDragSource_dec = [derived], _c$1) {
	constructor(m, x) {
		var S = m, { modifiers: C, type: T, sensors: D } = S, O = __objRest$4(S, [
			"modifiers",
			"type",
			"sensors"
		]);
		super(O, x), __runInitializers$3(_init4$1, 5, this), __privateAdd$4(this, _type, __runInitializers$3(_init4$1, 8, this)), __runInitializers$3(_init4$1, 11, this), __privateAdd$4(this, _modifiers, __runInitializers$3(_init4$1, 12, this)), __runInitializers$3(_init4$1, 15, this), __privateAdd$4(this, _status, __runInitializers$3(_init4$1, 16, this, this.isDragSource ? "dragging" : "idle")), __runInitializers$3(_init4$1, 19, this), this.type = T, this.sensors = D, this.modifiers = C, this.alignment = O.alignment;
	}
	get isDropping() {
		return this.status === "dropping" && this.isDragSource;
	}
	get isDragging() {
		return this.status === "dragging" && this.isDragSource;
	}
	get isDragSource() {
		return this.manager?.dragOperation.source?.id === this.id;
	}
};
_init4$1 = __decoratorStart$3(_c$1), _type = /* @__PURE__ */ new WeakMap(), _modifiers = /* @__PURE__ */ new WeakMap(), _status = /* @__PURE__ */ new WeakMap(), __decorateElement$3(_init4$1, 4, "type", _type_dec, Draggable$1, _type), __decorateElement$3(_init4$1, 4, "modifiers", _modifiers_dec, Draggable$1, _modifiers), __decorateElement$3(_init4$1, 4, "status", _status_dec, Draggable$1, _status), __decorateElement$3(_init4$1, 2, "isDropping", _isDropping_dec, Draggable$1), __decorateElement$3(_init4$1, 2, "isDragging", _isDragging_dec, Draggable$1), __decorateElement$3(_init4$1, 2, "isDragSource", _isDragSource_dec, Draggable$1), __decoratorMetadata$3(_init4$1, Draggable$1);
var _isDropTarget_dec, _shape_dec, _collisionPriority_dec, _collisionDetector_dec, _type_dec2, _accept_dec, _c2$1, _init5$1, _accept, _type2, _collisionDetector, _collisionPriority, _shape, Droppable$1 = class extends (_c2$1 = Entity, _accept_dec = [reactive], _type_dec2 = [reactive], _collisionDetector_dec = [reactive], _collisionPriority_dec = [reactive], _shape_dec = [reactive], _isDropTarget_dec = [derived], _c2$1) {
	constructor(m, x) {
		var S = m, { accept: C, collisionDetector: T, collisionPriority: D, type: O } = S, k = __objRest$4(S, [
			"accept",
			"collisionDetector",
			"collisionPriority",
			"type"
		]);
		super(k, x), __runInitializers$3(_init5$1, 5, this), __privateAdd$4(this, _accept, __runInitializers$3(_init5$1, 8, this)), __runInitializers$3(_init5$1, 11, this), __privateAdd$4(this, _type2, __runInitializers$3(_init5$1, 12, this)), __runInitializers$3(_init5$1, 15, this), __privateAdd$4(this, _collisionDetector, __runInitializers$3(_init5$1, 16, this)), __runInitializers$3(_init5$1, 19, this), __privateAdd$4(this, _collisionPriority, __runInitializers$3(_init5$1, 20, this)), __runInitializers$3(_init5$1, 23, this), __privateAdd$4(this, _shape, __runInitializers$3(_init5$1, 24, this)), __runInitializers$3(_init5$1, 27, this), this.accept = C, this.collisionDetector = T, this.collisionPriority = D, this.type = O;
	}
	accepts(m) {
		let { accept: x } = this;
		return x ? typeof x == "function" ? x(m) : m.type ? Array.isArray(x) ? x.includes(m.type) : m.type === x : !1 : !0;
	}
	get isDropTarget() {
		return this.manager?.dragOperation.target?.id === this.id;
	}
};
_init5$1 = __decoratorStart$3(_c2$1), _accept = /* @__PURE__ */ new WeakMap(), _type2 = /* @__PURE__ */ new WeakMap(), _collisionDetector = /* @__PURE__ */ new WeakMap(), _collisionPriority = /* @__PURE__ */ new WeakMap(), _shape = /* @__PURE__ */ new WeakMap(), __decorateElement$3(_init5$1, 4, "accept", _accept_dec, Droppable$1, _accept), __decorateElement$3(_init5$1, 4, "type", _type_dec2, Droppable$1, _type2), __decorateElement$3(_init5$1, 4, "collisionDetector", _collisionDetector_dec, Droppable$1, _collisionDetector), __decorateElement$3(_init5$1, 4, "collisionPriority", _collisionPriority_dec, Droppable$1, _collisionPriority), __decorateElement$3(_init5$1, 4, "shape", _shape_dec, Droppable$1, _shape), __decorateElement$3(_init5$1, 2, "isDropTarget", _isDropTarget_dec, Droppable$1), __decoratorMetadata$3(_init5$1, Droppable$1);
var Sensor = class extends Plugin {
	constructor(m, x) {
		super(m, x), this.manager = m, this.options = x;
	}
}, Modifier = class extends Plugin {
	constructor(m, x) {
		super(m, x), this.manager = m, this.options = x;
	}
	apply(m) {
		return m.transform;
	}
}, DragDropRegistry = class {
	constructor(m) {
		this.draggables = new EntityRegistry(), this.droppables = new EntityRegistry(), this.plugins = new PluginRegistry(m), this.sensors = new PluginRegistry(m), this.modifiers = new PluginRegistry(m);
	}
	register(m, x) {
		if (m instanceof Draggable$1) return this.draggables.register(m.id, m);
		if (m instanceof Droppable$1) return this.droppables.register(m.id, m);
		if (m.prototype instanceof Modifier) return this.modifiers.register(m, x);
		if (m.prototype instanceof Sensor) return this.sensors.register(m, x);
		if (m.prototype instanceof Plugin) return this.plugins.register(m, x);
		throw Error("Invalid instance type");
	}
	unregister(m) {
		if (m instanceof Entity) return m instanceof Draggable$1 ? this.draggables.unregister(m.id, m) : m instanceof Droppable$1 ? this.droppables.unregister(m.id, m) : () => {};
		if (m.prototype instanceof Modifier) return this.modifiers.unregister(m);
		if (m.prototype instanceof Sensor) return this.sensors.unregister(m);
		if (m.prototype instanceof Plugin) return this.plugins.unregister(m);
		throw Error("Invalid instance type");
	}
	destroy() {
		this.draggables.destroy(), this.droppables.destroy(), this.plugins.destroy(), this.sensors.destroy(), this.modifiers.destroy();
	}
}, _transform_dec, _target_dec, _source_dec, _modifiers_dec2, _targetIdentifier_dec, _sourceIdentifier_dec, _activatorEvent_dec, _canceled_dec, _shape_dec2 = [derived], _manager2, _previousSource, _shape2, _init6, _canceled, _activatorEvent, _sourceIdentifier, _targetIdentifier, _modifiers2, _transform;
_canceled_dec = [reactive], _activatorEvent_dec = [reactive], _sourceIdentifier_dec = [reactive], _targetIdentifier_dec = [reactive], _modifiers_dec2 = [reactive], _source_dec = [derived], _target_dec = [derived], _transform_dec = [derived];
var DragOperation = class {
	constructor(m) {
		__runInitializers$3(_init6, 5, this), __privateAdd$4(this, _manager2), __privateAdd$4(this, _previousSource), __privateAdd$4(this, _shape2, new ValueHistory(void 0, (m, x) => m && x ? m.equals(x) : m === x)), this.status = new Status(), __privateAdd$4(this, _canceled, __runInitializers$3(_init6, 8, this, !1)), __runInitializers$3(_init6, 11, this), __privateAdd$4(this, _activatorEvent, __runInitializers$3(_init6, 12, this, null)), __runInitializers$3(_init6, 15, this), __privateAdd$4(this, _sourceIdentifier, __runInitializers$3(_init6, 16, this, null)), __runInitializers$3(_init6, 19, this), __privateAdd$4(this, _targetIdentifier, __runInitializers$3(_init6, 20, this, null)), __runInitializers$3(_init6, 23, this), __privateAdd$4(this, _modifiers2, __runInitializers$3(_init6, 24, this, [])), __runInitializers$3(_init6, 27, this), this.position = new Position$1({
			x: 0,
			y: 0
		}), __privateAdd$4(this, _transform, {
			x: 0,
			y: 0
		}), __privateSet$4(this, _manager2, m);
	}
	get shape() {
		let { current: m, initial: x, previous: S } = __privateGet$4(this, _shape2);
		return !m || !x ? null : {
			current: m,
			initial: x,
			previous: S
		};
	}
	set shape(m) {
		m ? __privateGet$4(this, _shape2).current = m : __privateGet$4(this, _shape2).reset();
	}
	get source() {
		let m = this.sourceIdentifier;
		if (m == null) return null;
		let x = __privateGet$4(this, _manager2).registry.draggables.get(m);
		return x && __privateSet$4(this, _previousSource, x), x ?? __privateGet$4(this, _previousSource) ?? null;
	}
	get target() {
		let m = this.targetIdentifier;
		return m == null ? null : __privateGet$4(this, _manager2).registry.droppables.get(m) ?? null;
	}
	get transform() {
		let { x: m, y: x } = this.position.delta, S = {
			x: m,
			y: x
		};
		for (let m of this.modifiers) S = m.apply(__spreadProps$5(__spreadValues$5({}, this.snapshot()), { transform: S }));
		return __privateSet$4(this, _transform, S), S;
	}
	snapshot() {
		return n(() => ({
			source: this.source,
			target: this.target,
			activatorEvent: this.activatorEvent,
			transform: __privateGet$4(this, _transform),
			shape: this.shape ? snapshot(this.shape) : null,
			position: snapshot(this.position),
			status: snapshot(this.status),
			canceled: this.canceled
		}));
	}
	reset() {
		r(() => {
			this.status.set("idle"), this.sourceIdentifier = null, this.targetIdentifier = null, __privateGet$4(this, _shape2).reset(), this.position.reset({
				x: 0,
				y: 0
			}), __privateSet$4(this, _transform, {
				x: 0,
				y: 0
			}), this.modifiers = [];
		});
	}
};
_init6 = __decoratorStart$3(null), _manager2 = /* @__PURE__ */ new WeakMap(), _previousSource = /* @__PURE__ */ new WeakMap(), _shape2 = /* @__PURE__ */ new WeakMap(), _canceled = /* @__PURE__ */ new WeakMap(), _activatorEvent = /* @__PURE__ */ new WeakMap(), _sourceIdentifier = /* @__PURE__ */ new WeakMap(), _targetIdentifier = /* @__PURE__ */ new WeakMap(), _modifiers2 = /* @__PURE__ */ new WeakMap(), _transform = /* @__PURE__ */ new WeakMap(), __decorateElement$3(_init6, 2, "shape", _shape_dec2, DragOperation), __decorateElement$3(_init6, 4, "canceled", _canceled_dec, DragOperation, _canceled), __decorateElement$3(_init6, 4, "activatorEvent", _activatorEvent_dec, DragOperation, _activatorEvent), __decorateElement$3(_init6, 4, "sourceIdentifier", _sourceIdentifier_dec, DragOperation, _sourceIdentifier), __decorateElement$3(_init6, 4, "targetIdentifier", _targetIdentifier_dec, DragOperation, _targetIdentifier), __decorateElement$3(_init6, 4, "modifiers", _modifiers_dec2, DragOperation, _modifiers2), __decorateElement$3(_init6, 2, "source", _source_dec, DragOperation), __decorateElement$3(_init6, 2, "target", _target_dec, DragOperation), __decorateElement$3(_init6, 2, "transform", _transform_dec, DragOperation), __decoratorMetadata$3(_init6, DragOperation);
var defaultRenderer = { get rendering() {
	return Promise.resolve();
} }, DragDropManager$1 = class {
	constructor(m) {
		this.destroy = () => {
			this.dragOperation.status.idle || this.actions.stop({ canceled: !0 }), this.dragOperation.modifiers.forEach((m) => m.destroy()), this.registry.destroy(), this.collisionObserver.destroy();
		};
		let { plugins: x = [], sensors: S = [], modifiers: C = [], renderer: T = defaultRenderer } = m ?? {}, D = new DragDropMonitor(this);
		this.registry = new DragDropRegistry(this), this.monitor = D, this.renderer = T, this.actions = new DragActions(this), this.dragOperation = new DragOperation(this), this.collisionObserver = new CollisionObserver(this), this.plugins = [CollisionNotifier, ...x], this.modifiers = C, this.sensors = S;
		let { destroy: O } = this, k = effects(() => {
			let m = n(() => this.dragOperation.modifiers), x = this.modifiers;
			m !== x && m.forEach((m) => m.destroy()), this.dragOperation.modifiers = (this.dragOperation.source?.modifiers)?.map((m) => {
				let { plugin: x, options: S } = descriptor(m);
				return new x(this, S);
			}) ?? x;
		});
		this.destroy = () => {
			k(), O();
		};
	}
	get plugins() {
		return this.registry.plugins.values;
	}
	set plugins(m) {
		this.registry.plugins.values = m;
	}
	get modifiers() {
		return this.registry.modifiers.values;
	}
	set modifiers(m) {
		this.registry.modifiers.values = m;
	}
	get sensors() {
		return this.registry.sensors.values;
	}
	set sensors(m) {
		this.registry.sensors.values = m;
	}
}, __typeError$3 = (m) => {
	throw TypeError(m);
}, __accessCheck$3 = (m, x, S) => x.has(m) || __typeError$3("Cannot " + S), __privateGet$3 = (m, x, S) => (__accessCheck$3(m, x, "read from private field"), x.get(m)), __privateAdd$3 = (m, x, S) => x.has(m) ? __typeError$3("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet$3 = (m, x, S, C) => (__accessCheck$3(m, x, "write to private field"), x.set(m, S), S), __privateMethod$1 = (m, x, S) => (__accessCheck$3(m, x, "access private method"), S);
function isKeyframeEffect(m) {
	return m ? m instanceof KeyframeEffect ? !0 : "getKeyframes" in m && typeof m.getKeyframes == "function" : !1;
}
function getFinalKeyframe$2(m, x) {
	let S = m.getAnimations();
	if (S.length > 0) for (let m of S) {
		if (m.playState !== "running") continue;
		let { effect: S } = m, C = (isKeyframeEffect(S) ? S.getKeyframes() : []).filter(x);
		if (C.length > 0) return [C[C.length - 1], m];
	}
	return null;
}
function getBoundingRectangle(m) {
	let { width: x, height: S, top: C, left: T, bottom: D, right: O } = m.getBoundingClientRect();
	return {
		width: x,
		height: S,
		top: C,
		left: T,
		bottom: D,
		right: O
	};
}
var canUseDOM = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0;
function isWindow(m) {
	let x = Object.prototype.toString.call(m);
	return x === "[object Window]" || x === "[object global]";
}
function isNode$1(m) {
	return "nodeType" in m;
}
function getWindow$1(m) {
	return m ? isWindow(m) ? m : isNode$1(m) ? "defaultView" in m ? m.defaultView ?? window : m.ownerDocument?.defaultView ?? window : window : window;
}
function isDocument(m) {
	let { Document: x } = getWindow$1(m);
	return m instanceof x || "nodeType" in m && m.nodeType === Node.DOCUMENT_NODE;
}
function isHTMLElement$1(m) {
	return !m || isWindow(m) ? !1 : m instanceof getWindow$1(m).HTMLElement || "namespaceURI" in m && typeof m.namespaceURI == "string" && m.namespaceURI.endsWith("html");
}
function isSVGElement$1(m) {
	return m instanceof getWindow$1(m).SVGElement || "namespaceURI" in m && typeof m.namespaceURI == "string" && m.namespaceURI.endsWith("svg");
}
function getDocument$1(m) {
	return m ? isWindow(m) ? m.document : isNode$1(m) ? isDocument(m) ? m : isHTMLElement$1(m) || isSVGElement$1(m) ? m.ownerDocument : document : document : document;
}
function getViewportBoundingRectangle(m) {
	let { documentElement: x } = getDocument$1(m), S = x.clientWidth, C = x.clientHeight;
	return {
		top: 0,
		left: 0,
		right: S,
		bottom: C,
		width: S,
		height: C
	};
}
function isOverflowVisible(m, x) {
	if (isDetailsElement(m) && m.open === !1) return !1;
	let { overflow: S, overflowX: C, overflowY: T } = getComputedStyle(m);
	return S === "visible" && C === "visible" && T === "visible";
}
function isDetailsElement(m) {
	return m.tagName === "DETAILS";
}
function getVisibleBoundingRectangle(m, x = m.getBoundingClientRect(), S = 0) {
	let C = x, { ownerDocument: T } = m, D = T.defaultView ?? window, O = m.parentElement;
	for (; O && O !== T.documentElement;) {
		if (!isOverflowVisible(O)) {
			let m = O.getBoundingClientRect(), x = S * (m.bottom - m.top), T = S * (m.right - m.left), D = S * (m.bottom - m.top), k = S * (m.right - m.left);
			C = {
				top: Math.max(C.top, m.top - x),
				right: Math.min(C.right, m.right + T),
				bottom: Math.min(C.bottom, m.bottom + D),
				left: Math.max(C.left, m.left - k),
				width: 0,
				height: 0
			}, C.width = C.right - C.left, C.height = C.bottom - C.top;
		}
		O = O.parentElement;
	}
	let k = D.innerWidth, A = D.innerHeight, j = S * A, M = S * k;
	return C = {
		top: Math.max(C.top, 0 - j),
		right: Math.min(C.right, k + M),
		bottom: Math.min(C.bottom, A + j),
		left: Math.max(C.left, 0 - M),
		width: 0,
		height: 0
	}, C.width = C.right - C.left, C.height = C.bottom - C.top, C.width < 0 && (C.width = 0), C.height < 0 && (C.height = 0), C;
}
function isSafari() {
	return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function cloneElement(m) {
	let x = "input, textarea, select, canvas, [contenteditable]", S = m.cloneNode(!0), C = Array.from(m.querySelectorAll(x));
	return Array.from(S.querySelectorAll(x)).forEach((m, x) => {
		let S = C[x];
		isField(m) && isField(S) && (m.type !== "file" && (m.value = S.value), m.type === "radio" && m.name && (m.name = `Cloned__${m.name}`)), isCanvasElement(m) && isCanvasElement(S) && S.width > 0 && S.height > 0 && m.getContext("2d")?.drawImage(S, 0, 0);
	}), S;
}
function isField(m) {
	return "value" in m;
}
function isCanvasElement(m) {
	return m.tagName === "CANVAS";
}
function getElementFromPoint(m, { x, y: S }) {
	let C = m.elementFromPoint(x, S);
	if (isIFrameElement(C)) {
		let { contentDocument: m } = C;
		if (m) {
			let { left: T, top: D } = C.getBoundingClientRect();
			return getElementFromPoint(m, {
				x: x - T,
				y: S - D
			});
		}
	}
	return C;
}
function isIFrameElement(m) {
	return m?.tagName === "IFRAME";
}
var ProxiedElements = /* @__PURE__ */ new WeakMap(), Listeners = class {
	constructor() {
		this.entries = /* @__PURE__ */ new Set(), this.clear = () => {
			for (let m of this.entries) {
				let [x, { type: S, listener: C, options: T }] = m;
				x.removeEventListener(S, C, T);
			}
			this.entries.clear();
		};
	}
	bind(m, x) {
		let S = Array.isArray(x) ? x : [x], C = [];
		for (let x of S) {
			let { type: S, listener: T, options: D } = x, O = [m, x];
			m.addEventListener(S, T, D), this.entries.add(O), C.push(O);
		}
		return function() {
			for (let [m, { type: x, listener: S, options: T }] of C) m.removeEventListener(x, S, T);
		};
	}
};
function getFrameElement(m) {
	let x = m?.ownerDocument.defaultView;
	if (x && x.self !== x.parent) return x.frameElement;
}
function getFrameElements(m) {
	let x = /* @__PURE__ */ new Set(), S = getFrameElement(m);
	for (; S;) x.add(S), S = getFrameElement(S);
	return x;
}
function timeout$1(m, x) {
	let S = setTimeout(m, x);
	return () => clearTimeout(S);
}
function throttle$1(m, x) {
	let S = () => performance.now(), C, T;
	return function(...D) {
		let O = this;
		T ? (C?.(), C = timeout$1(() => {
			m.apply(O, D), T = S();
		}, x - (S() - T))) : (m.apply(O, D), T = S());
	};
}
function isRectEqual(m, x) {
	return m === x ? !0 : !m || !x ? !1 : m.top == x.top && m.left == x.left && m.right == x.right && m.bottom == x.bottom;
}
function isVisible(m, x = m.getBoundingClientRect()) {
	let { width: S, height: C } = getVisibleBoundingRectangle(m, x);
	return S > 0 && C > 0;
}
var Observer$1 = canUseDOM ? ResizeObserver : class {
	observe() {}
	unobserve() {}
	disconnect() {}
}, _initialized, ResizeNotifier = class extends Observer$1 {
	constructor(m) {
		super((x) => {
			if (!__privateGet$3(this, _initialized)) {
				__privateSet$3(this, _initialized, !0);
				return;
			}
			m(x, this);
		}), __privateAdd$3(this, _initialized, !1);
	}
};
_initialized = /* @__PURE__ */ new WeakMap();
var threshold = Array.from({ length: 100 }, (m, x) => x / 100), THROTTLE_INTERVAL = 75, _visible, _previousBoundingClientRect, _resizeObserver, _positionObserver, _visibilityObserver, _debug, _disconnected, _observePosition, _PositionObserver_instances, notify_fn, updateDebug_fn, PositionObserver = class {
	constructor(m, x, S = {
		debug: !1,
		skipInitial: !1
	}) {
		this.element = m, this.callback = x, __privateAdd$3(this, _PositionObserver_instances), this.disconnect = () => {
			var m, x, S;
			__privateSet$3(this, _disconnected, !0), (m = __privateGet$3(this, _resizeObserver)) == null || m.disconnect(), (x = __privateGet$3(this, _positionObserver)) == null || x.disconnect(), __privateGet$3(this, _visibilityObserver).disconnect(), (S = __privateGet$3(this, _debug)) == null || S.remove();
		}, __privateAdd$3(this, _visible, !0), __privateAdd$3(this, _previousBoundingClientRect), __privateAdd$3(this, _resizeObserver), __privateAdd$3(this, _positionObserver), __privateAdd$3(this, _visibilityObserver), __privateAdd$3(this, _debug), __privateAdd$3(this, _disconnected, !1), __privateAdd$3(this, _observePosition, throttle$1(() => {
			var m;
			let { element: x } = this;
			if ((m = __privateGet$3(this, _positionObserver)) == null || m.disconnect(), __privateGet$3(this, _disconnected) || !__privateGet$3(this, _visible) || !x.isConnected) return;
			let S = x.ownerDocument ?? document, { innerHeight: C, innerWidth: T } = S.defaultView ?? window, D = x.getBoundingClientRect(), { top: O, left: k, bottom: A, right: j } = getVisibleBoundingRectangle(x, D), M = -Math.floor(O), N = -Math.floor(k), P = `${M}px ${-Math.floor(T - j)}px ${-Math.floor(C - A)}px ${N}px`;
			this.boundingClientRect = D, __privateSet$3(this, _positionObserver, new IntersectionObserver((m) => {
				let [S] = m, { intersectionRect: C } = S;
				(S.intersectionRatio === 1 ? Rectangle.intersectionRatio(C, getVisibleBoundingRectangle(x)) : S.intersectionRatio) !== 1 && __privateGet$3(this, _observePosition).call(this);
			}, {
				threshold,
				rootMargin: P,
				root: S
			})), __privateGet$3(this, _positionObserver).observe(x), __privateMethod$1(this, _PositionObserver_instances, notify_fn).call(this);
		}, THROTTLE_INTERVAL)), this.boundingClientRect = m.getBoundingClientRect(), __privateSet$3(this, _visible, isVisible(m, this.boundingClientRect));
		let C = !0;
		this.callback = (m) => {
			C && (C = !1, S.skipInitial) || x(m);
		};
		let T = m.ownerDocument;
		S?.debug && (__privateSet$3(this, _debug, document.createElement("div")), __privateGet$3(this, _debug).style.background = "rgba(0,0,0,0.15)", __privateGet$3(this, _debug).style.position = "fixed", __privateGet$3(this, _debug).style.pointerEvents = "none", T.body.appendChild(__privateGet$3(this, _debug))), __privateSet$3(this, _visibilityObserver, new IntersectionObserver((x) => {
			var S, C;
			let { boundingClientRect: T, isIntersecting: D } = x[x.length - 1], { width: O, height: k } = T, A = __privateGet$3(this, _visible);
			__privateSet$3(this, _visible, D), !(!O && !k) && (A && !D ? ((S = __privateGet$3(this, _positionObserver)) == null || S.disconnect(), this.callback(null), (C = __privateGet$3(this, _resizeObserver)) == null || C.disconnect(), __privateSet$3(this, _resizeObserver, void 0), __privateGet$3(this, _debug) && (__privateGet$3(this, _debug).style.visibility = "hidden")) : __privateGet$3(this, _observePosition).call(this), D && !__privateGet$3(this, _resizeObserver) && (__privateSet$3(this, _resizeObserver, new ResizeNotifier(__privateGet$3(this, _observePosition))), __privateGet$3(this, _resizeObserver).observe(m)));
		}, {
			threshold,
			root: T
		})), __privateGet$3(this, _visible) && !S.skipInitial && this.callback(this.boundingClientRect), __privateGet$3(this, _visibilityObserver).observe(m);
	}
};
_visible = /* @__PURE__ */ new WeakMap(), _previousBoundingClientRect = /* @__PURE__ */ new WeakMap(), _resizeObserver = /* @__PURE__ */ new WeakMap(), _positionObserver = /* @__PURE__ */ new WeakMap(), _visibilityObserver = /* @__PURE__ */ new WeakMap(), _debug = /* @__PURE__ */ new WeakMap(), _disconnected = /* @__PURE__ */ new WeakMap(), _observePosition = /* @__PURE__ */ new WeakMap(), _PositionObserver_instances = /* @__PURE__ */ new WeakSet(), notify_fn = function() {
	__privateGet$3(this, _disconnected) || (__privateMethod$1(this, _PositionObserver_instances, updateDebug_fn).call(this), !isRectEqual(this.boundingClientRect, __privateGet$3(this, _previousBoundingClientRect)) && (this.callback(this.boundingClientRect), __privateSet$3(this, _previousBoundingClientRect, this.boundingClientRect)));
}, updateDebug_fn = function() {
	if (__privateGet$3(this, _debug)) {
		let { top: m, left: x, width: S, height: C } = getVisibleBoundingRectangle(this.element);
		__privateGet$3(this, _debug).style.overflow = "hidden", __privateGet$3(this, _debug).style.visibility = "visible", __privateGet$3(this, _debug).style.top = `${Math.floor(m)}px`, __privateGet$3(this, _debug).style.left = `${Math.floor(x)}px`, __privateGet$3(this, _debug).style.width = `${Math.floor(S)}px`, __privateGet$3(this, _debug).style.height = `${Math.floor(C)}px`;
	}
};
var framePositionObservers = /* @__PURE__ */ new WeakMap(), scrollListeners = /* @__PURE__ */ new WeakMap();
function addFrameListener(m, x) {
	let S = framePositionObservers.get(m);
	return S ||= {
		disconnect: new PositionObserver(m, (x) => {
			let S = framePositionObservers.get(m);
			S && S.callbacks.forEach((m) => m(x));
		}, { skipInitial: !0 }).disconnect,
		callbacks: /* @__PURE__ */ new Set()
	}, S.callbacks.add(x), framePositionObservers.set(m, S), () => {
		S.callbacks.delete(x), S.callbacks.size === 0 && (framePositionObservers.delete(m), S.disconnect());
	};
}
function observeParentFrames(m, x) {
	let S = /* @__PURE__ */ new Set();
	for (let C of m) {
		let m = addFrameListener(C, x);
		S.add(m);
	}
	return () => S.forEach((m) => m());
}
function addScrollListener(m, x) {
	let S = m.ownerDocument;
	if (!scrollListeners.has(S)) {
		let m = new AbortController(), x = /* @__PURE__ */ new Set();
		document.addEventListener("scroll", (m) => x.forEach((x) => x(m)), {
			capture: !0,
			passive: !0,
			signal: m.signal
		}), scrollListeners.set(S, {
			disconnect: () => m.abort(),
			listeners: x
		});
	}
	let { listeners: C, disconnect: T } = scrollListeners.get(S) ?? {};
	return !C || !T ? () => {} : (C.add(x), () => {
		C.delete(x), C.size === 0 && (T(), scrollListeners.delete(S));
	});
}
var _elementObserver, _disconnected2, _frames, _handleScroll, FrameObserver = class {
	constructor(m, x, S) {
		this.callback = x, __privateAdd$3(this, _elementObserver), __privateAdd$3(this, _disconnected2, !1), __privateAdd$3(this, _frames), __privateAdd$3(this, _handleScroll, throttle$1((m) => {
			if (!__privateGet$3(this, _disconnected2) && m.target && "contains" in m.target && typeof m.target.contains == "function") {
				for (let x of __privateGet$3(this, _frames)) if (m.target.contains(x)) {
					this.callback(__privateGet$3(this, _elementObserver).boundingClientRect);
					break;
				}
			}
		}, THROTTLE_INTERVAL));
		let C = getFrameElements(m), T = observeParentFrames(C, x), D = addScrollListener(m, __privateGet$3(this, _handleScroll));
		__privateSet$3(this, _frames, C), __privateSet$3(this, _elementObserver, new PositionObserver(m, x, S)), this.disconnect = () => {
			__privateGet$3(this, _disconnected2) || (__privateSet$3(this, _disconnected2, !0), T(), D(), __privateGet$3(this, _elementObserver).disconnect());
		};
	}
};
_elementObserver = /* @__PURE__ */ new WeakMap(), _disconnected2 = /* @__PURE__ */ new WeakMap(), _frames = /* @__PURE__ */ new WeakMap(), _handleScroll = /* @__PURE__ */ new WeakMap();
function supportsPopover(m) {
	return "showPopover" in m && "hidePopover" in m && typeof m.showPopover == "function" && typeof m.hidePopover == "function";
}
function showPopover(m) {
	try {
		supportsPopover(m) && m.isConnected && m.hasAttribute("popover") && !m.matches(":popover-open") && m.showPopover();
	} catch {}
}
function isDocumentScrollingElement(m) {
	return !canUseDOM || !m ? !1 : m === getDocument$1(m).scrollingElement;
}
function getScrollPosition(m) {
	let x = getWindow$1(m), S = isDocumentScrollingElement(m) ? getViewportBoundingRectangle(m) : getBoundingRectangle(m), C = isDocumentScrollingElement(m) ? {
		height: x.innerHeight,
		width: x.innerWidth
	} : {
		height: m.clientHeight,
		width: m.clientWidth
	}, T = {
		current: {
			x: m.scrollLeft,
			y: m.scrollTop
		},
		max: {
			x: m.scrollWidth - C.width,
			y: m.scrollHeight - C.height
		}
	};
	return {
		rect: S,
		position: T,
		isTop: T.current.y <= 0,
		isLeft: T.current.x <= 0,
		isBottom: T.current.y >= T.max.y,
		isRight: T.current.x >= T.max.x
	};
}
function canScroll(m, x) {
	let { isTop: S, isBottom: C, isLeft: T, isRight: D, position: O } = getScrollPosition(m), { x: k, y: A } = x ?? {
		x: 0,
		y: 0
	}, j = !S && O.current.y + A > 0, M = !C && O.current.y + A < O.max.y, N = !T && O.current.x + k > 0, P = !D && O.current.x + k < O.max.x;
	return {
		top: j,
		bottom: M,
		left: N,
		right: P,
		x: N || P,
		y: j || M
	};
}
var Scheduler$1 = class {
	constructor(m) {
		this.scheduler = m, this.pending = !1, this.tasks = /* @__PURE__ */ new Set(), this.resolvers = /* @__PURE__ */ new Set(), this.flush = () => {
			let { tasks: m, resolvers: x } = this;
			this.pending = !1, this.tasks = /* @__PURE__ */ new Set(), this.resolvers = /* @__PURE__ */ new Set();
			for (let x of m) x();
			for (let m of x) m();
		};
	}
	schedule(m) {
		return this.tasks.add(m), this.pending || (this.pending = !0, this.scheduler(this.flush)), new Promise((m) => this.resolvers.add(m));
	}
}, scheduler = new Scheduler$1((m) => {
	typeof requestAnimationFrame == "function" ? requestAnimationFrame(m) : m();
}), scheduler2 = new Scheduler$1((m) => setTimeout(m, 50)), cachedStyles = /* @__PURE__ */ new Map(), clear = cachedStyles.clear.bind(cachedStyles);
function getComputedStyles(m, x = !1) {
	if (!x) return computeStyles(m);
	let S = cachedStyles.get(m);
	return S || (S = computeStyles(m), cachedStyles.set(m, S), scheduler2.schedule(clear), S);
}
function computeStyles(m) {
	return getWindow$1(m).getComputedStyle(m);
}
function isFixed(m, x = getComputedStyles(m, !0)) {
	return x.position === "fixed" || x.position === "sticky";
}
function isScrollable(m, x = getComputedStyles(m, !0)) {
	let S = /(auto|scroll|overlay)/;
	return [
		"overflow",
		"overflowX",
		"overflowY"
	].some((m) => {
		let C = x[m];
		return typeof C == "string" ? S.test(C) : !1;
	});
}
var defaultOptions = { excludeElement: !0 };
function getScrollableAncestors(m, x = defaultOptions) {
	let { limit: S, excludeElement: C } = x, T = /* @__PURE__ */ new Set();
	function D(x) {
		if (S != null && T.size >= S || !x) return T;
		if (isDocument(x) && x.scrollingElement != null && !T.has(x.scrollingElement)) return T.add(x.scrollingElement), T;
		if (!isHTMLElement$1(x)) return isSVGElement$1(x) ? D(x.parentElement) : T;
		if (T.has(x)) return T;
		let O = getComputedStyles(x, !0);
		if (C && x === m || isScrollable(x, O) && T.add(x), isFixed(x, O)) {
			let { scrollingElement: m } = x.ownerDocument;
			return m && T.add(m), T;
		}
		return D(x.parentNode);
	}
	return m ? D(m) : T;
}
function getFirstScrollableAncestor(m) {
	let [x] = getScrollableAncestors(m, { limit: 1 });
	return x ?? null;
}
function getFrameTransform(m, x = window.frameElement) {
	let S = {
		x: 0,
		y: 0,
		scaleX: 1,
		scaleY: 1
	};
	if (!m) return S;
	let C = getFrameElement(m);
	for (; C;) {
		if (C === x) return S;
		let m = getBoundingRectangle(C), { x: T, y: D } = getScale(C, m);
		S.x += m.left, S.y += m.top, S.scaleX *= T, S.scaleY *= D, C = getFrameElement(C);
	}
	return S;
}
function getScale(m, x = getBoundingRectangle(m)) {
	let S = Math.round(x.width), C = Math.round(x.height);
	if (isHTMLElement$1(m)) return {
		x: S / m.offsetWidth,
		y: C / m.offsetHeight
	};
	let T = getComputedStyles(m, !0);
	return {
		x: (parseFloat(T.width) || S) / S,
		y: (parseFloat(T.height) || C) / C
	};
}
function parseScale(m) {
	if (m === "none") return null;
	let x = m.split(" "), S = parseFloat(x[0]), C = parseFloat(x[1]);
	return isNaN(S) && isNaN(C) ? null : {
		x: isNaN(S) ? C : S,
		y: isNaN(C) ? S : C
	};
}
function parseTranslate(m) {
	if (m === "none") return null;
	let [x, S, C = "0"] = m.split(" "), T = {
		x: parseFloat(x),
		y: parseFloat(S),
		z: parseInt(C, 10)
	};
	return isNaN(T.x) && isNaN(T.y) ? null : {
		x: isNaN(T.x) ? 0 : T.x,
		y: isNaN(T.y) ? 0 : T.y,
		z: isNaN(T.z) ? 0 : T.z
	};
}
function parseTransform(m) {
	let { scale: x, transform: S, translate: C } = m, T = parseScale(x), D = parseTranslate(C), O = parseTransformMatrix(S);
	if (!O && !T && !D) return null;
	let k = {
		x: T?.x ?? 1,
		y: T?.y ?? 1
	}, A = {
		x: D?.x ?? 0,
		y: D?.y ?? 0
	}, j = {
		x: O?.x ?? 0,
		y: O?.y ?? 0,
		scaleX: O?.scaleX ?? 1,
		scaleY: O?.scaleY ?? 1
	};
	return {
		x: A.x + j.x,
		y: A.y + j.y,
		z: D?.z ?? 0,
		scaleX: k.x * j.scaleX,
		scaleY: k.y * j.scaleY
	};
}
function parseTransformMatrix(m) {
	if (m.startsWith("matrix3d(")) {
		let x = m.slice(9, -1).split(/, /);
		return {
			x: +x[12],
			y: +x[13],
			scaleX: +x[0],
			scaleY: +x[5]
		};
	} else if (m.startsWith("matrix(")) {
		let x = m.slice(7, -1).split(/, /);
		return {
			x: +x[4],
			y: +x[5],
			scaleX: +x[0],
			scaleY: +x[3]
		};
	}
	return null;
}
var ScrollDirection = /* @__PURE__ */ ((m) => (m[m.Idle = 0] = "Idle", m[m.Forward = 1] = "Forward", m[m.Reverse = -1] = "Reverse", m))(ScrollDirection || {}), defaultThreshold = {
	x: .2,
	y: .2
}, defaultTolerance = {
	x: 10,
	y: 10
};
function detectScrollIntent(m, x, S, C = 25, T = defaultThreshold, D = defaultTolerance) {
	let { x: O, y: k } = x, { rect: A, isTop: j, isBottom: M, isLeft: N, isRight: P } = getScrollPosition(m), F = getFrameTransform(m), I = parseTransform(getComputedStyles(m, !0)), L = I === null ? !1 : I?.scaleX < 0, R = I === null ? !1 : I?.scaleY < 0, z = new Rectangle(A.left * F.scaleX + F.x, A.top * F.scaleY + F.y, A.width * F.scaleX, A.height * F.scaleY), B = {
		x: 0,
		y: 0
	}, H = {
		x: 0,
		y: 0
	}, U = {
		height: z.height * T.y,
		width: z.width * T.x
	};
	return (!j || R && !M) && k <= z.top + U.height && S?.y !== 1 && O >= z.left - D.x && O <= z.right + D.x ? (B.y = R ? 1 : -1, H.y = C * Math.abs((z.top + U.height - k) / U.height)) : (!M || R && !j) && k >= z.bottom - U.height && S?.y !== -1 && O >= z.left - D.x && O <= z.right + D.x && (B.y = R ? -1 : 1, H.y = C * Math.abs((z.bottom - U.height - k) / U.height)), (!P || L && !N) && O >= z.right - U.width && S?.x !== -1 && k >= z.top - D.y && k <= z.bottom + D.y ? (B.x = L ? -1 : 1, H.x = C * Math.abs((z.right - U.width - O) / U.width)) : (!N || L && !P) && O <= z.left + U.width && S?.x !== 1 && k >= z.top - D.y && k <= z.bottom + D.y && (B.x = L ? 1 : -1, H.x = C * Math.abs((z.left + U.width - O) / U.width)), {
		direction: B,
		speed: H
	};
}
function supportsScrollIntoViewIfNeeded(m) {
	return "scrollIntoViewIfNeeded" in m && typeof m.scrollIntoViewIfNeeded == "function";
}
function scrollIntoViewIfNeeded(m, x = !1) {
	if (supportsScrollIntoViewIfNeeded(m)) {
		m.scrollIntoViewIfNeeded(x);
		return;
	}
	if (!isHTMLElement$1(m)) return m.scrollIntoView();
	var S = getFirstScrollableAncestor(m);
	if (!isHTMLElement$1(S)) return;
	let C = getComputedStyles(S, !0), T = parseInt(C.getPropertyValue("border-top-width")), D = parseInt(C.getPropertyValue("border-left-width")), O = m.offsetTop - S.offsetTop < S.scrollTop, k = m.offsetTop - S.offsetTop + m.clientHeight - T > S.scrollTop + S.clientHeight, A = m.offsetLeft - S.offsetLeft < S.scrollLeft, j = m.offsetLeft - S.offsetLeft + m.clientWidth - D > S.scrollLeft + S.clientWidth, M = O && !k;
	(O || k) && x && (S.scrollTop = m.offsetTop - S.offsetTop - S.clientHeight / 2 - T + m.clientHeight / 2), (A || j) && x && (S.scrollLeft = m.offsetLeft - S.offsetLeft - S.clientWidth / 2 - D + m.clientWidth / 2), (O || k || A || j) && !x && m.scrollIntoView(M);
}
function applyTransform(m, x, S) {
	let { scaleX: C, scaleY: T, x: D, y: O } = x, k = m.left + D + (1 - C) * parseFloat(S), A = m.top + O + (1 - T) * parseFloat(S.slice(S.indexOf(" ") + 1)), j = C ? m.width * C : m.width, M = T ? m.height * T : m.height;
	return {
		width: j,
		height: M,
		top: A,
		right: k + j,
		bottom: A + M,
		left: k
	};
}
function inverseTransform(m, x, S) {
	let { scaleX: C, scaleY: T, x: D, y: O } = x, k = m.left - D - (1 - C) * parseFloat(S), A = m.top - O - (1 - T) * parseFloat(S.slice(S.indexOf(" ") + 1)), j = C ? m.width / C : m.width, M = T ? m.height / T : m.height;
	return {
		width: j,
		height: M,
		top: A,
		right: k + j,
		bottom: A + M,
		left: k
	};
}
function animateTransform({ element: m, keyframes: x, options: S }) {
	return m.animate(x, S).finished;
}
function computeTranslate(m, x = getComputedStyles(m).translate, S = !0) {
	if (S) {
		let x = getFinalKeyframe$2(m, (m) => "translate" in m);
		if (x) {
			let { translate: m = "" } = x[0];
			if (typeof m == "string") {
				let x = parseTranslate(m);
				if (x) return x;
			}
		}
	}
	if (x) {
		let m = parseTranslate(x);
		if (m) return m;
	}
	return {
		x: 0,
		y: 0,
		z: 0
	};
}
var scheduler3$1 = new Scheduler$1((m) => setTimeout(m, 0)), animations$1 = /* @__PURE__ */ new Map(), clear2 = animations$1.clear.bind(animations$1);
function getDocumentAnimations(m) {
	let x = m.ownerDocument, S = animations$1.get(x);
	if (S) return S;
	S = x.getAnimations(), animations$1.set(x, S), scheduler3$1.schedule(clear2);
	let C = S.filter((x) => isKeyframeEffect(x.effect) && x.effect.target === m);
	return animations$1.set(m, C), S;
}
function forceFinishAnimations(m, x) {
	let S = getDocumentAnimations(m).filter((m) => {
		if (isKeyframeEffect(m.effect)) {
			let { target: S } = m.effect;
			if ((S && x.isValidTarget?.call(x, S)) ?? !0) return m.effect.getKeyframes().some((m) => {
				for (let S of x.properties) if (m[S]) return !0;
			});
		}
	}).map((m) => {
		let { effect: x, currentTime: S } = m, C = x?.getComputedTiming().duration;
		if (!(m.pending || m.playState === "finished") && typeof C == "number" && typeof S == "number" && S < C) return m.currentTime = C, () => {
			m.currentTime = S;
		};
	});
	if (S.length > 0) return () => S.forEach((m) => m?.());
}
var DOMRectangle = class extends Rectangle {
	constructor(m, x = {}) {
		let { frameTransform: S = getFrameTransform(m), ignoreTransforms: C, getBoundingClientRect: T = getBoundingRectangle } = x, D = forceFinishAnimations(m, {
			properties: [
				"transform",
				"translate",
				"scale",
				"width",
				"height"
			],
			isValidTarget: (x) => (x !== m || isSafari()) && x.contains(m)
		}), O = T(m), { top: k, left: A, width: j, height: M } = O, N, P = getComputedStyles(m), F = parseTransform(P), I = {
			x: F?.scaleX ?? 1,
			y: F?.scaleY ?? 1
		}, L = getProjectedTransform(m, P);
		D?.(), F && (N = inverseTransform(O, F, P.transformOrigin), (C || L) && (k = N.top, A = N.left, j = N.width, M = N.height));
		let R = {
			width: N?.width ?? j,
			height: N?.height ?? M
		};
		if (L && !C && N) {
			let m = applyTransform(N, L, P.transformOrigin);
			k = m.top, A = m.left, j = m.width, M = m.height, I.x = L.scaleX, I.y = L.scaleY;
		}
		S && (C || (A *= S.scaleX, j *= S.scaleX, k *= S.scaleY, M *= S.scaleY), A += S.x, k += S.y), super(A, k, j, M), this.scale = I, this.intrinsicWidth = R.width, this.intrinsicHeight = R.height;
	}
};
function getProjectedTransform(m, x) {
	let S = m.getAnimations(), C = null;
	if (!S.length) return null;
	for (let m of S) {
		if (m.playState !== "running") continue;
		let S = isKeyframeEffect(m.effect) ? m.effect.getKeyframes() : [], T = S[S.length - 1];
		if (!T) continue;
		let { transform: D, translate: O, scale: k } = T;
		if (D || O || k) {
			let m = parseTransform({
				transform: typeof D == "string" && D ? D : x.transform,
				translate: typeof O == "string" && O ? O : x.translate,
				scale: typeof k == "string" && k ? k : x.scale
			});
			m && (C = C ? {
				x: C.x + m.x,
				y: C.y + m.y,
				z: C.z ?? m.z,
				scaleX: C.scaleX * m.scaleX,
				scaleY: C.scaleY * m.scaleY
			} : m);
		}
	}
	return C;
}
function supportsStyle(m) {
	return "style" in m && typeof m.style == "object" && m.style !== null && "setProperty" in m.style && "removeProperty" in m.style && typeof m.style.setProperty == "function" && typeof m.style.removeProperty == "function";
}
var Styles = class {
	constructor(m) {
		this.element = m, this.initial = /* @__PURE__ */ new Map();
	}
	set(m, x = "") {
		let { element: S } = this;
		if (supportsStyle(S)) for (let [C, T] of Object.entries(m)) {
			let m = `${x}${C}`;
			this.initial.has(m) || this.initial.set(m, S.style.getPropertyValue(m)), S.style.setProperty(m, typeof T == "string" ? T : `${T}px`);
		}
	}
	remove(m, x = "") {
		let { element: S } = this;
		if (supportsStyle(S)) for (let C of m) {
			let m = `${x}${C}`;
			S.style.removeProperty(m);
		}
	}
	reset() {
		let { element: m } = this;
		if (supportsStyle(m)) {
			for (let [x, S] of this.initial) m.style.setProperty(x, S);
			m.getAttribute("style") === "" && m.removeAttribute("style");
		}
	}
};
function isElement(m) {
	return m ? m instanceof getWindow$1(m).Element || isNode$1(m) && m.nodeType === Node.ELEMENT_NODE : !1;
}
function isKeyboardEvent(m) {
	if (!m) return !1;
	let { KeyboardEvent: x } = getWindow$1(m.target);
	return m instanceof x;
}
function isPointerEvent(m) {
	if (!m) return !1;
	let { PointerEvent: x } = getWindow$1(m.target);
	return m instanceof x;
}
function isTextInput(m) {
	if (!isElement(m)) return !1;
	let { tagName: x } = m;
	return x === "INPUT" || x === "TEXTAREA" || isContentEditable(m);
}
function isContentEditable(m) {
	return m.hasAttribute("contenteditable") && m.getAttribute("contenteditable") !== "false";
}
var ids = {};
function generateUniqueId(m) {
	let x = ids[m] == null ? 0 : ids[m] + 1;
	return ids[m] = x, `${m}-${x}`;
}
var pointerIntersection$2 = ({ dragOperation: m, droppable: x }) => {
	let S = m.position.current;
	if (!S) return null;
	let { id: C } = x;
	return x.shape && x.shape.containsPoint(S) ? {
		id: C,
		value: 1 / Point.distance(x.shape.center, S),
		type: CollisionType.PointerIntersection,
		priority: CollisionPriority.High
	} : null;
}, shapeIntersection$1 = ({ dragOperation: m, droppable: x }) => {
	let { shape: S } = m;
	if (!x.shape || !S?.current) return null;
	let C = S.current.intersectionArea(x.shape);
	if (C) {
		let { position: T } = m, D = Point.distance(x.shape.center, T.current), O = C / (S.current.area + x.shape.area - C) / D;
		return {
			id: x.id,
			value: O,
			type: CollisionType.ShapeIntersection,
			priority: CollisionPriority.Normal
		};
	}
	return null;
}, defaultCollisionDetection = (m) => pointerIntersection$2(m) ?? shapeIntersection$1(m), closestCorners$1 = (m) => {
	let { dragOperation: x, droppable: S } = m, { shape: C, position: T } = x;
	if (!S.shape) return null;
	let D = C ? Rectangle.from(C.current.boundingRectangle).corners : void 0, O = Rectangle.from(S.shape.boundingRectangle).corners.reduce((m, x, S) => m + Point.distance(Point.from(x), D?.[S] ?? T.current), 0) / 4;
	return {
		id: S.id,
		value: 1 / O,
		type: CollisionType.Collision,
		priority: CollisionPriority.Normal
	};
}, __create$2 = Object.create, __defProp$3 = Object.defineProperty, __defProps$3 = Object.defineProperties, __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor, __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$3 = Object.getOwnPropertySymbols, __hasOwnProp$3 = Object.prototype.hasOwnProperty, __propIsEnum$3 = Object.prototype.propertyIsEnumerable, __knownSymbol$2 = (m, x) => (x = Symbol[m]) ? x : Symbol.for("Symbol." + m), __typeError$2 = (m) => {
	throw TypeError(m);
}, __defNormalProp$3 = (m, x, S) => x in m ? __defProp$3(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$4 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$3.call(x, S) && __defNormalProp$3(m, S, x[S]);
	if (__getOwnPropSymbols$3) for (var S of __getOwnPropSymbols$3(x)) __propIsEnum$3.call(x, S) && __defNormalProp$3(m, S, x[S]);
	return m;
}, __spreadProps$4 = (m, x) => __defProps$3(m, __getOwnPropDescs$3(x)), __name = (m, x) => __defProp$3(m, "name", {
	value: x,
	configurable: !0
}), __objRest$3 = (m, x) => {
	var S = {};
	for (var C in m) __hasOwnProp$3.call(m, C) && x.indexOf(C) < 0 && (S[C] = m[C]);
	if (m != null && __getOwnPropSymbols$3) for (var C of __getOwnPropSymbols$3(m)) x.indexOf(C) < 0 && __propIsEnum$3.call(m, C) && (S[C] = m[C]);
	return S;
}, __decoratorStart$2 = (m) => [
	,
	,
	,
	__create$2(m?.[__knownSymbol$2("metadata")] ?? null)
], __decoratorStrings$2 = [
	"class",
	"method",
	"getter",
	"setter",
	"accessor",
	"field",
	"value",
	"get",
	"set"
], __expectFn$2 = (m) => m !== void 0 && typeof m != "function" ? __typeError$2("Function expected") : m, __decoratorContext$2 = (m, x, S, C, T) => ({
	kind: __decoratorStrings$2[m],
	name: x,
	metadata: C,
	addInitializer: (m) => S._ ? __typeError$2("Already initialized") : T.push(__expectFn$2(m || null))
}), __decoratorMetadata$2 = (m, x) => __defNormalProp$3(x, __knownSymbol$2("metadata"), m[3]), __runInitializers$2 = (m, x, S, C) => {
	for (var T = 0, D = m[x >> 1], O = D && D.length; T < O; T++) x & 1 ? D[T].call(S) : C = D[T].call(S, C);
	return C;
}, __decorateElement$2 = (m, x, S, C, T, D) => {
	var O, k, A, j, M, N = x & 7, P = !!(x & 8), F = !!(x & 16), I = N > 3 ? m.length + 1 : N ? P ? 1 : 2 : 0, L = __decoratorStrings$2[N + 5], R = N > 3 && (m[I - 1] = []), z = m[I] || (m[I] = []), B = N && (!F && !P && (T = T.prototype), N < 5 && (N > 3 || !F) && __getOwnPropDesc$2(N < 4 ? T : {
		get [S]() {
			return __privateGet$2(this, D);
		},
		set [S](m) {
			return __privateSet$2(this, D, m);
		}
	}, S));
	N ? F && N < 4 && __name(D, (N > 2 ? "set " : N > 1 ? "get " : "") + S) : __name(T, S);
	for (var H = C.length - 1; H >= 0; H--) j = __decoratorContext$2(N, S, A = {}, m[3], z), N && (j.static = P, j.private = F, M = j.access = { has: F ? (m) => __privateIn(T, m) : (m) => S in m }, N ^ 3 && (M.get = F ? (m) => (N ^ 1 ? __privateGet$2 : __privateMethod)(m, T, N ^ 4 ? D : B.get) : (m) => m[S]), N > 2 && (M.set = F ? (m, x) => __privateSet$2(m, T, x, N ^ 4 ? D : B.set) : (m, x) => m[S] = x)), k = (0, C[H])(N ? N < 4 ? F ? D : B[L] : N > 4 ? void 0 : {
		get: B.get,
		set: B.set
	} : T, j), A._ = 1, N ^ 4 || k === void 0 ? __expectFn$2(k) && (N > 4 ? R.unshift(k) : N ? F ? D = k : B[L] = k : T = k) : typeof k != "object" || !k ? __typeError$2("Object expected") : (__expectFn$2(O = k.get) && (B.get = O), __expectFn$2(O = k.set) && (B.set = O), __expectFn$2(O = k.init) && R.unshift(O));
	return N || __decoratorMetadata$2(m, T), B && __defProp$3(T, S, B), F ? N ^ 4 ? D : B : T;
}, __accessCheck$2 = (m, x, S) => x.has(m) || __typeError$2("Cannot " + S), __privateIn = (m, x) => Object(x) === x ? m.has(x) : __typeError$2("Cannot use the \"in\" operator on this value"), __privateGet$2 = (m, x, S) => (__accessCheck$2(m, x, "read from private field"), S ? S.call(m) : x.get(m)), __privateAdd$2 = (m, x, S) => x.has(m) ? __typeError$2("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet$2 = (m, x, S, C) => (__accessCheck$2(m, x, "write to private field"), C ? C.call(m, S) : x.set(m, S), S), __privateMethod = (m, x, S) => (__accessCheck$2(m, x, "access private method"), S), defaultAttributes$1 = {
	role: "button",
	roleDescription: "draggable"
}, defaultDescriptionIdPrefix = "dnd-kit-description", defaultAnnouncementIdPrefix = "dnd-kit-announcement", defaultScreenReaderInstructions = { draggable: "To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item in a given direction. Press space again to drop the item in its new position, or press escape to cancel." }, defaultAnnouncements = {
	dragstart({ operation: { source: m } }) {
		if (m) return `Picked up draggable item ${m.id}.`;
	},
	dragover({ operation: { source: m, target: x } }) {
		if (!(!m || m.id === x?.id)) return x ? `Draggable item ${m.id} was moved over droppable target ${x.id}.` : `Draggable item ${m.id} is no longer over a droppable target.`;
	},
	dragend({ operation: { source: m, target: x }, canceled: S }) {
		if (m) return S ? `Dragging was cancelled. Draggable item ${m.id} was dropped.` : x ? `Draggable item ${m.id} was dropped over droppable target ${x.id}` : `Draggable item ${m.id} was dropped.`;
	}
};
function isFocusable(m) {
	let x = m.tagName.toLowerCase();
	return [
		"input",
		"select",
		"textarea",
		"a",
		"button"
	].includes(x);
}
function createHiddenText(m, x) {
	let S = document.createElement("div");
	return S.id = m, S.style.setProperty("display", "none"), S.textContent = x, S;
}
function createLiveRegion(m) {
	let x = document.createElement("div");
	return x.id = m, x.setAttribute("role", "status"), x.setAttribute("aria-live", "polite"), x.setAttribute("aria-atomic", "true"), x.style.setProperty("position", "fixed"), x.style.setProperty("width", "1px"), x.style.setProperty("height", "1px"), x.style.setProperty("margin", "-1px"), x.style.setProperty("border", "0"), x.style.setProperty("padding", "0"), x.style.setProperty("overflow", "hidden"), x.style.setProperty("clip", "rect(0 0 0 0)"), x.style.setProperty("clip-path", "inset(100%)"), x.style.setProperty("white-space", "nowrap"), x;
}
var debouncedEvents = ["dragover", "dragmove"], Accessibility = class extends Plugin {
	constructor(m, x) {
		super(m);
		let { id: S, idPrefix: { description: C = defaultDescriptionIdPrefix, announcement: T = defaultAnnouncementIdPrefix } = {}, announcements: D = defaultAnnouncements, screenReaderInstructions: O = defaultScreenReaderInstructions, debounce: k = 500 } = x ?? {}, A = S ? `${C}-${S}` : generateUniqueId(C), j = S ? `${T}-${S}` : generateUniqueId(T), M, N, P, F, I = (m = F) => {
			!P || !m || P?.nodeValue !== m && (P.nodeValue = m);
		}, L = () => scheduler.schedule(I), R = debounce$1(L, k), z = Object.entries(D).map(([m, x]) => this.manager.monitor.addEventListener(m, (S, C) => {
			let T = P;
			if (!T) return;
			let D = x?.(S, C);
			D && T.nodeValue !== D && (F = D, debouncedEvents.includes(m) ? R() : (L(), R.cancel()));
		})), B = () => {
			let m = [];
			M?.isConnected || (M = createHiddenText(A, O.draggable), m.push(M)), N?.isConnected || (N = createLiveRegion(j), P = document.createTextNode(""), N.appendChild(P), m.push(N)), m.length > 0 && document.body.append(...m);
		}, H = /* @__PURE__ */ new Set();
		function U() {
			for (let m of H) m();
		}
		this.registerEffect(() => {
			H.clear();
			for (let m of this.manager.registry.draggables.value) {
				let x = m.handle ?? m.element;
				if (x) {
					(!M || !N) && H.add(B), (!isFocusable(x) || isSafari()) && !x.hasAttribute("tabindex") && H.add(() => x.setAttribute("tabindex", "0")), !x.hasAttribute("role") && x.tagName.toLowerCase() !== "button" && H.add(() => x.setAttribute("role", defaultAttributes$1.role)), x.hasAttribute("aria-roledescription") || H.add(() => x.setAttribute("aria-roledescription", defaultAttributes$1.roleDescription)), x.hasAttribute("aria-describedby") || H.add(() => x.setAttribute("aria-describedby", A));
					for (let S of ["aria-pressed", "aria-grabbed"]) {
						let C = String(m.isDragging);
						x.getAttribute(S) !== C && H.add(() => x.setAttribute(S, C));
					}
					let S = String(m.disabled);
					x.getAttribute("aria-disabled") !== S && H.add(() => x.setAttribute("aria-disabled", S));
				}
			}
			H.size > 0 && scheduler.schedule(U);
		}), this.destroy = () => {
			super.destroy(), M?.remove(), N?.remove(), z.forEach((m) => m());
		};
	}
};
function debounce$1(m, x) {
	let S, C = () => {
		clearTimeout(S), S = setTimeout(m, x);
	};
	return C.cancel = () => clearTimeout(S), C;
}
var Cursor = class extends Plugin {
	constructor(m, x) {
		super(m, x), this.manager = m;
		let S = computed(() => getDocument$1(this.manager.dragOperation.source?.element));
		this.destroy = E(() => {
			let { dragOperation: m } = this.manager, { cursor: x = "grabbing", nonce: C } = this.options ?? {};
			if (m.status.initialized) {
				let m = S.value, T = m.createElement("style");
				return C && T.setAttribute("nonce", C), T.textContent = `* { cursor: ${x} !important; }`, m.head.appendChild(T), () => T.remove();
			}
		});
	}
}, ATTR_PREFIX = "data-dnd-", DROPPING_ATTRIBUTE = `${ATTR_PREFIX}dropping`, CSS_PREFIX = "--dnd-", ATTRIBUTE = `${ATTR_PREFIX}dragging`, PLACEHOLDER_ATTRIBUTE = `${ATTR_PREFIX}placeholder`, IGNORED_ATTRIBUTES = [
	ATTRIBUTE,
	PLACEHOLDER_ATTRIBUTE,
	"popover",
	"aria-pressed",
	"aria-grabbing"
], IGNORED_STYLES = ["view-transition-name"], CSS_RULES = `
  :root [${ATTRIBUTE}] {
    position: fixed !important;
    pointer-events: none !important;
    touch-action: none;
    z-index: calc(infinity);
    will-change: translate;
    top: var(${CSS_PREFIX}top, 0px) !important;
    left: var(${CSS_PREFIX}left, 0px) !important;
    right: unset !important;
    bottom: unset !important;
    width: var(${CSS_PREFIX}width, auto);
    max-width: var(${CSS_PREFIX}width, auto);
    height: var(${CSS_PREFIX}height, auto);
    max-height: var(${CSS_PREFIX}height, auto);
    transition: var(${CSS_PREFIX}transition) !important;
  }

  :root [${PLACEHOLDER_ATTRIBUTE}] {
    transition: none;
  }

  :root [${PLACEHOLDER_ATTRIBUTE}='hidden'] {
    visibility: hidden;
  }

  [${ATTRIBUTE}] * {
    pointer-events: none !important;
  }

  [${ATTRIBUTE}]:not([${DROPPING_ATTRIBUTE}]) {
    translate: var(${CSS_PREFIX}translate) !important;
  }

  [${ATTRIBUTE}][style*='${CSS_PREFIX}scale'] {
    scale: var(${CSS_PREFIX}scale) !important;
    transform-origin: var(${CSS_PREFIX}transform-origin) !important;
  }

  @layer {
    :where([${ATTRIBUTE}][popover]) {
      overflow: visible;
      background: unset;
      border: unset;
      margin: unset;
      padding: unset;
      color: inherit;

      &:is(input, button) {
        border: revert;
        background: revert;
      }
    }
  }
  [${ATTRIBUTE}]::backdrop, [${ATTR_PREFIX}overlay]:not([${ATTRIBUTE}]) {
    display: none;
    visibility: hidden;
  }
`.replace(/\n+/g, " ").replace(/\s+/g, " ").trim();
function createPlaceholder(m, x = "hidden") {
	return n(() => {
		let { element: S, manager: C } = m;
		if (!S || !C) return;
		let T = findContainedDroppables(S, C.registry.droppables), D = [], O = cloneElement(S), { remove: k } = O;
		return proxyDroppableElements(T, O, D), configurePlaceholder(O, x), O.remove = () => {
			D.forEach((m) => m()), k.call(O);
		}, O;
	});
}
function findContainedDroppables(m, x) {
	let S = /* @__PURE__ */ new Map();
	for (let C of x) if (C.element && (m === C.element || m.contains(C.element))) {
		let m = `${ATTR_PREFIX}${generateUniqueId("dom-id")}`;
		C.element.setAttribute(m, ""), S.set(C, m);
	}
	return S;
}
function proxyDroppableElements(m, x, S) {
	for (let [C, T] of m) {
		if (!C.element) continue;
		let m = `[${T}]`, D = x.matches(m) ? x : x.querySelector(m);
		if (C.element.removeAttribute(T), !D) continue;
		let O = C.element;
		C.proxy = D, D.removeAttribute(T), ProxiedElements.set(O, D), S.push(() => {
			ProxiedElements.delete(O), C.proxy = void 0;
		});
	}
}
function configurePlaceholder(m, x = "hidden") {
	m.setAttribute("inert", "true"), m.setAttribute("tab-index", "-1"), m.setAttribute("aria-hidden", "true"), m.setAttribute(PLACEHOLDER_ATTRIBUTE, x);
}
function isSameFrame(m, x) {
	return m === x ? !0 : getFrameElement(m) === getFrameElement(x);
}
function preventPopoverClose(m) {
	let { target: x } = m;
	"newState" in m && m.newState === "closed" && isElement(x) && x.hasAttribute("popover") && requestAnimationFrame(() => showPopover(x));
}
function isTableRow(m) {
	return m.tagName === "TR";
}
var styleSheetRegistry = /* @__PURE__ */ new Map(), _overlay_dec, _a$1, _init$2, _overlay, _Feedback_instances, render_fn, injectStyles_fn, _Feedback = class extends (_a$1 = Plugin, _overlay_dec = [reactive], _a$1) {
	constructor(m, x) {
		super(m, x), __privateAdd$2(this, _Feedback_instances), __privateAdd$2(this, _overlay, __runInitializers$2(_init$2, 8, this)), __runInitializers$2(_init$2, 11, this), this.state = {
			initial: {},
			current: {}
		}, this.registerEffect(__privateMethod(this, _Feedback_instances, injectStyles_fn)), this.registerEffect(__privateMethod(this, _Feedback_instances, render_fn));
	}
	destroy() {
		super.destroy();
		for (let [m, x] of styleSheetRegistry.entries()) x.instances.has(this) && (x.instances.delete(this), x.instances.size === 0 && (x.cleanup(), styleSheetRegistry.delete(m)));
	}
};
_init$2 = __decoratorStart$2(_a$1), _overlay = /* @__PURE__ */ new WeakMap(), _Feedback_instances = /* @__PURE__ */ new WeakSet(), render_fn = function() {
	let { state: m, manager: x, options: S } = this, { dragOperation: C } = x, { position: T, source: D, status: O } = C;
	if (O.idle) {
		m.current = {}, m.initial = {};
		return;
	}
	if (!D) return;
	let { element: k, feedback: A } = D;
	if (!k || A === "none" || !O.initialized || O.initializing) return;
	let { initial: j } = m, M = this.overlay ?? k, N = getFrameTransform(M), P = getFrameTransform(k), F = !isSameFrame(k, M), I = new DOMRectangle(k, {
		frameTransform: F ? P : null,
		ignoreTransforms: !F
	}), L = {
		x: P.scaleX / N.scaleX,
		y: P.scaleY / N.scaleY
	}, { width: R, height: z, top: B, left: H } = I;
	F && (R /= L.x, z /= L.y);
	let U, W, G = new Styles(M), { transition: K, translate: q, boxSizing: J, paddingBlockStart: Y, paddingBlockEnd: X, paddingInlineStart: Z, paddingInlineEnd: sH, borderInlineStartWidth: Q, borderInlineEndWidth: cH, borderBlockStartWidth: lH, borderBlockEndWidth: uH } = getComputedStyles(k), dH = A === "clone", fH = J === "content-box", pH = fH ? parseInt(Z) + parseInt(sH) + parseInt(Q) + parseInt(cH) : 0, mH = fH ? parseInt(Y) + parseInt(X) + parseInt(lH) + parseInt(uH) : 0, hH = A !== "move" && !this.overlay ? createPlaceholder(D, dH ? "clone" : "hidden") : null, gH = n(() => isKeyboardEvent(x.dragOperation.activatorEvent));
	if (q !== "none") {
		let m = parseTranslate(q);
		m && !j.translate && (j.translate = m);
	}
	if (!j.transformOrigin) {
		let m = n(() => T.current);
		j.transformOrigin = {
			x: (m.x - H * N.scaleX - N.x) / (R * N.scaleX),
			y: (m.y - B * N.scaleY - N.y) / (z * N.scaleY)
		};
	}
	let { transformOrigin: $ } = j, _H = B * N.scaleY + N.y, vH = H * N.scaleX + N.x;
	if (!j.coordinates && (j.coordinates = {
		x: vH,
		y: _H
	}, L.x !== 1 || L.y !== 1)) {
		let { scaleX: m, scaleY: x } = P, { x: S, y: C } = $;
		j.coordinates.x += (R * m - R) * S, j.coordinates.y += (z * x - z) * C;
	}
	j.dimensions ||= {
		width: R,
		height: z
	}, j.frameTransform ||= N;
	let yH = {
		x: j.coordinates.x - vH,
		y: j.coordinates.y - _H
	}, bH = {
		width: (j.dimensions.width * j.frameTransform.scaleX - R * N.scaleX) * $.x,
		height: (j.dimensions.height * j.frameTransform.scaleY - z * N.scaleY) * $.y
	}, xH = {
		x: yH.x / N.scaleX + bH.width,
		y: yH.y / N.scaleY + bH.height
	}, SH = {
		left: H + xH.x,
		top: B + xH.y
	};
	M.setAttribute(ATTRIBUTE, "true");
	let CH = n(() => C.transform), wH = j.translate ?? {
		x: 0,
		y: 0
	}, TH = `${CH.x * N.scaleX + wH.x}px ${CH.y * N.scaleY + wH.y}px 0`, EH = K ? `${K}, translate 0ms linear` : "";
	G.set({
		width: R - pH,
		height: z - mH,
		top: SH.top,
		left: SH.left,
		translate: TH,
		transition: EH,
		scale: F ? `${L.x} ${L.y}` : "",
		"transform-origin": `${$.x * 100}% ${$.y * 100}%`
	}, CSS_PREFIX), hH && (k.insertAdjacentElement("afterend", hH), S?.rootElement && (typeof S.rootElement == "function" ? S.rootElement(D) : S.rootElement).appendChild(k)), supportsPopover(M) && (M.hasAttribute("popover") || M.setAttribute("popover", "manual"), showPopover(M), M.addEventListener("beforetoggle", preventPopoverClose));
	let DH = new ResizeObserver(() => {
		if (!hH) return;
		let m = new DOMRectangle(hH, {
			frameTransform: N,
			ignoreTransforms: !0
		}), x = $ ?? {
			x: 1,
			y: 1
		}, S = (R - m.width) * x.x + xH.x, T = (z - m.height) * x.y + xH.y;
		if (G.set({
			width: m.width - pH,
			height: m.height - mH,
			top: B + T,
			left: H + S
		}, CSS_PREFIX), U?.takeRecords(), isTableRow(k) && isTableRow(hH)) {
			let m = Array.from(k.cells), x = Array.from(hH.cells);
			for (let [S, C] of m.entries()) {
				let m = x[S];
				C.style.width = `${m.offsetWidth}px`;
			}
		}
		C.shape = new DOMRectangle(M);
	}), OH = new DOMRectangle(M);
	n(() => C.shape = OH);
	let kH = getWindow$1(M), AH = (m) => {
		this.manager.actions.stop({ event: m });
	};
	gH && kH.addEventListener("resize", AH), n(() => D.status) === "idle" && requestAnimationFrame(() => D.status = "dragging"), hH && (DH.observe(hH), U = new MutationObserver((m) => {
		let x = !1;
		for (let S of m) {
			if (S.target !== k) {
				x = !0;
				continue;
			}
			if (S.type !== "attributes") continue;
			let m = S.attributeName;
			if (m.startsWith("aria-") || IGNORED_ATTRIBUTES.includes(m)) continue;
			let C = k.getAttribute(m);
			if (m === "style") {
				if (supportsStyle(k) && supportsStyle(hH)) {
					let m = k.style;
					for (let x of Array.from(hH.style)) m.getPropertyValue(x) === "" && hH.style.removeProperty(x);
					for (let x of Array.from(m)) {
						if (IGNORED_STYLES.includes(x) || x.startsWith(CSS_PREFIX)) continue;
						let S = m.getPropertyValue(x);
						hH.style.setProperty(x, S);
					}
				}
			} else C === null ? hH.removeAttribute(m) : hH.setAttribute(m, C);
		}
		x && dH && (hH.innerHTML = k.innerHTML);
	}), U.observe(k, {
		attributes: !0,
		subtree: !0,
		childList: !0
	}), W = new MutationObserver((m) => {
		for (let x of m) if (x.addedNodes.length !== 0) for (let m of Array.from(x.addedNodes)) {
			if (m.contains(k) && k.nextElementSibling !== hH) {
				k.insertAdjacentElement("afterend", hH), showPopover(M);
				return;
			}
			if (m.contains(hH) && hH.previousElementSibling !== k) {
				hH.insertAdjacentElement("beforebegin", k), showPopover(M);
				return;
			}
		}
	}), W.observe(k.ownerDocument.body, {
		childList: !0,
		subtree: !0
	}));
	let jH = x.dragOperation.source?.id, MH = () => {
		if (!gH || jH == null) return;
		let m = x.registry.draggables.get(jH), S = m?.handle ?? m?.element;
		isHTMLElement$1(S) && S.focus();
	}, NH = () => {
		U?.disconnect(), W?.disconnect(), DH.disconnect(), kH.removeEventListener("resize", AH), supportsPopover(M) && (M.removeEventListener("beforetoggle", preventPopoverClose), M.removeAttribute("popover")), M.removeAttribute(ATTRIBUTE), G.reset(), D.status = "idle";
		let x = m.current.translate != null;
		hH && (x || hH.parentElement !== M.parentElement) && M.isConnected && hH.replaceWith(M), hH?.remove();
	}, PH = effects(() => {
		let { transform: x, status: S } = C;
		if (!(!x.x && !x.y && !m.current.translate) && S.dragging) {
			let S = j.translate ?? {
				x: 0,
				y: 0
			}, T = {
				x: x.x / N.scaleX + S.x,
				y: x.y / N.scaleY + S.y
			}, D = m.current.translate, O = n(() => C.modifiers), k = n(() => C.shape?.current), A = gH ? "250ms cubic-bezier(0.25, 1, 0.5, 1)" : "0ms linear";
			if (G.set({
				transition: `${K}, translate ${A}`,
				translate: `${T.x}px ${T.y}px 0`
			}, CSS_PREFIX), U?.takeRecords(), k && k !== OH && D && !O.length) {
				let m = Point.delta(T, D);
				C.shape = Rectangle.from(k.boundingRectangle).translate(m.x * N.scaleX, m.y * N.scaleY);
			} else C.shape = new DOMRectangle(M);
			m.current.translate = T;
		}
	}, function() {
		if (C.status.dropped) {
			this.dispose(), D.status = "dropping";
			let S = m.current.translate, C = S != null;
			if (!S && k !== M && (S = {
				x: 0,
				y: 0
			}), !S) {
				NH();
				return;
			}
			x.renderer.rendering.then(() => {
				{
					showPopover(M);
					let [, m] = getFinalKeyframe$2(M, (m) => "translate" in m) ?? [];
					m?.pause();
					let x = hH ?? k, T = { frameTransform: isSameFrame(M, x) ? null : void 0 }, O = new DOMRectangle(M, T), A = parseTranslate(getComputedStyles(M).translate) ?? S, j = new DOMRectangle(x, T), N = Rectangle.delta(O, j, D.alignment), P = {
						x: A.x - N.x,
						y: A.y - N.y
					}, F = Math.round(O.intrinsicHeight) === Math.round(j.intrinsicHeight) ? {} : {
						minHeight: [`${O.intrinsicHeight}px`, `${j.intrinsicHeight}px`],
						maxHeight: [`${O.intrinsicHeight}px`, `${j.intrinsicHeight}px`]
					}, I = Math.round(O.intrinsicWidth) === Math.round(j.intrinsicWidth) ? {} : {
						minWidth: [`${O.intrinsicWidth}px`, `${j.intrinsicWidth}px`],
						maxWidth: [`${O.intrinsicWidth}px`, `${j.intrinsicWidth}px`]
					};
					G.set({ transition: K }, CSS_PREFIX), M.setAttribute(DROPPING_ATTRIBUTE, ""), U?.takeRecords(), animateTransform({
						element: M,
						keyframes: __spreadProps$4(__spreadValues$4(__spreadValues$4({}, F), I), { translate: [`${A.x}px ${A.y}px 0`, `${P.x}px ${P.y}px 0`] }),
						options: {
							duration: C || M !== k ? 250 : 0,
							easing: "ease"
						}
					}).then(() => {
						M.removeAttribute(DROPPING_ATTRIBUTE), m?.finish(), NH(), requestAnimationFrame(MH);
					});
				}
			});
		}
	});
	return () => {
		NH(), PH();
	};
}, injectStyles_fn = function() {
	let { status: m, source: x, target: S } = this.manager.dragOperation, { nonce: C } = this.options ?? {};
	if (m.initializing) {
		let m = getDocument$1(x?.element ?? null), T = getDocument$1(S?.element ?? null), D = /* @__PURE__ */ new Set([m, T]);
		for (let m of D) {
			let x = styleSheetRegistry.get(m);
			if (!x) {
				let S = document.createElement("style");
				S.textContent = CSS_RULES, C && S.setAttribute("nonce", C), m.head.prepend(S);
				let T = new MutationObserver((x) => {
					for (let C of x) if (C.type === "childList") {
						let x = Array.from(C.removedNodes);
						x.length > 0 && x.includes(S) && m.head.prepend(S);
					}
				});
				T.observe(m.head, { childList: !0 }), x = {
					cleanup: () => {
						T.disconnect(), S.remove();
					},
					instances: /* @__PURE__ */ new Set()
				}, styleSheetRegistry.set(m, x);
			}
			x.instances.add(this);
		}
	}
}, __decorateElement$2(_init$2, 4, "overlay", _overlay_dec, _Feedback, _overlay), __decoratorMetadata$2(_init$2, _Feedback), _Feedback.configure = configurator(_Feedback);
var Feedback = _Feedback, LOCKED = !0, UNLOCKED = !1, _dec, _a2, _dec2, _b = (_dec2 = [reactive], ScrollDirection.Forward), _init2, __b, __a;
_a2 = (_dec = [reactive], ScrollDirection.Reverse);
var ScrollLock = class {
	constructor() {
		__privateAdd$2(this, __b, __runInitializers$2(_init2, 8, this, LOCKED)), __runInitializers$2(_init2, 11, this), __privateAdd$2(this, __a, __runInitializers$2(_init2, 12, this, LOCKED)), __runInitializers$2(_init2, 15, this);
	}
	isLocked(m) {
		return m === ScrollDirection.Idle ? !1 : m == null ? this[ScrollDirection.Forward] === LOCKED && this[ScrollDirection.Reverse] === LOCKED : this[m] === LOCKED;
	}
	unlock(m) {
		m !== ScrollDirection.Idle && (this[m] = UNLOCKED);
	}
};
_init2 = __decoratorStart$2(null), __b = /* @__PURE__ */ new WeakMap(), __a = /* @__PURE__ */ new WeakMap(), __decorateElement$2(_init2, 4, _b, _dec2, ScrollLock, __b), __decorateElement$2(_init2, 4, _a2, _dec, ScrollLock, __a), __decoratorMetadata$2(_init2, ScrollLock);
var DIRECTIONS = [ScrollDirection.Forward, ScrollDirection.Reverse], ScrollIntent = class {
	constructor() {
		this.x = new ScrollLock(), this.y = new ScrollLock();
	}
	isLocked() {
		return this.x.isLocked() && this.y.isLocked();
	}
}, ScrollIntentTracker = class extends Plugin {
	constructor(m) {
		super(m);
		let x = d(new ScrollIntent()), S = null;
		this.signal = x, E(() => {
			let { status: C } = m.dragOperation;
			if (!C.initialized) {
				S = null, x.value = new ScrollIntent();
				return;
			}
			let { delta: T } = m.dragOperation.position;
			if (S) {
				let m = {
					x: getDirection$2(T.x, S.x),
					y: getDirection$2(T.y, S.y)
				}, C = x.peek();
				r(() => {
					for (let x of Axes) for (let S of DIRECTIONS) m[x] === S && C[x].unlock(S);
					x.value = C;
				});
			}
			S = T;
		});
	}
	get current() {
		return this.signal.peek();
	}
};
function getDirection$2(m, x) {
	return Math.sign(m - x);
}
var _autoScrolling_dec, _a3, _init3, _autoScrolling, _meta, _scroll, Scroller = class extends (_a3 = CorePlugin, _autoScrolling_dec = [reactive], _a3) {
	constructor(m) {
		super(m), __privateAdd$2(this, _autoScrolling, __runInitializers$2(_init3, 8, this, !1)), __runInitializers$2(_init3, 11, this), __privateAdd$2(this, _meta), __privateAdd$2(this, _scroll, () => {
			if (!__privateGet$2(this, _meta)) return;
			let { element: m, by: x } = __privateGet$2(this, _meta);
			x.y && (m.scrollTop += x.y), x.x && (m.scrollLeft += x.x);
		}), this.scroll = (m) => {
			if (this.disabled) return !1;
			let x = this.getScrollableElements();
			if (!x) return __privateSet$2(this, _meta, void 0), !1;
			let { position: S } = this.manager.dragOperation, C = S?.current;
			if (C) {
				let { by: S } = m ?? {}, T = S ? {
					x: getScrollIntent(S.x),
					y: getScrollIntent(S.y)
				} : void 0, D = T ? void 0 : this.scrollIntentTracker.current;
				if (D?.isLocked()) return !1;
				for (let m of x) {
					let x = canScroll(m, S);
					if (x.x || x.y) {
						let { speed: x, direction: O } = detectScrollIntent(m, C, T);
						if (D) for (let m of Axes) D[m].isLocked(O[m]) && (x[m] = 0, O[m] = 0);
						if (O.x || O.y) {
							let { x: C, y: T } = S ?? O, D = C * x.x, k = T * x.y;
							if (D || k) {
								let x = __privateGet$2(this, _meta)?.by;
								if (this.autoScrolling && x && (x.x && !D || x.y && !k)) continue;
								return __privateSet$2(this, _meta, {
									element: m,
									by: {
										x: D,
										y: k
									}
								}), scheduler.schedule(__privateGet$2(this, _scroll)), !0;
							}
						}
					}
				}
			}
			return __privateSet$2(this, _meta, void 0), !1;
		};
		let x = null, S = null, C = computed(() => {
			let { position: S, source: C } = m.dragOperation;
			if (!S) return null;
			let T = getElementFromPoint(getDocument$1(C?.element), S.current);
			return T && (x = T), T ?? x;
		}), T = computed(() => {
			let x = C.value, { documentElement: T } = getDocument$1(x);
			if (!x || x === T) {
				let { target: x } = m.dragOperation, C = x?.element;
				if (C) {
					let m = getScrollableAncestors(C, { excludeElement: !1 });
					return S = m, m;
				}
			}
			if (x) {
				let m = getScrollableAncestors(x, { excludeElement: !1 });
				return this.autoScrolling && S && m.size < S?.size ? S : (S = m, m);
			}
			return S = null, null;
		}, deepEqual);
		this.getScrollableElements = () => T.value, this.scrollIntentTracker = new ScrollIntentTracker(m), this.destroy = m.monitor.addEventListener("dragmove", (x) => {
			this.disabled || x.defaultPrevented || !isKeyboardEvent(m.dragOperation.activatorEvent) || !x.by || this.scroll({ by: x.by }) && x.preventDefault();
		});
	}
};
_init3 = __decoratorStart$2(_a3), _autoScrolling = /* @__PURE__ */ new WeakMap(), _meta = /* @__PURE__ */ new WeakMap(), _scroll = /* @__PURE__ */ new WeakMap(), __decorateElement$2(_init3, 4, "autoScrolling", _autoScrolling_dec, Scroller, _autoScrolling), __decoratorMetadata$2(_init3, Scroller);
function getScrollIntent(m) {
	return m > 0 ? ScrollDirection.Forward : m < 0 ? ScrollDirection.Reverse : ScrollDirection.Idle;
}
var scheduler3 = new class {
	constructor(m) {
		this.scheduler = m, this.pending = !1, this.tasks = /* @__PURE__ */ new Set(), this.resolvers = /* @__PURE__ */ new Set(), this.flush = () => {
			let { tasks: m, resolvers: x } = this;
			this.pending = !1, this.tasks = /* @__PURE__ */ new Set(), this.resolvers = /* @__PURE__ */ new Set();
			for (let x of m) x();
			for (let m of x) m();
		};
	}
	schedule(m) {
		return this.tasks.add(m), this.pending || (this.pending = !0, this.scheduler(this.flush)), new Promise((m) => this.resolvers.add(m));
	}
}((m) => {
	typeof requestAnimationFrame == "function" ? requestAnimationFrame(m) : m();
}), AUTOSCROLL_INTERVAL = 10, AutoScroller = class extends Plugin {
	constructor(m, x) {
		super(m);
		let S = m.registry.plugins.get(Scroller);
		if (!S) throw Error("AutoScroller plugin depends on Scroller plugin");
		this.destroy = E(() => {
			if (this.disabled) return;
			let { position: x, status: C } = m.dragOperation;
			if (C.dragging) if (S.scroll()) {
				S.autoScrolling = !0;
				let m = setInterval(() => scheduler3.schedule(S.scroll), AUTOSCROLL_INTERVAL);
				return () => {
					clearInterval(m);
				};
			} else S.autoScrolling = !1;
		});
	}
}, listenerOptions = {
	capture: !0,
	passive: !0
}, _timeout, ScrollListener = class extends CorePlugin {
	constructor(m) {
		super(m), __privateAdd$2(this, _timeout), this.handleScroll = () => {
			__privateGet$2(this, _timeout) ?? __privateSet$2(this, _timeout, setTimeout(() => {
				this.manager.collisionObserver.forceUpdate(!1), __privateSet$2(this, _timeout, void 0);
			}, 50));
		};
		let { dragOperation: x } = this.manager;
		this.destroy = E(() => {
			if (x.status.dragging) {
				let m = x.source?.element?.ownerDocument ?? document;
				return m.addEventListener("scroll", this.handleScroll, listenerOptions), () => {
					m.removeEventListener("scroll", this.handleScroll, listenerOptions);
				};
			}
		});
	}
};
_timeout = /* @__PURE__ */ new WeakMap();
var PreventSelection = class extends Plugin {
	constructor(m, x) {
		super(m, x), this.manager = m, this.destroy = E(() => {
			let { dragOperation: m } = this.manager, { nonce: x } = this.options ?? {};
			if (m.status.initialized) {
				let m = document.createElement("style");
				return x && m.setAttribute("nonce", x), m.textContent = "* { user-select: none !important; -webkit-user-select: none !important; }", document.head.appendChild(m), removeSelection(), document.addEventListener("selectionchange", removeSelection, { capture: !0 }), () => {
					document.removeEventListener("selectionchange", removeSelection, { capture: !0 }), m.remove();
				};
			}
		});
	}
};
function removeSelection() {
	var m;
	(m = document.getSelection()) == null || m.removeAllRanges();
}
var defaults$1 = Object.freeze({
	offset: 10,
	keyboardCodes: {
		start: ["Space", "Enter"],
		cancel: ["Escape"],
		end: [
			"Space",
			"Enter",
			"Tab"
		],
		up: ["ArrowUp"],
		down: ["ArrowDown"],
		left: ["ArrowLeft"],
		right: ["ArrowRight"]
	},
	shouldActivate(m) {
		let { event: x, source: S } = m, C = S.handle ?? S.element;
		return x.target === C;
	}
}), _cleanupFunctions, _KeyboardSensor = class extends Sensor {
	constructor(m, x) {
		super(m), this.manager = m, this.options = x, __privateAdd$2(this, _cleanupFunctions, []), this.listeners = new Listeners(), this.handleSourceKeyDown = (m, x, S) => {
			if (this.disabled || m.defaultPrevented || !isElement(m.target) || x.disabled) return;
			let { keyboardCodes: C = defaults$1.keyboardCodes, shouldActivate: T = defaults$1.shouldActivate } = S ?? {};
			C.start.includes(m.code) && this.manager.dragOperation.status.idle && T({
				event: m,
				source: x,
				manager: this.manager
			}) && this.handleStart(m, x, S);
		};
	}
	bind(m, x = this.options) {
		return E(() => {
			let S = m.handle ?? m.element, C = (S) => {
				isKeyboardEvent(S) && this.handleSourceKeyDown(S, m, x);
			};
			if (S) return S.addEventListener("keydown", C), () => {
				S.removeEventListener("keydown", C);
			};
		});
	}
	handleStart(m, x, S) {
		let { element: C } = x;
		if (!C) throw Error("Source draggable does not have an associated element");
		m.preventDefault(), m.stopImmediatePropagation(), scrollIntoViewIfNeeded(C);
		let { center: T } = new DOMRectangle(C);
		if (this.manager.actions.start({
			event: m,
			coordinates: {
				x: T.x,
				y: T.y
			},
			source: x
		}).signal.aborted) return this.cleanup();
		this.sideEffects();
		let D = getDocument$1(C), O = [this.listeners.bind(D, [{
			type: "keydown",
			listener: (m) => this.handleKeyDown(m, x, S),
			options: { capture: !0 }
		}])];
		__privateGet$2(this, _cleanupFunctions).push(...O);
	}
	handleKeyDown(m, x, S) {
		let { keyboardCodes: C = defaults$1.keyboardCodes } = S ?? {};
		if (isKeycode(m, [...C.end, ...C.cancel])) {
			m.preventDefault();
			let x = isKeycode(m, C.cancel);
			this.handleEnd(m, x);
			return;
		}
		isKeycode(m, C.up) ? this.handleMove("up", m) : isKeycode(m, C.down) && this.handleMove("down", m), isKeycode(m, C.left) ? this.handleMove("left", m) : isKeycode(m, C.right) && this.handleMove("right", m);
	}
	handleEnd(m, x) {
		this.manager.actions.stop({
			event: m,
			canceled: x
		}), this.cleanup();
	}
	handleMove(m, x) {
		let { shape: S } = this.manager.dragOperation, C = x.shiftKey ? 5 : 1, T = {
			x: 0,
			y: 0
		}, D = this.options?.offset ?? defaults$1.offset;
		if (typeof D == "number" && (D = {
			x: D,
			y: D
		}), S) {
			switch (m) {
				case "up":
					T = {
						x: 0,
						y: -D.y * C
					};
					break;
				case "down":
					T = {
						x: 0,
						y: D.y * C
					};
					break;
				case "left":
					T = {
						x: -D.x * C,
						y: 0
					};
					break;
				case "right":
					T = {
						x: D.x * C,
						y: 0
					};
					break;
			}
			(T.x || T.y) && (x.preventDefault(), this.manager.actions.move({
				event: x,
				by: T
			}));
		}
	}
	sideEffects() {
		let m = this.manager.registry.plugins.get(AutoScroller);
		m?.disabled === !1 && (m.disable(), __privateGet$2(this, _cleanupFunctions).push(() => {
			m.enable();
		}));
	}
	cleanup() {
		__privateGet$2(this, _cleanupFunctions).forEach((m) => m()), __privateSet$2(this, _cleanupFunctions, []);
	}
	destroy() {
		this.cleanup(), this.listeners.clear();
	}
};
_cleanupFunctions = /* @__PURE__ */ new WeakMap(), _KeyboardSensor.configure = configurator(_KeyboardSensor), _KeyboardSensor.defaults = defaults$1;
var KeyboardSensor = _KeyboardSensor;
function isKeycode(m, x) {
	return x.includes(m.code);
}
var defaults2 = Object.freeze({ activationConstraints(m, x) {
	let { pointerType: S, target: C } = m;
	if (!(S === "mouse" && isElement(C) && (x.handle === C || x.handle?.contains(C)))) return S === "touch" ? { delay: {
		value: 250,
		tolerance: 5
	} } : isTextInput(C) && !m.defaultPrevented ? { delay: {
		value: 200,
		tolerance: 0
	} } : {
		delay: {
			value: 200,
			tolerance: 10
		},
		distance: { value: 5 }
	};
} }), _cleanup, _clearTimeout, _PointerSensor = class extends Sensor {
	constructor(m, x) {
		super(m), this.manager = m, this.options = x, __privateAdd$2(this, _cleanup, /* @__PURE__ */ new Set()), __privateAdd$2(this, _clearTimeout), this.listeners = new Listeners(), this.latest = {
			event: void 0,
			coordinates: void 0
		}, this.handleMove = () => {
			let { event: m, coordinates: x } = this.latest;
			!m || !x || this.manager.actions.move({
				event: m,
				to: x
			});
		}, this.handleCancel = this.handleCancel.bind(this), this.handlePointerUp = this.handlePointerUp.bind(this), this.handleKeyDown = this.handleKeyDown.bind(this);
	}
	activationConstraints(m, x) {
		let { activationConstraints: S = defaults2.activationConstraints } = this.options ?? {};
		return typeof S == "function" ? S(m, x) : S;
	}
	bind(m, x = this.options) {
		return E(() => {
			let S = new AbortController(), { signal: C } = S, T = (S) => {
				isPointerEvent(S) && this.handlePointerDown(S, m, x);
			}, D = [m.handle ?? m.element];
			x?.activatorElements && (D = Array.isArray(x.activatorElements) ? x.activatorElements : x.activatorElements(m));
			for (let m of D) m && (patchWindow(m.ownerDocument.defaultView), m.addEventListener("pointerdown", T, { signal: C }));
			return () => S.abort();
		});
	}
	handlePointerDown(m, x, S = {}) {
		if (this.disabled || !m.isPrimary || m.button !== 0 || !isElement(m.target) || x.disabled || isCapturedBySensor(m) || !this.manager.dragOperation.status.idle) return;
		let { target: C } = m, T = isHTMLElement$1(C) && C.draggable && C.getAttribute("draggable") === "true", D = getFrameTransform(x.element);
		this.initialCoordinates = {
			x: m.clientX * D.scaleX + D.x,
			y: m.clientY * D.scaleY + D.y
		};
		let O = this.activationConstraints(m, x);
		if (m.sensor = this, !O?.delay && !O?.distance) this.handleStart(x, m);
		else {
			let { delay: S } = O;
			if (S) {
				let C = setTimeout(() => this.handleStart(x, m), S.value);
				__privateSet$2(this, _clearTimeout, () => {
					clearTimeout(C), __privateSet$2(this, _clearTimeout, void 0);
				});
			}
		}
		let k = getDocument$1(m.target), A = this.listeners.bind(k, [
			{
				type: "pointermove",
				listener: (m) => this.handlePointerMove(m, x)
			},
			{
				type: "pointerup",
				listener: this.handlePointerUp,
				options: { capture: !0 }
			},
			{
				type: "dragstart",
				listener: T ? this.handleCancel : preventDefault,
				options: { capture: !0 }
			}
		]);
		__privateGet$2(this, _cleanup).add(() => {
			var m;
			A(), (m = __privateGet$2(this, _clearTimeout)) == null || m.call(this), this.initialCoordinates = void 0;
		});
	}
	handlePointerMove(m, x) {
		let S = {
			x: m.clientX,
			y: m.clientY
		}, C = getFrameTransform(x.element);
		if (S.x = S.x * C.scaleX + C.x, S.y = S.y * C.scaleY + C.y, this.manager.dragOperation.status.dragging) {
			m.preventDefault(), m.stopPropagation(), this.latest.event = m, this.latest.coordinates = S, scheduler.schedule(this.handleMove);
			return;
		}
		if (!this.initialCoordinates) return;
		let T = {
			x: S.x - this.initialCoordinates.x,
			y: S.y - this.initialCoordinates.y
		}, { distance: D, delay: O } = this.activationConstraints(m, x) ?? {};
		if (D) {
			if (D.tolerance != null && exceedsDistance(T, D.tolerance)) return this.handleCancel(m);
			if (exceedsDistance(T, D.value)) return this.handleStart(x, m);
		}
		if (O && exceedsDistance(T, O.tolerance)) return this.handleCancel(m);
	}
	handlePointerUp(m) {
		let { status: x } = this.manager.dragOperation;
		if (!x.idle) {
			m.preventDefault(), m.stopPropagation();
			let S = !x.initialized;
			this.manager.actions.stop({
				event: m,
				canceled: S
			});
		}
		this.cleanup();
	}
	handleKeyDown(m) {
		m.key === "Escape" && (m.preventDefault(), this.handleCancel(m));
	}
	handleStart(m, x) {
		var S;
		let { manager: C, initialCoordinates: T } = this;
		if ((S = __privateGet$2(this, _clearTimeout)) == null || S.call(this), !T || !C.dragOperation.status.idle || x.defaultPrevented) return;
		if (C.actions.start({
			coordinates: T,
			event: x,
			source: m
		}).signal.aborted) return this.cleanup();
		x.preventDefault();
		let D = getDocument$1(x.target), O = D.body;
		O.setPointerCapture(x.pointerId);
		let k = this.listeners.bind(D, [
			{
				type: "touchmove",
				listener: preventDefault,
				options: { passive: !1 }
			},
			{
				type: "click",
				listener: preventDefault
			},
			{
				type: "contextmenu",
				listener: preventDefault
			},
			{
				type: "keydown",
				listener: this.handleKeyDown
			},
			{
				type: "lostpointercapture",
				listener: (m) => {
					m.target === O && this.handlePointerUp(m);
				}
			}
		]);
		__privateGet$2(this, _cleanup).add(k);
	}
	handleCancel(m) {
		let { dragOperation: x } = this.manager;
		x.status.initialized && this.manager.actions.stop({
			event: m,
			canceled: !0
		}), this.cleanup();
	}
	cleanup() {
		this.latest = {
			event: void 0,
			coordinates: void 0
		}, __privateGet$2(this, _cleanup).forEach((m) => m()), __privateGet$2(this, _cleanup).clear();
	}
	destroy() {
		this.cleanup(), this.listeners.clear();
	}
};
_cleanup = /* @__PURE__ */ new WeakMap(), _clearTimeout = /* @__PURE__ */ new WeakMap(), _PointerSensor.configure = configurator(_PointerSensor), _PointerSensor.defaults = defaults2;
var PointerSensor = _PointerSensor;
function isCapturedBySensor(m) {
	return "sensor" in m;
}
function preventDefault(m) {
	m.preventDefault();
}
function noop$2() {}
var windows = /* @__PURE__ */ new WeakSet();
function patchWindow(m) {
	!m || windows.has(m) || (m.addEventListener("touchmove", noop$2, {
		capture: !1,
		passive: !1
	}), windows.add(m));
}
var defaultPreset = {
	modifiers: [],
	plugins: [
		Accessibility,
		AutoScroller,
		Cursor,
		Feedback,
		PreventSelection
	],
	sensors: [PointerSensor, KeyboardSensor]
}, DragDropManager = class extends DragDropManager$1 {
	constructor(m = {}) {
		let { plugins: x = defaultPreset.plugins, sensors: S = defaultPreset.sensors, modifiers: C = [] } = m;
		super(__spreadProps$4(__spreadValues$4({}, m), {
			plugins: [
				ScrollListener,
				Scroller,
				...x
			],
			sensors: S,
			modifiers: C
		}));
	}
}, _feedback_dec, _element_dec, _handle_dec, _c, _init4, _handle, _element$1, _feedback, Draggable = class extends (_c = Draggable$1, _handle_dec = [reactive], _element_dec = [reactive], _feedback_dec = [reactive], _c) {
	constructor(m, x) {
		var S = m, { element: C, effects: T = () => [], handle: D, feedback: O = "default" } = S, k = __objRest$3(S, [
			"element",
			"effects",
			"handle",
			"feedback"
		]);
		super(__spreadValues$4({ effects: () => [...T(), () => {
			let { manager: m } = this;
			if (!m) return;
			let x = (this.sensors?.map(descriptor) ?? [...m.sensors]).map((x) => {
				let S = x instanceof Sensor ? x : m.registry.register(x.plugin), C = x instanceof Sensor ? void 0 : x.options;
				return S.bind(this, C);
			});
			return function() {
				x.forEach((m) => m());
			};
		}] }, k), x), __privateAdd$2(this, _handle, __runInitializers$2(_init4, 8, this)), __runInitializers$2(_init4, 11, this), __privateAdd$2(this, _element$1, __runInitializers$2(_init4, 12, this)), __runInitializers$2(_init4, 15, this), __privateAdd$2(this, _feedback, __runInitializers$2(_init4, 16, this)), __runInitializers$2(_init4, 19, this), this.element = C, this.handle = D, this.feedback = O;
	}
};
_init4 = __decoratorStart$2(_c), _handle = /* @__PURE__ */ new WeakMap(), _element$1 = /* @__PURE__ */ new WeakMap(), _feedback = /* @__PURE__ */ new WeakMap(), __decorateElement$2(_init4, 4, "handle", _handle_dec, Draggable, _handle), __decorateElement$2(_init4, 4, "element", _element_dec, Draggable, _element$1), __decorateElement$2(_init4, 4, "feedback", _feedback_dec, Draggable, _feedback), __decoratorMetadata$2(_init4, Draggable);
var _proxy_dec, _element_dec2, _c2, _init5, _element2, _d, element_get, element_set, _Droppable_instances, _proxy, Droppable = class extends (_c2 = Droppable$1, _element_dec2 = [reactive], _proxy_dec = [reactive], _c2) {
	constructor(m, x) {
		var S = m, { element: C, effects: T = () => [] } = S, D = __objRest$3(S, ["element", "effects"]);
		let { collisionDetector: O = defaultCollisionDetection } = D, k = (m) => {
			let { manager: x, element: S } = this;
			if (!S || m === null) {
				this.shape = void 0;
				return;
			}
			if (!x) return;
			let C = new DOMRectangle(S), T = n(() => this.shape);
			return C && T?.equals(C) ? T : (this.shape = C, C);
		}, A = d(!1);
		super(__spreadProps$4(__spreadValues$4({}, D), {
			collisionDetector: O,
			effects: () => [
				...T(),
				() => {
					let { element: m, manager: x } = this;
					if (!x) return;
					let { dragOperation: S } = x, { source: C } = S;
					A.value = !!(C && S.status.initialized && m && !this.disabled && this.accepts(C));
				},
				() => {
					let { element: m } = this;
					if (A.value && m) {
						let x = new FrameObserver(m, k);
						return () => {
							x.disconnect(), this.shape = void 0;
						};
					}
				},
				() => {
					if (this.manager?.dragOperation.status.initialized) return () => {
						this.shape = void 0;
					};
				}
			]
		}), x), __privateAdd$2(this, _Droppable_instances), __privateAdd$2(this, _element2, __runInitializers$2(_init5, 8, this)), __runInitializers$2(_init5, 11, this), __privateAdd$2(this, _proxy, __runInitializers$2(_init5, 12, this)), __runInitializers$2(_init5, 15, this), this.element = C, this.refreshShape = () => k();
	}
	set element(m) {
		__privateSet$2(this, _Droppable_instances, m, element_set);
	}
	get element() {
		return this.proxy ?? __privateGet$2(this, _Droppable_instances, element_get);
	}
};
_init5 = __decoratorStart$2(_c2), _element2 = /* @__PURE__ */ new WeakMap(), _Droppable_instances = /* @__PURE__ */ new WeakSet(), _proxy = /* @__PURE__ */ new WeakMap(), _d = __decorateElement$2(_init5, 20, "#element", _element_dec2, _Droppable_instances, _element2), element_get = _d.get, element_set = _d.set, __decorateElement$2(_init5, 4, "proxy", _proxy_dec, Droppable, _proxy), __decoratorMetadata$2(_init5, Droppable);
function isRef(m) {
	return typeof m == "object" && !!m && "current" in m;
}
function currentValue(m) {
	if (m != null) return isRef(m) ? m.current ?? void 0 : m;
}
var useIsomorphicLayoutEffect$3 = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0 ? useLayoutEffect : useEffect;
function useForceUpdate() {
	let m = useState(0)[1];
	return useCallback(() => {
		m((m) => m + 1);
	}, [m]);
}
function useDeepSignal(m, x) {
	let S = useRef(/* @__PURE__ */ new Map()), C = useForceUpdate();
	return useIsomorphicLayoutEffect$3(() => {
		if (!m) {
			S.current.clear();
			return;
		}
		return E(() => {
			let T = !1, D = !1;
			for (let C of S.current) {
				let [O] = C, k = n(() => C[1]), A = m[O];
				k !== A && (T = !0, S.current.set(O, A), D = x?.(O, k, A) ?? !1);
			}
			T && (D ? flushSync(C) : C());
		});
	}, [m]), useMemo(() => m && new Proxy(m, { get(m, x) {
		let C = m[x];
		return S.current.set(x, C), C;
	} }), [m]);
}
function useImmediateEffect(m, x) {
	m();
}
function useLatest(m) {
	let x = useRef(m);
	return useIsomorphicLayoutEffect$3(() => {
		x.current = m;
	}, [m]), x;
}
function useOnValueChange(m, x, S = useEffect, C = Object.is) {
	let T = useRef(m);
	S(() => {
		let S = T.current;
		C(m, S) || (T.current = m, x(m, S));
	}, [x, m]);
}
function useOnElementChange(m, x) {
	let S = useRef(currentValue(m));
	useIsomorphicLayoutEffect$3(() => {
		let C = currentValue(m);
		C !== S.current && (S.current = C, x(C));
	});
}
var __defProp$2 = Object.defineProperty, __defProps$2 = Object.defineProperties, __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (m, x, S) => x in m ? __defProp$2(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$3 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$2.call(x, S) && __defNormalProp$2(m, S, x[S]);
	if (__getOwnPropSymbols$2) for (var S of __getOwnPropSymbols$2(x)) __propIsEnum$2.call(x, S) && __defNormalProp$2(m, S, x[S]);
	return m;
}, __spreadProps$3 = (m, x) => __defProps$2(m, __getOwnPropDescs$2(x)), __objRest$2 = (m, x) => {
	var S = {};
	for (var C in m) __hasOwnProp$2.call(m, C) && x.indexOf(C) < 0 && (S[C] = m[C]);
	if (m != null && __getOwnPropSymbols$2) for (var C of __getOwnPropSymbols$2(m)) x.indexOf(C) < 0 && __propIsEnum$2.call(m, C) && (S[C] = m[C]);
	return S;
}, DragDropContext$1 = createContext(new DragDropManager()), Renderer = memo(forwardRef(({ children: m }, x) => {
	let [S, C] = useState(0), T = useRef(null), D = useRef(null), O = useMemo(() => ({
		renderer: { get rendering() {
			return T.current ?? Promise.resolve();
		} },
		trackRendering(m) {
			T.current ||= new Promise((m) => {
				D.current = m;
			}), startTransition(() => {
				m(), C((m) => m + 1);
			});
		}
	}), []);
	return useIsomorphicLayoutEffect$3(() => {
		var m;
		(m = D.current) == null || m.call(D), T.current = null;
	}, [m, S]), useImperativeHandle(x, () => O), null;
})), options = [void 0, deepEqual];
function DragDropProvider(m) {
	var x = m, { children: S, onCollision: C, onBeforeDragStart: T, onDragStart: D, onDragMove: O, onDragOver: k, onDragEnd: A } = x, M = __objRest$2(x, [
		"children",
		"onCollision",
		"onBeforeDragStart",
		"onDragStart",
		"onDragMove",
		"onDragOver",
		"onDragEnd"
	]);
	let N = useRef(null), [F, I] = useState(M.manager ?? null), { plugins: L, modifiers: R, sensors: z } = M, U = useLatest(T), W = useLatest(D), q = useLatest(k), J = useLatest(O), Y = useLatest(A), X = useLatest(C);
	return useEffect(() => {
		if (!N.current) throw Error("Renderer not found");
		let { renderer: m, trackRendering: x } = N.current, S = M.manager ?? new DragDropManager(M);
		return S.renderer = m, S.monitor.addEventListener("beforedragstart", (m) => {
			let C = U.current;
			C && x(() => C(m, S));
		}), S.monitor.addEventListener("dragstart", (m) => W.current?.call(W, m, S)), S.monitor.addEventListener("dragover", (m) => {
			let C = q.current;
			C && x(() => C(m, S));
		}), S.monitor.addEventListener("dragmove", (m) => {
			let C = J.current;
			C && x(() => C(m, S));
		}), S.monitor.addEventListener("dragend", (m) => {
			let C = Y.current;
			C && x(() => C(m, S));
		}), S.monitor.addEventListener("collision", (m) => X.current?.call(X, m, S)), startTransition(() => I(S)), S.destroy;
	}, [M.manager]), useOnValueChange(L, () => F && (F.plugins = L ?? defaultPreset.plugins), ...options), useOnValueChange(z, () => F && (F.sensors = z ?? defaultPreset.sensors), ...options), useOnValueChange(R, () => F && (F.modifiers = R ?? defaultPreset.modifiers), ...options), /* @__PURE__ */ jsxs(DragDropContext$1.Provider, {
		value: F,
		children: [/* @__PURE__ */ jsx(Renderer, {
			ref: N,
			children: S
		}), S]
	});
}
function useDragDropManager() {
	return useContext(DragDropContext$1);
}
function useInstance(m) {
	let x = useDragDropManager() ?? void 0, [S] = useState(() => m(x));
	return S.manager !== x && (S.manager = x), useIsomorphicLayoutEffect$3(S.register, [x, S]), S;
}
function useDraggable(m) {
	let { disabled: x, data: S, element: C, handle: T, id: D, modifiers: O, sensors: k } = m, A = useInstance((x) => new Draggable(__spreadProps$3(__spreadValues$3({}, m), {
		register: !1,
		handle: currentValue(T),
		element: currentValue(C)
	}), x)), j = useDeepSignal(A, shouldUpdateSynchronously$1);
	return useOnValueChange(D, () => A.id = D), useOnElementChange(T, (m) => A.handle = m), useOnElementChange(C, (m) => A.element = m), useOnValueChange(S, () => S && (A.data = S)), useOnValueChange(x, () => A.disabled = x === !0), useOnValueChange(k, () => A.sensors = k), useOnValueChange(O, () => A.modifiers = O, void 0, deepEqual), useOnValueChange(m.feedback, () => A.feedback = m.feedback ?? "default"), useOnValueChange(m.alignment, () => A.alignment = m.alignment), {
		draggable: j,
		get isDragging() {
			return j.isDragging;
		},
		get isDropping() {
			return j.isDropping;
		},
		get isDragSource() {
			return j.isDragSource;
		},
		handleRef: useCallback((m) => {
			A.handle = m ?? void 0;
		}, [A]),
		ref: useCallback((m) => {
			!m && A.element?.isConnected && !A.manager?.dragOperation.status.idle || (A.element = m ?? void 0);
		}, [A])
	};
}
function shouldUpdateSynchronously$1(m, x, S) {
	return !!(m === "isDragSource" && !S && x);
}
var __create$1 = Object.create, __defProp2$1 = Object.defineProperty, __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor, __knownSymbol$1 = (m, x) => (x = Symbol[m]) ? x : Symbol.for("Symbol." + m), __typeError$1 = (m) => {
	throw TypeError(m);
}, __defNormalProp2$1 = (m, x, S) => x in m ? __defProp2$1(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __decoratorStart$1 = (m) => [
	,
	,
	,
	__create$1(m?.[__knownSymbol$1("metadata")] ?? null)
], __decoratorStrings$1 = [
	"class",
	"method",
	"getter",
	"setter",
	"accessor",
	"field",
	"value",
	"get",
	"set"
], __expectFn$1 = (m) => m !== void 0 && typeof m != "function" ? __typeError$1("Function expected") : m, __decoratorContext$1 = (m, x, S, C, T) => ({
	kind: __decoratorStrings$1[m],
	name: x,
	metadata: C,
	addInitializer: (m) => S._ ? __typeError$1("Already initialized") : T.push(__expectFn$1(m || null))
}), __decoratorMetadata$1 = (m, x) => __defNormalProp2$1(x, __knownSymbol$1("metadata"), m[3]), __runInitializers$1 = (m, x, S, C) => {
	for (var T = 0, D = m[x >> 1], O = D && D.length; T < O; T++) D[T].call(S);
	return C;
}, __decorateElement$1 = (m, x, S, C, T, D) => {
	for (var O, k, A, j, M = x & 7, N = !1, P = !1, F = 2, I = __decoratorStrings$1[M + 5], L = m[F] || (m[F] = []), R = (T = T.prototype, __getOwnPropDesc$1(T, S)), z = C.length - 1; z >= 0; z--) A = __decoratorContext$1(M, S, k = {}, m[3], L), A.static = N, A.private = P, j = A.access = { has: (m) => S in m }, j.get = (m) => m[S], O = (0, C[z])(R[I], A), k._ = 1, __expectFn$1(O) && (R[I] = O);
	return R && __defProp2$1(T, S, R), T;
}, __accessCheck$1 = (m, x, S) => x.has(m) || __typeError$1("Cannot " + S), __privateGet$1 = (m, x, S) => (__accessCheck$1(m, x, "read from private field"), x.get(m)), __privateAdd$1 = (m, x, S) => x.has(m) ? __typeError$1("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet$1 = (m, x, S, C) => (__accessCheck$1(m, x, "write to private field"), x.set(m, S), S), Point$1 = class m {
	constructor(m, x) {
		this.x = m, this.y = x;
	}
	static delta(x, S) {
		return new m(x.x - S.x, x.y - S.y);
	}
	static distance(m, x) {
		return Math.hypot(m.x - x.x, m.y - x.y);
	}
	static equals(m, x) {
		return m.x === x.x && m.y === x.y;
	}
	static from({ x, y: S }) {
		return new m(x, S);
	}
}, _direction_dec, _delta_dec, _a, _timestamp, _init$1, Position = class extends (_a = ValueHistory, _delta_dec = [derived], _direction_dec = [derived], _a) {
	constructor(m) {
		let x = Point$1.from(m);
		super(x, (m, x) => Point$1.equals(m, x)), __runInitializers$1(_init$1, 5, this), __privateAdd$1(this, _timestamp, 0), this.velocity = {
			x: 0,
			y: 0
		};
	}
	get delta() {
		return Point$1.delta(this.current, this.initial);
	}
	get direction() {
		let { current: m, previous: x } = this;
		if (!x) return null;
		let S = {
			x: m.x - x.x,
			y: m.y - x.y
		};
		return !S.x && !S.y ? null : Math.abs(S.x) > Math.abs(S.y) ? S.x > 0 ? "right" : "left" : S.y > 0 ? "down" : "up";
	}
	get current() {
		return super.current;
	}
	set current(m) {
		let { current: x } = this, S = Point$1.from(m), C = {
			x: S.x - x.x,
			y: S.y - x.y
		}, T = Date.now(), D = T - __privateGet$1(this, _timestamp), O = (m) => Math.round(m / D * 100);
		r(() => {
			__privateSet$1(this, _timestamp, T), this.velocity = {
				x: O(C.x),
				y: O(C.y)
			}, super.current = S;
		});
	}
	reset(m = this.defaultValue) {
		super.reset(Point$1.from(m)), this.velocity = {
			x: 0,
			y: 0
		};
	}
};
_init$1 = __decoratorStart$1(_a), _timestamp = /* @__PURE__ */ new WeakMap(), __decorateElement$1(_init$1, 2, "delta", _delta_dec, Position), __decorateElement$1(_init$1, 2, "direction", _direction_dec, Position), __decoratorMetadata$1(_init$1, Position);
var Axis = /* @__PURE__ */ ((m) => (m.Horizontal = "x", m.Vertical = "y", m))(Axis || {});
Object.values(Axis);
var pointerIntersection$1 = ({ dragOperation: m, droppable: x }) => {
	let S = m.position.current;
	if (!S) return null;
	let { id: C } = x;
	return x.shape && x.shape.containsPoint(S) ? {
		id: C,
		value: 1 / Point$1.distance(x.shape.center, S),
		type: CollisionType.PointerIntersection,
		priority: CollisionPriority.High
	} : null;
}, shapeIntersection = ({ dragOperation: m, droppable: x }) => {
	let { shape: S } = m;
	if (!x.shape || !S?.current) return null;
	let C = S.current.intersectionArea(x.shape);
	if (C) {
		let { position: T } = m, D = Point$1.distance(x.shape.center, T.current), O = C / (S.current.area + x.shape.area - C) / D;
		return {
			id: x.id,
			value: O,
			type: CollisionType.ShapeIntersection,
			priority: CollisionPriority.Normal
		};
	}
	return null;
}, defaultCollisionDetection$1 = (m) => pointerIntersection$1(m) ?? shapeIntersection(m);
function useDroppable(m) {
	let { collisionDetector: x, data: S, disabled: C, element: T, id: D, accept: O, type: k } = m, A = useInstance((x) => new Droppable(__spreadProps$3(__spreadValues$3({}, m), {
		register: !1,
		element: currentValue(T)
	}), x)), j = useDeepSignal(A);
	return useOnValueChange(D, () => A.id = D), useOnElementChange(T, (m) => A.element = m), useOnValueChange(O, () => A.accept = O, void 0, deepEqual), useOnValueChange(x, () => A.collisionDetector = x ?? defaultCollisionDetection$1), useOnValueChange(S, () => S && (A.data = S)), useOnValueChange(C, () => A.disabled = C === !0), useOnValueChange(k, () => A.type = k), {
		droppable: j,
		get isDropTarget() {
			return j.isDropTarget;
		},
		ref: useCallback((m) => {
			!m && A.element?.isConnected && !A.manager?.dragOperation.status.idle || (A.element = m ?? void 0);
		}, [A])
	};
}
var __create = Object.create, __defProp$1 = Object.defineProperty, __defProps$1 = Object.defineProperties, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __knownSymbol = (m, x) => (x = Symbol[m]) ? x : Symbol.for("Symbol." + m), __typeError = (m) => {
	throw TypeError(m);
}, __defNormalProp$1 = (m, x, S) => x in m ? __defProp$1(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$2 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp$1.call(x, S) && __defNormalProp$1(m, S, x[S]);
	if (__getOwnPropSymbols$1) for (var S of __getOwnPropSymbols$1(x)) __propIsEnum$1.call(x, S) && __defNormalProp$1(m, S, x[S]);
	return m;
}, __spreadProps$2 = (m, x) => __defProps$1(m, __getOwnPropDescs$1(x)), __objRest$1 = (m, x) => {
	var S = {};
	for (var C in m) __hasOwnProp$1.call(m, C) && x.indexOf(C) < 0 && (S[C] = m[C]);
	if (m != null && __getOwnPropSymbols$1) for (var C of __getOwnPropSymbols$1(m)) x.indexOf(C) < 0 && __propIsEnum$1.call(m, C) && (S[C] = m[C]);
	return S;
}, __decoratorStart = (m) => [
	,
	,
	,
	__create(null)
], __decoratorStrings = [
	"class",
	"method",
	"getter",
	"setter",
	"accessor",
	"field",
	"value",
	"get",
	"set"
], __expectFn = (m) => m !== void 0 && typeof m != "function" ? __typeError("Function expected") : m, __decoratorContext = (m, x, S, C, T) => ({
	kind: __decoratorStrings[m],
	name: x,
	metadata: C,
	addInitializer: (m) => S._ ? __typeError("Already initialized") : T.push(__expectFn(m || null))
}), __decoratorMetadata = (m, x) => __defNormalProp$1(x, __knownSymbol("metadata"), m[3]), __runInitializers = (m, x, S, C) => {
	for (var T = 0, D = m[x >> 1], O = D && D.length; T < O; T++) x & 1 ? D[T].call(S) : C = D[T].call(S, C);
	return C;
}, __decorateElement = (m, x, S, C, T, D) => {
	for (var O, k, A, j, M, N = x & 7, P = !1, F = !1, I = m.length + 1, L = __decoratorStrings[N + 5], R = m[I - 1] = [], z = m[I] || (m[I] = []), B = (T = T.prototype, __getOwnPropDesc({
		get [S]() {
			return __privateGet(this, D);
		},
		set [S](m) {
			return __privateSet(this, D, m);
		}
	}, S)), H = C.length - 1; H >= 0; H--) j = __decoratorContext(N, S, A = {}, m[3], z), j.static = P, j.private = F, M = j.access = { has: (m) => S in m }, M.get = (m) => m[S], M.set = (m, x) => m[S] = x, k = (0, C[H])({
		get: B.get,
		set: B.set
	}, j), A._ = 1, k === void 0 ? __expectFn(k) && (B[L] = k) : typeof k != "object" || !k ? __typeError("Object expected") : (__expectFn(O = k.get) && (B.get = O), __expectFn(O = k.set) && (B.set = O), __expectFn(O = k.init) && R.unshift(O));
	return B && __defProp$1(T, S, B), T;
}, __accessCheck = (m, x, S) => x.has(m) || __typeError("Cannot " + S), __privateGet = (m, x, S) => (__accessCheck(m, x, "read from private field"), x.get(m)), __privateAdd = (m, x, S) => x.has(m) ? __typeError("Cannot add the same private member more than once") : x instanceof WeakSet ? x.add(m) : x.set(m, S), __privateSet = (m, x, S, C) => (__accessCheck(m, x, "write to private field"), x.set(m, S), S);
function isSortable(m) {
	return m instanceof SortableDroppable || m instanceof SortableDraggable;
}
var TOLERANCE = 10, SortableKeyboardPlugin = class extends Plugin {
	constructor(m) {
		super(m);
		let x = E(() => {
			let { dragOperation: x } = m;
			if (isKeyboardEvent(x.activatorEvent) && isSortable(x.source) && x.status.initialized) {
				let x = m.registry.plugins.get(Scroller);
				if (x) return x.disable(), () => x.enable();
			}
		}), S = m.monitor.addEventListener("dragmove", (m, x) => {
			queueMicrotask(() => {
				if (this.disabled || m.defaultPrevented || !m.nativeEvent) return;
				let { dragOperation: S } = x;
				if (!isKeyboardEvent(m.nativeEvent) || !isSortable(S.source) || !S.shape) return;
				let { actions: C, collisionObserver: T, registry: D } = x, { by: O } = m;
				if (!O) return;
				let k = getDirection$1(O), { source: A, target: j } = S, { center: M } = S.shape.current, N = [], P = [];
				r(() => {
					for (let m of D.droppables) {
						let { id: x } = m;
						if (!m.accepts(A) || x === j?.id && isSortable(m) || !m.element) continue;
						let S = m.shape, C = new DOMRectangle(m.element, { getBoundingClientRect: (m) => getVisibleBoundingRectangle(m, void 0, .2) });
						!C.height || !C.width || (k == "down" && M.y + TOLERANCE < C.center.y || k == "up" && M.y - TOLERANCE > C.center.y || k == "left" && M.x - TOLERANCE > C.center.x || k == "right" && M.x + TOLERANCE < C.center.x) && (N.push(m), m.shape = C, P.push(() => m.shape = S));
					}
				}), m.preventDefault(), T.disable();
				let F = T.computeCollisions(N, closestCorners$1);
				r(() => P.forEach((m) => m()));
				let [I] = F;
				if (!I) return;
				let { id: L } = I, { index: R, group: z } = A.sortable;
				C.setDropTarget(L).then(() => {
					let { source: m, target: x, shape: D } = S;
					if (!m || !isSortable(m) || !D) return;
					let { index: O, group: k, target: A } = m.sortable, j = R !== O || z !== k, M = j ? A : x?.element;
					if (!M) return;
					scrollIntoViewIfNeeded(M);
					let N = new DOMRectangle(M);
					if (!N) return;
					let P = Rectangle.delta(N, Rectangle.from(D.current.boundingRectangle), m.alignment);
					C.move({ by: P }), j ? C.setDropTarget(m.id).then(() => T.enable()) : T.enable();
				});
			});
		});
		this.destroy = () => {
			S(), x();
		};
	}
};
function getDirection$1(m) {
	let { x, y: S } = m;
	if (x > 0) return "right";
	if (x < 0) return "left";
	if (S > 0) return "down";
	if (S < 0) return "up";
}
var __defProp2 = Object.defineProperty, __defProps2 = Object.defineProperties, __getOwnPropDescs2 = Object.getOwnPropertyDescriptors, __getOwnPropSymbols2 = Object.getOwnPropertySymbols, __hasOwnProp2 = Object.prototype.hasOwnProperty, __propIsEnum2 = Object.prototype.propertyIsEnumerable, __defNormalProp2 = (m, x, S) => x in m ? __defProp2(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues2 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp2.call(x, S) && __defNormalProp2(m, S, x[S]);
	if (__getOwnPropSymbols2) for (var S of __getOwnPropSymbols2(x)) __propIsEnum2.call(x, S) && __defNormalProp2(m, S, x[S]);
	return m;
}, __spreadProps2 = (m, x) => __defProps2(m, __getOwnPropDescs2(x));
function arrayMove(m, x, S) {
	if (x === S) return m;
	let C = m.slice();
	return C.splice(S, 0, C.splice(x, 1)[0]), C;
}
function mutate(m, x, S) {
	let { source: C, target: T, canceled: D } = x.operation;
	if (!C || !T || D) return "preventDefault" in x && x.preventDefault(), m;
	let O = (m, x) => m === x || typeof m == "object" && "id" in m && m.id === x;
	if (Array.isArray(m)) {
		let x = m.findIndex((m) => O(m, C.id)), k = m.findIndex((m) => O(m, T.id));
		if (x === -1 || k === -1) return m;
		if (!D && "index" in C && typeof C.index == "number") {
			let T = C.index;
			if (T !== x) return S(m, x, T);
		}
		return S(m, x, k);
	}
	let k = Object.entries(m), A = -1, j, M = -1, N;
	for (let [m, x] of k) if (A === -1 && (A = x.findIndex((m) => O(m, C.id)), A !== -1 && (j = m)), M === -1 && (M = x.findIndex((m) => O(m, T.id)), M !== -1 && (N = m)), A !== -1 && M !== -1) break;
	if (!C.manager) return m;
	let { dragOperation: P } = C.manager, F = P.shape?.current.center ?? P.position.current;
	if (N == null && T.id in m) {
		let x = T.shape && F.y > T.shape.center.y ? m[T.id].length : 0;
		N = T.id, M = x;
	}
	if (j == null || N == null || j === N && A === M) return "preventDefault" in x && x.preventDefault(), m;
	if (j === N) return __spreadProps2(__spreadValues2({}, m), { [j]: S(m[j], A, M) });
	let I = T.shape && Math.round(F.y) > Math.round(T.shape.center.y) ? 1 : 0, L = m[j][A];
	return __spreadProps2(__spreadValues2({}, m), {
		[j]: [...m[j].slice(0, A), ...m[j].slice(A + 1)],
		[N]: [
			...m[N].slice(0, M + I),
			L,
			...m[N].slice(M + I)
		]
	});
}
function move(m, x) {
	return mutate(m, x, arrayMove);
}
var defaultGroup = "__default__", OptimisticSortingPlugin = class extends Plugin {
	constructor(m) {
		super(m);
		let x = () => {
			let x = /* @__PURE__ */ new Map();
			for (let S of m.registry.droppables) if (S instanceof SortableDroppable) {
				let { sortable: m } = S, { group: C } = m, T = x.get(C);
				T || (T = /* @__PURE__ */ new Set(), x.set(C, T)), T.add(m);
			}
			for (let [m, S] of x) x.set(m, new Set(sort(S)));
			return x;
		}, S = [m.monitor.addEventListener("dragover", (m, S) => {
			if (this.disabled) return;
			let { dragOperation: C } = S, { source: T, target: D } = C;
			if (!isSortable(T) || !isSortable(D) || T.sortable === D.sortable) return;
			let O = x(), k = T.sortable.group === D.sortable.group, A = O.get(T.sortable.group), j = k ? A : O.get(D.sortable.group);
			!A || !j || queueMicrotask(() => {
				m.defaultPrevented || S.renderer.rendering.then(() => {
					let C = x();
					for (let [m, x] of O.entries()) {
						let S = Array.from(x).entries();
						for (let [x, T] of S) if (T.index !== x || T.group !== m || !C.get(m)?.has(T)) return;
					}
					let M = T.sortable.element, N = D.sortable.element;
					if (!N || !M || !k && D.id === T.sortable.group) return;
					let P = sort(A), F = k ? P : sort(j), I = T.sortable.group ?? defaultGroup, L = D.sortable.group ?? defaultGroup, R = {
						[I]: P,
						[L]: F
					}, z = move(R, m);
					if (R === z) return;
					let B = z[L].indexOf(T.sortable), H = z[L].indexOf(D.sortable);
					S.collisionObserver.disable(), reorder$1(M, B, N, H), r(() => {
						for (let [m, x] of z[I].entries()) x.index = m;
						if (!k) for (let [m, x] of z[L].entries()) x.group = D.sortable.group, x.index = m;
					}), S.actions.setDropTarget(T.id).then(() => S.collisionObserver.enable());
				});
			});
		}), m.monitor.addEventListener("dragend", (m, S) => {
			if (!m.canceled) return;
			let { dragOperation: C } = S, { source: T } = C;
			isSortable(T) && (T.sortable.initialIndex === T.sortable.index && T.sortable.initialGroup === T.sortable.group || queueMicrotask(() => {
				let m = x(), C = m.get(T.sortable.initialGroup);
				C && S.renderer.rendering.then(() => {
					for (let [x, S] of m.entries()) {
						let m = Array.from(S).entries();
						for (let [S, C] of m) if (C.index !== S || C.group !== x) return;
					}
					let x = sort(C), S = T.sortable.element, D = x[T.sortable.initialIndex], O = D?.element;
					!D || !O || !S || (reorder$1(S, D.index, O, T.index), r(() => {
						for (let [x, S] of m.entries()) {
							let m = Array.from(S).values();
							for (let x of m) x.index = x.initialIndex, x.group = x.initialGroup;
						}
					}));
				});
			}));
		})];
		this.destroy = () => {
			for (let m of S) m();
		};
	}
};
function reorder$1(m, x, S, C) {
	let T = C < x ? "afterend" : "beforebegin";
	S.insertAdjacentElement(T, m);
}
function sortByIndex(m, x) {
	return m.index - x.index;
}
function sort(m) {
	return Array.from(m).sort(sortByIndex);
}
var defaultPlugins = [SortableKeyboardPlugin, OptimisticSortingPlugin], defaultSortableTransition = {
	duration: 250,
	easing: "cubic-bezier(0.25, 1, 0.5, 1)",
	idle: !1
}, store = new WeakStore(), _group_dec, _index_dec = [reactive], _init, _index, _previousGroup, _previousIndex, _group, _element;
_group_dec = [reactive];
var Sortable2 = class {
	constructor(m, x) {
		__privateAdd(this, _index, __runInitializers(_init, 8, this)), __runInitializers(_init, 11, this), __privateAdd(this, _previousGroup), __privateAdd(this, _previousIndex), __privateAdd(this, _group, __runInitializers(_init, 12, this)), __runInitializers(_init, 15, this), __privateAdd(this, _element), this.register = () => (r(() => {
			var m, x;
			(m = this.manager) == null || m.registry.register(this.droppable), (x = this.manager) == null || x.registry.register(this.draggable);
		}), () => this.unregister()), this.unregister = () => {
			r(() => {
				var m, x;
				(m = this.manager) == null || m.registry.unregister(this.droppable), (x = this.manager) == null || x.registry.unregister(this.draggable);
			});
		}, this.destroy = () => {
			r(() => {
				this.droppable.destroy(), this.draggable.destroy();
			});
		};
		var S = m, { effects: C = () => [], group: T, index: D, sensors: O, type: k, transition: A = defaultSortableTransition, plugins: j = defaultPlugins } = S, M = __objRest$1(S, [
			"effects",
			"group",
			"index",
			"sensors",
			"type",
			"transition",
			"plugins"
		]);
		this.droppable = new SortableDroppable(M, x, this), this.draggable = new SortableDraggable(__spreadProps$2(__spreadValues$2({}, M), {
			effects: () => [
				() => {
					let m = this.manager?.dragOperation.status;
					m?.initializing && this.id === this.manager?.dragOperation.source?.id && store.clear(this.manager), m?.dragging && store.set(this.manager, this.id, n(() => ({
						initialIndex: this.index,
						initialGroup: this.group
					})));
				},
				() => {
					let { index: m, group: x, manager: S } = this, C = __privateGet(this, _previousIndex), T = __privateGet(this, _previousGroup);
					(m !== C || x !== T) && (__privateSet(this, _previousIndex, m), __privateSet(this, _previousGroup, x), this.animate());
				},
				() => {
					let { target: m } = this, { feedback: x, isDragSource: S } = this.draggable;
					x == "move" && S && (this.droppable.disabled = !m);
				},
				() => {
					let { manager: m } = this;
					for (let x of j) m?.registry.register(x);
				},
				...C()
			],
			type: k,
			sensors: O
		}), x, this), __privateSet(this, _element, M.element), this.manager = x, this.index = D, __privateSet(this, _previousIndex, D), this.group = T, __privateSet(this, _previousGroup, T), this.type = k, this.transition = A;
	}
	get initialIndex() {
		return store.get(this.manager, this.id)?.initialIndex ?? this.index;
	}
	get initialGroup() {
		return store.get(this.manager, this.id)?.initialGroup ?? this.group;
	}
	animate() {
		n(() => {
			let { manager: m, transition: x } = this, { shape: S } = this.droppable;
			if (!m) return;
			let { idle: C } = m.dragOperation.status;
			!S || !x || C && !x.idle || m.renderer.rendering.then(() => {
				let { element: C } = this;
				if (!C) return;
				let T = this.refreshShape();
				if (!T) return;
				let D = {
					x: S.boundingRectangle.left - T.boundingRectangle.left,
					y: S.boundingRectangle.top - T.boundingRectangle.top
				}, { translate: O } = getComputedStyles(C), k = computeTranslate(C, O, !1), A = computeTranslate(C, O);
				(D.x || D.y) && animateTransform({
					element: C,
					keyframes: { translate: [`${k.x + D.x}px ${k.y + D.y}px ${k.z}`, `${A.x}px ${A.y}px ${A.z}`] },
					options: x
				}).then(() => {
					m.dragOperation.status.dragging || (this.droppable.shape = void 0);
				});
			});
		});
	}
	get manager() {
		return this.draggable.manager;
	}
	set manager(m) {
		r(() => {
			this.draggable.manager = m, this.droppable.manager = m;
		});
	}
	set element(m) {
		r(() => {
			let x = __privateGet(this, _element), S = this.droppable.element, C = this.draggable.element;
			(!S || S === x) && (this.droppable.element = m), (!C || C === x) && (this.draggable.element = m), __privateSet(this, _element, m);
		});
	}
	get element() {
		let m = __privateGet(this, _element);
		if (m) return ProxiedElements.get(m) ?? m ?? this.droppable.element;
	}
	set target(m) {
		this.droppable.element = m;
	}
	get target() {
		return this.droppable.element;
	}
	set source(m) {
		this.draggable.element = m;
	}
	get source() {
		return this.draggable.element;
	}
	get disabled() {
		return this.draggable.disabled && this.droppable.disabled;
	}
	set feedback(m) {
		this.draggable.feedback = m;
	}
	set disabled(m) {
		r(() => {
			this.droppable.disabled = m, this.draggable.disabled = m;
		});
	}
	set data(m) {
		r(() => {
			this.droppable.data = m, this.draggable.data = m;
		});
	}
	set handle(m) {
		this.draggable.handle = m;
	}
	set id(m) {
		r(() => {
			this.droppable.id = m, this.draggable.id = m;
		});
	}
	get id() {
		return this.droppable.id;
	}
	set sensors(m) {
		this.draggable.sensors = m;
	}
	set modifiers(m) {
		this.draggable.modifiers = m;
	}
	set collisionPriority(m) {
		this.droppable.collisionPriority = m;
	}
	set collisionDetector(m) {
		this.droppable.collisionDetector = m ?? defaultCollisionDetection;
	}
	set alignment(m) {
		this.draggable.alignment = m;
	}
	get alignment() {
		return this.draggable.alignment;
	}
	set type(m) {
		r(() => {
			this.droppable.type = m, this.draggable.type = m;
		});
	}
	get type() {
		return this.draggable.type;
	}
	set accept(m) {
		this.droppable.accept = m;
	}
	get accept() {
		return this.droppable.accept;
	}
	get isDropTarget() {
		return this.droppable.isDropTarget;
	}
	get isDragSource() {
		return this.draggable.isDragSource;
	}
	get isDragging() {
		return this.draggable.isDragging;
	}
	get isDropping() {
		return this.draggable.isDropping;
	}
	get status() {
		return this.draggable.status;
	}
	refreshShape() {
		return this.droppable.refreshShape();
	}
	accepts(m) {
		return this.droppable.accepts(m);
	}
};
_init = __decoratorStart(), _index = /* @__PURE__ */ new WeakMap(), _previousGroup = /* @__PURE__ */ new WeakMap(), _previousIndex = /* @__PURE__ */ new WeakMap(), _group = /* @__PURE__ */ new WeakMap(), _element = /* @__PURE__ */ new WeakMap(), __decorateElement(_init, 4, "index", _index_dec, Sortable2, _index), __decorateElement(_init, 4, "group", _group_dec, Sortable2, _group), __decoratorMetadata(_init, Sortable2);
var SortableDraggable = class extends Draggable {
	constructor(m, x, S) {
		super(m, x), this.sortable = S;
	}
	get index() {
		return this.sortable.index;
	}
}, SortableDroppable = class extends Droppable {
	constructor(m, x, S) {
		super(m, x), this.sortable = S;
	}
}, __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (m, x, S) => x in m ? __defProp(m, x, {
	enumerable: !0,
	configurable: !0,
	writable: !0,
	value: S
}) : m[x] = S, __spreadValues$1 = (m, x) => {
	for (var S in x ||= {}) __hasOwnProp.call(x, S) && __defNormalProp(m, S, x[S]);
	if (__getOwnPropSymbols) for (var S of __getOwnPropSymbols(x)) __propIsEnum.call(x, S) && __defNormalProp(m, S, x[S]);
	return m;
}, __spreadProps$1 = (m, x) => __defProps(m, __getOwnPropDescs(x));
function useSortable(m) {
	let { accept: x, collisionDetector: S, collisionPriority: C, id: T, data: D, element: O, handle: k, index: A, group: j, disabled: N, feedback: P, modifiers: F, sensors: I, target: L, type: R } = m, z = __spreadValues$1(__spreadValues$1({}, defaultSortableTransition), m.transition), B = useInstance((x) => new Sortable2(__spreadProps$1(__spreadValues$1({}, m), {
		transition: z,
		register: !1,
		handle: currentValue(k),
		element: currentValue(O),
		target: currentValue(L),
		feedback: P
	}), x)), H = useDeepSignal(B, shouldUpdateSynchronously);
	return useOnValueChange(T, () => B.id = T), useIsomorphicLayoutEffect$3(() => {
		r(() => {
			B.group = j, B.index = A;
		});
	}, [
		B,
		j,
		A
	]), useOnValueChange(R, () => B.type = R), useOnValueChange(x, () => B.accept = x, void 0, deepEqual), useOnValueChange(D, () => D && (B.data = D)), useOnValueChange(A, () => {
		B.manager?.dragOperation.status.idle && z?.idle && B.refreshShape();
	}, useImmediateEffect), useOnElementChange(k, (m) => B.handle = m), useOnElementChange(O, (m) => B.element = m), useOnElementChange(L, (m) => B.target = m), useOnValueChange(N, () => B.disabled = N === !0), useOnValueChange(I, () => B.sensors = I), useOnValueChange(S, () => B.collisionDetector = S), useOnValueChange(C, () => B.collisionPriority = C), useOnValueChange(P, () => B.feedback = P ?? "default"), useOnValueChange(z, () => B.transition = z, void 0, deepEqual), useOnValueChange(F, () => B.modifiers = F, void 0, deepEqual), useOnValueChange(m.alignment, () => B.alignment = m.alignment), {
		sortable: H,
		get isDragging() {
			return H.isDragging;
		},
		get isDropping() {
			return H.isDropping;
		},
		get isDragSource() {
			return H.isDragSource;
		},
		get isDropTarget() {
			return H.isDropTarget;
		},
		handleRef: useCallback((m) => {
			B.handle = m ?? void 0;
		}, [B]),
		ref: useCallback((m) => {
			!m && B.element?.isConnected && !B.manager?.dragOperation.status.idle || (B.element = m ?? void 0);
		}, [B]),
		sourceRef: useCallback((m) => {
			!m && B.source?.isConnected && !B.manager?.dragOperation.status.idle || (B.source = m ?? void 0);
		}, [B]),
		targetRef: useCallback((m) => {
			!m && B.target?.isConnected && !B.manager?.dragOperation.status.idle || (B.target = m ?? void 0);
		}, [B])
	};
}
function shouldUpdateSynchronously(m, x, S) {
	return !!(m === "isDragSource" && !S && x);
}
var isIterable = (m) => Symbol.iterator in m, hasIterableEntries = (m) => "entries" in m, compareEntries = (m, x) => {
	let S = m instanceof Map ? m : new Map(m.entries()), C = x instanceof Map ? x : new Map(x.entries());
	if (S.size !== C.size) return !1;
	for (let [m, x] of S) if (!C.has(m) || !Object.is(x, C.get(m))) return !1;
	return !0;
}, compareIterables = (m, x) => {
	let S = m[Symbol.iterator](), C = x[Symbol.iterator](), T = S.next(), D = C.next();
	for (; !T.done && !D.done;) {
		if (!Object.is(T.value, D.value)) return !1;
		T = S.next(), D = C.next();
	}
	return !!T.done && !!D.done;
};
function shallow(m, x) {
	return Object.is(m, x) ? !0 : typeof m != "object" || !m || typeof x != "object" || !x || Object.getPrototypeOf(m) !== Object.getPrototypeOf(x) ? !1 : isIterable(m) && isIterable(x) ? hasIterableEntries(m) && hasIterableEntries(x) ? compareEntries(m, x) : compareIterables(m, x) : compareEntries({ entries: () => Object.entries(m) }, { entries: () => Object.entries(x) });
}
function useShallow(m) {
	let S = React.useRef(void 0);
	return (x) => {
		let C = m(x);
		return shallow(S.current, C) ? S.current : S.current = C;
	};
}
function c(m, x, S) {
	var C = this, T = useRef(null), D = useRef(0), O = useRef(null), k = useRef([]), A = useRef(), j = useRef(), M = useRef(m), N = useRef(!0);
	useEffect(function() {
		M.current = m;
	}, [m]);
	var F = !x && x !== 0 && typeof window < "u";
	if (typeof m != "function") throw TypeError("Expected a function");
	x = +x || 0;
	var I = !!(S ||= {}).leading, L = !("trailing" in S) || !!S.trailing, R = "maxWait" in S, H = R ? Math.max(+S.maxWait || 0, x) : null;
	return useEffect(function() {
		return N.current = !0, function() {
			N.current = !1;
		};
	}, []), useMemo(function() {
		var m = function(m) {
			var x = k.current, S = A.current;
			return k.current = A.current = null, D.current = m, j.current = M.current.apply(S, x);
		}, S = function(m, x) {
			F && cancelAnimationFrame(O.current), O.current = F ? requestAnimationFrame(m) : setTimeout(m, x);
		}, P = function(m) {
			if (!N.current) return !1;
			var S = m - T.current;
			return !T.current || S >= x || S < 0 || R && m - D.current >= H;
		}, z = function(x) {
			return O.current = null, L && k.current ? m(x) : (k.current = A.current = null, j.current);
		}, B = function m() {
			var C = Date.now();
			if (P(C)) return z(C);
			if (N.current) {
				var O = x - (C - T.current);
				S(m, R ? Math.min(O, H - (C - D.current)) : O);
			}
		}, U = function() {
			var M = Date.now(), F = P(M);
			if (k.current = [].slice.call(arguments), A.current = C, T.current = M, F) {
				if (!O.current && N.current) return D.current = T.current, S(B, x), I ? m(T.current) : j.current;
				if (R) return S(B, x), m(T.current);
			}
			return O.current || S(B, x), j.current;
		};
		return U.cancel = function() {
			O.current && (F ? cancelAnimationFrame(O.current) : clearTimeout(O.current)), D.current = 0, k.current = T.current = A.current = O.current = null;
		}, U.isPending = function() {
			return !!O.current;
		}, U.flush = function() {
			return O.current ? z(Date.now()) : j.current;
		}, U;
	}, [
		I,
		R,
		x,
		H,
		L,
		F
	]);
}
var import_object_hash = /* @__PURE__ */ __toESM$1((/* @__PURE__ */ __commonJSMin(((m, x) => {
	(function(S) {
		var C;
		typeof m == "object" ? x.exports = S() : typeof define == "function" && define.amd ? define(S) : (typeof window < "u" ? C = window : typeof global < "u" ? C = global : typeof self < "u" && (C = self), C.objectHash = S());
	})(function() {
		return function m(x, S, C) {
			function T(O, k) {
				if (!S[O]) {
					if (!x[O]) {
						var A = typeof __require == "function" && __require;
						if (!k && A) return A(O, !0);
						if (D) return D(O, !0);
						throw Error("Cannot find module '" + O + "'");
					}
					k = S[O] = { exports: {} }, x[O][0].call(k.exports, function(m) {
						var S = x[O][1][m];
						return T(S || m);
					}, k, k.exports, m, x, S, C);
				}
				return S[O].exports;
			}
			for (var D = typeof __require == "function" && __require, O = 0; O < C.length; O++) T(C[O]);
			return T;
		}({
			1: [function(m, x, S) {
				(function(C, T, D, O, k, A, j, M, N) {
					var P = m("crypto");
					function F(m, x) {
						x = R(m, x);
						var S;
						return (S = x.algorithm === "passthrough" ? new H() : P.createHash(x.algorithm)).write === void 0 && (S.write = S.update, S.end = S.update), B(x, S).dispatch(m), S.update || S.end(""), S.digest ? S.digest(x.encoding === "buffer" ? void 0 : x.encoding) : (m = S.read(), x.encoding === "buffer" ? m : m.toString(x.encoding));
					}
					(S = x.exports = F).sha1 = function(m) {
						return F(m);
					}, S.keys = function(m) {
						return F(m, {
							excludeValues: !0,
							algorithm: "sha1",
							encoding: "hex"
						});
					}, S.MD5 = function(m) {
						return F(m, {
							algorithm: "md5",
							encoding: "hex"
						});
					}, S.keysMD5 = function(m) {
						return F(m, {
							algorithm: "md5",
							encoding: "hex",
							excludeValues: !0
						});
					};
					var I = P.getHashes ? P.getHashes().slice() : ["sha1", "md5"], L = (I.push("passthrough"), [
						"buffer",
						"hex",
						"binary",
						"base64"
					]);
					function R(m, x) {
						var S = {};
						if (S.algorithm = (x ||= {}).algorithm || "sha1", S.encoding = x.encoding || "hex", S.excludeValues = !!x.excludeValues, S.algorithm = S.algorithm.toLowerCase(), S.encoding = S.encoding.toLowerCase(), S.ignoreUnknown = !0 === x.ignoreUnknown, S.respectType = !1 !== x.respectType, S.respectFunctionNames = !1 !== x.respectFunctionNames, S.respectFunctionProperties = !1 !== x.respectFunctionProperties, S.unorderedArrays = !0 === x.unorderedArrays, S.unorderedSets = !1 !== x.unorderedSets, S.unorderedObjects = !1 !== x.unorderedObjects, S.replacer = x.replacer || void 0, S.excludeKeys = x.excludeKeys || void 0, m === void 0) throw Error("Object argument required.");
						for (var C = 0; C < I.length; ++C) I[C].toLowerCase() === S.algorithm.toLowerCase() && (S.algorithm = I[C]);
						if (I.indexOf(S.algorithm) === -1) throw Error("Algorithm \"" + S.algorithm + "\"  not supported. supported values: " + I.join(", "));
						if (L.indexOf(S.encoding) === -1 && S.algorithm !== "passthrough") throw Error("Encoding \"" + S.encoding + "\"  not supported. supported values: " + L.join(", "));
						return S;
					}
					function z(m) {
						if (typeof m == "function") return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(m)) != null;
					}
					function B(m, x, S) {
						S ||= [];
						function C(m) {
							return x.update ? x.update(m, "utf8") : x.write(m, "utf8");
						}
						return {
							dispatch: function(x) {
								return this["_" + ((x = m.replacer ? m.replacer(x) : x) === null ? "null" : typeof x)](x);
							},
							_object: function(x) {
								var T, O = Object.prototype.toString.call(x), k = /\[object (.*)\]/i.exec(O);
								if (k = (k = k ? k[1] : "unknown:[" + O + "]").toLowerCase(), 0 <= (O = S.indexOf(x))) return this.dispatch("[CIRCULAR:" + O + "]");
								if (S.push(x), D !== void 0 && D.isBuffer && D.isBuffer(x)) return C("buffer:"), C(x);
								if (k === "object" || k === "function" || k === "asyncfunction") return O = Object.keys(x), m.unorderedObjects && (O = O.sort()), !1 === m.respectType || z(x) || O.splice(0, 0, "prototype", "__proto__", "constructor"), m.excludeKeys && (O = O.filter(function(x) {
									return !m.excludeKeys(x);
								})), C("object:" + O.length + ":"), T = this, O.forEach(function(S) {
									T.dispatch(S), C(":"), m.excludeValues || T.dispatch(x[S]), C(",");
								});
								if (!this["_" + k]) {
									if (m.ignoreUnknown) return C("[" + k + "]");
									throw Error("Unknown object type \"" + k + "\"");
								}
								this["_" + k](x);
							},
							_array: function(x, T) {
								T = T === void 0 ? !1 !== m.unorderedArrays : T;
								var D = this;
								if (C("array:" + x.length + ":"), !T || x.length <= 1) return x.forEach(function(m) {
									return D.dispatch(m);
								});
								var O = [], T = x.map(function(x) {
									var C = new H(), T = S.slice();
									return B(m, C, T).dispatch(x), O = O.concat(T.slice(S.length)), C.read().toString();
								});
								return S = S.concat(O), T.sort(), this._array(T, !1);
							},
							_date: function(m) {
								return C("date:" + m.toJSON());
							},
							_symbol: function(m) {
								return C("symbol:" + m.toString());
							},
							_error: function(m) {
								return C("error:" + m.toString());
							},
							_boolean: function(m) {
								return C("bool:" + m.toString());
							},
							_string: function(m) {
								C("string:" + m.length + ":"), C(m.toString());
							},
							_function: function(x) {
								C("fn:"), z(x) ? this.dispatch("[native]") : this.dispatch(x.toString()), !1 !== m.respectFunctionNames && this.dispatch("function-name:" + String(x.name)), m.respectFunctionProperties && this._object(x);
							},
							_number: function(m) {
								return C("number:" + m.toString());
							},
							_xml: function(m) {
								return C("xml:" + m.toString());
							},
							_null: function() {
								return C("Null");
							},
							_undefined: function() {
								return C("Undefined");
							},
							_regexp: function(m) {
								return C("regex:" + m.toString());
							},
							_uint8array: function(m) {
								return C("uint8array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_uint8clampedarray: function(m) {
								return C("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_int8array: function(m) {
								return C("int8array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_uint16array: function(m) {
								return C("uint16array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_int16array: function(m) {
								return C("int16array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_uint32array: function(m) {
								return C("uint32array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_int32array: function(m) {
								return C("int32array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_float32array: function(m) {
								return C("float32array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_float64array: function(m) {
								return C("float64array:"), this.dispatch(Array.prototype.slice.call(m));
							},
							_arraybuffer: function(m) {
								return C("arraybuffer:"), this.dispatch(new Uint8Array(m));
							},
							_url: function(m) {
								return C("url:" + m.toString());
							},
							_map: function(x) {
								return C("map:"), x = Array.from(x), this._array(x, !1 !== m.unorderedSets);
							},
							_set: function(x) {
								return C("set:"), x = Array.from(x), this._array(x, !1 !== m.unorderedSets);
							},
							_file: function(m) {
								return C("file:"), this.dispatch([
									m.name,
									m.size,
									m.type,
									m.lastModfied
								]);
							},
							_blob: function() {
								if (m.ignoreUnknown) return C("[blob]");
								throw Error("Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse \"options.replacer\" or \"options.ignoreUnknown\"\n");
							},
							_domwindow: function() {
								return C("domwindow");
							},
							_bigint: function(m) {
								return C("bigint:" + m.toString());
							},
							_process: function() {
								return C("process");
							},
							_timer: function() {
								return C("timer");
							},
							_pipe: function() {
								return C("pipe");
							},
							_tcp: function() {
								return C("tcp");
							},
							_udp: function() {
								return C("udp");
							},
							_tty: function() {
								return C("tty");
							},
							_statwatcher: function() {
								return C("statwatcher");
							},
							_securecontext: function() {
								return C("securecontext");
							},
							_connection: function() {
								return C("connection");
							},
							_zlib: function() {
								return C("zlib");
							},
							_context: function() {
								return C("context");
							},
							_nodescript: function() {
								return C("nodescript");
							},
							_httpparser: function() {
								return C("httpparser");
							},
							_dataview: function() {
								return C("dataview");
							},
							_signal: function() {
								return C("signal");
							},
							_fsevent: function() {
								return C("fsevent");
							},
							_tlswrap: function() {
								return C("tlswrap");
							}
						};
					}
					function H() {
						return {
							buf: "",
							write: function(m) {
								this.buf += m;
							},
							end: function(m) {
								this.buf += m;
							},
							read: function() {
								return this.buf;
							}
						};
					}
					S.writeToStream = function(m, x, S) {
						return S === void 0 && (S = x, x = {}), B(x = R(m, x), S).dispatch(m);
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
			}, {
				buffer: 3,
				crypto: 5,
				lYpoI2: 11
			}],
			2: [function(m, x, S) {
				(function(m, x, C, T, D, O, k, A, j) {
					(function(m) {
						var x = typeof Uint8Array < "u" ? Uint8Array : Array, S = 43, C = 47, T = 48, D = 97, O = 65, k = 45, A = 95;
						function j(m) {
							return m = m.charCodeAt(0), m === S || m === k ? 62 : m === C || m === A ? 63 : m < T ? -1 : m < T + 10 ? m - T + 26 + 26 : m < O + 26 ? m - O : m < D + 26 ? m - D + 26 : void 0;
						}
						m.toByteArray = function(m) {
							var S, C;
							if (0 < m.length % 4) throw Error("Invalid string. Length must be a multiple of 4");
							var T = m.length, T = m.charAt(T - 2) === "=" ? 2 : m.charAt(T - 1) === "=" ? 1 : 0, D = new x(3 * m.length / 4 - T), O = 0 < T ? m.length - 4 : m.length, k = 0;
							function A(m) {
								D[k++] = m;
							}
							for (S = 0; S < O; S += 4) A((16711680 & (C = j(m.charAt(S)) << 18 | j(m.charAt(S + 1)) << 12 | j(m.charAt(S + 2)) << 6 | j(m.charAt(S + 3)))) >> 16), A((65280 & C) >> 8), A(255 & C);
							return T == 2 ? A(255 & (C = j(m.charAt(S)) << 2 | j(m.charAt(S + 1)) >> 4)) : T == 1 && (A((C = j(m.charAt(S)) << 10 | j(m.charAt(S + 1)) << 4 | j(m.charAt(S + 2)) >> 2) >> 8 & 255), A(255 & C)), D;
						}, m.fromByteArray = function(m) {
							var x, S, C, T, D = m.length % 3, O = "";
							function k(m) {
								return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(m);
							}
							for (x = 0, C = m.length - D; x < C; x += 3) S = (m[x] << 16) + (m[x + 1] << 8) + m[x + 2], O += k((T = S) >> 18 & 63) + k(T >> 12 & 63) + k(T >> 6 & 63) + k(63 & T);
							switch (D) {
								case 1:
									O = (O += k((S = m[m.length - 1]) >> 2)) + k(S << 4 & 63) + "==";
									break;
								case 2: O = (O = (O += k((S = (m[m.length - 2] << 8) + m[m.length - 1]) >> 10)) + k(S >> 4 & 63)) + k(S << 2 & 63) + "=";
							}
							return O;
						};
					})(S === void 0 ? this.base64js = {} : S);
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
			}, {
				buffer: 3,
				lYpoI2: 11
			}],
			3: [function(m, x, S) {
				(function(x, C, T, D, O, k, A, j, M) {
					var N = m("base64-js"), P = m("ieee754");
					function T(m, x, S) {
						if (!(this instanceof T)) return new T(m, x, S);
						var C, D, O, k, A = typeof m;
						if (x === "base64" && A == "string") for (m = (k = m).trim ? k.trim() : k.replace(/^\s+|\s+$/g, ""); m.length % 4 != 0;) m += "=";
						if (A == "number") C = Q(m);
						else if (A == "string") C = T.byteLength(m, x);
						else {
							if (A != "object") throw Error("First argument needs to be a number, array or string.");
							C = Q(m.length);
						}
						if (T._useTypedArrays ? D = T._augment(new Uint8Array(C)) : ((D = this).length = C, D._isBuffer = !0), T._useTypedArrays && typeof m.byteLength == "number") D._set(m);
						else if (cH(k = m) || T.isBuffer(k) || k && typeof k == "object" && typeof k.length == "number") for (O = 0; O < C; O++) T.isBuffer(m) ? D[O] = m.readUInt8(O) : D[O] = m[O];
						else if (A == "string") D.write(m, 0, x);
						else if (A == "number" && !T._useTypedArrays && !S) for (O = 0; O < C; O++) D[O] = 0;
						return D;
					}
					function F(m, x, S, C) {
						return T._charsWritten = fH(function(m) {
							for (var x = [], S = 0; S < m.length; S++) x.push(255 & m.charCodeAt(S));
							return x;
						}(x), m, S, C);
					}
					function I(m, x, S, C) {
						return T._charsWritten = fH(function(m) {
							for (var x, S, C = [], T = 0; T < m.length; T++) S = m.charCodeAt(T), x = S >> 8, S %= 256, C.push(S), C.push(x);
							return C;
						}(x), m, S, C);
					}
					function L(m, x, S) {
						var C = "";
						S = Math.min(m.length, S);
						for (var T = x; T < S; T++) C += String.fromCharCode(m[T]);
						return C;
					}
					function R(m, x, S, C) {
						C || ($(typeof S == "boolean", "missing or invalid endian"), $(x != null, "missing offset"), $(x + 1 < m.length, "Trying to read beyond buffer length"));
						var T, C = m.length;
						if (!(C <= x)) return S ? (T = m[x], x + 1 < C && (T |= m[x + 1] << 8)) : (T = m[x] << 8, x + 1 < C && (T |= m[x + 1])), T;
					}
					function z(m, x, S, C) {
						C || ($(typeof S == "boolean", "missing or invalid endian"), $(x != null, "missing offset"), $(x + 3 < m.length, "Trying to read beyond buffer length"));
						var T, C = m.length;
						if (!(C <= x)) return S ? (x + 2 < C && (T = m[x + 2] << 16), x + 1 < C && (T |= m[x + 1] << 8), T |= m[x], x + 3 < C && (T += m[x + 3] << 24 >>> 0)) : (x + 1 < C && (T = m[x + 1] << 16), x + 2 < C && (T |= m[x + 2] << 8), x + 3 < C && (T |= m[x + 3]), T += m[x] << 24 >>> 0), T;
					}
					function B(m, x, S, C) {
						if (C || ($(typeof S == "boolean", "missing or invalid endian"), $(x != null, "missing offset"), $(x + 1 < m.length, "Trying to read beyond buffer length")), !(m.length <= x)) return C = R(m, x, S, !0), 32768 & C ? -1 * (65535 - C + 1) : C;
					}
					function H(m, x, S, C) {
						if (C || ($(typeof S == "boolean", "missing or invalid endian"), $(x != null, "missing offset"), $(x + 3 < m.length, "Trying to read beyond buffer length")), !(m.length <= x)) return C = z(m, x, S, !0), 2147483648 & C ? -1 * (4294967295 - C + 1) : C;
					}
					function U(m, x, S, C) {
						return C || ($(typeof S == "boolean", "missing or invalid endian"), $(x + 3 < m.length, "Trying to read beyond buffer length")), P.read(m, x, S, 23, 4);
					}
					function W(m, x, S, C) {
						return C || ($(typeof S == "boolean", "missing or invalid endian"), $(x + 7 < m.length, "Trying to read beyond buffer length")), P.read(m, x, S, 52, 8);
					}
					function G(m, x, S, C, T) {
						if (T || ($(x != null, "missing value"), $(typeof C == "boolean", "missing or invalid endian"), $(S != null, "missing offset"), $(S + 1 < m.length, "trying to write beyond buffer length"), mH(x, 65535)), T = m.length, !(T <= S)) for (var D = 0, O = Math.min(T - S, 2); D < O; D++) m[S + D] = (x & 255 << 8 * (C ? D : 1 - D)) >>> 8 * (C ? D : 1 - D);
					}
					function K(m, x, S, C, T) {
						if (T || ($(x != null, "missing value"), $(typeof C == "boolean", "missing or invalid endian"), $(S != null, "missing offset"), $(S + 3 < m.length, "trying to write beyond buffer length"), mH(x, 4294967295)), T = m.length, !(T <= S)) for (var D = 0, O = Math.min(T - S, 4); D < O; D++) m[S + D] = x >>> 8 * (C ? D : 3 - D) & 255;
					}
					function q(m, x, S, C, T) {
						T || ($(x != null, "missing value"), $(typeof C == "boolean", "missing or invalid endian"), $(S != null, "missing offset"), $(S + 1 < m.length, "Trying to write beyond buffer length"), hH(x, 32767, -32768)), m.length <= S || G(m, 0 <= x ? x : 65535 + x + 1, S, C, T);
					}
					function J(m, x, S, C, T) {
						T || ($(x != null, "missing value"), $(typeof C == "boolean", "missing or invalid endian"), $(S != null, "missing offset"), $(S + 3 < m.length, "Trying to write beyond buffer length"), hH(x, 2147483647, -2147483648)), m.length <= S || K(m, 0 <= x ? x : 4294967295 + x + 1, S, C, T);
					}
					function Y(m, x, S, C, T) {
						T || ($(x != null, "missing value"), $(typeof C == "boolean", "missing or invalid endian"), $(S != null, "missing offset"), $(S + 3 < m.length, "Trying to write beyond buffer length"), gH(x, 34028234663852886e22, -34028234663852886e22)), m.length <= S || P.write(m, x, S, C, 23, 4);
					}
					function X(m, x, S, C, T) {
						T || ($(x != null, "missing value"), $(typeof C == "boolean", "missing or invalid endian"), $(S != null, "missing offset"), $(S + 7 < m.length, "Trying to write beyond buffer length"), gH(x, 17976931348623157e292, -17976931348623157e292)), m.length <= S || P.write(m, x, S, C, 52, 8);
					}
					S.Buffer = T, S.SlowBuffer = T, S.INSPECT_MAX_BYTES = 50, T.poolSize = 8192, T._useTypedArrays = function() {
						try {
							var m = /* @__PURE__ */ new ArrayBuffer(0), x = new Uint8Array(m);
							return x.foo = function() {
								return 42;
							}, x.foo() === 42 && typeof x.subarray == "function";
						} catch {
							return !1;
						}
					}(), T.isEncoding = function(m) {
						switch (String(m).toLowerCase()) {
							case "hex":
							case "utf8":
							case "utf-8":
							case "ascii":
							case "binary":
							case "base64":
							case "raw":
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le": return !0;
							default: return !1;
						}
					}, T.isBuffer = function(m) {
						return !(m == null || !m._isBuffer);
					}, T.byteLength = function(m, x) {
						var S;
						switch (m += "", x || "utf8") {
							case "hex":
								S = m.length / 2;
								break;
							case "utf8":
							case "utf-8":
								S = uH(m).length;
								break;
							case "ascii":
							case "binary":
							case "raw":
								S = m.length;
								break;
							case "base64":
								S = dH(m).length;
								break;
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le":
								S = 2 * m.length;
								break;
							default: throw Error("Unknown encoding");
						}
						return S;
					}, T.concat = function(m, x) {
						if ($(cH(m), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), m.length === 0) return new T(0);
						if (m.length === 1) return m[0];
						if (typeof x != "number") for (D = x = 0; D < m.length; D++) x += m[D].length;
						for (var S = new T(x), C = 0, D = 0; D < m.length; D++) {
							var O = m[D];
							O.copy(S, C), C += O.length;
						}
						return S;
					}, T.prototype.write = function(m, x, S, C) {
						isFinite(x) ? isFinite(S) || (C = S, S = void 0) : (j = C, C = x, x = S, S = j), x = Number(x) || 0;
						var D, O, k, A, j = this.length - x;
						switch ((!S || j < (S = Number(S))) && (S = j), C = String(C || "utf8").toLowerCase()) {
							case "hex":
								D = function(m, x, S, C) {
									S = Number(S) || 0;
									var D = m.length - S;
									(!C || D < (C = Number(C))) && (C = D), $((D = x.length) % 2 == 0, "Invalid hex string"), D / 2 < C && (C = D / 2);
									for (var O = 0; O < C; O++) {
										var k = parseInt(x.substr(2 * O, 2), 16);
										$(!isNaN(k), "Invalid hex string"), m[S + O] = k;
									}
									return T._charsWritten = 2 * O, O;
								}(this, m, x, S);
								break;
							case "utf8":
							case "utf-8":
								O = this, k = x, A = S, D = T._charsWritten = fH(uH(m), O, k, A);
								break;
							case "ascii":
							case "binary":
								D = F(this, m, x, S);
								break;
							case "base64":
								O = this, k = x, A = S, D = T._charsWritten = fH(dH(m), O, k, A);
								break;
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le":
								D = I(this, m, x, S);
								break;
							default: throw Error("Unknown encoding");
						}
						return D;
					}, T.prototype.toString = function(m, x, S) {
						var C, T, D, O, k = this;
						if (m = String(m || "utf8").toLowerCase(), x = Number(x) || 0, (S = S === void 0 ? k.length : Number(S)) === x) return "";
						switch (m) {
							case "hex":
								C = function(m, x, S) {
									var C = m.length;
									(!x || x < 0) && (x = 0), (!S || S < 0 || C < S) && (S = C);
									for (var T = "", D = x; D < S; D++) T += lH(m[D]);
									return T;
								}(k, x, S);
								break;
							case "utf8":
							case "utf-8":
								C = function(m, x, S) {
									var C = "", T = "";
									S = Math.min(m.length, S);
									for (var D = x; D < S; D++) m[D] <= 127 ? (C += pH(T) + String.fromCharCode(m[D]), T = "") : T += "%" + m[D].toString(16);
									return C + pH(T);
								}(k, x, S);
								break;
							case "ascii":
							case "binary":
								C = L(k, x, S);
								break;
							case "base64":
								T = k, O = S, C = (D = x) === 0 && O === T.length ? N.fromByteArray(T) : N.fromByteArray(T.slice(D, O));
								break;
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le":
								C = function(m, x, S) {
									for (var C = m.slice(x, S), T = "", D = 0; D < C.length; D += 2) T += String.fromCharCode(C[D] + 256 * C[D + 1]);
									return T;
								}(k, x, S);
								break;
							default: throw Error("Unknown encoding");
						}
						return C;
					}, T.prototype.toJSON = function() {
						return {
							type: "Buffer",
							data: Array.prototype.slice.call(this._arr || this, 0)
						};
					}, T.prototype.copy = function(m, x, S, C) {
						if (x ||= 0, (C = C || C === 0 ? C : this.length) !== (S ||= 0) && m.length !== 0 && this.length !== 0) {
							$(S <= C, "sourceEnd < sourceStart"), $(0 <= x && x < m.length, "targetStart out of bounds"), $(0 <= S && S < this.length, "sourceStart out of bounds"), $(0 <= C && C <= this.length, "sourceEnd out of bounds"), C > this.length && (C = this.length);
							var D = (C = m.length - x < C - S ? m.length - x + S : C) - S;
							if (D < 100 || !T._useTypedArrays) for (var O = 0; O < D; O++) m[O + x] = this[O + S];
							else m._set(this.subarray(S, S + D), x);
						}
					}, T.prototype.slice = function(m, x) {
						var S = this.length;
						if (m = sH(m, S, 0), x = sH(x, S, S), T._useTypedArrays) return T._augment(this.subarray(m, x));
						for (var C = x - m, D = new T(C, void 0, !0), O = 0; O < C; O++) D[O] = this[O + m];
						return D;
					}, T.prototype.get = function(m) {
						return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(m);
					}, T.prototype.set = function(m, x) {
						return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(m, x);
					}, T.prototype.readUInt8 = function(m, x) {
						if (x || ($(m != null, "missing offset"), $(m < this.length, "Trying to read beyond buffer length")), !(m >= this.length)) return this[m];
					}, T.prototype.readUInt16LE = function(m, x) {
						return R(this, m, !0, x);
					}, T.prototype.readUInt16BE = function(m, x) {
						return R(this, m, !1, x);
					}, T.prototype.readUInt32LE = function(m, x) {
						return z(this, m, !0, x);
					}, T.prototype.readUInt32BE = function(m, x) {
						return z(this, m, !1, x);
					}, T.prototype.readInt8 = function(m, x) {
						if (x || ($(m != null, "missing offset"), $(m < this.length, "Trying to read beyond buffer length")), !(m >= this.length)) return 128 & this[m] ? -1 * (255 - this[m] + 1) : this[m];
					}, T.prototype.readInt16LE = function(m, x) {
						return B(this, m, !0, x);
					}, T.prototype.readInt16BE = function(m, x) {
						return B(this, m, !1, x);
					}, T.prototype.readInt32LE = function(m, x) {
						return H(this, m, !0, x);
					}, T.prototype.readInt32BE = function(m, x) {
						return H(this, m, !1, x);
					}, T.prototype.readFloatLE = function(m, x) {
						return U(this, m, !0, x);
					}, T.prototype.readFloatBE = function(m, x) {
						return U(this, m, !1, x);
					}, T.prototype.readDoubleLE = function(m, x) {
						return W(this, m, !0, x);
					}, T.prototype.readDoubleBE = function(m, x) {
						return W(this, m, !1, x);
					}, T.prototype.writeUInt8 = function(m, x, S) {
						S || ($(m != null, "missing value"), $(x != null, "missing offset"), $(x < this.length, "trying to write beyond buffer length"), mH(m, 255)), x >= this.length || (this[x] = m);
					}, T.prototype.writeUInt16LE = function(m, x, S) {
						G(this, m, x, !0, S);
					}, T.prototype.writeUInt16BE = function(m, x, S) {
						G(this, m, x, !1, S);
					}, T.prototype.writeUInt32LE = function(m, x, S) {
						K(this, m, x, !0, S);
					}, T.prototype.writeUInt32BE = function(m, x, S) {
						K(this, m, x, !1, S);
					}, T.prototype.writeInt8 = function(m, x, S) {
						S || ($(m != null, "missing value"), $(x != null, "missing offset"), $(x < this.length, "Trying to write beyond buffer length"), hH(m, 127, -128)), x >= this.length || (0 <= m ? this.writeUInt8(m, x, S) : this.writeUInt8(255 + m + 1, x, S));
					}, T.prototype.writeInt16LE = function(m, x, S) {
						q(this, m, x, !0, S);
					}, T.prototype.writeInt16BE = function(m, x, S) {
						q(this, m, x, !1, S);
					}, T.prototype.writeInt32LE = function(m, x, S) {
						J(this, m, x, !0, S);
					}, T.prototype.writeInt32BE = function(m, x, S) {
						J(this, m, x, !1, S);
					}, T.prototype.writeFloatLE = function(m, x, S) {
						Y(this, m, x, !0, S);
					}, T.prototype.writeFloatBE = function(m, x, S) {
						Y(this, m, x, !1, S);
					}, T.prototype.writeDoubleLE = function(m, x, S) {
						X(this, m, x, !0, S);
					}, T.prototype.writeDoubleBE = function(m, x, S) {
						X(this, m, x, !1, S);
					}, T.prototype.fill = function(m, x, S) {
						if (x ||= 0, S ||= this.length, $(typeof (m = typeof (m ||= 0) == "string" ? m.charCodeAt(0) : m) == "number" && !isNaN(m), "value is not a number"), $(x <= S, "end < start"), S !== x && this.length !== 0) {
							$(0 <= x && x < this.length, "start out of bounds"), $(0 <= S && S <= this.length, "end out of bounds");
							for (var C = x; C < S; C++) this[C] = m;
						}
					}, T.prototype.inspect = function() {
						for (var m = [], x = this.length, C = 0; C < x; C++) if (m[C] = lH(this[C]), C === S.INSPECT_MAX_BYTES) {
							m[C + 1] = "...";
							break;
						}
						return "<Buffer " + m.join(" ") + ">";
					}, T.prototype.toArrayBuffer = function() {
						if (typeof Uint8Array > "u") throw Error("Buffer.toArrayBuffer not supported in this browser");
						if (T._useTypedArrays) return new T(this).buffer;
						for (var m = new Uint8Array(this.length), x = 0, S = m.length; x < S; x += 1) m[x] = this[x];
						return m.buffer;
					};
					var Z = T.prototype;
					function sH(m, x, S) {
						return typeof m == "number" ? x <= (m = ~~m) ? x : 0 <= m || 0 <= (m += x) ? m : 0 : S;
					}
					function Q(m) {
						return (m = ~~Math.ceil(+m)) < 0 ? 0 : m;
					}
					function cH(m) {
						return (Array.isArray || function(m) {
							return Object.prototype.toString.call(m) === "[object Array]";
						})(m);
					}
					function lH(m) {
						return m < 16 ? "0" + m.toString(16) : m.toString(16);
					}
					function uH(m) {
						for (var x = [], S = 0; S < m.length; S++) {
							var C = m.charCodeAt(S);
							if (C <= 127) x.push(m.charCodeAt(S));
							else for (var T = S, D = (55296 <= C && C <= 57343 && S++, encodeURIComponent(m.slice(T, S + 1)).substr(1).split("%")), O = 0; O < D.length; O++) x.push(parseInt(D[O], 16));
						}
						return x;
					}
					function dH(m) {
						return N.toByteArray(m);
					}
					function fH(m, x, S, C) {
						for (var T = 0; T < C && !(T + S >= x.length || T >= m.length); T++) x[T + S] = m[T];
						return T;
					}
					function pH(m) {
						try {
							return decodeURIComponent(m);
						} catch {
							return "";
						}
					}
					function mH(m, x) {
						$(typeof m == "number", "cannot write a non-number as a number"), $(0 <= m, "specified a negative value for writing an unsigned value"), $(m <= x, "value is larger than maximum value for type"), $(Math.floor(m) === m, "value has a fractional component");
					}
					function hH(m, x, S) {
						$(typeof m == "number", "cannot write a non-number as a number"), $(m <= x, "value larger than maximum allowed value"), $(S <= m, "value smaller than minimum allowed value"), $(Math.floor(m) === m, "value has a fractional component");
					}
					function gH(m, x, S) {
						$(typeof m == "number", "cannot write a non-number as a number"), $(m <= x, "value larger than maximum allowed value"), $(S <= m, "value smaller than minimum allowed value");
					}
					function $(m, x) {
						if (!m) throw Error(x || "Failed assertion");
					}
					T._augment = function(m) {
						return m._isBuffer = !0, m._get = m.get, m._set = m.set, m.get = Z.get, m.set = Z.set, m.write = Z.write, m.toString = Z.toString, m.toLocaleString = Z.toString, m.toJSON = Z.toJSON, m.copy = Z.copy, m.slice = Z.slice, m.readUInt8 = Z.readUInt8, m.readUInt16LE = Z.readUInt16LE, m.readUInt16BE = Z.readUInt16BE, m.readUInt32LE = Z.readUInt32LE, m.readUInt32BE = Z.readUInt32BE, m.readInt8 = Z.readInt8, m.readInt16LE = Z.readInt16LE, m.readInt16BE = Z.readInt16BE, m.readInt32LE = Z.readInt32LE, m.readInt32BE = Z.readInt32BE, m.readFloatLE = Z.readFloatLE, m.readFloatBE = Z.readFloatBE, m.readDoubleLE = Z.readDoubleLE, m.readDoubleBE = Z.readDoubleBE, m.writeUInt8 = Z.writeUInt8, m.writeUInt16LE = Z.writeUInt16LE, m.writeUInt16BE = Z.writeUInt16BE, m.writeUInt32LE = Z.writeUInt32LE, m.writeUInt32BE = Z.writeUInt32BE, m.writeInt8 = Z.writeInt8, m.writeInt16LE = Z.writeInt16LE, m.writeInt16BE = Z.writeInt16BE, m.writeInt32LE = Z.writeInt32LE, m.writeInt32BE = Z.writeInt32BE, m.writeFloatLE = Z.writeFloatLE, m.writeFloatBE = Z.writeFloatBE, m.writeDoubleLE = Z.writeDoubleLE, m.writeDoubleBE = Z.writeDoubleBE, m.fill = Z.fill, m.inspect = Z.inspect, m.toArrayBuffer = Z.toArrayBuffer, m;
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
			}, {
				"base64-js": 2,
				buffer: 3,
				ieee754: 10,
				lYpoI2: 11
			}],
			4: [function(m, x, S) {
				(function(S, C, T, D, O, k, A, j, M) {
					var T = m("buffer").Buffer, N = 4, P = new T(N);
					P.fill(0), x.exports = { hash: function(m, x, S, C) {
						for (var D = x(function(m, x) {
							m.length % N != 0 && (S = m.length + (N - m.length % N), m = T.concat([m, P], S));
							for (var S, C = [], D = x ? m.readInt32BE : m.readInt32LE, O = 0; O < m.length; O += N) C.push(D.call(m, O));
							return C;
						}(m = T.isBuffer(m) ? m : new T(m), C), 8 * m.length), x = C, O = new T(S), k = x ? O.writeInt32BE : O.writeInt32LE, A = 0; A < D.length; A++) k.call(O, D[A], 4 * A, !0);
						return O;
					} };
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
			}, {
				buffer: 3,
				lYpoI2: 11
			}],
			5: [function(m, x, S) {
				(function(x, C, T, D, O, k, A, j, M) {
					var T = m("buffer").Buffer, N = m("./sha"), P = m("./sha256"), F = m("./rng"), I = {
						sha1: N,
						sha256: P,
						md5: m("./md5")
					}, L = 64, R = new T(L);
					function z(m, x) {
						var S = I[m ||= "sha1"], C = [];
						return S || B("algorithm:", m, "is not yet supported"), {
							update: function(m) {
								return T.isBuffer(m) || (m = new T(m)), C.push(m), m.length, this;
							},
							digest: function(m) {
								var D = T.concat(C), D = x ? function(m, x, S) {
									T.isBuffer(x) || (x = new T(x)), T.isBuffer(S) || (S = new T(S)), x.length > L ? x = m(x) : x.length < L && (x = T.concat([x, R], L));
									for (var C = new T(L), D = new T(L), O = 0; O < L; O++) C[O] = 54 ^ x[O], D[O] = 92 ^ x[O];
									return S = m(T.concat([C, S])), m(T.concat([D, S]));
								}(S, x, D) : S(D);
								return C = null, m ? D.toString(m) : D;
							}
						};
					}
					function B() {
						var m = [].slice.call(arguments).join(" ");
						throw Error([
							m,
							"we accept pull requests",
							"http://github.com/dominictarr/crypto-browserify"
						].join("\n"));
					}
					R.fill(0), S.createHash = function(m) {
						return z(m);
					}, S.createHmac = z, S.randomBytes = function(m, x) {
						if (!x || !x.call) return new T(F(m));
						try {
							x.call(this, void 0, new T(F(m)));
						} catch (m) {
							x(m);
						}
					};
					var H, U = [
						"createCredentials",
						"createCipher",
						"createCipheriv",
						"createDecipher",
						"createDecipheriv",
						"createSign",
						"createVerify",
						"createDiffieHellman",
						"pbkdf2"
					], W = function(m) {
						S[m] = function() {
							B("sorry,", m, "is not implemented yet");
						};
					};
					for (H in U) W(U[H], H);
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
			}, {
				"./md5": 6,
				"./rng": 7,
				"./sha": 8,
				"./sha256": 9,
				buffer: 3,
				lYpoI2: 11
			}],
			6: [function(m, x, S) {
				(function(S, C, T, D, O, k, A, j, M) {
					var N = m("./helpers");
					function P(m, x) {
						m[x >> 5] |= 128 << x % 32, m[14 + (x + 64 >>> 9 << 4)] = x;
						for (var S = 1732584193, C = -271733879, T = -1732584194, D = 271733878, O = 0; O < m.length; O += 16) {
							var k = S, A = C, j = T, M = D, S = I(S, C, T, D, m[O + 0], 7, -680876936), D = I(D, S, C, T, m[O + 1], 12, -389564586), T = I(T, D, S, C, m[O + 2], 17, 606105819), C = I(C, T, D, S, m[O + 3], 22, -1044525330);
							S = I(S, C, T, D, m[O + 4], 7, -176418897), D = I(D, S, C, T, m[O + 5], 12, 1200080426), T = I(T, D, S, C, m[O + 6], 17, -1473231341), C = I(C, T, D, S, m[O + 7], 22, -45705983), S = I(S, C, T, D, m[O + 8], 7, 1770035416), D = I(D, S, C, T, m[O + 9], 12, -1958414417), T = I(T, D, S, C, m[O + 10], 17, -42063), C = I(C, T, D, S, m[O + 11], 22, -1990404162), S = I(S, C, T, D, m[O + 12], 7, 1804603682), D = I(D, S, C, T, m[O + 13], 12, -40341101), T = I(T, D, S, C, m[O + 14], 17, -1502002290), S = L(S, C = I(C, T, D, S, m[O + 15], 22, 1236535329), T, D, m[O + 1], 5, -165796510), D = L(D, S, C, T, m[O + 6], 9, -1069501632), T = L(T, D, S, C, m[O + 11], 14, 643717713), C = L(C, T, D, S, m[O + 0], 20, -373897302), S = L(S, C, T, D, m[O + 5], 5, -701558691), D = L(D, S, C, T, m[O + 10], 9, 38016083), T = L(T, D, S, C, m[O + 15], 14, -660478335), C = L(C, T, D, S, m[O + 4], 20, -405537848), S = L(S, C, T, D, m[O + 9], 5, 568446438), D = L(D, S, C, T, m[O + 14], 9, -1019803690), T = L(T, D, S, C, m[O + 3], 14, -187363961), C = L(C, T, D, S, m[O + 8], 20, 1163531501), S = L(S, C, T, D, m[O + 13], 5, -1444681467), D = L(D, S, C, T, m[O + 2], 9, -51403784), T = L(T, D, S, C, m[O + 7], 14, 1735328473), S = R(S, C = L(C, T, D, S, m[O + 12], 20, -1926607734), T, D, m[O + 5], 4, -378558), D = R(D, S, C, T, m[O + 8], 11, -2022574463), T = R(T, D, S, C, m[O + 11], 16, 1839030562), C = R(C, T, D, S, m[O + 14], 23, -35309556), S = R(S, C, T, D, m[O + 1], 4, -1530992060), D = R(D, S, C, T, m[O + 4], 11, 1272893353), T = R(T, D, S, C, m[O + 7], 16, -155497632), C = R(C, T, D, S, m[O + 10], 23, -1094730640), S = R(S, C, T, D, m[O + 13], 4, 681279174), D = R(D, S, C, T, m[O + 0], 11, -358537222), T = R(T, D, S, C, m[O + 3], 16, -722521979), C = R(C, T, D, S, m[O + 6], 23, 76029189), S = R(S, C, T, D, m[O + 9], 4, -640364487), D = R(D, S, C, T, m[O + 12], 11, -421815835), T = R(T, D, S, C, m[O + 15], 16, 530742520), S = z(S, C = R(C, T, D, S, m[O + 2], 23, -995338651), T, D, m[O + 0], 6, -198630844), D = z(D, S, C, T, m[O + 7], 10, 1126891415), T = z(T, D, S, C, m[O + 14], 15, -1416354905), C = z(C, T, D, S, m[O + 5], 21, -57434055), S = z(S, C, T, D, m[O + 12], 6, 1700485571), D = z(D, S, C, T, m[O + 3], 10, -1894986606), T = z(T, D, S, C, m[O + 10], 15, -1051523), C = z(C, T, D, S, m[O + 1], 21, -2054922799), S = z(S, C, T, D, m[O + 8], 6, 1873313359), D = z(D, S, C, T, m[O + 15], 10, -30611744), T = z(T, D, S, C, m[O + 6], 15, -1560198380), C = z(C, T, D, S, m[O + 13], 21, 1309151649), S = z(S, C, T, D, m[O + 4], 6, -145523070), D = z(D, S, C, T, m[O + 11], 10, -1120210379), T = z(T, D, S, C, m[O + 2], 15, 718787259), C = z(C, T, D, S, m[O + 9], 21, -343485551), S = B(S, k), C = B(C, A), T = B(T, j), D = B(D, M);
						}
						return [
							S,
							C,
							T,
							D
						];
					}
					function F(m, x, S, C, T, D) {
						return B((x = B(B(x, m), B(C, D))) << T | x >>> 32 - T, S);
					}
					function I(m, x, S, C, T, D, O) {
						return F(x & S | ~x & C, m, x, T, D, O);
					}
					function L(m, x, S, C, T, D, O) {
						return F(x & C | S & ~C, m, x, T, D, O);
					}
					function R(m, x, S, C, T, D, O) {
						return F(x ^ S ^ C, m, x, T, D, O);
					}
					function z(m, x, S, C, T, D, O) {
						return F(S ^ (x | ~C), m, x, T, D, O);
					}
					function B(m, x) {
						var S = (65535 & m) + (65535 & x);
						return (m >> 16) + (x >> 16) + (S >> 16) << 16 | 65535 & S;
					}
					x.exports = function(m) {
						return N.hash(m, P, 16);
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
			}, {
				"./helpers": 4,
				buffer: 3,
				lYpoI2: 11
			}],
			7: [function(m, x, S) {
				(function(m, S, C, T, D, O, k, A, j) {
					var M;
					x.exports = M || function(m) {
						for (var x, S = Array(m), C = 0; C < m; C++) !(3 & C) && (x = 4294967296 * Math.random()), S[C] = x >>> ((3 & C) << 3) & 255;
						return S;
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
			}, {
				buffer: 3,
				lYpoI2: 11
			}],
			8: [function(m, x, S) {
				(function(S, C, T, D, O, k, A, j, M) {
					var N = m("./helpers");
					function P(m, x) {
						m[x >> 5] |= 128 << 24 - x % 32, m[15 + (x + 64 >> 9 << 4)] = x;
						for (var S, C, T, D = Array(80), O = 1732584193, k = -271733879, A = -1732584194, j = 271733878, M = -1009589776, N = 0; N < m.length; N += 16) {
							for (var P = O, L = k, R = A, z = j, B = M, H = 0; H < 80; H++) {
								D[H] = H < 16 ? m[N + H] : I(D[H - 3] ^ D[H - 8] ^ D[H - 14] ^ D[H - 16], 1);
								var U = F(F(I(O, 5), (U = k, C = A, T = j, (S = H) < 20 ? U & C | ~U & T : !(S < 40) && S < 60 ? U & C | U & T | C & T : U ^ C ^ T)), F(F(M, D[H]), (S = H) < 20 ? 1518500249 : S < 40 ? 1859775393 : S < 60 ? -1894007588 : -899497514)), M = j, j = A, A = I(k, 30), k = O, O = U;
							}
							O = F(O, P), k = F(k, L), A = F(A, R), j = F(j, z), M = F(M, B);
						}
						return [
							O,
							k,
							A,
							j,
							M
						];
					}
					function F(m, x) {
						var S = (65535 & m) + (65535 & x);
						return (m >> 16) + (x >> 16) + (S >> 16) << 16 | 65535 & S;
					}
					function I(m, x) {
						return m << x | m >>> 32 - x;
					}
					x.exports = function(m) {
						return N.hash(m, P, 20, !0);
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
			}, {
				"./helpers": 4,
				buffer: 3,
				lYpoI2: 11
			}],
			9: [function(m, x, S) {
				(function(S, C, T, D, O, k, A, j, M) {
					function N(m, x) {
						var S = (65535 & m) + (65535 & x);
						return (m >> 16) + (x >> 16) + (S >> 16) << 16 | 65535 & S;
					}
					function P(m, x) {
						var S, C = [
							1116352408,
							1899447441,
							3049323471,
							3921009573,
							961987163,
							1508970993,
							2453635748,
							2870763221,
							3624381080,
							310598401,
							607225278,
							1426881987,
							1925078388,
							2162078206,
							2614888103,
							3248222580,
							3835390401,
							4022224774,
							264347078,
							604807628,
							770255983,
							1249150122,
							1555081692,
							1996064986,
							2554220882,
							2821834349,
							2952996808,
							3210313671,
							3336571891,
							3584528711,
							113926993,
							338241895,
							666307205,
							773529912,
							1294757372,
							1396182291,
							1695183700,
							1986661051,
							2177026350,
							2456956037,
							2730485921,
							2820302411,
							3259730800,
							3345764771,
							3516065817,
							3600352804,
							4094571909,
							275423344,
							430227734,
							506948616,
							659060556,
							883997877,
							958139571,
							1322822218,
							1537002063,
							1747873779,
							1955562222,
							2024104815,
							2227730452,
							2361852424,
							2428436474,
							2756734187,
							3204031479,
							3329325298
						], T = [
							1779033703,
							3144134277,
							1013904242,
							2773480762,
							1359893119,
							2600822924,
							528734635,
							1541459225
						], D = Array(64);
						m[x >> 5] |= 128 << 24 - x % 32, m[15 + (x + 64 >> 9 << 4)] = x;
						for (var O, k, A = 0; A < m.length; A += 16) {
							for (var j = T[0], M = T[1], P = T[2], F = T[3], R = T[4], z = T[5], B = T[6], H = T[7], U = 0; U < 64; U++) D[U] = U < 16 ? m[U + A] : N(N(N((k = D[U - 2], I(k, 17) ^ I(k, 19) ^ L(k, 10)), D[U - 7]), (k = D[U - 15], I(k, 7) ^ I(k, 18) ^ L(k, 3))), D[U - 16]), S = N(N(N(N(H, I(k = R, 6) ^ I(k, 11) ^ I(k, 25)), R & z ^ ~R & B), C[U]), D[U]), O = N(I(O = j, 2) ^ I(O, 13) ^ I(O, 22), j & M ^ j & P ^ M & P), H = B, B = z, z = R, R = N(F, S), F = P, P = M, M = j, j = N(S, O);
							T[0] = N(j, T[0]), T[1] = N(M, T[1]), T[2] = N(P, T[2]), T[3] = N(F, T[3]), T[4] = N(R, T[4]), T[5] = N(z, T[5]), T[6] = N(B, T[6]), T[7] = N(H, T[7]);
						}
						return T;
					}
					var F = m("./helpers"), I = function(m, x) {
						return m >>> x | m << 32 - x;
					}, L = function(m, x) {
						return m >>> x;
					};
					x.exports = function(m) {
						return F.hash(m, P, 32, !0);
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
			}, {
				"./helpers": 4,
				buffer: 3,
				lYpoI2: 11
			}],
			10: [function(m, x, S) {
				(function(m, x, C, T, D, O, k, A, j) {
					S.read = function(m, x, S, C, T) {
						var D, O, k = 8 * T - C - 1, A = (1 << k) - 1, j = A >> 1, M = -7, N = S ? T - 1 : 0, P = S ? -1 : 1, T = m[x + N];
						for (N += P, D = T & (1 << -M) - 1, T >>= -M, M += k; 0 < M; D = 256 * D + m[x + N], N += P, M -= 8);
						for (O = D & (1 << -M) - 1, D >>= -M, M += C; 0 < M; O = 256 * O + m[x + N], N += P, M -= 8);
						if (D === 0) D = 1 - j;
						else {
							if (D === A) return O ? NaN : Infinity * (T ? -1 : 1);
							O += 2 ** C, D -= j;
						}
						return (T ? -1 : 1) * O * 2 ** (D - C);
					}, S.write = function(m, x, S, C, T, D) {
						var O, k, A = 8 * D - T - 1, j = (1 << A) - 1, M = j >> 1, N = T === 23 ? 2 ** -24 - 2 ** -77 : 0, P = C ? 0 : D - 1, F = C ? 1 : -1, D = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
						for (x = Math.abs(x), isNaN(x) || x === Infinity ? (k = isNaN(x) ? 1 : 0, O = j) : (O = Math.floor(Math.log(x) / Math.LN2), x * (C = 2 ** -O) < 1 && (O--, C *= 2), 2 <= (x += 1 <= O + M ? N / C : N * 2 ** (1 - M)) * C && (O++, C /= 2), j <= O + M ? (k = 0, O = j) : 1 <= O + M ? (k = (x * C - 1) * 2 ** T, O += M) : (k = x * 2 ** (M - 1) * 2 ** T, O = 0)); 8 <= T; m[S + P] = 255 & k, P += F, k /= 256, T -= 8);
						for (O = O << T | k, A += T; 0 < A; m[S + P] = 255 & O, P += F, O /= 256, A -= 8);
						m[S + P - F] |= 128 * D;
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
			}, {
				buffer: 3,
				lYpoI2: 11
			}],
			11: [function(m, x, S) {
				(function(m, S, C, T, D, O, k, A, j) {
					var M, N, P;
					function F() {}
					(m = x.exports = {}).nextTick = (N = typeof window < "u" && window.setImmediate, P = typeof window < "u" && window.postMessage && window.addEventListener, N ? function(m) {
						return window.setImmediate(m);
					} : P ? (M = [], window.addEventListener("message", function(m) {
						var x = m.source;
						x !== window && x !== null || m.data !== "process-tick" || (m.stopPropagation(), 0 < M.length && M.shift()());
					}, !0), function(m) {
						M.push(m), window.postMessage("process-tick", "*");
					}) : function(m) {
						setTimeout(m, 0);
					}), m.title = "browser", m.browser = !0, m.env = {}, m.argv = [], m.on = F, m.addListener = F, m.once = F, m.off = F, m.removeListener = F, m.removeAllListeners = F, m.emit = F, m.binding = function(m) {
						throw Error("process.binding is not supported");
					}, m.cwd = function() {
						return "/";
					}, m.chdir = function(m) {
						throw Error("process.chdir is not supported");
					};
				}).call(this, m("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, m("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
			}, {
				buffer: 3,
				lYpoI2: 11
			}]
		}, {}, [1])(1);
	});
})))(), 1), import_fast_deep_equal = /* @__PURE__ */ __toESM$1(require_fast_deep_equal(), 1), require_classnames = __commonJS({ "../../node_modules/classnames/index.js"(m, x) {
	init_react_import(), (function() {
		var m = {}.hasOwnProperty;
		function S() {
			for (var m = "", x = 0; x < arguments.length; x++) {
				var S = arguments[x];
				S && (m = T(m, C(S)));
			}
			return m;
		}
		function C(x) {
			if (typeof x == "string" || typeof x == "number") return x;
			if (typeof x != "object") return "";
			if (Array.isArray(x)) return S.apply(null, x);
			if (x.toString !== Object.prototype.toString && !x.toString.toString().includes("[native code]")) return x.toString();
			var C = "";
			for (var D in x) m.call(x, D) && x[D] && (C = T(C, D));
			return C;
		}
		function T(m, x) {
			return x ? m ? m + " " + x : m + x : m;
		}
		x !== void 0 && x.exports ? (S.default = S, x.exports = S) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function() {
			return S;
		}) : window.classNames = S;
	})();
} });
init_react_import(), init_react_import(), init_react_import();
var import_classnames = __toESM(require_classnames()), get_class_name_factory_default = (m, x, S = { baseClass: "" }) => (C = {}) => {
	if (typeof C == "string") {
		let T = C;
		return x[`${m}-${T}`] && S.baseClass + x[`${m}-${T}`] || "";
	} else if (typeof C == "object") {
		let T = C, D = {};
		for (let S in T) D[x[`${m}--${S}`]] = T[S];
		let O = x[m];
		return S.baseClass + (0, import_classnames.default)(__spreadValues({ [O]: !!O }, D));
	} else return S.baseClass + x[m] || "";
};
init_react_import();
var getClassName = get_class_name_factory_default("ActionBar", {
	ActionBar: "_ActionBar_rvadt_1",
	"ActionBar-label": "_ActionBar-label_rvadt_18",
	"ActionBar-action": "_ActionBar-action_rvadt_30",
	"ActionBar-group": "_ActionBar-group_rvadt_38"
}), ActionBar = ({ label: m, children: x }) => /* @__PURE__ */ jsxs("div", {
	className: getClassName(),
	onClick: (m) => {
		m.stopPropagation();
	},
	children: [m && /* @__PURE__ */ jsx(ActionBar.Group, { children: /* @__PURE__ */ jsx("div", {
		className: getClassName("label"),
		children: m
	}) }), x]
});
ActionBar.Action = ({ children: m, label: x, onClick: S }) => /* @__PURE__ */ jsx("button", {
	type: "button",
	className: getClassName("action"),
	onClick: S,
	title: x,
	children: m
}), ActionBar.Label = ({ label: m }) => /* @__PURE__ */ jsx("div", {
	className: getClassName("label"),
	children: m
}), ActionBar.Group = ({ children: m }) => /* @__PURE__ */ jsx("div", {
	className: getClassName("group"),
	children: m
}), init_react_import(), init_react_import();
var IconButton_module_default = {
	IconButton: "_IconButton_swpni_1",
	"IconButton--disabled": "_IconButton--disabled_swpni_20",
	"IconButton-title": "_IconButton-title_swpni_33"
};
init_react_import(), init_react_import(), init_react_import(), init_react_import();
var reorder = (m, x, S) => {
	let C = Array.from(m), [T] = C.splice(x, 1);
	return C.splice(S, 0, T), C;
};
init_react_import();
var replace = (m, x, S) => {
	let C = Array.from(m);
	return C.splice(x, 1), C.splice(x, 0, S), C;
};
init_react_import(), init_react_import(), init_react_import(), init_react_import();
var setAction = (m, x, S) => {
	if (typeof x.state == "object") {
		let C = __spreadValues(__spreadValues({}, m), x.state);
		return x.state.indexes ? C : (console.warn("`set` is expensive and may cause unnecessary re-renders. Consider using a more atomic action instead."), walkAppState(C, S.config));
	}
	return __spreadValues(__spreadValues({}, m), x.state(m));
};
init_react_import(), init_react_import();
var insert = (m, x, S) => {
	let C = Array.from(m || []);
	return C.splice(x, 0, S), C;
};
init_react_import();
var generateId = (m) => m ? `${m}-${v4_default()}` : v4_default();
init_react_import();
var getIdsForParent = (m, x) => {
	let [S] = m.split(":");
	return (x.indexes.nodes[S]?.path || []).map((m) => m.split(":")[0]);
};
init_react_import();
var populateIds = (m, x, S = !1) => {
	let C = generateId(m.type);
	return walkTree(__spreadProps(__spreadValues({}, m), { props: S ? __spreadProps(__spreadValues({}, m.props), { id: C }) : __spreadValues({}, m.props) }), x, (m) => m.map((m) => {
		let x = generateId(m.type);
		return __spreadProps(__spreadValues({}, m), { props: S ? __spreadProps(__spreadValues({}, m.props), { id: x }) : __spreadValues({ id: x }, m.props) });
	}));
};
function insertAction(m, x, S) {
	let C = x.id || generateId(x.componentType), T = populateIds({
		type: x.componentType,
		props: __spreadProps(__spreadValues({}, S.config.components[x.componentType].defaultProps || {}), { id: C })
	}, S.config), [D] = x.destinationZone.split(":"), O = getIdsForParent(x.destinationZone, m);
	return walkAppState(m, S.config, (m, S) => S === x.destinationZone ? insert(m || [], x.destinationIndex, T) : m, (m, S) => m.props.id === C || m.props.id === D || O.includes(m.props.id) || S.includes(x.destinationZone) ? m : null);
}
init_react_import();
var replaceAction = (m, x, S) => {
	let [C] = x.destinationZone.split(":"), T = getIdsForParent(x.destinationZone, m), D = m.indexes.zones[x.destinationZone].contentIds[x.destinationIndex];
	if (D !== x.data.props.id) throw Error("Can't change the id during a replace action. Please us \"remove\" and \"insert\" to define a new node.");
	let O = [], k = walkTree(x.data, S.config, (m, x) => (O.push(`${x.parentId}:${x.propName}`), m.map((m) => {
		let x = generateId(m.type);
		return __spreadProps(__spreadValues({}, m), { props: __spreadValues({ id: x }, m.props) });
	}))), A = __spreadValues({}, m);
	return Object.keys(m.indexes.zones).forEach((m) => {
		m.split(":")[0] === D && (O.includes(m) || delete A.indexes.zones[m]);
	}), walkAppState(A, S.config, (m, S) => {
		let C = [...m];
		return S === x.destinationZone && (C[x.destinationIndex] = k), C;
	}, (m, x) => {
		let S = x.map((m) => m.split(":")[0]);
		return m.props.id === k.props.id ? k : m.props.id === C || T.indexOf(m.props.id) > -1 || S.indexOf(k.props.id) > -1 ? m : null;
	});
};
init_react_import();
var replaceRootAction = (m, x, S) => walkAppState(m, S.config, (m) => m, (m) => m.props.id === "root" ? __spreadProps(__spreadValues({}, m), {
	props: __spreadValues(__spreadValues({}, m.props), x.root.props),
	readOnly: x.root.readOnly
}) : m);
init_react_import(), init_react_import();
function getItem(m, x) {
	let S = x.indexes.zones?.[m.zone || rootDroppableId];
	return S ? x.indexes.nodes[S.contentIds[m.index]]?.data : void 0;
}
function duplicateAction(m, x, S) {
	let C = getItem({
		index: x.sourceIndex,
		zone: x.sourceZone
	}, m), T = getIdsForParent(x.sourceZone, m), D = __spreadProps(__spreadValues({}, C), { props: __spreadProps(__spreadValues({}, C.props), { id: generateId(C.type) }) }), O = walkAppState(m, S.config, (m, S) => S === x.sourceZone ? insert(m, x.sourceIndex + 1, C) : m, (m, S, C) => {
		let O = S[S.length - 1];
		if (S.map((m) => m.split(":")[0]).indexOf(D.props.id) > -1) return __spreadProps(__spreadValues({}, m), { props: __spreadProps(__spreadValues({}, m.props), { id: generateId(m.type) }) });
		if (O === x.sourceZone && C === x.sourceIndex + 1) return D;
		let [k] = x.sourceZone.split(":");
		return k === m.props.id || T.indexOf(m.props.id) > -1 ? m : null;
	});
	return __spreadProps(__spreadValues({}, O), { ui: __spreadProps(__spreadValues({}, O.ui), { itemSelector: {
		index: x.sourceIndex + 1,
		zone: x.sourceZone
	} }) });
}
init_react_import(), init_react_import(), init_react_import();
var remove = (m, x) => {
	let S = Array.from(m);
	return S.splice(x, 1), S;
}, moveAction$1 = (m, x, S) => {
	if (x.sourceZone === x.destinationZone && x.sourceIndex === x.destinationIndex) return m;
	let C = getItem({
		zone: x.sourceZone,
		index: x.sourceIndex
	}, m);
	if (!C) return m;
	let T = getIdsForParent(x.sourceZone, m), D = getIdsForParent(x.destinationZone, m);
	return walkAppState(m, S.config, (m, S) => S === x.sourceZone && S === x.destinationZone ? insert(remove(m, x.sourceIndex), x.destinationIndex, C) : S === x.sourceZone ? remove(m, x.sourceIndex) : S === x.destinationZone ? insert(m, x.destinationIndex, C) : m, (m, S) => {
		let [O] = x.sourceZone.split(":"), [k] = x.destinationZone.split(":"), A = m.props.id;
		return O === A || k === A || C.props.id === A || T.indexOf(A) > -1 || D.indexOf(A) > -1 || S.includes(x.destinationZone) ? m : null;
	});
}, reorderAction = (m, x, S) => moveAction$1(m, {
	type: "move",
	sourceIndex: x.sourceIndex,
	sourceZone: x.destinationZone,
	destinationIndex: x.destinationIndex,
	destinationZone: x.destinationZone
}, S);
init_react_import();
var removeAction = (m, x, S) => {
	let C = getItem({
		index: x.index,
		zone: x.zone
	}, m), T = Object.entries(m.indexes.nodes).reduce((m, [x, S]) => S.path.map((m) => m.split(":")[0]).includes(C.props.id) ? [...m, x] : m, [C.props.id]), D = walkAppState(m, S.config, (m, S) => S === x.zone ? remove(m, x.index) : m);
	return Object.keys(D.data.zones || {}).forEach((m) => {
		let x = m.split(":")[0];
		T.includes(x) && D.data.zones && delete D.data.zones[m];
	}), Object.keys(D.indexes.zones).forEach((m) => {
		let x = m.split(":")[0];
		T.includes(x) && delete D.indexes.zones[m];
	}), T.forEach((m) => {
		delete D.indexes.nodes[m];
	}), D;
};
init_react_import();
var zoneCache = {};
function registerZoneAction(m, x) {
	return zoneCache[x.zone] ? __spreadProps(__spreadValues({}, m), {
		data: __spreadProps(__spreadValues({}, m.data), { zones: __spreadProps(__spreadValues({}, m.data.zones), { [x.zone]: zoneCache[x.zone] }) }),
		indexes: __spreadProps(__spreadValues({}, m.indexes), { zones: __spreadProps(__spreadValues({}, m.indexes.zones), { [x.zone]: __spreadProps(__spreadValues({}, m.indexes.zones[x.zone]), {
			contentIds: zoneCache[x.zone].map((m) => m.props.id),
			type: "dropzone"
		}) }) })
	}) : __spreadProps(__spreadValues({}, m), { data: setupZone(m.data, x.zone) });
}
function unregisterZoneAction(m, x) {
	let S = __spreadValues({}, m.data.zones || {}), C = __spreadValues({}, m.indexes.zones || {});
	return S[x.zone] && (zoneCache[x.zone] = S[x.zone], delete S[x.zone]), delete C[x.zone], __spreadProps(__spreadValues({}, m), {
		data: __spreadProps(__spreadValues({}, m.data), { zones: S }),
		indexes: __spreadProps(__spreadValues({}, m.indexes), { zones: C })
	});
}
init_react_import();
var setDataAction = (m, x, S) => typeof x.data == "object" ? (console.warn("`setData` is expensive and may cause unnecessary re-renders. Consider using a more atomic action instead."), walkAppState(__spreadProps(__spreadValues({}, m), { data: __spreadValues(__spreadValues({}, m.data), x.data) }), S.config)) : walkAppState(__spreadProps(__spreadValues({}, m), { data: __spreadValues(__spreadValues({}, m.data), x.data(m.data)) }), S.config);
init_react_import();
var setUiAction = (m, x) => typeof x.ui == "object" ? __spreadProps(__spreadValues({}, m), { ui: __spreadValues(__spreadValues({}, m.ui), x.ui) }) : __spreadProps(__spreadValues({}, m), { ui: __spreadValues(__spreadValues({}, m.ui), x.ui(m.ui)) });
init_react_import();
var makeStatePublic = (m) => {
	let { data: x, ui: S } = m;
	return {
		data: x,
		ui: S
	};
};
init_react_import();
function storeInterceptor(m, x, S) {
	return (C, T) => {
		let D = m(C, T), O = ![
			"registerZone",
			"unregisterZone",
			"setData",
			"setUi",
			"set"
		].includes(T.type);
		return (T.recordHistory === void 0 ? O : T.recordHistory) && x && x(D), S?.(T, makeStatePublic(D), makeStatePublic(C)), D;
	};
}
function createReducer({ record: m, onAction: x, appStore: S }) {
	return storeInterceptor((m, x) => x.type === "set" ? setAction(m, x, S) : x.type === "insert" ? insertAction(m, x, S) : x.type === "replace" ? replaceAction(m, x, S) : x.type === "replaceRoot" ? replaceRootAction(m, x, S) : x.type === "duplicate" ? duplicateAction(m, x, S) : x.type === "reorder" ? reorderAction(m, x, S) : x.type === "move" ? moveAction$1(m, x, S) : x.type === "remove" ? removeAction(m, x, S) : x.type === "registerZone" ? registerZoneAction(m, x) : x.type === "unregisterZone" ? unregisterZoneAction(m, x) : x.type === "setData" ? setDataAction(m, x, S) : x.type === "setUi" ? setUiAction(m, x) : m, m, x);
}
init_react_import(), init_react_import();
var keyCodeMap = {
	ControlLeft: "ctrl",
	ControlRight: "ctrl",
	MetaLeft: "meta",
	MetaRight: "meta",
	ShiftLeft: "shift",
	ShiftRight: "shift",
	KeyA: "a",
	KeyB: "b",
	KeyC: "c",
	KeyD: "d",
	KeyE: "e",
	KeyF: "f",
	KeyG: "g",
	KeyH: "h",
	KeyI: "i",
	KeyJ: "j",
	KeyK: "k",
	KeyL: "l",
	KeyM: "m",
	KeyN: "n",
	KeyO: "o",
	KeyP: "p",
	KeyQ: "q",
	KeyR: "r",
	KeyS: "s",
	KeyT: "t",
	KeyU: "u",
	KeyV: "v",
	KeyW: "w",
	KeyX: "x",
	KeyY: "y",
	KeyZ: "z"
}, useHotkeyStore = create()(subscribeWithSelector((m) => ({
	held: {},
	hold: (x) => m((m) => m.held[x] ? m : { held: __spreadProps(__spreadValues({}, m.held), { [x]: !0 }) }),
	release: (x) => m((m) => m.held[x] ? { held: __spreadProps(__spreadValues({}, m.held), { [x]: !1 }) } : m),
	reset: (x = {}) => m(() => ({ held: x })),
	triggers: {}
}))), monitorHotkeys = (m) => {
	let x = (m) => {
		let x = keyCodeMap[m.code];
		if (x) {
			useHotkeyStore.getState().hold(x);
			let { held: S, triggers: C } = useHotkeyStore.getState();
			Object.values(C).forEach(({ combo: x, cb: C }) => {
				Object.entries(x).every(([m, x]) => x === !!S[m]) && Object.entries(S).every(([m, S]) => S === !!x[m]) && (m.preventDefault(), C());
			}), x !== "meta" && x !== "ctrl" && x !== "shift" && useHotkeyStore.getState().release(x);
		}
	}, S = (m) => {
		let x = keyCodeMap[m.code];
		x && (x === "meta" ? useHotkeyStore.getState().reset() : useHotkeyStore.getState().release(x));
	}, C = (m) => {
		document.visibilityState === "hidden" && useHotkeyStore.getState().reset();
	};
	return m.addEventListener("keydown", x), m.addEventListener("keyup", S), m.addEventListener("visibilitychange", C), () => {
		m.removeEventListener("keydown", x), m.removeEventListener("keyup", S), m.removeEventListener("visibilitychange", C);
	};
}, useMonitorHotkeys = () => {
	useEffect(() => monitorHotkeys(document), []);
}, useHotkey = (m, x) => {
	useEffect(() => useHotkeyStore.setState((S) => ({ triggers: __spreadProps(__spreadValues({}, S.triggers), { [`${Object.keys(m).join("+")}`]: {
		combo: m,
		cb: x
	} }) })), []);
}, EMPTY_HISTORY_INDEX = 0;
function debounce(m, x = 300) {
	let S;
	return (...C) => {
		clearTimeout(S), S = setTimeout(() => {
			m(...C);
		}, x);
	};
}
var tidyState = (m) => __spreadProps(__spreadValues({}, m), { ui: __spreadProps(__spreadValues({}, m.ui), { field: { focus: null } }) }), createHistorySlice = (m, x) => ({
	initialAppState: {},
	index: EMPTY_HISTORY_INDEX,
	histories: [],
	hasPast: () => x().history.index > EMPTY_HISTORY_INDEX,
	hasFuture: () => x().history.index < x().history.histories.length - 1,
	prevHistory: () => {
		let { history: m } = x();
		return m.hasPast() ? m.histories[m.index - 1] : null;
	},
	nextHistory: () => {
		let m = x().history;
		return m.hasFuture() ? m.histories[m.index + 1] : null;
	},
	currentHistory: () => x().history.histories[x().history.index],
	back: () => {
		let { history: S, dispatch: C } = x();
		S.hasPast() && (C({
			type: "set",
			state: tidyState(S.prevHistory()?.state || S.initialAppState)
		}), m({ history: __spreadProps(__spreadValues({}, S), { index: S.index - 1 }) }));
	},
	forward: () => {
		let { history: S, dispatch: C } = x();
		if (S.hasFuture()) {
			let x = S.nextHistory()?.state;
			C({
				type: "set",
				state: x ? tidyState(x) : {}
			}), m({ history: __spreadProps(__spreadValues({}, S), { index: S.index + 1 }) });
		}
	},
	setHistories: (S) => {
		let { dispatch: C, history: T } = x();
		C({
			type: "set",
			state: S[S.length - 1]?.state || T.initialAppState
		}), m({ history: __spreadProps(__spreadValues({}, T), {
			histories: S,
			index: S.length - 1
		}) });
	},
	setHistoryIndex: (S) => {
		let { dispatch: C, history: T } = x();
		C({
			type: "set",
			state: T.histories[S]?.state || T.initialAppState
		}), m({ history: __spreadProps(__spreadValues({}, T), { index: S }) });
	},
	record: debounce((S) => {
		let { histories: C, index: T } = x().history, D = {
			state: S,
			id: generateId("history")
		}, O = [...C.slice(0, T + 1), D];
		m({ history: __spreadProps(__spreadValues({}, x().history), {
			histories: O,
			index: O.length - 1
		}) });
	}, 250)
});
function useRegisterHistorySlice(m, { histories: x, index: S, initialAppState: C }) {
	useEffect(() => m.setState({ history: __spreadProps(__spreadValues({}, m.getState().history), {
		histories: x,
		index: S,
		initialAppState: C
	}) }), [
		x,
		S,
		C
	]);
	let T = () => {
		m.getState().history.back();
	}, D = () => {
		m.getState().history.forward();
	};
	useHotkey({
		meta: !0,
		z: !0
	}, T), useHotkey({
		meta: !0,
		shift: !0,
		z: !0
	}, D), useHotkey({
		meta: !0,
		y: !0
	}, D), useHotkey({
		ctrl: !0,
		z: !0
	}, T), useHotkey({
		ctrl: !0,
		shift: !0,
		z: !0
	}, D), useHotkey({
		ctrl: !0,
		y: !0
	}, D);
}
init_react_import();
var createNodesSlice = (m, x) => ({
	nodes: {},
	registerNode: (S, C) => {
		let T = x().nodes, D = {
			id: S,
			methods: {
				sync: () => null,
				hideOverlay: () => null,
				showOverlay: () => null
			},
			element: null
		}, O = T.nodes[S];
		m({ nodes: __spreadProps(__spreadValues({}, T), { nodes: __spreadProps(__spreadValues({}, T.nodes), { [S]: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, D), O), C), { id: S }) }) }) });
	},
	unregisterNode: (S) => {
		let C = x().nodes;
		if (C.nodes[S]) {
			let x = __spreadValues({}, C.nodes);
			delete x[S], m({ nodes: __spreadProps(__spreadValues({}, C), { nodes: x }) });
		}
	}
});
init_react_import(), init_react_import();
var flattenData = (m, x) => {
	let S = [];
	return walkAppState(m, x, (m) => m, (m) => (S.push(m), null)), S;
}, createPermissionsSlice = (m, x) => {
	let S = (...S) => __async(void 0, [...S], function* (S = {}, C) {
		let { state: T, permissions: D, config: O } = x(), { cache: k, globalPermissions: A } = D, j = (S, C = !1) => __async(void 0, null, function* () {
			let { config: T, state: D, setComponentLoading: O } = x(), j = S.type === "root" ? T.root : T.components[S.type];
			if (!j) return;
			let M = __spreadValues(__spreadValues({}, A), j.permissions);
			if (j.resolvePermissions) {
				let T = getChanged(S, k[S.props.id]?.lastData);
				if (Object.values(T).some((m) => m === !0) || C) {
					let C = O(S.props.id, !0, 50), A = yield j.resolvePermissions(S, {
						changed: T,
						lastPermissions: k[S.props.id]?.lastPermissions || null,
						permissions: M,
						appState: makeStatePublic(D),
						lastData: k[S.props.id]?.lastData || null
					}), N = x().permissions;
					m({ permissions: __spreadProps(__spreadValues({}, N), {
						cache: __spreadProps(__spreadValues({}, N.cache), { [S.props.id]: {
							lastData: S,
							lastPermissions: A
						} }),
						resolvedPermissions: __spreadProps(__spreadValues({}, N.resolvedPermissions), { [S.props.id]: A })
					}) }), C();
				}
			}
		}), M = (m = !1) => {
			let { state: S } = x();
			j({
				type: "root",
				props: __spreadProps(__spreadValues({}, S.data.root.props), { id: "root" })
			}, m);
		}, { item: N, type: P, root: F } = S;
		N ? yield j(N, C) : P ? flattenData(T, O).filter((m) => m.type === P).map((m) => __async(void 0, null, function* () {
			yield j(m, C);
		})) : F ? M(C) : flattenData(T, O).map((m) => __async(void 0, null, function* () {
			yield j(m, C);
		}));
	});
	return {
		cache: {},
		globalPermissions: {
			drag: !0,
			edit: !0,
			delete: !0,
			duplicate: !0,
			insert: !0
		},
		resolvedPermissions: {},
		getPermissions: ({ item: m, type: S, root: C } = {}) => {
			let { config: T, permissions: D } = x(), { globalPermissions: O, resolvedPermissions: k } = D;
			if (m) {
				let x = T.components[m.type], S = __spreadValues(__spreadValues({}, O), x?.permissions), C = k[m.props.id];
				return C ? __spreadValues(__spreadValues({}, O), C) : S;
			} else if (S) {
				let m = T.components[S];
				return __spreadValues(__spreadValues({}, O), m?.permissions);
			} else if (C) {
				let m = T.root, x = __spreadValues(__spreadValues({}, O), m?.permissions), S = k.root;
				return S ? __spreadValues(__spreadValues({}, O), S) : x;
			}
			return O;
		},
		resolvePermissions: S,
		refreshPermissions: (m) => S(m, !0)
	};
}, useRegisterPermissionsSlice = (m, x) => {
	useEffect(() => {
		let { permissions: S } = m.getState(), { globalPermissions: C } = S;
		m.setState({ permissions: __spreadProps(__spreadValues({}, S), { globalPermissions: __spreadValues(__spreadValues({}, C), x) }) }), S.resolvePermissions();
	}, [x]), useEffect(() => m.subscribe((m) => m.state.data, () => {
		m.getState().permissions.resolvePermissions();
	}), []), useEffect(() => m.subscribe((m) => m.config, () => {
		m.getState().permissions.resolvePermissions();
	}), []);
};
init_react_import();
var createFieldsSlice = (m, x) => ({
	fields: {},
	loading: !1,
	lastResolvedData: {},
	id: void 0
}), useRegisterFieldsSlice = (m, x) => {
	let S = useCallback((S) => __async(void 0, null, function* () {
		let { fields: C, lastResolvedData: T } = m.getState().fields, D = m.getState().state.indexes.nodes, O = D[x || "root"], k = O?.data, A = (O?.parentId ? D[O.parentId] : null)?.data || null, { getComponentConfig: j, state: M } = m.getState(), N = j(k?.type);
		if (!k || !N) return;
		let P = N.fields || {}, F = N.resolveFields, I = C;
		if (S && (m.setState((m) => ({ fields: __spreadProps(__spreadValues({}, m.fields), {
			fields: P,
			id: x
		}) })), I = P), F) {
			let S = setTimeout(() => {
				m.setState((m) => ({ fields: __spreadProps(__spreadValues({}, m.fields), { loading: !0 }) }));
			}, 50), C = T.props?.id === x ? T : null, D = yield F(k, {
				changed: getChanged(k, C),
				fields: P,
				lastFields: I,
				lastData: C,
				appState: makeStatePublic(M),
				parent: A
			});
			if (clearTimeout(S), m.getState().selectedItem?.props.id !== x) return;
			m.setState({ fields: {
				fields: D,
				loading: !1,
				lastResolvedData: k,
				id: x
			} });
		} else m.setState((m) => ({ fields: __spreadProps(__spreadValues({}, m.fields), {
			fields: P,
			id: x
		}) }));
	}), [x]);
	useEffect(() => (S(!0), m.subscribe((m) => m.state.indexes.nodes[x || "root"], () => S())), [x]);
};
init_react_import();
var toRoot = (m) => {
	if ("type" in m && m.type !== "root") throw Error("Converting non-root item to root.");
	let { readOnly: x } = m;
	if (m.props) {
		if ("id" in m.props) {
			let S = m.props, { id: C } = S;
			return {
				props: __objRest(S, ["id"]),
				readOnly: x
			};
		}
		return {
			props: m.props,
			readOnly: x
		};
	}
	return {
		props: {},
		readOnly: x
	};
}, defaultPageFields = { title: { type: "text" } }, createAppStore = (m) => create()(subscribeWithSelector((x, S) => __spreadProps(__spreadValues({
	state: defaultAppState,
	config: { components: {} },
	componentState: {},
	plugins: [],
	overrides: {},
	viewports: defaultViewports,
	zoomConfig: {
		autoZoom: 1,
		rootHeight: 0,
		zoom: 1
	},
	status: "LOADING",
	iframe: {},
	metadata: {},
	fieldTransforms: {}
}, m), {
	fields: createFieldsSlice(x, S),
	history: createHistorySlice(x, S),
	nodes: createNodesSlice(x, S),
	permissions: createPermissionsSlice(x, S),
	getComponentConfig: (m) => {
		let { config: x, selectedItem: C } = S(), T = x.root?.fields || defaultPageFields;
		return m && m !== "root" ? x.components[m] : C ? x.components[C.type] : __spreadProps(__spreadValues({}, x.root), { fields: T });
	},
	selectedItem: (m?.state)?.ui.itemSelector ? getItem((m?.state)?.ui.itemSelector, m.state) : null,
	dispatch: (m) => x((x) => {
		var C, T;
		let { record: D } = S().history, O = createReducer({
			record: D,
			appStore: x
		})(x.state, m), k = O.ui.itemSelector ? getItem(O.ui.itemSelector, O) : null;
		return (T = (C = S()).onAction) == null || T.call(C, m, O, S().state), __spreadProps(__spreadValues({}, x), {
			state: O,
			selectedItem: k
		});
	}),
	setZoomConfig: (m) => x({ zoomConfig: m }),
	setStatus: (m) => x({ status: m }),
	setComponentState: (m) => x({ componentState: m }),
	pendingLoadTimeouts: {},
	setComponentLoading: (m, C = !0, T = 0) => {
		let { setComponentState: D, pendingLoadTimeouts: O } = S(), k = generateId(), A = () => {
			let { componentState: x } = S();
			D(__spreadProps(__spreadValues({}, x), { [m]: __spreadProps(__spreadValues({}, x[m]), { loadingCount: (x[m]?.loadingCount || 0) + 1 }) }));
		}, j = () => {
			let { componentState: C } = S();
			clearTimeout(M), delete O[k], x({ pendingLoadTimeouts: O }), D(__spreadProps(__spreadValues({}, C), { [m]: __spreadProps(__spreadValues({}, C[m]), { loadingCount: Math.max((C[m]?.loadingCount || 0) - 1, 0) }) }));
		}, M = setTimeout(() => {
			C ? A() : j(), delete O[k], x({ pendingLoadTimeouts: O });
		}, T);
		return x({ pendingLoadTimeouts: __spreadProps(__spreadValues({}, O), { [m]: M }) }), j;
	},
	unsetComponentLoading: (m) => {
		let { setComponentLoading: x } = S();
		x(m, !1);
	},
	setUi: (m, S) => x((x) => {
		let C = createReducer({
			record: () => {},
			appStore: x
		})(x.state, {
			type: "setUi",
			ui: m,
			recordHistory: S
		}), T = C.ui.itemSelector ? getItem(C.ui.itemSelector, C) : null;
		return __spreadProps(__spreadValues({}, x), {
			state: C,
			selectedItem: T
		});
	}),
	resolveComponentData: (m, x) => __async(void 0, null, function* () {
		let { config: C, metadata: T, setComponentLoading: D, permissions: O } = S(), k = {};
		return yield resolveComponentData(m, C, T, (m) => {
			let x = "id" in m.props ? m.props.id : "root";
			k[x] = D(x, !0, 50);
		}, (m) => __async(void 0, null, function* () {
			let x = "id" in m.props ? m.props.id : "root";
			"type" in m ? yield O.refreshPermissions({ item: m }) : yield O.refreshPermissions({ root: !0 }), k[x]();
		}), x);
	}),
	resolveAndCommitData: () => __async(void 0, null, function* () {
		let { config: m, state: x, dispatch: C, resolveComponentData: T } = S();
		walkAppState(x, m, (m) => m, (m) => (T(m, "load").then((m) => {
			let { state: x } = S(), T = x.indexes.nodes[m.node.props.id];
			if (T && m.didChange) if (m.node.props.id === "root") C({
				type: "replaceRoot",
				root: toRoot(m.node)
			});
			else {
				let S = `${T.parentId}:${T.zone}`, D = x.indexes.zones[S].contentIds.indexOf(m.node.props.id);
				C({
					type: "replace",
					data: m.node,
					destinationIndex: D,
					destinationZone: S
				});
			}
		}), m));
	})
}))), appStoreContext = createContext(createAppStore());
function useAppStore(m) {
	return useStore(useContext(appStoreContext), m);
}
function useAppStoreApi() {
	return useContext(appStoreContext);
}
init_react_import(), init_react_import(), init_react_import();
var isProduction = process.env.NODE_ENV === "production", prefix = "Invariant failed";
function invariant$1(m, x) {
	if (!m) {
		if (isProduction) throw Error(prefix);
		var S = typeof x == "function" ? x() : x, C = S ? `${prefix}: ${S}` : prefix;
		throw Error(C);
	}
}
var getRect = function(m) {
	var x = m.top, S = m.right, C = m.bottom, T = m.left;
	return {
		top: x,
		right: S,
		bottom: C,
		left: T,
		width: S - T,
		height: C - x,
		x: T,
		y: x,
		center: {
			x: (S + T) / 2,
			y: (C + x) / 2
		}
	};
}, expand = function(m, x) {
	return {
		top: m.top - x.top,
		left: m.left - x.left,
		bottom: m.bottom + x.bottom,
		right: m.right + x.right
	};
}, shrink = function(m, x) {
	return {
		top: m.top + x.top,
		left: m.left + x.left,
		bottom: m.bottom - x.bottom,
		right: m.right - x.right
	};
}, noSpacing = {
	top: 0,
	right: 0,
	bottom: 0,
	left: 0
}, createBox$1 = function(m) {
	var x = m.borderBox, S = m.margin, C = S === void 0 ? noSpacing : S, T = m.border, D = T === void 0 ? noSpacing : T, O = m.padding, k = O === void 0 ? noSpacing : O, A = getRect(expand(x, C)), j = getRect(shrink(x, D)), M = getRect(shrink(j, k));
	return {
		marginBox: A,
		borderBox: getRect(x),
		paddingBox: j,
		contentBox: M,
		margin: C,
		border: D,
		padding: k
	};
}, parse$1 = function(m) {
	var x = m.slice(0, -2);
	if (m.slice(-2) !== "px") return 0;
	var S = Number(x);
	return isNaN(S) && (process.env.NODE_ENV === "production" ? invariant$1(!1) : invariant$1(!1, "Could not parse value [raw: " + m + ", without suffix: " + x + "]")), S;
}, calculateBox = function(m, x) {
	return createBox$1({
		borderBox: m,
		margin: {
			top: parse$1(x.marginTop),
			right: parse$1(x.marginRight),
			bottom: parse$1(x.marginBottom),
			left: parse$1(x.marginLeft)
		},
		padding: {
			top: parse$1(x.paddingTop),
			right: parse$1(x.paddingRight),
			bottom: parse$1(x.paddingBottom),
			left: parse$1(x.paddingLeft)
		},
		border: {
			top: parse$1(x.borderTopWidth),
			right: parse$1(x.borderRightWidth),
			bottom: parse$1(x.borderBottomWidth),
			left: parse$1(x.borderLeftWidth)
		}
	});
}, getBox = function(m) {
	return calculateBox(m.getBoundingClientRect(), window.getComputedStyle(m));
}, RESET_ZOOM_SMALLER_THAN_FRAME = !0, getZoomConfig = (m, x, S) => {
	let { width: C, height: T } = getBox(x).contentBox, D = m.height === "auto" ? T : m.height, O = 0, k = 1;
	if (m.width > C || D > T) {
		let x = Math.min(C / m.width, 1), A = Math.min(T / D, 1);
		S = x, x < A ? O = D / S : (O = D, S = A), k = S;
	} else RESET_ZOOM_SMALLER_THAN_FRAME && (k = 1, S = 1, O = D);
	return {
		autoZoom: k,
		rootHeight: O,
		zoom: S
	};
}, useResetAutoZoom = (m) => {
	let x = useAppStoreApi();
	return (S) => {
		let { state: C, zoomConfig: T, setZoomConfig: D } = x.getState(), { viewports: O } = C.ui, k = S?.viewports || O;
		m.current && D(getZoomConfig(k?.current, m.current, T.zoom));
	};
};
init_react_import();
var getClassName2 = get_class_name_factory_default("Loader", {
	Loader: "_Loader_nacdm_13",
	"loader-animation": "_loader-animation_nacdm_1"
}), Loader = (m) => {
	var x = m, { color: S, size: C = 16 } = x, T = __objRest(x, ["color", "size"]);
	return /* @__PURE__ */ jsx("span", __spreadValues({
		className: getClassName2(),
		style: {
			width: C,
			height: C,
			color: S
		},
		"aria-label": "loading"
	}, T));
}, getClassName3 = get_class_name_factory_default("IconButton", IconButton_module_default), IconButton = ({ children: m, href: x, onClick: S, variant: C = "primary", type: T, disabled: D, tabIndex: O, newTab: k, fullWidth: A, title: j }) => {
	let [M, N] = useState(!1);
	return /* @__PURE__ */ jsxs(x ? "a" : "button", {
		className: getClassName3({
			primary: C === "primary",
			secondary: C === "secondary",
			disabled: D,
			fullWidth: A
		}),
		onClick: (m) => {
			S && (N(!0), Promise.resolve(S(m)).then(() => {
				N(!1);
			}));
		},
		type: T,
		disabled: D || M,
		tabIndex: O,
		target: k ? "_blank" : void 0,
		rel: k ? "noreferrer" : void 0,
		href: x,
		title: j,
		children: [
			/* @__PURE__ */ jsx("span", {
				className: getClassName3("title"),
				children: j
			}),
			m,
			M && /* @__PURE__ */ jsxs(Fragment$1, { children: ["\xA0\xA0", /* @__PURE__ */ jsx(Loader, { size: 14 })] })
		]
	});
};
init_react_import(), init_react_import();
var Button_module_default = {
	Button: "_Button_10byl_1",
	"Button--medium": "_Button--medium_10byl_29",
	"Button--large": "_Button--large_10byl_37",
	"Button-icon": "_Button-icon_10byl_44",
	"Button--primary": "_Button--primary_10byl_48",
	"Button--secondary": "_Button--secondary_10byl_67",
	"Button--flush": "_Button--flush_10byl_84",
	"Button--disabled": "_Button--disabled_10byl_88",
	"Button--fullWidth": "_Button--fullWidth_10byl_95",
	"Button-spinner": "_Button-spinner_10byl_100"
};
init_react_import();
var dataAttrRe = /^(data-.*)$/, filterDataAttrs = (m) => {
	let x = {};
	for (let S in m) Object.prototype.hasOwnProperty.call(m, S) && dataAttrRe.test(S) && (x[S] = m[S]);
	return x;
}, getClassName4 = get_class_name_factory_default("Button", Button_module_default), Button = (m) => {
	var x = m, { children: S, href: C, onClick: T, variant: D = "primary", type: O, disabled: k, tabIndex: A, newTab: j, fullWidth: M, icon: N, size: F = "medium", loading: I = !1 } = x, L = __objRest(x, [
		"children",
		"href",
		"onClick",
		"variant",
		"type",
		"disabled",
		"tabIndex",
		"newTab",
		"fullWidth",
		"icon",
		"size",
		"loading"
	]);
	let [R, z] = useState(I);
	useEffect(() => z(I), [I]);
	let B = C ? "a" : O ? "button" : "span", U = filterDataAttrs(L);
	return /* @__PURE__ */ jsxs(B, __spreadProps(__spreadValues({
		className: getClassName4({
			primary: D === "primary",
			secondary: D === "secondary",
			disabled: k,
			fullWidth: M,
			[F]: !0
		}),
		onClick: (m) => {
			T && (z(!0), Promise.resolve(T(m)).then(() => {
				z(!1);
			}));
		},
		type: O,
		disabled: k || R,
		tabIndex: A,
		target: j ? "_blank" : void 0,
		rel: j ? "noreferrer" : void 0,
		href: C
	}, U), { children: [
		N && /* @__PURE__ */ jsx("div", {
			className: getClassName4("icon"),
			children: N
		}),
		S,
		R && /* @__PURE__ */ jsx("div", {
			className: getClassName4("spinner"),
			children: /* @__PURE__ */ jsx(Loader, { size: 14 })
		})
	] }));
};
init_react_import(), init_react_import();
var styles_module_default3 = {
	InputWrapper: "_InputWrapper_bsxfo_1",
	"Input-label": "_Input-label_bsxfo_5",
	"Input-labelIcon": "_Input-labelIcon_bsxfo_14",
	"Input-disabledIcon": "_Input-disabledIcon_bsxfo_21",
	"Input-input": "_Input-input_bsxfo_26",
	Input: "_Input_bsxfo_1",
	"Input--readOnly": "_Input--readOnly_bsxfo_82",
	"Input-radioGroupItems": "_Input-radioGroupItems_bsxfo_93",
	"Input-radio": "_Input-radio_bsxfo_93",
	"Input-radioInner": "_Input-radioInner_bsxfo_110",
	"Input-radioInput": "_Input-radioInput_bsxfo_155"
};
init_react_import(), init_react_import(), init_react_import();
var styles_module_default4 = {
	ArrayField: "_ArrayField_14u8o_5",
	"ArrayField--isDraggingFrom": "_ArrayField--isDraggingFrom_14u8o_13",
	"ArrayField-addButton": "_ArrayField-addButton_14u8o_18",
	"ArrayField--hasItems": "_ArrayField--hasItems_14u8o_33",
	"ArrayField-inner": "_ArrayField-inner_14u8o_59",
	ArrayFieldItem: "_ArrayFieldItem_14u8o_67",
	"ArrayFieldItem--isDragging": "_ArrayFieldItem--isDragging_14u8o_78",
	"ArrayFieldItem--isExpanded": "_ArrayFieldItem--isExpanded_14u8o_82",
	"ArrayFieldItem-summary": "_ArrayFieldItem-summary_14u8o_97",
	"ArrayField--addDisabled": "_ArrayField--addDisabled_14u8o_127",
	"ArrayFieldItem-body": "_ArrayFieldItem-body_14u8o_166",
	"ArrayFieldItem-fieldset": "_ArrayFieldItem-fieldset_14u8o_175",
	"ArrayFieldItem-rhs": "_ArrayFieldItem-rhs_14u8o_183",
	"ArrayFieldItem-actions": "_ArrayFieldItem-actions_14u8o_189"
};
init_react_import(), init_react_import(), init_react_import();
var toKebabCase = (m) => m.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), mergeClasses = (...m) => m.filter((m, x, S) => !!m && m.trim() !== "" && S.indexOf(m) === x).join(" ").trim();
init_react_import(), init_react_import();
var defaultAttributes = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	strokeWidth: 2,
	strokeLinecap: "round",
	strokeLinejoin: "round"
}, Icon = forwardRef((m, x) => {
	var S = m, { color: C = "currentColor", size: T = 24, strokeWidth: O = 2, absoluteStrokeWidth: k, className: A = "", children: j, iconNode: M } = S, N = __objRest(S, [
		"color",
		"size",
		"strokeWidth",
		"absoluteStrokeWidth",
		"className",
		"children",
		"iconNode"
	]);
	return createElement("svg", __spreadValues(__spreadProps(__spreadValues({ ref: x }, defaultAttributes), {
		width: T,
		height: T,
		stroke: C,
		strokeWidth: k ? Number(O) * 24 / Number(T) : O,
		className: mergeClasses("lucide", A)
	}), N), [...M.map(([m, x]) => createElement(m, x)), ...Array.isArray(j) ? j : [j]]);
}), createLucideIcon = (m, x) => {
	let S = forwardRef((S, C) => {
		var T = S, { className: O } = T, k = __objRest(T, ["className"]);
		return createElement(Icon, __spreadValues({
			ref: C,
			iconNode: x,
			className: mergeClasses(`lucide-${toKebabCase(m)}`, O)
		}, k));
	});
	return S.displayName = `${m}`, S;
};
init_react_import();
var ChevronDown = createLucideIcon("ChevronDown", [["path", {
	d: "m6 9 6 6 6-6",
	key: "qrunsl"
}]]);
init_react_import();
var ChevronRight = createLucideIcon("ChevronRight", [["path", {
	d: "m9 18 6-6-6-6",
	key: "mthhwq"
}]]);
init_react_import();
var ChevronUp = createLucideIcon("ChevronUp", [["path", {
	d: "m18 15-6-6-6 6",
	key: "153udz"
}]]);
init_react_import();
var CircleCheckBig = createLucideIcon("CircleCheckBig", [["path", {
	d: "M21.801 10A10 10 0 1 1 17 3.335",
	key: "yps3ct"
}], ["path", {
	d: "m9 11 3 3L22 4",
	key: "1pflzl"
}]]);
init_react_import();
var Copy = createLucideIcon("Copy", [["rect", {
	width: "14",
	height: "14",
	x: "8",
	y: "8",
	rx: "2",
	ry: "2",
	key: "17jyea"
}], ["path", {
	d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
	key: "zix9uf"
}]]);
init_react_import();
var CornerLeftUp = createLucideIcon("CornerLeftUp", [["polyline", {
	points: "14 9 9 4 4 9",
	key: "m9oyvo"
}], ["path", {
	d: "M20 20h-7a4 4 0 0 1-4-4V4",
	key: "1blwi3"
}]]);
init_react_import();
var EllipsisVertical = createLucideIcon("EllipsisVertical", [
	["circle", {
		cx: "12",
		cy: "12",
		r: "1",
		key: "41hilf"
	}],
	["circle", {
		cx: "12",
		cy: "5",
		r: "1",
		key: "gxeob9"
	}],
	["circle", {
		cx: "12",
		cy: "19",
		r: "1",
		key: "lyex9k"
	}]
]);
init_react_import();
var Globe = createLucideIcon("Globe", [
	["circle", {
		cx: "12",
		cy: "12",
		r: "10",
		key: "1mglay"
	}],
	["path", {
		d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20",
		key: "13o1zl"
	}],
	["path", {
		d: "M2 12h20",
		key: "9i4pu4"
	}]
]);
init_react_import();
var Hash = createLucideIcon("Hash", [
	["line", {
		x1: "4",
		x2: "20",
		y1: "9",
		y2: "9",
		key: "4lhtct"
	}],
	["line", {
		x1: "4",
		x2: "20",
		y1: "15",
		y2: "15",
		key: "vyu0kd"
	}],
	["line", {
		x1: "10",
		x2: "8",
		y1: "3",
		y2: "21",
		key: "1ggp8o"
	}],
	["line", {
		x1: "16",
		x2: "14",
		y1: "3",
		y2: "21",
		key: "weycgp"
	}]
]);
init_react_import();
var Layers = createLucideIcon("Layers", [
	["path", {
		d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
		key: "zw3jo"
	}],
	["path", {
		d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
		key: "1wduqc"
	}],
	["path", {
		d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
		key: "kqbvx6"
	}]
]);
init_react_import();
var LayoutGrid = createLucideIcon("LayoutGrid", [
	["rect", {
		width: "7",
		height: "7",
		x: "3",
		y: "3",
		rx: "1",
		key: "1g98yp"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "14",
		y: "3",
		rx: "1",
		key: "6d4xhi"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "14",
		y: "14",
		rx: "1",
		key: "nxv5o0"
	}],
	["rect", {
		width: "7",
		height: "7",
		x: "3",
		y: "14",
		rx: "1",
		key: "1bb6yr"
	}]
]);
init_react_import();
var Link = createLucideIcon("Link", [["path", {
	d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
	key: "1cjeqo"
}], ["path", {
	d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
	key: "19qd67"
}]]);
init_react_import();
var List = createLucideIcon("List", [
	["path", {
		d: "M3 12h.01",
		key: "nlz23k"
	}],
	["path", {
		d: "M3 18h.01",
		key: "1tta3j"
	}],
	["path", {
		d: "M3 6h.01",
		key: "1rqtza"
	}],
	["path", {
		d: "M8 12h13",
		key: "1za7za"
	}],
	["path", {
		d: "M8 18h13",
		key: "1lx6n3"
	}],
	["path", {
		d: "M8 6h13",
		key: "ik3vkj"
	}]
]);
init_react_import();
var LockOpen = createLucideIcon("LockOpen", [["rect", {
	width: "18",
	height: "11",
	x: "3",
	y: "11",
	rx: "2",
	ry: "2",
	key: "1w4ew1"
}], ["path", {
	d: "M7 11V7a5 5 0 0 1 9.9-1",
	key: "1mm8w8"
}]]);
init_react_import();
var Lock = createLucideIcon("Lock", [["rect", {
	width: "18",
	height: "11",
	x: "3",
	y: "11",
	rx: "2",
	ry: "2",
	key: "1w4ew1"
}], ["path", {
	d: "M7 11V7a5 5 0 0 1 10 0v4",
	key: "fwvmzm"
}]]);
init_react_import();
var Monitor = createLucideIcon("Monitor", [
	["rect", {
		width: "20",
		height: "14",
		x: "2",
		y: "3",
		rx: "2",
		key: "48i651"
	}],
	["line", {
		x1: "8",
		x2: "16",
		y1: "21",
		y2: "21",
		key: "1svkeh"
	}],
	["line", {
		x1: "12",
		x2: "12",
		y1: "17",
		y2: "21",
		key: "vw1qmm"
	}]
]);
init_react_import();
var PanelLeft = createLucideIcon("PanelLeft", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}], ["path", {
	d: "M9 3v18",
	key: "fh3hqa"
}]]);
init_react_import();
var PanelRight = createLucideIcon("PanelRight", [["rect", {
	width: "18",
	height: "18",
	x: "3",
	y: "3",
	rx: "2",
	key: "afitv7"
}], ["path", {
	d: "M15 3v18",
	key: "14nvp0"
}]]);
init_react_import();
var Plus = createLucideIcon("Plus", [["path", {
	d: "M5 12h14",
	key: "1ays0h"
}], ["path", {
	d: "M12 5v14",
	key: "s699le"
}]]);
init_react_import();
var Redo2 = createLucideIcon("Redo2", [["path", {
	d: "m15 14 5-5-5-5",
	key: "12vg1m"
}], ["path", {
	d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13",
	key: "6uklza"
}]]);
init_react_import();
var Search = createLucideIcon("Search", [["circle", {
	cx: "11",
	cy: "11",
	r: "8",
	key: "4ej97u"
}], ["path", {
	d: "m21 21-4.3-4.3",
	key: "1qie3q"
}]]);
init_react_import();
var SlidersHorizontal = createLucideIcon("SlidersHorizontal", [
	["line", {
		x1: "21",
		x2: "14",
		y1: "4",
		y2: "4",
		key: "obuewd"
	}],
	["line", {
		x1: "10",
		x2: "3",
		y1: "4",
		y2: "4",
		key: "1q6298"
	}],
	["line", {
		x1: "21",
		x2: "12",
		y1: "12",
		y2: "12",
		key: "1iu8h1"
	}],
	["line", {
		x1: "8",
		x2: "3",
		y1: "12",
		y2: "12",
		key: "ntss68"
	}],
	["line", {
		x1: "21",
		x2: "16",
		y1: "20",
		y2: "20",
		key: "14d8ph"
	}],
	["line", {
		x1: "12",
		x2: "3",
		y1: "20",
		y2: "20",
		key: "m0wm8r"
	}],
	["line", {
		x1: "14",
		x2: "14",
		y1: "2",
		y2: "6",
		key: "14e1ph"
	}],
	["line", {
		x1: "8",
		x2: "8",
		y1: "10",
		y2: "14",
		key: "1i6ji0"
	}],
	["line", {
		x1: "16",
		x2: "16",
		y1: "18",
		y2: "22",
		key: "1lctlv"
	}]
]);
init_react_import();
var Smartphone = createLucideIcon("Smartphone", [["rect", {
	width: "14",
	height: "20",
	x: "5",
	y: "2",
	rx: "2",
	ry: "2",
	key: "1yt0o3"
}], ["path", {
	d: "M12 18h.01",
	key: "mhygvu"
}]]);
init_react_import();
var Tablet = createLucideIcon("Tablet", [["rect", {
	width: "16",
	height: "20",
	x: "4",
	y: "2",
	rx: "2",
	ry: "2",
	key: "76otgf"
}], ["line", {
	x1: "12",
	x2: "12.01",
	y1: "18",
	y2: "18",
	key: "1dp563"
}]]);
init_react_import();
var Trash = createLucideIcon("Trash", [
	["path", {
		d: "M3 6h18",
		key: "d0wm0j"
	}],
	["path", {
		d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
		key: "4alrt4"
	}],
	["path", {
		d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
		key: "v07s0e"
	}]
]);
init_react_import();
var Type = createLucideIcon("Type", [
	["polyline", {
		points: "4 7 4 4 20 4 20 7",
		key: "1nosan"
	}],
	["line", {
		x1: "9",
		x2: "15",
		y1: "20",
		y2: "20",
		key: "swin9y"
	}],
	["line", {
		x1: "12",
		x2: "12",
		y1: "4",
		y2: "20",
		key: "1tx1rr"
	}]
]);
init_react_import();
var Undo2 = createLucideIcon("Undo2", [["path", {
	d: "M9 14 4 9l5-5",
	key: "102s5s"
}], ["path", {
	d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11",
	key: "f3b9sd"
}]]);
init_react_import();
var ZoomIn = createLucideIcon("ZoomIn", [
	["circle", {
		cx: "11",
		cy: "11",
		r: "8",
		key: "4ej97u"
	}],
	["line", {
		x1: "21",
		x2: "16.65",
		y1: "21",
		y2: "16.65",
		key: "13gj7c"
	}],
	["line", {
		x1: "11",
		x2: "11",
		y1: "8",
		y2: "14",
		key: "1vmskp"
	}],
	["line", {
		x1: "8",
		x2: "14",
		y1: "11",
		y2: "11",
		key: "durymu"
	}]
]);
init_react_import();
var ZoomOut = createLucideIcon("ZoomOut", [
	["circle", {
		cx: "11",
		cy: "11",
		r: "8",
		key: "4ej97u"
	}],
	["line", {
		x1: "21",
		x2: "16.65",
		y1: "21",
		y2: "16.65",
		key: "13gj7c"
	}],
	["line", {
		x1: "8",
		x2: "14",
		y1: "11",
		y2: "11",
		key: "durymu"
	}]
]);
init_react_import(), init_react_import(), init_react_import();
var getClassName5 = get_class_name_factory_default("DragIcon", {
	DragIcon: "_DragIcon_17p8x_1",
	"DragIcon--disabled": "_DragIcon--disabled_17p8x_8"
}), DragIcon = ({ isDragDisabled: m }) => /* @__PURE__ */ jsx("div", {
	className: getClassName5({ disabled: m }),
	children: /* @__PURE__ */ jsx("svg", {
		viewBox: "0 0 20 20",
		width: "12",
		fill: "currentColor",
		children: /* @__PURE__ */ jsx("path", { d: "M7 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 2zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 14zm6-8a2 2 0 1 0-.001-4.001A2 2 0 0 0 13 6zm0 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 14z" })
	})
});
init_react_import(), init_react_import();
var touchDefault = { delay: {
	value: 200,
	tolerance: 10
} }, otherDefault = {
	delay: {
		value: 200,
		tolerance: 10
	},
	distance: { value: 5 }
}, useSensors = ({ other: m = otherDefault, mouse: x, touch: S = touchDefault } = {
	touch: touchDefault,
	other: otherDefault
}) => {
	let [C] = useState(() => [PointerSensor.configure({ activationConstraints(C, T) {
		let { pointerType: D, target: O } = C;
		return D === "mouse" && isElement(O) && (T.handle === O || T.handle?.contains(O)) ? x : D === "touch" ? S : m;
	} })]);
	return C;
};
init_react_import(), init_react_import(), init_react_import();
var DEBUG = !1, debugElements = {}, timeout, collisionDebug = (m, x, S, C, T) => {
	if (!DEBUG) return;
	let D = `${S}-debug`;
	clearTimeout(timeout), timeout = setTimeout(() => {
		Object.entries(debugElements).forEach(([m, { svg: x }]) => {
			x.remove(), delete debugElements[m];
		});
	}, 1e3), requestAnimationFrame(() => {
		let S = debugElements[D], O = debugElements[D]?.line, k = debugElements[D]?.text;
		if (!S) {
			let m = "http://www.w3.org/2000/svg", x = document.createElementNS(m, "svg");
			O = document.createElementNS(m, "line"), k = document.createElementNS(m, "text"), x.setAttribute("id", D), x.setAttribute("style", "position: fixed; height: 100%; width: 100%; pointer-events: none; top: 0px; left: 0px;"), x.appendChild(O), x.appendChild(k), k.setAttribute("fill", "black"), document.body.appendChild(x), debugElements[D] = {
				svg: x,
				line: O,
				text: k
			};
		}
		O.setAttribute("x1", m.x.toString()), O.setAttribute("x2", x.x.toString()), O.setAttribute("y1", m.y.toString()), O.setAttribute("y2", x.y.toString()), O.setAttribute("style", `stroke:${C};stroke-width:2`), k.setAttribute("x", (m.x - (m.x - x.x) / 2).toString()), k.setAttribute("y", (m.y - (m.y - x.y) / 2).toString()), T && (k.innerHTML = T);
	});
}, distanceChange = "increasing", directionalCollision = (m, x) => {
	let { dragOperation: S, droppable: C } = m, { shape: T } = C, { position: D } = S, O = S.shape?.current;
	if (!O || !T) return null;
	let k = T.center, A = Math.sqrt((k.x - x.x) ** 2 + (k.y - x.y) ** 2), j = Math.sqrt((k.x - D.current.x) ** 2 + (k.y - D.current.y) ** 2);
	return distanceChange = j === A ? distanceChange : j < A ? "decreasing" : "increasing", collisionDebug(O.center, k, C.id.toString(), "rebeccapurple"), distanceChange === "decreasing" ? {
		id: C.id,
		value: 1,
		type: CollisionType.Collision
	} : null;
};
init_react_import();
var getDirection = (m, x) => m === "dynamic" ? Math.abs(x.y) > Math.abs(x.x) ? x.y === 0 ? null : x.y > 0 ? "down" : "up" : x.x === 0 ? null : x.x > 0 ? "right" : "left" : m === "x" ? x.x === 0 ? null : x.x > 0 ? "right" : "left" : x.y === 0 ? null : x.y > 0 ? "down" : "up";
init_react_import();
var getMidpointImpact = (m, x, S, C = 0) => {
	let T = m.boundingRectangle, D = x.center;
	if (S === "down") {
		let m = C * x.boundingRectangle.height;
		return T.bottom >= D.y + m;
	} else if (S === "up") {
		let m = C * x.boundingRectangle.height;
		return T.top < D.y - m;
	} else if (S === "left") {
		let m = C * x.boundingRectangle.width;
		return D.x - m >= T.left;
	}
	let O = C * x.boundingRectangle.width;
	return T.right - O >= D.x;
};
init_react_import();
var INTERVAL_SENSITIVITY = 10, intervalCache = {
	current: {
		x: 0,
		y: 0
	},
	delta: {
		x: 0,
		y: 0
	},
	previous: {
		x: 0,
		y: 0
	},
	direction: null
}, trackMovementInterval = (m, x = "dynamic") => (intervalCache.current = m, intervalCache.delta = {
	x: m.x - intervalCache.previous.x,
	y: m.y - intervalCache.previous.y
}, intervalCache.direction = getDirection(x, intervalCache.delta) || intervalCache.direction, (Math.abs(intervalCache.delta.x) > INTERVAL_SENSITIVITY || Math.abs(intervalCache.delta.y) > INTERVAL_SENSITIVITY) && (intervalCache.previous = Point.from(m)), intervalCache);
init_react_import();
var pointerIntersection = ({ dragOperation: m, droppable: x }) => {
	let S = m.position.current;
	if (!S) return null;
	let { id: C } = x;
	return x.shape && x.shape.containsPoint(S) ? {
		id: C,
		value: 1 / Point.distance(x.shape.center, S),
		type: CollisionType.PointerIntersection,
		priority: CollisionPriority.High
	} : null;
}, closestCorners = (m) => {
	let { dragOperation: x, droppable: S } = m, { shape: C, position: T } = x;
	if (!S.shape) return null;
	let D = C ? Rectangle.from(C.current.boundingRectangle).corners : void 0, O = Rectangle.from(S.shape.boundingRectangle).corners.reduce((m, x, S) => m + Point.distance(Point.from(x), D?.[S] ?? T.current), 0) / 4;
	return {
		id: S.id,
		value: 1 / O,
		type: CollisionType.Collision,
		priority: CollisionPriority.Normal
	};
};
init_react_import();
var collisionStore = createStore(() => ({ fallbackEnabled: !1 })), flushNext = "", createDynamicCollisionDetector = (m, x = .05) => (S) => {
	let { dragOperation: C, droppable: T } = S, { position: D } = C, O = C.shape?.current, { shape: k } = T;
	if (!O || !k) return null;
	let { center: A } = O, { fallbackEnabled: j } = collisionStore.getState(), M = trackMovementInterval(D.current, m), N = { direction: M.direction }, { center: P } = k, F = getMidpointImpact(O, k, M.direction, x);
	if (C.source?.id === T.id) {
		let m = directionalCollision(S, M.previous);
		if (collisionDebug(A, P, T.id.toString(), "yellow"), m) return __spreadProps(__spreadValues({}, m), {
			priority: CollisionPriority.Highest,
			data: N
		});
	}
	let I = O.intersectionArea(k), L = I / k.area;
	if (I && F) {
		collisionDebug(A, P, T.id.toString(), "green", M.direction);
		let m = {
			id: T.id,
			value: L,
			priority: CollisionPriority.High,
			type: CollisionType.Collision
		}, x = flushNext === T.id;
		return flushNext = "", __spreadProps(__spreadValues({}, m), {
			id: x ? "flush" : m.id,
			data: N
		});
	}
	if (j && C.source?.id !== T.id) {
		let x = k.boundingRectangle.right > O.boundingRectangle.left && k.boundingRectangle.left < O.boundingRectangle.right, C = k.boundingRectangle.bottom > O.boundingRectangle.top && k.boundingRectangle.top < O.boundingRectangle.bottom;
		if (m === "y" && x || C) {
			let x = closestCorners(S);
			if (x) {
				let S = getDirection(m, {
					x: O.center.x - (T.shape?.center.x || 0),
					y: O.center.y - (T.shape?.center.y || 0)
				});
				return N.direction = S, I ? (collisionDebug(A, P, T.id.toString(), "red", S || ""), flushNext = T.id, __spreadProps(__spreadValues({}, x), {
					priority: CollisionPriority.Low,
					data: N
				})) : (collisionDebug(A, P, T.id.toString(), "orange", S || ""), __spreadProps(__spreadValues({}, x), {
					priority: CollisionPriority.Lowest,
					data: N
				}));
			}
		}
	}
	return collisionDebug(A, P, T.id.toString(), "hotpink"), null;
}, SortableProvider = ({ children: m, onDragStart: x, onDragEnd: S, onMove: C }) => /* @__PURE__ */ jsx(DragDropProvider, {
	sensors: useSensors({ mouse: { distance: { value: 5 } } }),
	onDragStart: (m) => x(m.operation.source?.id.toString() ?? ""),
	onDragOver: (m, x) => {
		m.preventDefault();
		let { operation: S } = m, { source: T, target: D } = S;
		if (!T || !D) return;
		let O = T.data.index, k = D.data.index, A = x.collisionObserver.collisions[0]?.data;
		if (O !== k && T.id !== D.id) {
			let m = A?.direction === "up" ? "before" : "after";
			k >= O && --k, m === "after" && (k += 1), C({
				source: O,
				target: k
			});
		}
	},
	onDragEnd: () => {
		setTimeout(() => {
			S();
		}, 250);
	},
	children: m
}), Sortable = ({ id: m, index: x, disabled: S, children: C, type: T = "item" }) => {
	let { ref: D, isDragging: O, isDropping: k, handleRef: A } = useSortable({
		id: m,
		type: T,
		index: x,
		disabled: S,
		data: { index: x },
		collisionDetector: createDynamicCollisionDetector("y")
	});
	return C({
		isDragging: O,
		isDropping: k,
		ref: D,
		handleRef: A
	});
};
init_react_import();
var NestedFieldContext = createContext({}), useNestedFieldContext = () => {
	let m = useContext(NestedFieldContext);
	return __spreadProps(__spreadValues({}, m), { readOnlyFields: m.readOnlyFields || {} });
}, NestedFieldProvider = ({ children: m, name: x, subName: S, wildcardName: C = x, readOnlyFields: T }) => {
	let D = `${x}.${S}`, O = `${C}.${S}`, k = useMemo(() => Object.keys(T).reduce((m, S) => {
		if (S.indexOf(D) > -1 || S.indexOf(O) > -1) {
			let D = new RegExp(`^(${x}|${C}).`.replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\./g, "\\.").replace(/\*/g, "\\*")), O = S.replace(D, "");
			return __spreadProps(__spreadValues({}, m), { [O]: T[S] });
		}
		return m;
	}, {}), [
		x,
		S,
		C,
		T
	]);
	return /* @__PURE__ */ jsx(NestedFieldContext.Provider, {
		value: {
			readOnlyFields: k,
			localName: S
		},
		children: m
	});
}, getClassName6 = get_class_name_factory_default("ArrayField", styles_module_default4), getClassNameItem = get_class_name_factory_default("ArrayFieldItem", styles_module_default4), ArrayField = ({ field: m, onChange: x, value: S, name: C, label: T, labelIcon: D, readOnly: O, id: k, Label: A = (m) => /* @__PURE__ */ jsx("div", __spreadValues({}, m)) }) => {
	let j = useAppStore((m) => m.state.ui.arrayState[k]), N = useAppStore((m) => m.setUi), { readOnlyFields: F, localName: I = C } = useNestedFieldContext(), L = S, R = j || {
		items: Array.from(L || []).map((m, x) => ({
			_originalIndex: x,
			_arrayId: `${k}-${x}`
		})),
		openId: ""
	}, [z, U] = useState({
		arrayState: R,
		value: L
	});
	useEffect(() => {
		U({
			arrayState: W.getState().state.ui.arrayState[k] ?? R,
			value: L
		});
	}, [L]);
	let W = useAppStoreApi(), q = useCallback((m) => {
		let x = W.getState().state;
		return { arrayState: __spreadProps(__spreadValues({}, x.ui.arrayState), { [k]: __spreadValues(__spreadValues({}, R), m) }) };
	}, [R, W]), J = useCallback(() => R.items.reduce((m, x) => x._originalIndex > m ? x._originalIndex : m, -1), [R]), Y = useCallback((m) => {
		let x = J(), S = Array.from(m || []).map((m, S) => {
			let C = R.items[S], T = {
				_originalIndex: C?._originalIndex === void 0 ? x + 1 : C._originalIndex,
				_arrayId: R.items[S]?._arrayId || `${k}-${x + 1}`
			};
			return T._originalIndex > x && (x = T._originalIndex), T;
		});
		return __spreadProps(__spreadValues({}, R), { items: S });
	}, [R]);
	useEffect(() => {
		R.items.length > 0 && N(q(R));
	}, []);
	let [X, Z] = useState(""), sH = !!X, Q = !useAppStore((m) => m.permissions.getPermissions({ item: m.selectedItem }).edit), cH = useRef(L), lH = useCallback((x) => {
		if (m.type !== "array" || !m.arrayFields) return;
		let S = W.getState().config;
		return walkField({
			value: x,
			fields: m.arrayFields,
			mappers: { slot: ({ value: m }) => m.map((m) => populateIds(m, S, !0)) },
			config: S
		});
	}, [W, m]);
	if (m.type !== "array" || !m.arrayFields) return null;
	let uH = m.max !== void 0 && z.arrayState.items.length >= m.max || O;
	return /* @__PURE__ */ jsx(A, {
		label: T || C,
		icon: D || /* @__PURE__ */ jsx(List, { size: 16 }),
		el: "div",
		readOnly: O,
		children: /* @__PURE__ */ jsx(SortableProvider, {
			onDragStart: (m) => Z(m),
			onDragEnd: () => {
				Z(""), x(cH.current);
			},
			onMove: (m) => {
				if (R.items[m.source]._arrayId !== X) return;
				let x = reorder(z.value, m.source, m.target), S = reorder(R.items, m.source, m.target), C = W.getState().state;
				N({ arrayState: __spreadProps(__spreadValues({}, C.ui.arrayState), { [k]: __spreadProps(__spreadValues({}, R), { items: S }) }) }, !1), U({
					value: x,
					arrayState: __spreadProps(__spreadValues({}, R), { items: S })
				}), cH.current = x;
			},
			children: /* @__PURE__ */ jsxs("div", {
				className: getClassName6({
					hasItems: Array.isArray(L) && L.length > 0,
					addDisabled: uH
				}),
				children: [z.arrayState.items.length > 0 && /* @__PURE__ */ jsx("div", {
					className: getClassName6("inner"),
					"data-dnd-container": !0,
					children: z.arrayState.items.map((S, T) => {
						let { _arrayId: D = `${k}-${T}`, _originalIndex: A = T } = S, j = Array.from(z.value || [])[T] || {};
						return /* @__PURE__ */ jsx(Sortable, {
							id: D,
							index: T,
							disabled: O,
							children: ({ isDragging: S, ref: k, handleRef: M }) => /* @__PURE__ */ jsxs("div", {
								ref: k,
								className: getClassNameItem({
									isExpanded: R.openId === D,
									isDragging: S,
									readOnly: O
								}),
								children: [/* @__PURE__ */ jsxs("div", {
									ref: M,
									onClick: (m) => {
										S || (m.preventDefault(), m.stopPropagation(), R.openId === D ? N(q({ openId: "" })) : N(q({ openId: D })));
									},
									className: getClassNameItem("summary"),
									children: [m.getItemSummary ? m.getItemSummary(j, T) : `Item #${A}`, /* @__PURE__ */ jsxs("div", {
										className: getClassNameItem("rhs"),
										children: [!O && /* @__PURE__ */ jsxs("div", {
											className: getClassNameItem("actions"),
											children: [/* @__PURE__ */ jsx("div", {
												className: getClassNameItem("action"),
												children: /* @__PURE__ */ jsx(IconButton, {
													type: "button",
													disabled: !!uH,
													onClick: (m) => {
														m.stopPropagation();
														let S = [...L || []], C = lH(S[T]);
														S.splice(T, 0, C), N(q(Y(S)), !1), x(S);
													},
													title: "Duplicate",
													children: /* @__PURE__ */ jsx(Copy, { size: 16 })
												})
											}), /* @__PURE__ */ jsx("div", {
												className: getClassNameItem("action"),
												children: /* @__PURE__ */ jsx(IconButton, {
													type: "button",
													disabled: m.min !== void 0 && m.min >= z.arrayState.items.length,
													onClick: (m) => {
														m.stopPropagation();
														let S = [...L || []], C = [...R.items || []];
														S.splice(T, 1), C.splice(T, 1), N(q({ items: C }), !1), x(S);
													},
													title: "Delete",
													children: /* @__PURE__ */ jsx(Trash, { size: 16 })
												})
											})]
										}), /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(DragIcon, {}) })]
									})]
								}), /* @__PURE__ */ jsx("div", {
									className: getClassNameItem("body"),
									children: R.openId === D && /* @__PURE__ */ jsx("fieldset", {
										className: getClassNameItem("fieldset"),
										children: Object.keys(m.arrayFields).map((S) => {
											let O = m.arrayFields[S], k = `${`${C}[${T}]`}.${S}`, A = `${I}[${T}]`, M = `${I}[*]`, N = `${A}.${S}`, P = `${M}.${S}`, R = Q || (F[k] === void 0 ? F[P] : F[N]), z = O.label || S;
											return /* @__PURE__ */ jsx(NestedFieldProvider, {
												name: A,
												wildcardName: M,
												subName: S,
												readOnlyFields: F,
												children: /* @__PURE__ */ jsx(AutoFieldPrivate, {
													name: k,
													label: z,
													id: `${D}_${S}`,
													readOnly: R,
													field: __spreadProps(__spreadValues({}, O), { label: z }),
													value: j[S],
													onChange: (m, C) => {
														x(replace(L, T, __spreadProps(__spreadValues({}, j), { [S]: m })), C);
													}
												})
											}, k);
										})
									})
								})]
							})
						}, D);
					})
				}), !uH && /* @__PURE__ */ jsx("button", {
					type: "button",
					className: getClassName6("addButton"),
					onClick: () => {
						if (sH) return;
						let S = L || [], C = defaultSlots(lH(m.defaultItemProps ?? {}), m.arrayFields), T = [...S, C];
						N(q(Y(T)), !1), x(T);
					},
					children: /* @__PURE__ */ jsx(Plus, { size: 21 })
				})]
			})
		})
	});
};
init_react_import();
var getClassName7 = get_class_name_factory_default("Input", styles_module_default3), DefaultField = ({ field: m, onChange: x, readOnly: S, value: C, name: T, label: D, labelIcon: O, Label: k, id: A }) => {
	let j = C;
	return /* @__PURE__ */ jsx(k, {
		label: D || T,
		icon: O || /* @__PURE__ */ jsxs(Fragment$1, { children: [m.type === "text" && /* @__PURE__ */ jsx(Type, { size: 16 }), m.type === "number" && /* @__PURE__ */ jsx(Hash, { size: 16 })] }),
		readOnly: S,
		children: /* @__PURE__ */ jsx("input", {
			className: getClassName7("input"),
			autoComplete: "off",
			type: m.type,
			title: D || T,
			name: T,
			value: j?.toString ? j.toString() : "",
			onChange: (S) => {
				if (m.type === "number") {
					let C = Number(S.currentTarget.value);
					if (m.min !== void 0 && C < m.min || m.max !== void 0 && C > m.max) return;
					x(C);
				} else x(S.currentTarget.value);
			},
			readOnly: S,
			tabIndex: S ? -1 : void 0,
			id: A,
			min: m.type === "number" ? m.min : void 0,
			max: m.type === "number" ? m.max : void 0,
			placeholder: m.type === "text" || m.type === "number" ? m.placeholder : void 0,
			step: m.type === "number" ? m.step : void 0
		})
	});
};
init_react_import(), init_react_import(), init_react_import();
var styles_module_default6 = {
	"ExternalInput-actions": "_ExternalInput-actions_91ls0_1",
	"ExternalInput-button": "_ExternalInput-button_91ls0_5",
	"ExternalInput--dataSelected": "_ExternalInput--dataSelected_91ls0_24",
	"ExternalInput--readOnly": "_ExternalInput--readOnly_91ls0_31",
	"ExternalInput-detachButton": "_ExternalInput-detachButton_91ls0_35",
	ExternalInput: "_ExternalInput_91ls0_1",
	ExternalInputModal: "_ExternalInputModal_91ls0_79",
	"ExternalInputModal-grid": "_ExternalInputModal-grid_91ls0_89",
	"ExternalInputModal--filtersToggled": "_ExternalInputModal--filtersToggled_91ls0_100",
	"ExternalInputModal-filters": "_ExternalInputModal-filters_91ls0_105",
	"ExternalInputModal-masthead": "_ExternalInputModal-masthead_91ls0_124",
	"ExternalInputModal-tableWrapper": "_ExternalInputModal-tableWrapper_91ls0_133",
	"ExternalInputModal-table": "_ExternalInputModal-table_91ls0_133",
	"ExternalInputModal-thead": "_ExternalInputModal-thead_91ls0_149",
	"ExternalInputModal-th": "_ExternalInputModal-th_91ls0_149",
	"ExternalInputModal-td": "_ExternalInputModal-td_91ls0_164",
	"ExternalInputModal-tr": "_ExternalInputModal-tr_91ls0_169",
	"ExternalInputModal-tbody": "_ExternalInputModal-tbody_91ls0_176",
	"ExternalInputModal--hasData": "_ExternalInputModal--hasData_91ls0_202",
	"ExternalInputModal-loadingBanner": "_ExternalInputModal-loadingBanner_91ls0_206",
	"ExternalInputModal--isLoading": "_ExternalInputModal--isLoading_91ls0_223",
	"ExternalInputModal-searchForm": "_ExternalInputModal-searchForm_91ls0_227",
	"ExternalInputModal-search": "_ExternalInputModal-search_91ls0_227",
	"ExternalInputModal-searchIcon": "_ExternalInputModal-searchIcon_91ls0_264",
	"ExternalInputModal-searchIconText": "_ExternalInputModal-searchIconText_91ls0_289",
	"ExternalInputModal-searchInput": "_ExternalInputModal-searchInput_91ls0_299",
	"ExternalInputModal-searchActions": "_ExternalInputModal-searchActions_91ls0_313",
	"ExternalInputModal-searchActionIcon": "_ExternalInputModal-searchActionIcon_91ls0_326",
	"ExternalInputModal-footerContainer": "_ExternalInputModal-footerContainer_91ls0_330",
	"ExternalInputModal-footer": "_ExternalInputModal-footer_91ls0_330",
	"ExternalInputModal-field": "_ExternalInputModal-field_91ls0_343"
};
init_react_import(), init_react_import();
var getClassName8 = get_class_name_factory_default("Modal", {
	Modal: "_Modal_ikbaj_1",
	"Modal--isOpen": "_Modal--isOpen_ikbaj_15",
	"Modal-inner": "_Modal-inner_ikbaj_19"
}), Modal = ({ children: m, onClose: x, isOpen: S }) => {
	let [C, T] = useState(null);
	return useEffect(() => {
		T(document.getElementById("puck-portal-root"));
	}, []), C ? createPortal(/* @__PURE__ */ jsx("div", {
		className: getClassName8({ isOpen: S }),
		onClick: x,
		children: /* @__PURE__ */ jsx("div", {
			className: getClassName8("inner"),
			onClick: (m) => m.stopPropagation(),
			children: m
		})
	}), C) : /* @__PURE__ */ jsx("div", {});
};
init_react_import(), init_react_import();
var getClassName9 = get_class_name_factory_default("Heading", {
	Heading: "_Heading_qxrry_1",
	"Heading--xxxxl": "_Heading--xxxxl_qxrry_12",
	"Heading--xxxl": "_Heading--xxxl_qxrry_18",
	"Heading--xxl": "_Heading--xxl_qxrry_22",
	"Heading--xl": "_Heading--xl_qxrry_26",
	"Heading--l": "_Heading--l_qxrry_30",
	"Heading--m": "_Heading--m_qxrry_34",
	"Heading--s": "_Heading--s_qxrry_38",
	"Heading--xs": "_Heading--xs_qxrry_42"
}), Heading = ({ children: m, rank: x, size: S = "m" }) => /* @__PURE__ */ jsx(x ? `h${x}` : "span", {
	className: getClassName9({ [S]: !0 }),
	children: m
});
init_react_import();
var getClassName10 = get_class_name_factory_default("ExternalInput", styles_module_default6), getClassNameModal = get_class_name_factory_default("ExternalInputModal", styles_module_default6), dataCache = {}, ExternalInput = ({ field: m, onChange: x, value: S = null, name: C, id: T, readOnly: D }) => {
	let { mapProp: O = (m) => m, mapRow: A = (m) => m, filterFields: j } = m || {}, [N, F] = useState([]), [I, L] = useState(!1), [R, B] = useState(!0), U = !!j, [q, J] = useState(m.initialFilters || {}), [Y, X] = useState(U), Z = useMemo(() => N.map(A), [N]), sH = useMemo(() => {
		let m = /* @__PURE__ */ new Set();
		for (let x of Z) for (let S of Object.keys(x)) (typeof x[S] == "string" || typeof x[S] == "number" || isValidElement(x[S])) && m.add(S);
		return Array.from(m);
	}, [Z]), [Q, cH] = useState(m.initialQuery || ""), lH = useCallback((x, S) => __async(void 0, null, function* () {
		B(!0);
		let C = `${T}-${x}-${JSON.stringify(S)}`, D = dataCache[C] || (yield m.fetchList({
			query: x,
			filters: S
		}));
		D && (F(D), B(!1), dataCache[C] = D);
	}), [T, m]), uH = useCallback((x) => m.renderFooter ? m.renderFooter(x) : /* @__PURE__ */ jsxs("span", {
		className: getClassNameModal("footer"),
		children: [
			x.items.length,
			" result",
			x.items.length === 1 ? "" : "s"
		]
	}), [m.renderFooter]);
	return useEffect(() => {
		lH(Q, q);
	}, []), /* @__PURE__ */ jsxs("div", {
		className: getClassName10({
			dataSelected: !!S,
			modalVisible: I,
			readOnly: D
		}),
		id: T,
		children: [/* @__PURE__ */ jsxs("div", {
			className: getClassName10("actions"),
			children: [/* @__PURE__ */ jsx("button", {
				type: "button",
				onClick: () => L(!0),
				className: getClassName10("button"),
				disabled: D,
				children: S ? m.getItemSummary ? m.getItemSummary(S) : "External item" : /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx(Link, { size: "16" }), /* @__PURE__ */ jsx("span", { children: m.placeholder })] })
			}), S && /* @__PURE__ */ jsx("button", {
				type: "button",
				className: getClassName10("detachButton"),
				onClick: () => {
					x(null);
				},
				disabled: D,
				children: /* @__PURE__ */ jsx(LockOpen, { size: 16 })
			})]
		}), /* @__PURE__ */ jsx(Modal, {
			onClose: () => L(!1),
			isOpen: I,
			children: /* @__PURE__ */ jsxs("form", {
				className: getClassNameModal({
					isLoading: R,
					loaded: !R,
					hasData: Z.length > 0,
					filtersToggled: Y
				}),
				onSubmit: (m) => {
					m.preventDefault(), lH(Q, q);
				},
				children: [
					/* @__PURE__ */ jsx("div", {
						className: getClassNameModal("masthead"),
						children: m.showSearch ? /* @__PURE__ */ jsxs("div", {
							className: getClassNameModal("searchForm"),
							children: [/* @__PURE__ */ jsxs("label", {
								className: getClassNameModal("search"),
								children: [
									/* @__PURE__ */ jsx("span", {
										className: getClassNameModal("searchIconText"),
										children: "Search"
									}),
									/* @__PURE__ */ jsx("div", {
										className: getClassNameModal("searchIcon"),
										children: /* @__PURE__ */ jsx(Search, { size: "18" })
									}),
									/* @__PURE__ */ jsx("input", {
										className: getClassNameModal("searchInput"),
										name: "q",
										type: "search",
										placeholder: m.placeholder,
										onChange: (m) => {
											cH(m.currentTarget.value);
										},
										autoComplete: "off",
										value: Q
									})
								]
							}), /* @__PURE__ */ jsxs("div", {
								className: getClassNameModal("searchActions"),
								children: [/* @__PURE__ */ jsx(Button, {
									type: "submit",
									loading: R,
									fullWidth: !0,
									children: "Search"
								}), U && /* @__PURE__ */ jsx("div", {
									className: getClassNameModal("searchActionIcon"),
									children: /* @__PURE__ */ jsx(IconButton, {
										type: "button",
										title: "Toggle filters",
										onClick: (m) => {
											m.preventDefault(), m.stopPropagation(), X(!Y);
										},
										children: /* @__PURE__ */ jsx(SlidersHorizontal, { size: 20 })
									})
								})]
							})]
						}) : /* @__PURE__ */ jsx(Heading, {
							rank: "2",
							size: "xs",
							children: m.placeholder || "Select data"
						})
					}),
					/* @__PURE__ */ jsxs("div", {
						className: getClassNameModal("grid"),
						children: [U && /* @__PURE__ */ jsx("div", {
							className: getClassNameModal("filters"),
							children: U && Object.keys(j).map((m) => {
								let x = j[m];
								return /* @__PURE__ */ jsx("div", {
									className: getClassNameModal("field"),
									children: /* @__PURE__ */ jsx(AutoFieldPrivate, {
										field: x,
										name: m,
										id: `external_field_${m}_filter`,
										label: x.label || m,
										value: q[m],
										onChange: (x) => {
											let S = __spreadProps(__spreadValues({}, q), { [m]: x });
											J(S), lH(Q, S);
										}
									})
								}, m);
							})
						}), /* @__PURE__ */ jsxs("div", {
							className: getClassNameModal("tableWrapper"),
							children: [/* @__PURE__ */ jsxs("table", {
								className: getClassNameModal("table"),
								children: [/* @__PURE__ */ jsx("thead", {
									className: getClassNameModal("thead"),
									children: /* @__PURE__ */ jsx("tr", {
										className: getClassNameModal("tr"),
										children: sH.map((m) => /* @__PURE__ */ jsx("th", {
											className: getClassNameModal("th"),
											style: { textAlign: "left" },
											children: m
										}, m))
									})
								}), /* @__PURE__ */ jsx("tbody", {
									className: getClassNameModal("tbody"),
									children: Z.map((m, S) => /* @__PURE__ */ jsx("tr", {
										style: { whiteSpace: "nowrap" },
										className: getClassNameModal("tr"),
										onClick: () => {
											x(O(N[S])), L(!1);
										},
										children: sH.map((x) => /* @__PURE__ */ jsx("td", {
											className: getClassNameModal("td"),
											children: m[x]
										}, x))
									}, S))
								})]
							}), /* @__PURE__ */ jsx("div", {
								className: getClassNameModal("loadingBanner"),
								children: /* @__PURE__ */ jsx(Loader, { size: 24 })
							})]
						})]
					}),
					/* @__PURE__ */ jsx("div", {
						className: getClassNameModal("footerContainer"),
						children: /* @__PURE__ */ jsx(uH, { items: Z })
					})
				]
			})
		})]
	});
}, ExternalField = ({ field: m, onChange: x, value: S, name: C, label: T, labelIcon: D, Label: O, id: k, readOnly: A }) => {
	let j = m, M = m;
	return useEffect(() => {
		M.adaptor && console.error("Warning: The `adaptor` API is deprecated. Please use updated APIs on the `external` field instead. This will be a breaking change in a future release.");
	}, []), m.type === "external" ? /* @__PURE__ */ jsx(O, {
		label: T || C,
		icon: D || /* @__PURE__ */ jsx(Link, { size: 16 }),
		el: "div",
		children: /* @__PURE__ */ jsx(ExternalInput, {
			name: C,
			field: __spreadProps(__spreadValues({}, j), {
				placeholder: M.adaptor?.name ? `Select from ${M.adaptor.name}` : j.placeholder || "Select data",
				mapProp: M.adaptor?.mapProp || j.mapProp,
				mapRow: j.mapRow,
				fetchList: M.adaptor?.fetchList ? () => __async(void 0, null, function* () {
					return yield M.adaptor.fetchList(M.adaptorParams);
				}) : j.fetchList
			}),
			onChange: x,
			value: S,
			id: k,
			readOnly: A
		})
	}) : null;
};
init_react_import();
var getClassName11 = get_class_name_factory_default("Input", styles_module_default3), RadioField = ({ field: m, onChange: x, readOnly: S, value: C, name: T, id: D, label: O, labelIcon: k, Label: A }) => m.type !== "radio" || !m.options ? null : /* @__PURE__ */ jsx(A, {
	icon: k || /* @__PURE__ */ jsx(CircleCheckBig, { size: 16 }),
	label: O || T,
	readOnly: S,
	el: "div",
	children: /* @__PURE__ */ jsx("div", {
		className: getClassName11("radioGroupItems"),
		id: D,
		children: m.options.map((m) => /* @__PURE__ */ jsxs("label", {
			className: getClassName11("radio"),
			children: [/* @__PURE__ */ jsx("input", {
				type: "radio",
				className: getClassName11("radioInput"),
				value: JSON.stringify({ value: m.value }),
				name: T,
				onChange: (m) => {
					x(JSON.parse(m.target.value).value);
				},
				disabled: S,
				checked: C === m.value
			}), /* @__PURE__ */ jsx("div", {
				className: getClassName11("radioInner"),
				children: m.label || m.value?.toString()
			})]
		}, m.label + m.value))
	})
});
init_react_import();
var getClassName12 = get_class_name_factory_default("Input", styles_module_default3), SelectField = ({ field: m, onChange: x, label: S, labelIcon: C, Label: T, value: D, name: O, readOnly: k, id: A }) => m.type !== "select" || !m.options ? null : /* @__PURE__ */ jsx(T, {
	label: S || O,
	icon: C || /* @__PURE__ */ jsx(ChevronDown, { size: 16 }),
	readOnly: k,
	children: /* @__PURE__ */ jsx("select", {
		id: A,
		title: S || O,
		className: getClassName12("input"),
		disabled: k,
		onChange: (m) => {
			x(JSON.parse(m.target.value).value);
		},
		value: JSON.stringify({ value: D }),
		children: m.options.map((m) => /* @__PURE__ */ jsx("option", {
			label: m.label,
			value: JSON.stringify({ value: m.value })
		}, m.label + JSON.stringify(m.value)))
	})
});
init_react_import();
var getClassName13 = get_class_name_factory_default("Input", styles_module_default3), TextareaField = ({ field: m, onChange: x, readOnly: S, value: C, name: T, label: D, labelIcon: O, Label: k, id: A }) => /* @__PURE__ */ jsx(k, {
	label: D || T,
	icon: O || /* @__PURE__ */ jsx(Type, { size: 16 }),
	readOnly: S,
	children: /* @__PURE__ */ jsx("textarea", {
		id: A,
		className: getClassName13("input"),
		autoComplete: "off",
		name: T,
		value: C === void 0 ? "" : C,
		onChange: (m) => x(m.currentTarget.value),
		readOnly: S,
		tabIndex: S ? -1 : void 0,
		rows: 5,
		placeholder: m.type === "textarea" ? m.placeholder : void 0
	})
});
init_react_import(), init_react_import();
var getClassName14 = get_class_name_factory_default("ObjectField", {
	ObjectField: "_ObjectField_1ua3y_5",
	"ObjectField-fieldset": "_ObjectField-fieldset_1ua3y_13"
}), ObjectField = ({ field: m, onChange: x, value: S, name: C, label: T, labelIcon: D, Label: O, readOnly: k, id: A }) => {
	let { readOnlyFields: j, localName: M = C } = useNestedFieldContext();
	if (m.type !== "object" || !m.objectFields) return null;
	let N = S || {};
	return /* @__PURE__ */ jsx(O, {
		label: T || C,
		icon: D || /* @__PURE__ */ jsx(EllipsisVertical, { size: 16 }),
		el: "div",
		readOnly: k,
		children: /* @__PURE__ */ jsx("div", {
			className: getClassName14(),
			children: /* @__PURE__ */ jsx("fieldset", {
				className: getClassName14("fieldset"),
				children: Object.keys(m.objectFields).map((S) => {
					let C = m.objectFields[S], T = `${M}.${S}`, D = k || j[T], O = C.label || S;
					return /* @__PURE__ */ jsx(NestedFieldProvider, {
						name: M || A,
						subName: S,
						readOnlyFields: j,
						children: /* @__PURE__ */ jsx(AutoFieldPrivate, {
							name: T,
							label: T,
							id: `${A}_${S}`,
							readOnly: D,
							field: __spreadProps(__spreadValues({}, C), { label: O }),
							value: N[S],
							onChange: (m, C) => {
								x(__spreadProps(__spreadValues({}, N), { [S]: m }), C);
							}
						})
					}, T);
				})
			})
		})
	});
};
init_react_import();
var useSafeId = () => {
	if (React.useId !== void 0) return React.useId();
	let [m] = useState(generateId());
	return m;
}, getClassName15 = get_class_name_factory_default("Input", styles_module_default3), getClassNameWrapper = get_class_name_factory_default("InputWrapper", styles_module_default3), FieldLabel = ({ children: m, icon: x, label: S, el: C = "label", readOnly: T, className: D }) => /* @__PURE__ */ jsxs(C, {
	className: D,
	children: [/* @__PURE__ */ jsxs("div", {
		className: getClassName15("label"),
		children: [
			x ? /* @__PURE__ */ jsx("div", {
				className: getClassName15("labelIcon"),
				children: x
			}) : /* @__PURE__ */ jsx(Fragment$1, {}),
			S,
			T && /* @__PURE__ */ jsx("div", {
				className: getClassName15("disabledIcon"),
				title: "Read-only",
				children: /* @__PURE__ */ jsx(Lock, { size: "12" })
			})
		]
	}), m]
}), FieldLabelInternal = ({ children: m, icon: x, label: S, el: C = "label", readOnly: T }) => {
	let D = useAppStore((m) => m.overrides), O = useMemo(() => D.fieldLabel || FieldLabel, [D]);
	return S ? /* @__PURE__ */ jsx(O, {
		label: S,
		icon: x,
		className: getClassName15({ readOnly: T }),
		readOnly: T,
		el: C,
		children: m
	}) : /* @__PURE__ */ jsx(Fragment$1, { children: m });
}, defaultFields = {
	array: ArrayField,
	external: ExternalField,
	object: ObjectField,
	select: SelectField,
	textarea: TextareaField,
	radio: RadioField,
	text: DefaultField,
	number: DefaultField
};
function AutoFieldInternal(m) {
	let x = useAppStore((m) => m.dispatch), S = useAppStore((m) => m.overrides), C = useAppStore((m) => m.selectedItem?.readOnly), T = useContext(NestedFieldContext), { id: D, Label: O = FieldLabelInternal } = m, k = m.field, A = k.label, j = k.labelIcon, P = useSafeId(), F = D || P, I = useMemo(() => __spreadProps(__spreadValues({}, S.fieldTypes), {
		array: S.fieldTypes?.array || defaultFields.array,
		external: S.fieldTypes?.external || defaultFields.external,
		object: S.fieldTypes?.object || defaultFields.object,
		select: S.fieldTypes?.select || defaultFields.select,
		textarea: S.fieldTypes?.textarea || defaultFields.textarea,
		radio: S.fieldTypes?.radio || defaultFields.radio,
		text: S.fieldTypes?.text || defaultFields.text,
		number: S.fieldTypes?.number || defaultFields.number
	}), [S]), L = useMemo(() => __spreadProps(__spreadValues({}, m), {
		field: k,
		label: A,
		labelIcon: j,
		Label: O,
		id: F
	}), [
		m,
		k,
		A,
		j,
		O,
		F
	]), R = useCallback((m) => {
		L.name && (m.target.nodeName === "INPUT" || m.target.nodeName === "TEXTAREA") && (m.stopPropagation(), x({
			type: "setUi",
			ui: { field: { focus: L.name } }
		}));
	}, [L.name]), B = useCallback((m) => {
		"name" in m.target && x({
			type: "setUi",
			ui: { field: { focus: null } }
		});
	}, []), H = useMemo(() => k.type !== "custom" && k.type !== "slot" ? defaultFields[k.type] : (m) => null, [k.type]), U = useMemo(() => {
		if (k.type === "custom") return k.render ? k.render : null;
		if (k.type !== "slot") return I[k.type];
	}, [k.type, I]), { visible: W = !0 } = m.field;
	if (!W || k.type === "slot") return null;
	if (!U) throw Error(`Field type for ${k.type} did not exist.`);
	return /* @__PURE__ */ jsx(NestedFieldContext.Provider, {
		value: {
			readOnlyFields: T.readOnlyFields || C || {},
			localName: T.localName ?? L.name
		},
		children: /* @__PURE__ */ jsx("div", {
			className: getClassNameWrapper(),
			onFocus: R,
			onBlur: B,
			onClick: (m) => {
				m.stopPropagation();
			},
			children: /* @__PURE__ */ jsx(U, __spreadProps(__spreadValues({}, L), { children: /* @__PURE__ */ jsx(H, __spreadValues({}, L)) }))
		})
	});
}
function AutoFieldPrivate(m) {
	let x = useAppStore((x) => x.state.ui.field.focus === m.name), { value: S, onChange: C } = m, [T, D] = useState(S), O = useCallback((m, x) => {
		D(m), C(m, x);
	}, [C]);
	useEffect(() => {
		x || D(S);
	}, [S]), useEffect(() => {
		x || S !== T && D(S);
	}, [
		x,
		S,
		T
	]);
	let k = {
		value: T,
		onChange: O
	};
	return /* @__PURE__ */ jsx(AutoFieldInternal, __spreadValues(__spreadValues({}, m), k));
}
init_react_import(), init_react_import(), init_react_import(), init_react_import();
var styles_module_default10 = {
	DraggableComponent: "_DraggableComponent_1vaqy_1",
	"DraggableComponent-overlayWrapper": "_DraggableComponent-overlayWrapper_1vaqy_12",
	"DraggableComponent-overlay": "_DraggableComponent-overlay_1vaqy_12",
	"DraggableComponent-loadingOverlay": "_DraggableComponent-loadingOverlay_1vaqy_34",
	"DraggableComponent--hover": "_DraggableComponent--hover_1vaqy_50",
	"DraggableComponent--isSelected": "_DraggableComponent--isSelected_1vaqy_57",
	"DraggableComponent-actionsOverlay": "_DraggableComponent-actionsOverlay_1vaqy_71",
	"DraggableComponent-actions": "_DraggableComponent-actions_1vaqy_71"
};
init_react_import();
function getDeepScrollPosition(m) {
	let x = {
		x: 0,
		y: 0
	}, S = m;
	for (; S && S !== document.documentElement;) {
		let m = S.parentElement;
		m && (x.x += m.scrollLeft, x.y += m.scrollTop), S = m;
	}
	return x;
}
init_react_import();
var dropZoneContext = createContext(null), ZoneStoreContext = createContext(createStore(() => ({
	zoneDepthIndex: {},
	nextZoneDepthIndex: {},
	areaDepthIndex: {},
	nextAreaDepthIndex: {},
	draggedItem: null,
	previewIndex: {},
	enabledIndex: {},
	hoveringComponent: null
}))), ZoneStoreProvider = ({ children: m, store: x }) => /* @__PURE__ */ jsx(ZoneStoreContext.Provider, {
	value: x,
	children: m
}), DropZoneProvider = ({ children: m, value: x }) => {
	let S = useAppStore((m) => m.dispatch), C = useCallback((m) => {
		S({
			type: "registerZone",
			zone: m
		});
	}, [S]), T = useMemo(() => __spreadValues({ registerZone: C }, x), [x]);
	return /* @__PURE__ */ jsx(Fragment$1, { children: T && /* @__PURE__ */ jsx(dropZoneContext.Provider, {
		value: T,
		children: m
	}) });
};
init_react_import();
function accumulateTransform(m) {
	let x = new DOMMatrixReadOnly(), S = m.parentElement;
	for (; S && S !== document.documentElement;) {
		let m = getComputedStyle(S).transform;
		m && m !== "none" && (x = new DOMMatrixReadOnly(m).multiply(x)), S = S.parentElement;
	}
	return {
		scaleX: x.a,
		scaleY: x.d
	};
}
init_react_import();
function useContextStore(m, x) {
	let S = useContext(m);
	if (!S) throw Error("useContextStore must be used inside context");
	return useStore(S, useShallow(x));
}
init_react_import();
var useOnDragFinished = (m, x = []) => {
	let S = useAppStoreApi();
	return useCallback(() => {
		let x = () => {}, C = (S) => {
			S ? m(!1) : (setTimeout(() => {
				m(!0);
			}, 0), x && x());
		}, T = S.getState().state.ui.isDragging;
		return C(T), T && (x = S.subscribe((m) => m.state.ui.isDragging, (m) => {
			C(m);
		})), x;
	}, [S, ...x]);
}, getClassName16 = get_class_name_factory_default("DraggableComponent", styles_module_default10), DEBUG2 = !1, space = 8, actionsOverlayTop = space * 6.5, actionsTop = -(actionsOverlayTop - 8), actionsSide = space, DefaultActionBar = ({ label: m, children: x, parentAction: S }) => /* @__PURE__ */ jsxs(ActionBar, { children: [/* @__PURE__ */ jsxs(ActionBar.Group, { children: [S, m && /* @__PURE__ */ jsx(ActionBar.Label, { label: m })] }), /* @__PURE__ */ jsx(ActionBar.Group, { children: x })] }), DefaultOverlay = ({ children: m }) => /* @__PURE__ */ jsx(Fragment$1, { children: m }), DraggableComponent = ({ children: m, depth: x, componentType: S, id: C, index: T, zoneCompound: D, isLoading: O = !1, isSelected: k = !1, debug: A, label: j, autoDragAxis: F, userDragAxis: I, inDroppableZone: L = !0 }) => {
	let R = useAppStore((m) => m.selectedItem?.props.id === C ? m.zoomConfig.zoom : 1), W = useAppStore((m) => m.overrides), q = useAppStore((m) => m.dispatch), J = useAppStore((m) => m.iframe), X = useContext(dropZoneContext), [Z, sH] = useState({}), Q = useCallback((m, x) => {
		var S;
		(S = X?.registerLocalZone) == null || S.call(X, m, x), sH((S) => __spreadProps(__spreadValues({}, S), { [m]: x }));
	}, [sH]), cH = useCallback((m) => {
		var x;
		(x = X?.unregisterLocalZone) == null || x.call(X, m), sH((x) => {
			let S = __spreadValues({}, x);
			return delete S[m], S;
		});
	}, [sH]), lH = Object.values(Z).filter(Boolean).length > 0, uH = useAppStore(useShallow((m) => m.state.indexes.nodes[C]?.path)), dH = useAppStore(useShallow((m) => {
		let x = getItem({
			index: T,
			zone: D
		}, m.state);
		return m.permissions.getPermissions({ item: x });
	})), fH = useContext(ZoneStoreContext), [pH, mH] = useState(I || F), hH = useMemo(() => createDynamicCollisionDetector(pH), [pH]), { ref: gH, isDragging: $, sortable: _H } = useSortable({
		id: C,
		index: T,
		group: D,
		type: "component",
		data: {
			areaId: X?.areaId,
			zone: D,
			index: T,
			componentType: S,
			containsActiveZone: lH,
			depth: x,
			path: uH || [],
			inDroppableZone: L
		},
		collisionPriority: x,
		collisionDetector: hH,
		transition: {
			duration: 200,
			easing: "cubic-bezier(0.2, 0, 0, 1)"
		},
		feedback: "clone"
	});
	useEffect(() => {
		let m = fH.getState().enabledIndex[D];
		_H.droppable.disabled = !m, _H.draggable.disabled = !dH.drag;
		let x = fH.subscribe((m) => {
			_H.droppable.disabled = !m.enabledIndex[D];
		});
		return vH.current && !dH.drag ? (vH.current.setAttribute("data-puck-disabled", ""), () => {
			var m;
			(m = vH.current) == null || m.removeAttribute("data-puck-disabled"), x();
		}) : x;
	}, [dH.drag, D]);
	let vH = useRef(null), yH = useCallback((m) => {
		gH(m), m && (vH.current = m);
	}, [gH]), [bH, xH] = useState();
	useEffect(() => {
		xH(J.enabled ? vH.current?.ownerDocument.body : vH.current?.closest("[data-puck-preview]") ?? document.body);
	}, [J.enabled, vH.current]);
	let SH = useCallback(() => {
		if (!vH.current) return;
		let m = vH.current.getBoundingClientRect(), x = getDeepScrollPosition(vH.current), S = J.enabled ? null : vH.current?.closest("[data-puck-preview]"), C = S?.getBoundingClientRect(), T = S ? getDeepScrollPosition(S) : {
			x: 0,
			y: 0
		}, D = {
			x: x.x - T.x - (C?.left ?? 0),
			y: x.y - T.y - (C?.top ?? 0)
		}, O = {
			height: vH.current.offsetHeight,
			width: vH.current.offsetWidth
		}, k = accumulateTransform(vH.current);
		return {
			left: `${(m.left + D.x) / k.scaleX}px`,
			top: `${(m.top + D.y) / k.scaleY}px`,
			height: `${O.height}px`,
			width: `${O.width}px`
		};
	}, [vH.current]), [CH, wH] = useState(), TH = useCallback(() => {
		wH(SH());
	}, [vH.current, J]);
	useEffect(() => {
		if (vH.current) {
			let m = new ResizeObserver(TH);
			return m.observe(vH.current), () => {
				m.disconnect();
			};
		}
	}, [vH.current]);
	let EH = useAppStore((m) => m.nodes.registerNode), DH = useCallback(() => {
		BH(!1);
	}, []), OH = useCallback(() => {
		BH(!0);
	}, []);
	useEffect(() => (EH(C, {
		methods: {
			sync: TH,
			showOverlay: OH,
			hideOverlay: DH
		},
		element: vH.current ?? null
	}), () => {
		EH(C, {
			methods: {
				sync: () => null,
				hideOverlay: () => null,
				showOverlay: () => null
			},
			element: null
		});
	}), [
		C,
		D,
		T,
		S,
		TH
	]);
	let kH = useMemo(() => W.actionBar || DefaultActionBar, [W.actionBar]), AH = useMemo(() => W.componentOverlay || DefaultOverlay, [W.componentOverlay]), jH = useCallback((m) => {
		m.target.closest("[data-puck-overlay-portal]") || m.stopPropagation(), q({
			type: "setUi",
			ui: { itemSelector: {
				index: T,
				zone: D
			} }
		});
	}, [
		T,
		D,
		C
	]), MH = useAppStoreApi(), NH = useCallback(() => {
		let { nodes: m, zones: x } = MH.getState().state.indexes, S = m[C], T = S?.parentId ? m[S?.parentId] : null;
		if (!T || !S.parentId) return;
		let D = `${T.parentId}:${T.zone}`;
		q({
			type: "setUi",
			ui: { itemSelector: {
				zone: D,
				index: x[D].contentIds.indexOf(S.parentId)
			} }
		});
	}, [X, uH]), PH = useCallback(() => {
		q({
			type: "duplicate",
			sourceIndex: T,
			sourceZone: D
		});
	}, [T, D]), FH = useCallback(() => {
		q({
			type: "remove",
			index: T,
			zone: D
		});
	}, [T, D]), [IH, LH] = useState(!1), RH = useContextStore(ZoneStoreContext, (m) => m.hoveringComponent === C);
	useEffect(() => {
		if (!vH.current) return;
		let m = vH.current, x = (m) => {
			fH.getState().draggedItem ? LH(!!$) : LH(!0), m.stopPropagation();
		}, S = (m) => {
			m.stopPropagation(), LH(!1);
		};
		return m.setAttribute("data-puck-component", C), m.setAttribute("data-puck-dnd", C), m.style.position = "relative", m.addEventListener("click", jH), m.addEventListener("mouseover", x), m.addEventListener("mouseout", S), () => {
			m.removeAttribute("data-puck-component"), m.removeAttribute("data-puck-dnd"), m.removeEventListener("click", jH), m.removeEventListener("mouseover", x), m.removeEventListener("mouseout", S);
		};
	}, [
		vH.current,
		jH,
		lH,
		D,
		C,
		$,
		L
	]);
	let [zH, BH] = useState(!1), [VH, HH] = useState(!0), [UH, WH] = useTransition();
	useEffect(() => {
		WH(() => {
			IH || RH || k ? (TH(), BH(!0), KH(!1)) : BH(!1);
		});
	}, [
		IH,
		RH,
		k,
		J
	]);
	let [GH, KH] = useState(!1), qH = useOnDragFinished((m) => {
		m ? WH(() => {
			TH(), HH(!0);
		}) : HH(!1);
	});
	useEffect(() => {
		$ && KH(!0);
	}, [$]), useEffect(() => {
		if (GH) return qH();
	}, [GH, qH]);
	let JH = useCallback((m) => {
		if (m && m.ownerDocument.defaultView) {
			let x = m.getBoundingClientRect(), S = x.x < 0, C = x.y < 0;
			S && (m.style.transformOrigin = "left top", m.style.left = "0px"), C && (m.style.top = "12px", S || (m.style.transformOrigin = "right top"));
		}
	}, [R]);
	useEffect(() => {
		if (I) {
			mH(I);
			return;
		}
		if (vH.current) {
			let m = window.getComputedStyle(vH.current);
			if (m.display === "inline" || m.display === "inline-block") {
				mH("x");
				return;
			}
		}
		mH(F);
	}, [
		vH,
		I,
		F
	]);
	let YH = useMemo(() => X?.areaId && X?.areaId !== "root" && /* @__PURE__ */ jsx(ActionBar.Action, {
		onClick: NH,
		label: "Select parent",
		children: /* @__PURE__ */ jsx(CornerLeftUp, { size: 16 })
	}), [X?.areaId]);
	return /* @__PURE__ */ jsxs(DropZoneProvider, {
		value: useMemo(() => __spreadProps(__spreadValues({}, X), {
			areaId: C,
			zoneCompound: D,
			index: T,
			depth: x + 1,
			registerLocalZone: Q,
			unregisterLocalZone: cH
		}), [
			X,
			C,
			D,
			T,
			x,
			Q,
			cH
		]),
		children: [VH && zH && createPortal(/* @__PURE__ */ jsxs("div", {
			className: getClassName16({
				isSelected: k,
				isDragging: $,
				hover: IH || RH
			}),
			style: __spreadValues({}, CH),
			"data-puck-overlay": !0,
			children: [
				A,
				O && /* @__PURE__ */ jsx("div", {
					className: getClassName16("loadingOverlay"),
					children: /* @__PURE__ */ jsx(Loader, {})
				}),
				/* @__PURE__ */ jsx("div", {
					className: getClassName16("actionsOverlay"),
					style: { top: actionsOverlayTop / R },
					children: /* @__PURE__ */ jsx("div", {
						className: getClassName16("actions"),
						style: {
							transform: `scale(${1 / R}`,
							top: actionsTop / R,
							right: 0,
							paddingLeft: actionsSide,
							paddingRight: actionsSide
						},
						ref: JH,
						children: /* @__PURE__ */ jsxs(kH, {
							parentAction: YH,
							label: DEBUG2 ? C : j,
							children: [dH.duplicate && /* @__PURE__ */ jsx(ActionBar.Action, {
								onClick: PH,
								label: "Duplicate",
								children: /* @__PURE__ */ jsx(Copy, { size: 16 })
							}), dH.delete && /* @__PURE__ */ jsx(ActionBar.Action, {
								onClick: FH,
								label: "Delete",
								children: /* @__PURE__ */ jsx(Trash, { size: 16 })
							})]
						})
					})
				}),
				/* @__PURE__ */ jsx("div", {
					className: getClassName16("overlayWrapper"),
					children: /* @__PURE__ */ jsx(AH, {
						componentId: C,
						componentType: S,
						hover: IH,
						isSelected: k,
						children: /* @__PURE__ */ jsx("div", { className: getClassName16("overlay") })
					})
				})
			]
		}), bH || document.body), m(yH)]
	});
};
init_react_import();
var styles_module_default11 = {
	DropZone: "_DropZone_1i2sv_1",
	"DropZone--hasChildren": "_DropZone--hasChildren_1i2sv_11",
	"DropZone--isAreaSelected": "_DropZone--isAreaSelected_1i2sv_24",
	"DropZone--hoveringOverArea": "_DropZone--hoveringOverArea_1i2sv_25",
	"DropZone--isRootZone": "_DropZone--isRootZone_1i2sv_25",
	"DropZone--isDestination": "_DropZone--isDestination_1i2sv_35",
	"DropZone-item": "_DropZone-item_1i2sv_47",
	"DropZone-hitbox": "_DropZone-hitbox_1i2sv_51",
	"DropZone--isEnabled": "_DropZone--isEnabled_1i2sv_59",
	"DropZone--isAnimating": "_DropZone--isAnimating_1i2sv_68"
};
init_react_import(), init_react_import();
var styles_module_default12 = {
	Drawer: "_Drawer_pl7z0_1",
	"Drawer-draggable": "_Drawer-draggable_pl7z0_8",
	"Drawer-draggableBg": "_Drawer-draggableBg_pl7z0_12",
	"DrawerItem-draggable": "_DrawerItem-draggable_pl7z0_22",
	"DrawerItem--disabled": "_DrawerItem--disabled_pl7z0_35",
	DrawerItem: "_DrawerItem_pl7z0_22",
	"Drawer--isDraggingFrom": "_Drawer--isDraggingFrom_pl7z0_45",
	"DrawerItem-name": "_DrawerItem-name_pl7z0_63"
};
init_react_import(), init_react_import(), init_react_import();
function timeout2(m, x) {
	let S = setTimeout(m, x);
	return () => clearTimeout(S);
}
function throttle(m, x) {
	let S = () => performance.now(), C, T = 0;
	return function(...D) {
		let O = S(), k = this;
		O - T >= x ? (m.apply(k, D), T = O) : (C?.(), C = timeout2(() => {
			m.apply(k, D), T = S();
		}, x - (O - T)));
	};
}
init_react_import();
var getFrame = () => {
	if (typeof window > "u") return;
	let m = document.querySelector("#preview-frame");
	return m?.tagName === "IFRAME" ? m.contentDocument || document : m?.ownerDocument || document;
};
init_react_import();
var GlobalPosition = class {
	constructor(m, x) {
		this.scaleFactor = 1, this.frameEl = null, this.frameRect = null, this.target = m, this.original = x, this.frameEl = document.querySelector("iframe#preview-frame"), this.frameEl && (this.frameRect = this.frameEl.getBoundingClientRect(), this.scaleFactor = this.frameRect.width / (this.frameEl.contentWindow?.innerWidth || 1));
	}
	get x() {
		return this.original.x;
	}
	get y() {
		return this.original.y;
	}
	get global() {
		return document !== this.target.ownerDocument && this.frameRect ? {
			x: this.x * this.scaleFactor + this.frameRect.left,
			y: this.y * this.scaleFactor + this.frameRect.top
		} : this.original;
	}
	get frame() {
		return document === this.target.ownerDocument && this.frameRect ? {
			x: (this.x - this.frameRect.left) / this.scaleFactor,
			y: (this.y - this.frameRect.top) / this.scaleFactor
		} : this.original;
	}
};
init_react_import();
var BaseEvent = typeof PointerEvent < "u" ? PointerEvent : Event, BubbledPointerEvent = class extends BaseEvent {
	constructor(m, x) {
		super(m, x), this._originalTarget = null, this.originalTarget = x.originalTarget;
	}
	set originalTarget(m) {
		this._originalTarget = m;
	}
	get originalTarget() {
		return this._originalTarget;
	}
}, depthSort = (m) => m.sort((m, x) => {
	let S = m.data, C = x.data;
	return S.depth > C.depth ? 1 : C.depth > S.depth ? -1 : 0;
}), getZoneId = (m) => {
	let x = m?.id;
	if (!m) return null;
	if (m.type === "component") {
		let S = m.data;
		x = S.containsActiveZone ? null : S.zone;
	} else if (m.type === "void") return "void";
	return x;
}, BUFFER = 6, getPointerCollisions = (m, x) => {
	let S = [], C = m.target.ownerDocument.elementsFromPoint(m.x, m.y), T = C.find((m) => m.getAttribute("data-puck-preview")), D = C.find((m) => m.getAttribute("data-puck-drawer"));
	if (D && (C = [D]), T) {
		let x = getFrame();
		x && (C = x.elementsFromPoint(m.frame.x, m.frame.y));
	}
	if (C) for (let T = 0; T < C.length; T++) {
		let D = C[T], O = D.getAttribute("data-puck-dropzone"), k = D.getAttribute("data-puck-dnd"), A = D.hasAttribute("data-puck-dnd-void");
		if (BUFFER && (O || k) && !A) {
			let x = D.getBoundingClientRect(), S = {
				left: x.left + BUFFER,
				right: x.right - BUFFER,
				top: x.top + BUFFER,
				bottom: x.bottom - BUFFER
			};
			if (m.frame.x < S.left || m.frame.x > S.right || m.frame.y > S.bottom || m.frame.y < S.top) continue;
		}
		if (O) {
			let m = x.registry.droppables.get(O);
			m && S.push(m);
		}
		if (k) {
			let m = x.registry.droppables.get(k);
			m && S.push(m);
		}
	}
	return S;
}, findDeepestCandidate = (m, x) => {
	let S = getPointerCollisions(m, x);
	if (S.length > 0) {
		let m = depthSort(S), C = x.dragOperation.source, T = m.findIndex((m) => m.id === C?.id), D = C?.id, O = [...m];
		D && T > -1 && O.splice(T, 1), O = O.filter((m) => {
			let x = m.data;
			if (D && T > -1 && x.path.indexOf(D) > -1) return !1;
			if (m.type === "dropzone") {
				let x = m.data;
				if (!x.isDroppableTarget || x.areaId === D) return !1;
			} else if (m.type === "component" && !m.data.inDroppableZone) return !1;
			return !0;
		}), O.reverse();
		let k = O[0];
		if (!k) return {
			zone: null,
			area: null
		};
		let A = k.data, j = "containsActiveZone" in A;
		return {
			zone: getZoneId(k),
			area: j && A.containsActiveZone ? O[0].id : O[0]?.data.areaId
		};
	}
	return {
		zone: rootDroppableId,
		area: rootAreaId
	};
}, createNestedDroppablePlugin = ({ onChange: m }, x) => class extends Plugin {
	constructor(S, C) {
		super(S), !(typeof window > "u") && this.registerEffect(() => {
			let C = throttle((C) => {
				let T = new GlobalPosition(C instanceof BubbledPointerEvent && C.originalTarget || C.target, {
					x: C.clientX,
					y: C.clientY
				});
				document.elementsFromPoint(T.global.x, T.global.y).some((m) => m.id === x) && m(findDeepestCandidate(T, S), S);
			}, 50), T = (m) => {
				C(m);
			};
			return document.body.addEventListener("pointermove", T, { capture: !0 }), () => {
				document.body.removeEventListener("pointermove", T, { capture: !0 });
			};
		});
	}
};
init_react_import();
var insertComponent = (m, x, S, C) => __async(void 0, null, function* () {
	let T = {
		type: "insert",
		componentType: m,
		destinationIndex: S,
		destinationZone: x,
		id: generateId(m)
	}, { state: D, dispatch: O, resolveComponentData: k } = C, A = insertAction(D, T, C);
	O(__spreadProps(__spreadValues({}, T), { recordHistory: !0 }));
	let j = {
		index: S,
		zone: x
	};
	O({
		type: "setUi",
		ui: { itemSelector: j }
	});
	let M = getItem(j, A);
	if (M) {
		let m = yield k(M, "insert");
		m.didChange && O({
			type: "replace",
			destinationZone: j.zone,
			destinationIndex: j.index,
			data: m.node
		});
	}
});
init_react_import();
function getDeepDir(m) {
	function x(m) {
		return m ? m.getAttribute("dir") || x(m.parentElement) : "ltr";
	}
	return m ? x(m) : "ltr";
}
var DEBUG3 = !1, dragListenerContext = createContext({ dragListeners: {} });
function useDragListener(m, x, S = []) {
	let { setDragListeners: C } = useContext(dragListenerContext);
	useEffect(() => {
		C && C((S) => __spreadProps(__spreadValues({}, S), { [m]: [...S[m] || [], x] }));
	}, S);
}
var AREA_CHANGE_DEBOUNCE_MS = 100, useTempDisableFallback = (m) => {
	let x = useRef(null);
	return useCallback((S) => {
		collisionStore.setState({ fallbackEnabled: !1 });
		let C = generateId();
		x.current = C, setTimeout(() => {
			x.current === C && (collisionStore.setState({ fallbackEnabled: !0 }), S.collisionObserver.forceUpdate(!0));
		}, m);
	}, []);
}, DragDropContextClient = ({ children: m, disableAutoScroll: x }) => {
	let S = useAppStore((m) => m.dispatch), C = useAppStoreApi(), T = useSafeId(), D = useRef(null), O = useTempDisableFallback(100), [k] = useState(() => createStore(() => ({
		zoneDepthIndex: {},
		nextZoneDepthIndex: {},
		areaDepthIndex: {},
		nextAreaDepthIndex: {},
		draggedItem: null,
		previewIndex: {},
		enabledIndex: {},
		hoveringComponent: null
	}))), A = useCallback((m, x) => {
		let { zoneDepthIndex: S = {}, areaDepthIndex: C = {} } = k.getState() || {}, T = Object.keys(S).length > 0, D = Object.keys(C).length > 0, O = !1, A = !1;
		return (m.zone && !S[m.zone] || !m.zone && T) && (O = !0), (m.area && !C[m.area] || !m.area && D) && (A = !0), {
			zoneChanged: O,
			areaChanged: A
		};
	}, [k]), j = useCallback((m, x) => {
		let { zoneChanged: S, areaChanged: C } = A(m, T);
		!S && !C || (k.setState({
			zoneDepthIndex: m.zone ? { [m.zone]: !0 } : {},
			areaDepthIndex: m.area ? { [m.area]: !0 } : {}
		}), O(x), setTimeout(() => {
			x.collisionObserver.forceUpdate(!0);
		}, 50), D.current = null);
	}, [k]), N = c(j, AREA_CHANGE_DEBOUNCE_MS), F = () => {
		N.cancel(), D.current = null;
	};
	useEffect(() => {
		DEBUG3 && k.subscribe((m) => console.log(m.previewIndex, Object.entries(m.zoneDepthIndex || {})[0]?.[0], Object.entries(m.areaDepthIndex || {})[0]?.[0]));
	}, []);
	let [I] = useState(() => [...x ? defaultPreset.plugins.filter((m) => m !== AutoScroller) : defaultPreset.plugins, createNestedDroppablePlugin({ onChange: (m, x) => {
		let S = k.getState(), { zoneChanged: C, areaChanged: O } = A(m, T), M = x.dragOperation.status.dragging;
		if (O || C) {
			let x = {}, S = {};
			m.zone && (x = { [m.zone]: !0 }), m.area && (S = { [m.area]: !0 }), k.setState({
				nextZoneDepthIndex: x,
				nextAreaDepthIndex: S
			});
		}
		if (m.zone !== "void" && S?.zoneDepthIndex.void) {
			j(m, x);
			return;
		}
		if (O) {
			if (M) {
				let S = D.current;
				S && S.area === m.area && S.zone === m.zone || (F(), N(m, x), D.current = m);
			} else F(), j(m, x);
			return;
		}
		C && j(m, x), F();
	} }, T)]), L = useSensors(), [R, U] = useState({}), W = useRef(null), K = useRef(void 0), q = useMemo(() => ({
		mode: "edit",
		areaId: "root",
		depth: 0
	}), []);
	return /* @__PURE__ */ jsx("div", {
		id: T,
		children: /* @__PURE__ */ jsx(dragListenerContext.Provider, {
			value: {
				dragListeners: R,
				setDragListeners: U
			},
			children: /* @__PURE__ */ jsx(DragDropProvider, {
				plugins: I,
				sensors: L,
				onDragEnd: (m, x) => {
					(getFrame()?.querySelector("[data-puck-entry]"))?.removeAttribute("data-puck-dragging");
					let { source: T, target: D } = m.operation;
					if (!T) {
						k.setState({ draggedItem: null });
						return;
					}
					let { zone: O, index: A } = T.data, { previewIndex: j = {} } = k.getState() || {}, M = j[O]?.props.id === T.id ? j[O] : null, N = () => {
						var T, j;
						if (k.setState({ draggedItem: null }), m.canceled || D?.type === "void") {
							k.setState({ previewIndex: {} }), (T = R.dragend) == null || T.forEach((S) => {
								S(m, x);
							}), S({
								type: "setUi",
								ui: {
									itemSelector: null,
									isDragging: !1
								}
							});
							return;
						}
						M && (k.setState({ previewIndex: {} }), M.type === "insert" ? insertComponent(M.componentType, M.zone, M.index, C.getState()) : K.current && S({
							type: "move",
							sourceIndex: K.current.index,
							sourceZone: K.current.zone,
							destinationIndex: M.index,
							destinationZone: M.zone,
							recordHistory: !1
						})), S({
							type: "setUi",
							ui: {
								itemSelector: {
									index: A,
									zone: O
								},
								isDragging: !1
							},
							recordHistory: !0
						}), (j = R.dragend) == null || j.forEach((S) => {
							S(m, x);
						});
					}, P;
					P = E(() => {
						T.status === "idle" && (N(), P?.());
					});
				},
				onDragOver: (m, x) => {
					var S;
					if (m.preventDefault(), !k.getState()?.draggedItem) return;
					F();
					let { source: T, target: D } = m.operation;
					if (!D || !T || D.type === "void") return;
					let [O] = T.id.split(":"), [A] = D.id.split(":"), j = T.data, M = j.zone, N = j.index, P = "", I = 0;
					if (D.type === "component") {
						let m = D.data;
						P = m.zone, I = m.index;
						let S = x.collisionObserver.collisions[0]?.data, C = getDeepDir(D.element), T = S?.direction === "up" || C === "ltr" && S?.direction === "left" || C === "rtl" && S?.direction === "right" ? "before" : "after";
						I >= N && M === P && --I, T === "after" && (I += 1);
					} else P = D.id.toString(), I = 0;
					let L = C.getState().state.indexes.nodes[D.id]?.path || [];
					if (!(A === O || L.find((m) => {
						let [x] = m.split(":");
						return x === O;
					}))) {
						if (W.current === "new") k.setState({ previewIndex: { [P]: {
							componentType: j.componentType,
							type: "insert",
							index: I,
							zone: P,
							element: T.element,
							props: { id: T.id.toString() }
						} } });
						else {
							K.current ||= {
								zone: j.zone,
								index: j.index
							};
							let m = getItem(K.current, C.getState().state);
							m && k.setState({ previewIndex: { [P]: {
								componentType: j.componentType,
								type: "move",
								index: I,
								zone: P,
								props: m.props,
								element: T.element
							} } });
						}
						(S = R.dragover) == null || S.forEach((S) => {
							S(m, x);
						});
					}
				},
				onDragStart: (m, x) => {
					var S;
					let { source: T } = m.operation;
					if (T && T.type !== "void") {
						let m = T.data, x = getItem({
							zone: m.zone,
							index: m.index
						}, C.getState().state);
						x && k.setState({ previewIndex: { [m.zone]: {
							componentType: m.componentType,
							type: "move",
							index: m.index,
							zone: m.zone,
							props: x.props,
							element: T.element
						} } });
					}
					(S = R.dragstart) == null || S.forEach((S) => {
						S(m, x);
					});
				},
				onBeforeDragStart: (m) => {
					W.current = m.operation.source?.type === "drawer" ? "new" : "existing", K.current = void 0, k.setState({ draggedItem: m.operation.source }), C.getState().selectedItem?.props.id === m.operation.source?.id ? S({
						type: "setUi",
						ui: { isDragging: !0 },
						recordHistory: !1
					}) : S({
						type: "setUi",
						ui: {
							itemSelector: null,
							isDragging: !0
						},
						recordHistory: !1
					}), (getFrame()?.querySelector("[data-puck-entry]"))?.setAttribute("data-puck-dragging", "true");
				},
				children: /* @__PURE__ */ jsx(ZoneStoreProvider, {
					store: k,
					children: /* @__PURE__ */ jsx(DropZoneProvider, {
						value: q,
						children: m
					})
				})
			})
		})
	});
}, DragDropContext = ({ children: m, disableAutoScroll: x }) => useAppStore((m) => m.status) === "LOADING" ? m : /* @__PURE__ */ jsx(DragDropContextClient, {
	disableAutoScroll: x,
	children: m
}), getClassName17 = get_class_name_factory_default("Drawer", styles_module_default12), getClassNameItem2 = get_class_name_factory_default("DrawerItem", styles_module_default12), DrawerItemInner = ({ children: m, name: x, label: S, dragRef: C, isDragDisabled: T }) => {
	let D = useMemo(() => m || (({ children: m }) => /* @__PURE__ */ jsx("div", {
		className: getClassNameItem2("default"),
		children: m
	})), [m]);
	return /* @__PURE__ */ jsx("div", {
		className: getClassNameItem2({ disabled: T }),
		ref: C,
		onMouseDown: (m) => m.preventDefault(),
		"data-testid": C ? `drawer-item:${x}` : "",
		"data-puck-drawer-item": !0,
		children: /* @__PURE__ */ jsx(D, {
			name: x,
			children: /* @__PURE__ */ jsx("div", {
				className: getClassNameItem2("draggableWrapper"),
				children: /* @__PURE__ */ jsxs("div", {
					className: getClassNameItem2("draggable"),
					children: [/* @__PURE__ */ jsx("div", {
						className: getClassNameItem2("name"),
						children: S ?? x
					}), /* @__PURE__ */ jsx("div", {
						className: getClassNameItem2("icon"),
						children: /* @__PURE__ */ jsx(DragIcon, {})
					})]
				})
			})
		})
	});
}, DrawerItemDraggable = ({ children: m, name: x, label: S, id: C, isDragDisabled: T }) => {
	let { ref: D } = useDraggable({
		id: C,
		data: { componentType: x },
		disabled: T,
		type: "drawer"
	});
	return /* @__PURE__ */ jsxs("div", {
		className: getClassName17("draggable"),
		children: [/* @__PURE__ */ jsx("div", {
			className: getClassName17("draggableBg"),
			children: /* @__PURE__ */ jsx(DrawerItemInner, {
				name: x,
				label: S,
				children: m
			})
		}), /* @__PURE__ */ jsx("div", {
			className: getClassName17("draggableFg"),
			children: /* @__PURE__ */ jsx(DrawerItemInner, {
				name: x,
				label: S,
				dragRef: D,
				isDragDisabled: T,
				children: m
			})
		})]
	});
}, DrawerItem = ({ name: m, children: x, id: S, label: C, index: T, isDragDisabled: D }) => {
	let O = S || m, [k, A] = useState(generateId(O));
	return T !== void 0 && console.error("Warning: The `index` prop on Drawer.Item is deprecated and no longer required."), useDragListener("dragend", () => {
		A(generateId(O));
	}, [O]), /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(DrawerItemDraggable, {
		name: m,
		label: C,
		id: k,
		isDragDisabled: D,
		children: x
	}) }, k);
}, Drawer = ({ children: m, droppableId: x, direction: S }) => {
	x && console.error("Warning: The `droppableId` prop on Drawer is deprecated and no longer required."), S && console.error("Warning: The `direction` prop on Drawer is deprecated and no longer required to achieve multi-directional dragging.");
	let C = useSafeId(), { ref: T } = useDroppable({
		id: C,
		type: "void",
		collisionPriority: 0
	});
	return /* @__PURE__ */ jsx("div", {
		className: getClassName17(),
		ref: T,
		"data-puck-dnd": C,
		"data-puck-drawer": !0,
		"data-puck-dnd-void": !0,
		children: m
	});
};
Drawer.Item = DrawerItem, init_react_import();
var getNumItems = (m, x) => m.getState().state.indexes.zones[x].contentIds.length, useMinEmptyHeight = ({ zoneCompound: m, userMinEmptyHeight: x, ref: S }) => {
	let C = useAppStoreApi(), [T, D] = useState(0), [O, k] = useState(!1), { draggedItem: A, isZone: j } = useContextStore(ZoneStoreContext, (x) => ({
		draggedItem: x.draggedItem?.data.zone === m ? x.draggedItem : null,
		isZone: x.draggedItem?.data.zone === m
	})), M = useRef(0), N = useOnDragFinished((x) => {
		var S;
		if (x) {
			let x = getNumItems(C, m);
			if (D(0), x || M.current === 0) {
				k(!1);
				return;
			}
			let T = C.getState().selectedItem, O = C.getState().state.indexes.zones, A = C.getState().nodes;
			(S = A.nodes[T?.props.id]) == null || S.methods.hideOverlay(), setTimeout(() => {
				(O[m]?.contentIds || []).forEach((m) => {
					A.nodes[m]?.methods.sync();
				}), T && setTimeout(() => {
					var m, x;
					(m = A.nodes[T.props.id]) == null || m.methods.sync(), (x = A.nodes[T.props.id]) == null || x.methods.showOverlay();
				}, 200), k(!1);
			}, 100);
		}
	}, [
		C,
		T,
		m
	]);
	return useEffect(() => {
		if (A && S.current && j) {
			let x = S.current.getBoundingClientRect();
			return M.current = getNumItems(C, m), D(x.height), k(!0), N();
		}
	}, [
		S.current,
		A,
		N
	]), [T || x, O];
};
init_react_import();
function assignRef(m, x) {
	typeof m == "function" ? m(x) : m && typeof m == "object" && "current" in m && (m.current = x);
}
function assignRefs(m, x) {
	m.forEach((m) => {
		assignRef(m, x);
	});
}
init_react_import(), init_react_import();
function useRenderedCallback(m, x) {
	let S = useDragDropManager();
	return useCallback((...x) => __async(this, null, function* () {
		return yield S?.renderer.rendering, m(...x);
	}), [...x, S]);
}
var useContentIdsWithPreview = (m, x) => {
	let S = useContext(ZoneStoreContext), C = useContextStore(ZoneStoreContext, (m) => m.previewIndex[x]), T = useAppStore((m) => m.state.ui.isDragging), [D, O] = useState(m), [k, A] = useState(C), j = useRenderedCallback((m, x, S, C, T) => {
		S && !T || (x ? (x.type, O(insert(m.filter((m) => m !== x.props.id), x.index, x.props.id))) : O(T ? m.filter((m) => m !== C) : m), A(x));
	}, []);
	return useEffect(() => {
		let x = S.getState();
		j(m, C, T, x.draggedItem?.id, Object.keys(x.previewIndex || {}).length > 0);
	}, [
		m,
		C,
		T
	]), [D, k];
};
init_react_import();
var GRID_DRAG_AXIS = "dynamic", FLEX_ROW_DRAG_AXIS = "x", DEFAULT_DRAG_AXIS = "y", useDragAxis = (m, x) => {
	let S = useAppStore((m) => m.status), [C, T] = useState(x || DEFAULT_DRAG_AXIS), D = useCallback(() => {
		if (m.current) {
			let x = window.getComputedStyle(m.current);
			x.display === "grid" ? T(GRID_DRAG_AXIS) : x.display === "flex" && x.flexDirection === "row" ? T(FLEX_ROW_DRAG_AXIS) : T(DEFAULT_DRAG_AXIS);
		}
	}, [m.current]);
	return useEffect(() => {
		let m = () => {
			D();
		};
		return window.addEventListener("viewportchange", m), () => {
			window.removeEventListener("viewportchange", m);
		};
	}, []), useEffect(D, [S, x]), [C, D];
};
init_react_import();
var ContextSlotRender = ({ componentId: m, zone: x }) => {
	let S = useAppStore((m) => m.config), C = useAppStore((m) => m.metadata);
	return /* @__PURE__ */ jsx(SlotRenderPure, {
		content: useAppStore(useShallow((S) => {
			let C = S.state.indexes;
			return (C.zones[`${m}:${x}`]?.contentIds ?? []).map((m) => C.nodes[m].flatData);
		})),
		zone: x,
		config: S,
		metadata: C
	});
};
init_react_import(), init_react_import(), init_react_import();
var registerOverlayPortal = (m, x = {}) => {
	if (!m) return;
	let { disableDrag: S = !1, disableDragOnFocus: C = !0 } = x, T = (m) => {
		m.stopPropagation();
	};
	m.addEventListener("mouseover", T, { capture: !0 });
	let D = () => {
		setTimeout(() => {
			m.addEventListener("pointerdown", T, { capture: !0 });
		}, 200);
	};
	return C ? (m.addEventListener("focus", D, { capture: !0 }), m.addEventListener("blur", () => {
		m.removeEventListener("pointerdown", T, { capture: !0 });
	}, { capture: !0 })) : S && m.addEventListener("pointerdown", T, { capture: !0 }), m.setAttribute("data-puck-overlay-portal", "true"), () => {
		m.removeEventListener("mouseover", T, { capture: !0 }), C ? (m.removeEventListener("focus", D, { capture: !0 }), m.removeEventListener("blur", D, { capture: !0 })) : S && m.removeEventListener("pointerdown", T, { capture: !0 }), m.removeAttribute("data-puck-overlay-portal");
	};
};
init_react_import();
var styles_module_default13 = { InlineTextField: "_InlineTextField_1xph6_1" };
init_react_import();
function setDeep(m, x, S) {
	let C = x.split("."), T = __spreadValues({}, m), D = T;
	for (let m = 0; m < C.length; m++) {
		let [x, T] = C[m].replace("]", "").split("["), O = m === C.length - 1;
		if (T !== void 0) {
			Array.isArray(D[x]) || (D[x] = []);
			let m = Number(T);
			if (O) {
				D[x][m] = S;
				continue;
			}
			D[x][m] === void 0 && (D[x][m] = {}), D = D[x][m];
			continue;
		}
		if (O) {
			D[x] = S;
			continue;
		}
		D[x] === void 0 && (D[x] = {}), D = D[x];
	}
	return __spreadValues(__spreadValues({}, m), T);
}
init_react_import();
var getSelectorForId = (m, x) => {
	let S = m.indexes.nodes[x];
	if (!S) return;
	let C = `${S.parentId}:${S.zone}`;
	return {
		zone: C,
		index: m.indexes.zones[C].contentIds.indexOf(x)
	};
}, getClassName18 = get_class_name_factory_default("InlineTextField", styles_module_default13), InlineTextField = memo(({ propPath: m, componentId: x, value: S, isReadOnly: C, opts: T = {} }) => {
	let D = useRef(null), O = useAppStoreApi(), k = T.disableLineBreaks ?? !1;
	useEffect(() => {
		let C = O.getState(), T = C.state.indexes.nodes[x].data;
		if (!C.getComponentConfig(T.type)) throw Error(`InlineTextField Error: No config defined for ${T.type}`);
		if (D.current) {
			S !== D.current.innerText && D.current.replaceChildren(S);
			let C = registerOverlayPortal(D.current), T = (S) => __async(void 0, null, function* () {
				let C = O.getState(), T = C.state.indexes.nodes[x], D = `${T.parentId}:${T.zone}`, A = C.state.indexes.zones[D]?.contentIds.indexOf(x), j = S.target.innerText;
				k && (j = j.replaceAll(/\n/gm, ""));
				let M = setDeep(T.data.props, m, j), N = yield C.resolveComponentData(__spreadProps(__spreadValues({}, T.data), { props: M }), "replace");
				C.dispatch({
					type: "replace",
					data: N.node,
					destinationIndex: A,
					destinationZone: D
				});
			});
			return D.current.addEventListener("input", T), () => {
				var m;
				(m = D.current) == null || m.removeEventListener("input", T), C?.();
			};
		}
	}, [
		O,
		D.current,
		S,
		k
	]);
	let [A, j] = useState(!1), [M, N] = useState(!1);
	return /* @__PURE__ */ jsx("span", {
		className: getClassName18(),
		ref: D,
		contentEditable: A || M ? "plaintext-only" : "false",
		onClick: (m) => {
			m.preventDefault(), m.stopPropagation();
		},
		onClickCapture: (m) => {
			m.preventDefault(), m.stopPropagation();
			let S = getSelectorForId(O.getState().state, x);
			O.getState().setUi({ itemSelector: S });
		},
		onKeyDown: (m) => {
			m.stopPropagation(), (k && m.key === "Enter" || C) && m.preventDefault();
		},
		onKeyUp: (m) => {
			m.stopPropagation(), m.preventDefault();
		},
		onMouseOverCapture: () => j(!0),
		onMouseOutCapture: () => j(!1),
		onFocus: () => N(!0),
		onBlur: () => N(!1)
	});
}), getInlineTextTransform = () => ({
	text: ({ value: m, componentId: x, field: S, propPath: C, isReadOnly: T }) => S.contentEditable ? /* @__PURE__ */ jsx(InlineTextField, {
		propPath: C,
		componentId: x,
		value: m,
		opts: { disableLineBreaks: !0 },
		isReadOnly: T
	}) : m,
	textarea: ({ value: m, componentId: x, field: S, propPath: C, isReadOnly: T }) => S.contentEditable ? /* @__PURE__ */ jsx(InlineTextField, {
		propPath: C,
		componentId: x,
		value: m,
		isReadOnly: T
	}) : m,
	custom: ({ value: m, componentId: x, field: S, propPath: C, isReadOnly: T }) => S.contentEditable && typeof m == "string" ? /* @__PURE__ */ jsx(InlineTextField, {
		propPath: C,
		componentId: x,
		value: m,
		isReadOnly: T
	}) : m
}), getClassName19 = get_class_name_factory_default("DropZone", styles_module_default11), getRandomColor = () => `#${Math.floor(Math.random() * 16777215).toString(16)}`, RENDER_DEBUG = !1, DropZoneEditPure = (m) => /* @__PURE__ */ jsx(DropZoneEdit, __spreadValues({}, m)), DropZoneChildMemo = memo(({ zoneCompound: m, componentId: x, index: S, dragAxis: C, collisionAxis: T, inDroppableZone: D }) => {
	let O = useAppStore((m) => m.metadata), { depth: k = 1 } = useContext(dropZoneContext) ?? {}, A = useContext(ZoneStoreContext), j = useAppStore(useShallow((m) => m.state.indexes.nodes[x]?.flatData.props)), M = useAppStore((m) => m.state.indexes.nodes[x]?.data.type), P = useAppStore(useShallow((m) => m.state.indexes.nodes[x]?.data.readOnly)), F = useMemo(() => {
		if (j) return expandNode({
			type: M,
			props: j
		});
		let S = A.getState().previewIndex[m];
		return x === S?.props.id ? {
			type: S.componentType,
			props: S.props,
			previewType: S.type,
			element: S.element
		} : null;
	}, [
		useAppStoreApi(),
		x,
		m,
		M,
		j
	]), I = useAppStore((m) => F?.type ? m.config.components[F.type] : null), L = useMemo(() => ({
		renderDropZone: DropZoneEditPure,
		isEditing: !0,
		dragRef: null,
		metadata: __spreadValues(__spreadValues({}, O), I?.metadata)
	}), [O, I?.metadata]), R = useAppStore((m) => m.overrides), B = useAppStore((m) => m.componentState[x]?.loadingCount > 0), H = useAppStore((m) => m.selectedItem?.props.id === x || !1), U = I?.label ?? F?.type.toString() ?? "Component", q = useMemo(() => function() {
		return F && "element" in F && F.element ? /* @__PURE__ */ jsx("div", { dangerouslySetInnerHTML: { __html: F.element.outerHTML } }) : /* @__PURE__ */ jsx(DrawerItemInner, {
			name: U,
			children: R.componentItem ?? R.drawerItem
		});
	}, [
		x,
		U,
		R
	]), J = useMemo(() => __spreadProps(__spreadValues(__spreadValues({}, I?.defaultProps), F?.props), {
		puck: L,
		editMode: !0
	}), [
		I?.defaultProps,
		F?.props,
		L
	]), Y = useMemo(() => ({
		type: F?.type ?? M,
		props: J
	}), [
		F?.type,
		M,
		J
	]), X = useAppStore((m) => m.config), Z = useAppStore((m) => m.plugins), sH = useAppStore((m) => m.fieldTransforms), Q = useFieldTransforms(X, Y, useMemo(() => __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, getSlotTransform(DropZoneEditPure, (m) => /* @__PURE__ */ jsx(ContextSlotRender, {
		componentId: x,
		zone: m.zone
	}))), getInlineTextTransform()), Z.reduce((m, x) => __spreadValues(__spreadValues({}, m), x.fieldTransforms), {})), sH), [Z, sH]), P, B);
	if (!F) return;
	let cH = I ? I.render : () => /* @__PURE__ */ jsxs("div", {
		style: {
			padding: 48,
			textAlign: "center"
		},
		children: ["No configuration for ", F.type]
	}), lH = F.type, uH = "previewType" in F ? F.previewType === "insert" : !1;
	return uH && (cH = q), /* @__PURE__ */ jsx(DraggableComponent, {
		id: x,
		componentType: lH,
		zoneCompound: m,
		depth: k + 1,
		index: S,
		isLoading: B,
		isSelected: H,
		label: U,
		autoDragAxis: C,
		userDragAxis: T,
		inDroppableZone: D,
		children: (m) => I?.inline && !uH ? /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(cH, __spreadProps(__spreadValues({}, Q), { puck: __spreadProps(__spreadValues({}, Q.puck), { dragRef: m }) })) }) : /* @__PURE__ */ jsx("div", {
			ref: m,
			children: /* @__PURE__ */ jsx(cH, __spreadValues({}, Q))
		})
	});
}), DropZoneEdit = forwardRef(function({ zone: m, allow: x, disallow: S, style: C, className: T, minEmptyHeight: D = 128, collisionAxis: O }, k) {
	let A = useContext(dropZoneContext), j = useAppStoreApi(), { areaId: F, depth: I = 0, registerLocalZone: L, unregisterLocalZone: R } = A ?? {}, H = useAppStore(useShallow((m) => F ? m.state.indexes.nodes[F]?.path : null)), U = rootDroppableId;
	F && m !== rootDroppableId && (U = `${F}:${m}`);
	let W = U === rootDroppableId || m === rootDroppableId || F === "root", K = useContextStore(ZoneStoreContext, (m) => m.nextAreaDepthIndex[F || ""]), q = useAppStore(useShallow((m) => m.state.indexes.zones[U]?.contentIds)), J = useAppStore(useShallow((m) => m.state.indexes.zones[U]?.type));
	useEffect(() => {
		(!J || J === "dropzone") && A?.registerZone && A?.registerZone(U);
	}, [J, j]), useEffect(() => {
		J === "dropzone" && U !== rootDroppableId && console.warn("DropZones have been deprecated in favor of slot fields and will be removed in a future version of Puck. Please see the migration guide: https://www.puckeditor.com/docs/guides/migrations/dropzones-to-slots");
	}, [J]);
	let Y = useMemo(() => q || [], [q]), X = useRef(null), Z = useCallback((m) => {
		if (!m) return !0;
		if (S) {
			let C = x || [];
			if ((S || []).filter((m) => C.indexOf(m) === -1).indexOf(m) !== -1) return !1;
		} else if (x && x.indexOf(m) === -1) return !1;
		return !0;
	}, [x, S]), sH = useContextStore(ZoneStoreContext, (m) => Z(m.draggedItem?.data.componentType)), Q = K || W, cH = useContextStore(ZoneStoreContext, (m) => {
		let x = !0;
		return x = m.zoneDepthIndex[U] ?? !1, x &&= sH, x;
	});
	useEffect(() => (L && L(U, sH || cH), () => {
		R && R(U);
	}), [
		sH,
		cH,
		U
	]);
	let [lH, uH] = useContentIdsWithPreview(Y, U), dH = cH && (uH ? lH.length === 1 : lH.length === 0), fH = useContext(ZoneStoreContext);
	useEffect(() => {
		let { enabledIndex: m } = fH.getState();
		fH.setState({ enabledIndex: __spreadProps(__spreadValues({}, m), { [U]: cH }) });
	}, [
		cH,
		fH,
		U
	]);
	let { ref: pH } = useDroppable({
		id: U,
		collisionPriority: cH ? I : 0,
		disabled: !dH,
		collisionDetector: pointerIntersection,
		type: "dropzone",
		data: {
			areaId: F,
			depth: I,
			isDroppableTarget: sH,
			path: H || []
		}
	}), mH = useAppStore((m) => m?.selectedItem && F === m?.selectedItem.props.id), [hH] = useDragAxis(X, O), [gH, $] = useMinEmptyHeight({
		zoneCompound: U,
		userMinEmptyHeight: D,
		ref: X
	});
	return /* @__PURE__ */ jsx("div", {
		className: `${getClassName19({
			isRootZone: W,
			hoveringOverArea: Q,
			isEnabled: cH,
			isAreaSelected: mH,
			hasChildren: Y.length > 0,
			isAnimating: $
		})}${T ? ` ${T}` : ""}`,
		ref: (m) => {
			assignRefs([
				X,
				pH,
				k
			], m);
		},
		"data-testid": `dropzone:${U}`,
		"data-puck-dropzone": U,
		style: __spreadProps(__spreadValues({}, C), {
			"--min-empty-height": `${gH}px`,
			backgroundColor: RENDER_DEBUG ? getRandomColor() : C?.backgroundColor
		}),
		children: lH.map((m, x) => /* @__PURE__ */ jsx(DropZoneChildMemo, {
			zoneCompound: U,
			componentId: m,
			dragAxis: hH,
			index: x,
			collisionAxis: O,
			inDroppableZone: sH
		}, m))
	});
}), DropZoneRenderItem = ({ config: m, item: x, metadata: S }) => {
	let C = m.components[x.type], T = useSlots(m, x, (x) => /* @__PURE__ */ jsx(SlotRenderPure, __spreadProps(__spreadValues({}, x), {
		config: m,
		metadata: S
	})));
	return /* @__PURE__ */ jsx(DropZoneProvider, {
		value: useMemo(() => ({
			areaId: T.id,
			depth: 1
		}), [T]),
		children: /* @__PURE__ */ jsx(C.render, __spreadProps(__spreadValues({}, T), { puck: __spreadProps(__spreadValues({}, T.puck), {
			renderDropZone: DropZoneRenderPure,
			metadata: __spreadValues(__spreadValues({}, S), C.metadata)
		}) }))
	}, T.id);
}, DropZoneRenderPure = (m) => /* @__PURE__ */ jsx(DropZoneRender, __spreadValues({}, m)), DropZoneRender = forwardRef(function({ className: m, style: x, zone: S }, C) {
	let T = useContext(dropZoneContext), { areaId: D = "root" } = T || {}, { config: O, data: k, metadata: A } = useContext(renderContext), j = `${D}:${S}`, M = k?.content || [];
	return useEffect(() => {
		M || T?.registerZone && T?.registerZone(j);
	}, [M]), !k || !O ? null : (j !== rootDroppableId && (M = setupZone(k, j).zones[j]), /* @__PURE__ */ jsx("div", {
		className: m,
		style: x,
		ref: C,
		children: M.map((m) => O.components[m.type] ? /* @__PURE__ */ jsx(DropZoneRenderItem, {
			config: O,
			item: m,
			metadata: A
		}, m.props.id) : null)
	}));
}), DropZonePure = (m) => /* @__PURE__ */ jsx(DropZone, __spreadValues({}, m)), DropZone = forwardRef(function(m, x) {
	return useContext(dropZoneContext)?.mode === "edit" ? /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(DropZoneEdit, __spreadProps(__spreadValues({}, m), { ref: x })) }) : /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(DropZoneRender, __spreadProps(__spreadValues({}, m), { ref: x })) });
}), renderContext = React.createContext({
	config: { components: {} },
	data: {
		root: {},
		content: []
	},
	metadata: {}
});
function Render({ config: m, data: x, metadata: S = {} }) {
	let C = __spreadProps(__spreadValues({}, x), {
		root: x.root || {},
		content: x.content || []
	}), T = "props" in C.root ? C.root.props : C.root, D = T?.title || "", O = useSlots(m, {
		type: "root",
		props: __spreadProps(__spreadValues({}, T), {
			puck: {
				renderDropZone: DropZonePure,
				isEditing: !1,
				dragRef: null,
				metadata: S
			},
			title: D,
			editMode: !1,
			id: "puck-root"
		})
	}, (x) => /* @__PURE__ */ jsx(SlotRender, __spreadProps(__spreadValues({}, x), {
		config: m,
		metadata: S
	}))), k = useMemo(() => ({
		mode: "render",
		depth: 0
	}), []);
	return m.root?.render ? /* @__PURE__ */ jsx(renderContext.Provider, {
		value: {
			config: m,
			data: C,
			metadata: S
		},
		children: /* @__PURE__ */ jsx(DropZoneProvider, {
			value: k,
			children: /* @__PURE__ */ jsx(m.root.render, __spreadProps(__spreadValues({}, O), { children: /* @__PURE__ */ jsx(DropZoneRenderPure, { zone: rootZone }) }))
		})
	}) : /* @__PURE__ */ jsx(renderContext.Provider, {
		value: {
			config: m,
			data: C,
			metadata: S
		},
		children: /* @__PURE__ */ jsx(DropZoneProvider, {
			value: k,
			children: /* @__PURE__ */ jsx(DropZoneRenderPure, { zone: rootZone })
		})
	});
}
init_react_import();
var generateUsePuck = (m) => {
	let x = {
		back: m.history.back,
		forward: m.history.forward,
		setHistories: m.history.setHistories,
		setHistoryIndex: m.history.setHistoryIndex,
		hasPast: m.history.hasPast(),
		hasFuture: m.history.hasFuture(),
		histories: m.history.histories,
		index: m.history.index
	};
	return {
		appState: makeStatePublic(m.state),
		config: m.config,
		dispatch: m.dispatch,
		getPermissions: m.permissions.getPermissions,
		refreshPermissions: m.permissions.refreshPermissions,
		history: x,
		selectedItem: m.selectedItem || null,
		getItemBySelector: (x) => getItem(x, m.state),
		getItemById: (x) => m.state.indexes.nodes[x].data,
		getSelectorForId: (x) => getSelectorForId(m.state, x)
	};
}, UsePuckStoreContext = createContext(null), convertToPickedStore = (m) => ({
	state: m.state,
	config: m.config,
	dispatch: m.dispatch,
	permissions: m.permissions,
	history: m.history,
	selectedItem: m.selectedItem
}), useRegisterUsePuckStore = (m) => {
	let [x] = useState(() => createStore(() => generateUsePuck(convertToPickedStore(m.getState()))));
	return useEffect(() => m.subscribe((m) => convertToPickedStore(m), (m) => {
		x.setState(generateUsePuck(m));
	}), []), x;
};
init_react_import(), init_react_import(), init_react_import();
var styles_module_default14 = {
	SidebarSection: "_SidebarSection_8boj8_1",
	"SidebarSection-title": "_SidebarSection-title_8boj8_12",
	"SidebarSection--noBorderTop": "_SidebarSection--noBorderTop_8boj8_20",
	"SidebarSection-content": "_SidebarSection-content_8boj8_24",
	"SidebarSection--noPadding": "_SidebarSection--noPadding_8boj8_28",
	"SidebarSection-breadcrumbLabel": "_SidebarSection-breadcrumbLabel_8boj8_41",
	"SidebarSection-breadcrumbs": "_SidebarSection-breadcrumbs_8boj8_70",
	"SidebarSection-breadcrumb": "_SidebarSection-breadcrumb_8boj8_41",
	"SidebarSection-heading": "_SidebarSection-heading_8boj8_82",
	"SidebarSection-loadingOverlay": "_SidebarSection-loadingOverlay_8boj8_86"
};
init_react_import();
var useBreadcrumbs = (m) => {
	let x = useAppStore((m) => m.selectedItem?.props.id), S = useAppStore((m) => m.config), C = useAppStore((m) => m.state.indexes.nodes[x]?.path), T = useAppStoreApi();
	return useMemo(() => {
		let x = C?.map((m) => {
			let [x] = m.split(":");
			if (x === "root") return {
				label: "Page",
				selector: null
			};
			let C = T.getState().state.indexes.nodes[x], D = C.path[C.path.length - 1], O = (T.getState().state.indexes.zones[D]?.contentIds || []).indexOf(x);
			return {
				label: C ? S.components[C.data.type]?.label ?? C.data.type : "Component",
				selector: C ? {
					index: O,
					zone: C.path[C.path.length - 1]
				} : null
			};
		}) || [];
		return m ? x.slice(x.length - m) : x;
	}, [C, m]);
}, getClassName20 = get_class_name_factory_default("SidebarSection", styles_module_default14), SidebarSection = ({ children: m, title: x, background: S, showBreadcrumbs: C, noBorderTop: T, noPadding: D, isLoading: O }) => {
	let k = useAppStore((m) => m.setUi), A = useBreadcrumbs(1);
	return /* @__PURE__ */ jsxs("div", {
		className: getClassName20({
			noBorderTop: T,
			noPadding: D
		}),
		style: { background: S },
		children: [
			/* @__PURE__ */ jsx("div", {
				className: getClassName20("title"),
				children: /* @__PURE__ */ jsxs("div", {
					className: getClassName20("breadcrumbs"),
					children: [C ? A.map((m, x) => /* @__PURE__ */ jsxs("div", {
						className: getClassName20("breadcrumb"),
						children: [/* @__PURE__ */ jsx("button", {
							type: "button",
							className: getClassName20("breadcrumbLabel"),
							onClick: () => k({ itemSelector: m.selector }),
							children: m.label
						}), /* @__PURE__ */ jsx(ChevronRight, { size: 16 })]
					}, x)) : null, /* @__PURE__ */ jsx("div", {
						className: getClassName20("heading"),
						children: /* @__PURE__ */ jsx(Heading, {
							rank: "2",
							size: "xs",
							children: x
						})
					})]
				})
			}),
			/* @__PURE__ */ jsx("div", {
				className: getClassName20("content"),
				children: m
			}),
			O && /* @__PURE__ */ jsx("div", {
				className: getClassName20("loadingOverlay"),
				children: /* @__PURE__ */ jsx(Loader, { size: 32 })
			})
		]
	});
};
init_react_import();
var styles_module_default15 = {
	Puck: "_Puck_1yxlw_19",
	"Puck-portal": "_Puck-portal_1yxlw_31",
	"PuckLayout-inner": "_PuckLayout-inner_1yxlw_38",
	"PuckLayout--mounted": "_PuckLayout--mounted_1yxlw_59",
	"PuckLayout--leftSideBarVisible": "_PuckLayout--leftSideBarVisible_1yxlw_63",
	"PuckLayout--rightSideBarVisible": "_PuckLayout--rightSideBarVisible_1yxlw_69",
	"PuckLayout-mounted": "_PuckLayout-mounted_1yxlw_83",
	PuckLayout: "_PuckLayout_1yxlw_38"
};
init_react_import(), init_react_import();
var getClassName21 = get_class_name_factory_default("PuckFields", {
	PuckFields: "_PuckFields_10bh7_1",
	"PuckFields--isLoading": "_PuckFields--isLoading_10bh7_6",
	"PuckFields-loadingOverlay": "_PuckFields-loadingOverlay_10bh7_10",
	"PuckFields-loadingOverlayInner": "_PuckFields-loadingOverlayInner_10bh7_25",
	"PuckFields-field": "_PuckFields-field_10bh7_32",
	"PuckFields--wrapFields": "_PuckFields--wrapFields_10bh7_36"
}), DefaultFields = ({ children: m }) => /* @__PURE__ */ jsx(Fragment$1, { children: m }), createOnChange = (m, x) => (S, C) => __async(void 0, null, function* () {
	let T, { dispatch: D, state: O, selectedItem: k, resolveComponentData: A } = x.getState(), { data: j, ui: M } = O, { itemSelector: N } = M, P = j.root.props || j.root;
	T = k ? k.props : P;
	let F = __spreadProps(__spreadValues({}, T), { [m]: S });
	k && N ? D({
		type: "replace",
		destinationIndex: N.index,
		destinationZone: N.zone || rootDroppableId,
		data: (yield A(__spreadProps(__spreadValues({}, k), { props: F }), "replace")).node,
		ui: C
	}) : j.root.props ? D({
		type: "replaceRoot",
		root: (yield A(__spreadProps(__spreadValues({}, j.root), { props: F }), "replace")).node,
		ui: __spreadValues(__spreadValues({}, M), C),
		recordHistory: !0
	}) : D({
		type: "setData",
		data: { root: F }
	});
}), FieldsChildMemo = memo(({ fieldName: m }) => {
	let x = useAppStore((x) => x.fields.fields[m]), S = useAppStore((x) => ((x.selectedItem ? x.selectedItem.readOnly : x.state.data.root.readOnly) || {})[m]), C = useAppStore((x) => {
		let S = x.state.data.root.props || x.state.data.root;
		return x.selectedItem ? x.selectedItem.props[m] : S[m];
	}), T = useAppStore((S) => x ? S.selectedItem ? `${S.selectedItem.props.id}_${x.type}_${m}` : `root_${x.type}_${m}` : null), D = useAppStore(useShallow((m) => {
		let { selectedItem: x, permissions: S } = m;
		return x ? S.getPermissions({ item: x }) : S.getPermissions({ root: !0 });
	})), O = useCallback(createOnChange(m, useAppStoreApi()), [m]), { visible: k = !0 } = x ?? {};
	return !x || !T || !k || x.type === "slot" ? null : /* @__PURE__ */ jsx("div", {
		className: getClassName21("field"),
		children: /* @__PURE__ */ jsx(AutoFieldPrivate, {
			field: x,
			name: m,
			id: T,
			readOnly: !D.edit || S,
			value: C,
			onChange: O
		})
	}, T);
}), Fields = memo(({ wrapFields: m = !0 }) => {
	let x = useAppStore((m) => m.overrides), S = useAppStore((m) => ((m.selectedItem ? m.componentState[m.selectedItem.props.id]?.loadingCount : m.componentState.root?.loadingCount) ?? 0) > 0), C = useAppStore(useShallow((m) => m.state.ui.itemSelector)), T = useAppStore((m) => m.selectedItem?.props.id);
	useRegisterFieldsSlice(useAppStoreApi(), T);
	let D = useAppStore((m) => m.fields.loading), O = useAppStore(useShallow((m) => m.fields.id === T ? Object.keys(m.fields.fields) : [])), k = D || S, A = useMemo(() => x.fields || DefaultFields, [x]);
	return /* @__PURE__ */ jsxs("form", {
		className: getClassName21({ wrapFields: m }),
		onSubmit: (m) => {
			m.preventDefault();
		},
		children: [/* @__PURE__ */ jsx(A, {
			isLoading: k,
			itemSelector: C,
			children: O.map((m) => /* @__PURE__ */ jsx(FieldsChildMemo, { fieldName: m }, m))
		}), k && /* @__PURE__ */ jsx("div", {
			className: getClassName21("loadingOverlay"),
			children: /* @__PURE__ */ jsx("div", {
				className: getClassName21("loadingOverlayInner"),
				children: /* @__PURE__ */ jsx(Loader, { size: 16 })
			})
		})]
	});
});
init_react_import(), init_react_import(), init_react_import(), init_react_import();
var getClassName22 = get_class_name_factory_default("ComponentList", {
	ComponentList: "_ComponentList_1rrlt_1",
	"ComponentList--isExpanded": "_ComponentList--isExpanded_1rrlt_5",
	"ComponentList-content": "_ComponentList-content_1rrlt_9",
	"ComponentList-title": "_ComponentList-title_1rrlt_17",
	"ComponentList-titleIcon": "_ComponentList-titleIcon_1rrlt_53"
}), ComponentListItem = ({ name: m, label: x }) => {
	let S = useAppStore((m) => m.overrides), C = useAppStore((x) => x.permissions.getPermissions({ type: m }).insert);
	return useEffect(() => {
		S.componentItem && console.warn("The `componentItem` override has been deprecated and renamed to `drawerItem`");
	}, [S]), /* @__PURE__ */ jsx(Drawer.Item, {
		label: x,
		name: m,
		isDragDisabled: !C,
		children: S.componentItem ?? S.drawerItem
	});
}, ComponentList = ({ children: m, title: x, id: S }) => {
	let C = useAppStore((m) => m.config), T = useAppStore((m) => m.setUi), D = useAppStore((m) => m.state.ui.componentList), { expanded: O = !0 } = D[S] || {};
	return /* @__PURE__ */ jsxs("div", {
		className: getClassName22({ isExpanded: O }),
		children: [x && /* @__PURE__ */ jsxs("button", {
			type: "button",
			className: getClassName22("title"),
			onClick: () => T({ componentList: __spreadProps(__spreadValues({}, D), { [S]: __spreadProps(__spreadValues({}, D[S]), { expanded: !O }) }) }),
			title: O ? `Collapse${x ? ` ${x}` : ""}` : `Expand${x ? ` ${x}` : ""}`,
			children: [/* @__PURE__ */ jsx("div", { children: x }), /* @__PURE__ */ jsx("div", {
				className: getClassName22("titleIcon"),
				children: jsx(O ? ChevronUp : ChevronDown, { size: 12 })
			})]
		}), /* @__PURE__ */ jsx("div", {
			className: getClassName22("content"),
			children: /* @__PURE__ */ jsx(Drawer, { children: m || Object.keys(C.components).map((m) => /* @__PURE__ */ jsx(ComponentListItem, {
				label: C.components[m].label ?? m,
				name: m
			}, m)) })
		})]
	});
};
ComponentList.Item = ComponentListItem;
var useComponentList = () => {
	let [m, x] = useState(), S = useAppStore((m) => m.config), C = useAppStore((m) => m.state.ui.componentList);
	return useEffect(() => {
		if (Object.keys(C).length > 0) {
			let m = [], T;
			T = Object.entries(C).map(([x, C]) => !C.components || (C.components.forEach((x) => {
				m.push(x);
			}), C.visible === !1) ? null : /* @__PURE__ */ jsx(ComponentList, {
				id: x,
				title: C.title || x,
				children: C.components.map((m, x) => {
					let C = S.components[m] || {};
					return /* @__PURE__ */ jsx(ComponentList.Item, {
						label: C.label ?? m,
						name: m,
						index: x
					}, m);
				})
			}, x));
			let D = Object.keys(S.components).filter((x) => m.indexOf(x) === -1);
			D.length > 0 && !C.other?.components && C.other?.visible !== !1 && T.push(/* @__PURE__ */ jsx(ComponentList, {
				id: "other",
				title: C.other?.title || "Other",
				children: D.map((m, x) => {
					let C = S.components[m] || {};
					return /* @__PURE__ */ jsx(ComponentList.Item, {
						name: m,
						label: C.label ?? m,
						index: x
					}, m);
				})
			}, "other")), x(T);
		}
	}, [
		S.categories,
		S.components,
		C
	]), m;
}, Components = () => {
	let m = useAppStore((m) => m.overrides), x = useComponentList();
	return /* @__PURE__ */ jsx(useMemo(() => (m.components && console.warn("The `components` override has been deprecated and renamed to `drawer`"), m.components || m.drawer || "div"), [m]), { children: x || /* @__PURE__ */ jsx(ComponentList, { id: "all" }) });
};
init_react_import(), init_react_import();
var styleSelector = "style, link[rel=\"stylesheet\"]", collectStyles = (m) => {
	let x = [];
	return m.querySelectorAll(styleSelector).forEach((m) => {
		m.tagName === "STYLE" ? m.innerHTML.trim() && x.push(m) : x.push(m);
	}), x;
}, getStyleSheet = (m) => Array.from(document.styleSheets).find((x) => x.ownerNode.href === m.href), getStyles = (m) => {
	if (m) try {
		return [...Array.from(m.cssRules)].map((m) => m.cssText).join("");
	} catch {
		console.warn("Access to stylesheet %s is denied. Ignoring", m.href);
	}
	return "";
}, syncAttributes = (m, x) => {
	let S = m.attributes;
	S?.length > 0 && Array.from(S).forEach((m) => {
		x.setAttribute(m.name, m.value);
	});
}, defer = (m) => setTimeout(m, 0), CopyHostStyles = ({ children: m, debug: x = !1, onStylesLoaded: S = () => null }) => {
	let { document: C, window: T } = useFrame();
	return useEffect(() => {
		if (!T || !C) return () => {};
		let m = [], D = {}, O = (x) => m.findIndex((m) => m.original === x), k = (m, S = !1) => __async(void 0, null, function* () {
			let C;
			if (m.nodeName === "LINK" && S) {
				C = document.createElement("style"), C.type = "text/css";
				let S = getStyleSheet(m);
				S ||= (yield new Promise((x) => {
					let S = () => {
						x(), m.removeEventListener("load", S);
					};
					m.addEventListener("load", S);
				}), getStyleSheet(m));
				let T = getStyles(S);
				if (!T) {
					x && console.warn("Tried to load styles for link element, but couldn't find them. Skipping...");
					return;
				}
				C.innerHTML = T, C.setAttribute("data-href", m.getAttribute("href"));
			} else C = m.cloneNode(!0);
			return C;
		}), A = (S) => __async(void 0, null, function* () {
			let T = O(S);
			if (T > -1) {
				x && console.log("Tried to add an element that was already mirrored. Updating instead..."), m[T].mirror.innerText = S.innerText;
				return;
			}
			let A = yield k(S);
			if (!A) return;
			let j = (0, import_object_hash.default)(A.outerHTML);
			if (D[j]) {
				x && console.log("iframe already contains element that is being mirrored. Skipping...");
				return;
			}
			D[j] = !0, C.head.append(A), m.push({
				original: S,
				mirror: A
			}), x && console.log(`Added style node ${S.outerHTML}`);
		}), j = (S) => {
			var C;
			let T = O(S);
			if (T === -1) {
				x && console.log("Tried to remove an element that did not exist. Skipping...");
				return;
			}
			let k = (0, import_object_hash.default)(S.outerHTML);
			(C = m[T]?.mirror) == null || C.remove(), delete D[k], x && console.log(`Removed style node ${S.outerHTML}`);
		}, M = new MutationObserver((m) => {
			m.forEach((m) => {
				m.type === "childList" && (m.addedNodes.forEach((m) => {
					if (m.nodeType === Node.TEXT_NODE || m.nodeType === Node.ELEMENT_NODE) {
						let x = m.nodeType === Node.TEXT_NODE ? m.parentElement : m;
						x && x.matches(styleSelector) && defer(() => A(x));
					}
				}), m.removedNodes.forEach((m) => {
					if (m.nodeType === Node.TEXT_NODE || m.nodeType === Node.ELEMENT_NODE) {
						let x = m.nodeType === Node.TEXT_NODE ? m.parentElement : m;
						x && x.matches(styleSelector) && defer(() => j(x));
					}
				}));
			});
		}), N = T.parent.document, P = collectStyles(N), F = [], I = 0, L = N.getElementsByTagName("html")[0];
		syncAttributes(L, C.documentElement);
		let R = N.getElementsByTagName("body")[0];
		return syncAttributes(R, C.body), Promise.all(P.map((x, S) => __async(void 0, null, function* () {
			if (x.nodeName === "LINK") {
				let m = x.href;
				if (F.indexOf(m) > -1) return;
				F.push(m);
			}
			let S = yield k(x);
			if (S) return m.push({
				original: x,
				mirror: S
			}), S;
		}))).then((x) => {
			let T = x.filter((m) => m !== void 0);
			T.forEach((x) => {
				x.onload = () => {
					I += 1, I >= m.length && S();
				}, x.onerror = () => {
					console.warn("AutoFrame couldn't load a stylesheet"), I += 1, I >= m.length && S();
				};
			}), C.head.innerHTML = "", C.head.append(...T), M.observe(N.head, {
				childList: !0,
				subtree: !0
			}), T.forEach((m) => {
				let x = (0, import_object_hash.default)(m.outerHTML);
				D[x] = !0;
			});
		}), () => {
			M.disconnect();
		};
	}, []), /* @__PURE__ */ jsx(Fragment$1, { children: m });
}, autoFrameContext = createContext({}), useFrame = () => useContext(autoFrameContext);
function AutoFrame(m) {
	var x = m, { children: S, className: C, debug: T, id: D, onReady: O = () => {}, onNotReady: k = () => {}, frameRef: A } = x, j = __objRest(x, [
		"children",
		"className",
		"debug",
		"id",
		"onReady",
		"onNotReady",
		"frameRef"
	]);
	let [M, N] = useState(!1), [F, I] = useState({}), [L, R] = useState(), [z, B] = useState(!1);
	return useEffect(() => {
		if (A.current) {
			let m = A.current.contentDocument, x = A.current.contentWindow;
			I({
				document: m || void 0,
				window: x || void 0
			}), R(A.current.contentDocument?.getElementById("frame-root")), m && x && z ? O() : k();
		}
	}, [
		A,
		M,
		z
	]), /* @__PURE__ */ jsx("iframe", __spreadProps(__spreadValues({}, j), {
		className: C,
		id: D,
		srcDoc: "<!DOCTYPE html><html><head></head><body><div id=\"frame-root\" data-puck-entry></div></body></html>",
		ref: A,
		onLoad: () => {
			N(!0);
		},
		children: /* @__PURE__ */ jsx(autoFrameContext.Provider, {
			value: F,
			children: M && L && /* @__PURE__ */ jsx(CopyHostStyles, {
				debug: T,
				onStylesLoaded: () => B(!0),
				children: createPortal(S, L)
			})
		})
	}));
}
AutoFrame.displayName = "AutoFrame";
var AutoFrame_default = AutoFrame;
init_react_import();
var getClassName23 = get_class_name_factory_default("PuckPreview", {
	PuckPreview: "_PuckPreview_z2rgu_1",
	"PuckPreview-frame": "_PuckPreview-frame_z2rgu_6"
}), useBubbleIframeEvents = (m) => {
	let x = useAppStore((m) => m.status);
	useEffect(() => {
		if (m.current && x === "READY") {
			let x = m.current, S = (m) => {
				let S = new BubbledPointerEvent("pointermove", __spreadProps(__spreadValues({}, m), {
					bubbles: !0,
					cancelable: !1,
					clientX: m.clientX,
					clientY: m.clientY,
					originalTarget: m.target
				}));
				x.dispatchEvent(S);
			}, C = () => {
				var m;
				T(), (m = x.contentDocument) == null || m.addEventListener("pointermove", S, { capture: !0 });
			}, T = () => {
				var m;
				(m = x.contentDocument) == null || m.removeEventListener("pointermove", S);
			};
			return C(), () => {
				T();
			};
		}
	}, [x]);
}, Preview2 = ({ id: m = "puck-preview" }) => {
	let x = useAppStore((m) => m.dispatch), S = useAppStore((m) => m.state.data.root), C = useAppStore((m) => m.config), T = useAppStore((m) => m.setStatus), D = useAppStore((m) => m.iframe), O = useAppStore((m) => m.overrides), k = useAppStore((m) => m.metadata), A = useAppStore((m) => m.state.ui.previewMode === "edit" ? null : m.state.data), j = useCallback((m) => {
		let x = useSlots(C, {
			type: "root",
			props: m
		}, DropZoneEditPure);
		return C.root?.render ? C.root?.render(__spreadValues({ id: "puck-root" }, x)) : /* @__PURE__ */ jsx(Fragment$1, { children: x.children });
	}, [C]), N = useMemo(() => O.iframe, [O]), F = S.props || S, I = useRef(null);
	useBubbleIframeEvents(I);
	let L = A ? /* @__PURE__ */ jsx(Render, {
		data: A,
		config: C,
		metadata: k
	}) : /* @__PURE__ */ jsx(j, __spreadProps(__spreadValues({}, F), {
		puck: {
			renderDropZone: DropZonePure,
			isEditing: !0,
			dragRef: null,
			metadata: k
		},
		editMode: !0,
		children: /* @__PURE__ */ jsx(DropZonePure, { zone: rootDroppableId })
	}));
	return useEffect(() => {
		D.enabled || T("READY");
	}, [D.enabled]), /* @__PURE__ */ jsx("div", {
		className: getClassName23(),
		id: m,
		"data-puck-preview": !0,
		onClick: (m) => {
			let S = m.target;
			!S.hasAttribute("data-puck-component") && !S.hasAttribute("data-puck-dropzone") && x({
				type: "setUi",
				ui: { itemSelector: null }
			});
		},
		children: D.enabled ? /* @__PURE__ */ jsx(AutoFrame_default, {
			id: "preview-frame",
			className: getClassName23("frame"),
			"data-rfd-iframe": !0,
			onReady: () => {
				T("READY");
			},
			onNotReady: () => {
				T("MOUNTED");
			},
			frameRef: I,
			children: /* @__PURE__ */ jsx(autoFrameContext.Consumer, { children: ({ document: m }) => N ? /* @__PURE__ */ jsx(N, {
				document: m,
				children: L
			}) : L })
		}) : /* @__PURE__ */ jsx("div", {
			id: "preview-frame",
			className: getClassName23("frame"),
			ref: I,
			"data-puck-entry": !0,
			children: L
		})
	});
};
init_react_import(), init_react_import(), init_react_import();
var styles_module_default19 = {
	LayerTree: "_LayerTree_7rx04_1",
	"LayerTree-zoneTitle": "_LayerTree-zoneTitle_7rx04_11",
	"LayerTree-helper": "_LayerTree-helper_7rx04_17",
	Layer: "_Layer_7rx04_1",
	"Layer-inner": "_Layer-inner_7rx04_29",
	"Layer--containsZone": "_Layer--containsZone_7rx04_35",
	"Layer-clickable": "_Layer-clickable_7rx04_39",
	"Layer--isSelected": "_Layer--isSelected_7rx04_61",
	"Layer-chevron": "_Layer-chevron_7rx04_77",
	"Layer--childIsSelected": "_Layer--childIsSelected_7rx04_78",
	"Layer-zones": "_Layer-zones_7rx04_82",
	"Layer-title": "_Layer-title_7rx04_96",
	"Layer-name": "_Layer-name_7rx04_105",
	"Layer-icon": "_Layer-icon_7rx04_111",
	"Layer-zoneIcon": "_Layer-zoneIcon_7rx04_116"
};
init_react_import();
var scrollIntoView = (m) => {
	let x = __spreadValues({}, m.style);
	m.style.scrollMargin = "256px", m && (m?.scrollIntoView({ behavior: "smooth" }), m.style.scrollMargin = x.scrollMargin || "");
};
init_react_import();
var onScrollEnd = (m, x) => {
	let S, C = function() {
		clearTimeout(S), S = setTimeout(function() {
			x(), m?.removeEventListener("scroll", C);
		}, 50);
	};
	m?.addEventListener("scroll", C), setTimeout(() => {
		S || x();
	}, 50);
}, getClassName24 = get_class_name_factory_default("LayerTree", styles_module_default19), getClassNameLayer = get_class_name_factory_default("Layer", styles_module_default19), Layer = ({ index: m, itemId: x, zoneCompound: S }) => {
	let C = useAppStore((m) => m.config), T = useAppStore((m) => m.state.ui.itemSelector), D = useAppStore((m) => m.dispatch), O = useCallback((m) => {
		D({
			type: "setUi",
			ui: { itemSelector: m }
		});
	}, [D]), k = useAppStore((m) => m.selectedItem?.props.id) === x || T && T.zone === rootDroppableId && !S, A = useAppStore((m) => m.state.indexes.nodes[x]), j = useAppStore(useShallow((m) => Object.keys(m.state.indexes.zones).filter((m) => m.split(":")[0] === x))), P = j.length > 0, F = useContext(ZoneStoreContext), I = useContextStore(ZoneStoreContext, (m) => m.hoveringComponent === x), L = useAppStore((m) => m.state.indexes.nodes[m.selectedItem?.props.id]?.path.some((m) => {
		let [S] = m.split(":");
		return S === x;
	}) ?? !1), R = C.components[A.data.type]?.label ?? A.data.type.toString();
	return /* @__PURE__ */ jsxs("li", {
		className: getClassNameLayer({
			isSelected: k,
			isHovering: I,
			containsZone: P,
			childIsSelected: L
		}),
		children: [/* @__PURE__ */ jsx("div", {
			className: getClassNameLayer("inner"),
			children: /* @__PURE__ */ jsxs("button", {
				type: "button",
				className: getClassNameLayer("clickable"),
				onClick: () => {
					if (k) {
						O(null);
						return;
					}
					let C = getFrame(), T = C?.querySelector(`[data-puck-component="${x}"]`);
					if (!T) {
						O({
							index: m,
							zone: S
						});
						return;
					}
					scrollIntoView(T), onScrollEnd(C, () => {
						O({
							index: m,
							zone: S
						});
					});
				},
				onMouseEnter: (m) => {
					m.stopPropagation(), F.setState({ hoveringComponent: x });
				},
				onMouseLeave: (m) => {
					m.stopPropagation(), F.setState({ hoveringComponent: null });
				},
				children: [P && /* @__PURE__ */ jsx("div", {
					className: getClassNameLayer("chevron"),
					title: k ? "Collapse" : "Expand",
					children: /* @__PURE__ */ jsx(ChevronDown, { size: "12" })
				}), /* @__PURE__ */ jsxs("div", {
					className: getClassNameLayer("title"),
					children: [/* @__PURE__ */ jsx("div", {
						className: getClassNameLayer("icon"),
						children: A.data.type === "Text" || A.data.type === "Heading" ? /* @__PURE__ */ jsx(Type, { size: "16" }) : /* @__PURE__ */ jsx(LayoutGrid, { size: "16" })
					}), /* @__PURE__ */ jsx("div", {
						className: getClassNameLayer("name"),
						children: R
					})]
				})]
			})
		}), P && j.map((m) => /* @__PURE__ */ jsx("div", {
			className: getClassNameLayer("zones"),
			children: /* @__PURE__ */ jsx(LayerTree, { zoneCompound: m })
		}, m))]
	});
}, LayerTree = ({ label: m, zoneCompound: x }) => {
	let S = useAppStore((S) => {
		if (m) return m;
		if (x === rootDroppableId) return;
		let [C, T] = x.split(":"), D = S.state.indexes.nodes[C]?.data.type;
		return (D && D !== "root" ? S.config.components[D] : S.config.root)?.fields?.[T]?.label ?? T;
	}), C = useAppStore(useShallow((m) => x ? m.state.indexes.zones[x]?.contentIds ?? [] : []));
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [S && /* @__PURE__ */ jsxs("div", {
		className: getClassName24("zoneTitle"),
		children: [/* @__PURE__ */ jsx("div", {
			className: getClassName24("zoneIcon"),
			children: /* @__PURE__ */ jsx(Layers, { size: "16" })
		}), S]
	}), /* @__PURE__ */ jsxs("ul", {
		className: getClassName24(),
		children: [C.length === 0 && /* @__PURE__ */ jsx("div", {
			className: getClassName24("helper"),
			children: "No items"
		}), C.map((m, S) => /* @__PURE__ */ jsx(Layer, {
			index: S,
			itemId: m,
			zoneCompound: x
		}, m))]
	})] });
};
init_react_import();
var findZonesForArea = (m, x) => Object.keys(m.indexes.zones).filter((m) => m.split(":")[0] === x), Outline = () => {
	let m = useAppStore((m) => m.overrides.outline), x = useAppStore(useShallow((m) => findZonesForArea(m.state, "root")));
	return /* @__PURE__ */ jsx(useMemo(() => m || "div", [m]), { children: x.map((m) => /* @__PURE__ */ jsx(LayerTree, {
		label: x.length === 1 ? "" : m.split(":")[1],
		zoneCompound: m
	}, m)) });
};
init_react_import(), init_react_import(), init_react_import();
var styles_module_default20 = {
	ViewportControls: "_ViewportControls_gejzr_1",
	"ViewportControls-divider": "_ViewportControls-divider_gejzr_15",
	"ViewportControls-zoomSelect": "_ViewportControls-zoomSelect_gejzr_21",
	"ViewportButton--isActive": "_ViewportButton--isActive_gejzr_38",
	"ViewportButton-inner": "_ViewportButton-inner_gejzr_38"
}, icons = {
	Smartphone: /* @__PURE__ */ jsx(Smartphone, { size: 16 }),
	Tablet: /* @__PURE__ */ jsx(Tablet, { size: 16 }),
	Monitor: /* @__PURE__ */ jsx(Monitor, { size: 16 })
}, getClassName25 = get_class_name_factory_default("ViewportControls", styles_module_default20), getClassNameButton = get_class_name_factory_default("ViewportButton", styles_module_default20), ViewportButton = ({ children: m, height: x = "auto", title: S, width: C, onClick: T }) => {
	let D = useAppStore((m) => m.state.ui.viewports), [O, k] = useState(!1);
	return useEffect(() => {
		k(C === D.current.width);
	}, [C, D.current.width]), /* @__PURE__ */ jsx("span", {
		className: getClassNameButton({ isActive: O }),
		children: /* @__PURE__ */ jsx(IconButton, {
			type: "button",
			title: S,
			disabled: O,
			onClick: (m) => {
				m.stopPropagation(), T({
					width: C,
					height: x
				});
			},
			children: /* @__PURE__ */ jsx("span", {
				className: getClassNameButton("inner"),
				children: m
			})
		})
	});
}, defaultZoomOptions = [
	{
		label: "25%",
		value: .25
	},
	{
		label: "50%",
		value: .5
	},
	{
		label: "75%",
		value: .75
	},
	{
		label: "100%",
		value: 1
	},
	{
		label: "125%",
		value: 1.25
	},
	{
		label: "150%",
		value: 1.5
	},
	{
		label: "200%",
		value: 2
	}
], ViewportControls = ({ autoZoom: m, zoom: x, onViewportChange: S, onZoom: C }) => {
	let T = useAppStore((m) => m.viewports), D = defaultZoomOptions.find((x) => x.value === m), O = useMemo(() => [...defaultZoomOptions, ...D ? [] : [{
		value: m,
		label: `${(m * 100).toFixed(0)}% (Auto)`
	}]].filter((x) => x.value <= m).sort((m, x) => m.value > x.value ? 1 : -1), [m]);
	return /* @__PURE__ */ jsxs("div", {
		className: getClassName25(),
		children: [
			T.map((m, x) => /* @__PURE__ */ jsx(ViewportButton, {
				height: m.height,
				width: m.width,
				title: m.label ? `Switch to ${m.label} viewport` : "Switch viewport",
				onClick: S,
				children: typeof m.icon == "string" ? icons[m.icon] || m.icon : m.icon || icons.Smartphone
			}, x)),
			/* @__PURE__ */ jsx("div", { className: getClassName25("divider") }),
			/* @__PURE__ */ jsx(IconButton, {
				type: "button",
				title: "Zoom viewport out",
				disabled: x <= O[0]?.value,
				onClick: (m) => {
					m.stopPropagation(), C(O[Math.max(O.findIndex((m) => m.value === x) - 1, 0)].value);
				},
				children: /* @__PURE__ */ jsx(ZoomOut, { size: 16 })
			}),
			/* @__PURE__ */ jsx(IconButton, {
				type: "button",
				title: "Zoom viewport in",
				disabled: x >= O[O.length - 1]?.value,
				onClick: (m) => {
					m.stopPropagation(), C(O[Math.min(O.findIndex((m) => m.value === x) + 1, O.length - 1)].value);
				},
				children: /* @__PURE__ */ jsx(ZoomIn, { size: 16 })
			}),
			/* @__PURE__ */ jsx("div", { className: getClassName25("divider") }),
			/* @__PURE__ */ jsx("select", {
				className: getClassName25("zoomSelect"),
				value: x.toString(),
				onClick: (m) => {
					m.stopPropagation();
				},
				onChange: (m) => {
					C(parseFloat(m.currentTarget.value));
				},
				children: O.map((m) => /* @__PURE__ */ jsx("option", {
					value: m.value,
					label: m.label
				}, m.label))
			})
		]
	});
};
init_react_import();
var styles_module_default21 = {
	PuckCanvas: "_PuckCanvas_18jay_1",
	"PuckCanvas-controls": "_PuckCanvas-controls_18jay_16",
	"PuckCanvas-inner": "_PuckCanvas-inner_18jay_21",
	"PuckCanvas-root": "_PuckCanvas-root_18jay_30",
	"PuckCanvas--ready": "_PuckCanvas--ready_18jay_55",
	"PuckCanvas-loader": "_PuckCanvas-loader_18jay_60",
	"PuckCanvas--showLoader": "_PuckCanvas--showLoader_18jay_70"
};
init_react_import();
var FrameContext = createContext(null), FrameProvider = ({ children: m }) => {
	let x = useRef(null), S = useMemo(() => ({ frameRef: x }), []);
	return /* @__PURE__ */ jsx(FrameContext.Provider, {
		value: S,
		children: m
	});
}, useCanvasFrame = () => {
	let m = useContext(FrameContext);
	if (m === null) throw Error("useCanvasFrame must be used within a FrameProvider");
	return m;
}, getClassName26 = get_class_name_factory_default("PuckCanvas", styles_module_default21), ZOOM_ON_CHANGE = !0, TRANSITION_DURATION = 150, Canvas = () => {
	let { frameRef: m } = useCanvasFrame(), x = useResetAutoZoom(m), { dispatch: S, overrides: C, setUi: T, zoomConfig: D, setZoomConfig: O, status: k, iframe: A } = useAppStore(useShallow((m) => ({
		dispatch: m.dispatch,
		overrides: m.overrides,
		setUi: m.setUi,
		zoomConfig: m.zoomConfig,
		setZoomConfig: m.setZoomConfig,
		status: m.status,
		iframe: m.iframe
	}))), { leftSideBarVisible: j, rightSideBarVisible: N, leftSideBarWidth: F, rightSideBarWidth: I, viewports: L } = useAppStore(useShallow((m) => ({
		leftSideBarVisible: m.state.ui.leftSideBarVisible,
		rightSideBarVisible: m.state.ui.rightSideBarVisible,
		leftSideBarWidth: m.state.ui.leftSideBarWidth,
		rightSideBarWidth: m.state.ui.rightSideBarWidth,
		viewports: m.state.ui.viewports
	}))), [R, U] = useState(!1), q = useRef(!1), J = useMemo(() => ({ children: m }) => /* @__PURE__ */ jsx(Fragment$1, { children: m }), []), Y = useMemo(() => C.preview || J, [C]), X = useCallback(() => {
		if (m.current) {
			let x = m.current, S = getBox(x);
			return {
				width: S.contentBox.width,
				height: S.contentBox.height
			};
		}
		return {
			width: 0,
			height: 0
		};
	}, [m]);
	useEffect(() => {
		x();
	}, [
		m,
		j,
		N,
		F,
		I,
		L
	]), useEffect(() => {
		let { height: m } = X();
		L.current.height === "auto" && O(__spreadProps(__spreadValues({}, D), { rootHeight: m / D.zoom }));
	}, [
		D.zoom,
		X,
		O
	]), useEffect(() => {
		ZOOM_ON_CHANGE && x();
	}, [L.current.width, L]), useEffect(() => {
		if (!m.current) return;
		let S = new ResizeObserver(() => {
			q.current || x();
		});
		return S.observe(m.current), () => {
			S.disconnect();
		};
	}, [m.current]);
	let [Z, sH] = useState(!1);
	return useEffect(() => {
		setTimeout(() => {
			sH(!0);
		}, 500);
	}, []), /* @__PURE__ */ jsxs("div", {
		className: getClassName26({
			ready: k === "READY" || !A.enabled || !A.waitForStyles,
			showLoader: Z
		}),
		onClick: (m) => {
			let x = m.target;
			!x.hasAttribute("data-puck-component") && !x.hasAttribute("data-puck-dropzone") && S({
				type: "setUi",
				ui: { itemSelector: null },
				recordHistory: !0
			});
		},
		children: [L.controlsVisible && A.enabled && /* @__PURE__ */ jsx("div", {
			className: getClassName26("controls"),
			children: /* @__PURE__ */ jsx(ViewportControls, {
				autoZoom: D.autoZoom,
				zoom: D.zoom,
				onViewportChange: (m) => {
					U(!0), q.current = !0;
					let S = __spreadProps(__spreadValues({}, m), {
						height: m.height || "auto",
						zoom: D.zoom
					});
					T({ viewports: __spreadProps(__spreadValues({}, L), { current: S }) }), ZOOM_ON_CHANGE && x({ viewports: __spreadProps(__spreadValues({}, L), { current: S }) });
				},
				onZoom: (m) => {
					U(!0), q.current = !0, O(__spreadProps(__spreadValues({}, D), { zoom: m }));
				}
			})
		}), /* @__PURE__ */ jsxs("div", {
			className: getClassName26("inner"),
			ref: m,
			children: [/* @__PURE__ */ jsx("div", {
				className: getClassName26("root"),
				style: {
					width: A.enabled ? L.current.width : "100%",
					height: D.rootHeight,
					transform: A.enabled ? `scale(${D.zoom})` : void 0,
					transition: R ? `width ${TRANSITION_DURATION}ms ease-out, height ${TRANSITION_DURATION}ms ease-out, transform ${TRANSITION_DURATION}ms ease-out` : "",
					overflow: A.enabled ? void 0 : "auto"
				},
				suppressHydrationWarning: !0,
				id: "puck-canvas-root",
				onTransitionEnd: () => {
					U(!1), q.current = !1;
				},
				children: /* @__PURE__ */ jsx(Y, { children: /* @__PURE__ */ jsx(Preview2, {}) })
			}), /* @__PURE__ */ jsx("div", {
				className: getClassName26("loader"),
				children: /* @__PURE__ */ jsx(Loader, { size: 24 })
			})]
		})]
	});
};
init_react_import(), init_react_import();
var loadOverrides = ({ overrides: m, plugins: x }) => {
	let S = __spreadValues({}, m);
	return x?.forEach((m) => {
		m.overrides && Object.keys(m.overrides).forEach((x) => {
			let C = x;
			if (!m.overrides?.[C]) return;
			if (C === "fieldTypes") {
				let x = m.overrides.fieldTypes;
				Object.keys(x).forEach((m) => {
					S.fieldTypes = S.fieldTypes || {};
					let C = S.fieldTypes[m], T = (S) => x[m](__spreadProps(__spreadValues({}, S), { children: C ? C(S) : S.children }));
					S.fieldTypes[m] = T;
				});
				return;
			}
			let T = S[C];
			S[C] = (x) => m.overrides[C](__spreadProps(__spreadValues({}, x), { children: T ? T(x) : x.children }));
		});
	}), S;
}, useLoadedOverrides = ({ overrides: m, plugins: x }) => useMemo(() => loadOverrides({
	overrides: m,
	plugins: x
}), [x, m]);
init_react_import();
var DefaultOverride = ({ children: m }) => /* @__PURE__ */ jsx(Fragment$1, { children: m });
init_react_import();
var styles = "", useInjectStyleSheet = (m, x) => {
	let [S, C] = useState();
	return useEffect(() => {
		C(document.createElement("style"));
	}, []), useEffect(() => {
		var C;
		!S || typeof window > "u" || (S.innerHTML = m, x && ((C = getFrame()?.head) == null || C.appendChild(S)), document.head.appendChild(S));
	}, [x, S]), S;
}, useInjectGlobalCss = (m) => useInjectStyleSheet(styles, m);
init_react_import();
var usePreviewModeHotkeys = () => {
	let m = useAppStoreApi(), x = useCallback(() => {
		let x = m.getState().dispatch;
		x({
			type: "setUi",
			ui: (m) => ({ previewMode: m.previewMode === "edit" ? "interactive" : "edit" })
		});
	}, [m]);
	useHotkey({
		meta: !0,
		i: !0
	}, x), useHotkey({
		ctrl: !0,
		i: !0
	}, x);
};
init_react_import(), init_react_import(), init_react_import();
var getClassName27 = get_class_name_factory_default("MenuBar", {
	MenuBar: "_MenuBar_8pf8c_1",
	"MenuBar--menuOpen": "_MenuBar--menuOpen_8pf8c_14",
	"MenuBar-inner": "_MenuBar-inner_8pf8c_29",
	"MenuBar-history": "_MenuBar-history_8pf8c_45"
});
function MenuBar({ menuOpen: m = !1, renderHeaderActions: x, setMenuOpen: S }) {
	let C = useAppStore((m) => m.history.back), T = useAppStore((m) => m.history.forward), D = useAppStore((m) => m.history.hasFuture()), O = useAppStore((m) => m.history.hasPast());
	return /* @__PURE__ */ jsx("div", {
		className: getClassName27({ menuOpen: m }),
		onClick: (m) => {
			let x = m.target;
			window.matchMedia("(min-width: 638px)").matches || x.tagName === "A" && x.getAttribute("href")?.startsWith("#") && S(!1);
		},
		children: /* @__PURE__ */ jsxs("div", {
			className: getClassName27("inner"),
			children: [/* @__PURE__ */ jsxs("div", {
				className: getClassName27("history"),
				children: [/* @__PURE__ */ jsx(IconButton, {
					type: "button",
					title: "undo",
					disabled: !O,
					onClick: C,
					children: /* @__PURE__ */ jsx(Undo2, { size: 21 })
				}), /* @__PURE__ */ jsx(IconButton, {
					type: "button",
					title: "redo",
					disabled: !D,
					onClick: T,
					children: /* @__PURE__ */ jsx(Redo2, { size: 21 })
				})]
			}), /* @__PURE__ */ jsx(Fragment$1, { children: x && x() })]
		})
	});
}
init_react_import();
var getClassName28 = get_class_name_factory_default("PuckHeader", {
	PuckHeader: "_PuckHeader_15xnq_1",
	"PuckHeader-inner": "_PuckHeader-inner_15xnq_10",
	"PuckHeader-toggle": "_PuckHeader-toggle_15xnq_20",
	"PuckHeader--rightSideBarVisible": "_PuckHeader--rightSideBarVisible_15xnq_27",
	"PuckHeader-rightSideBarToggle": "_PuckHeader-rightSideBarToggle_15xnq_27",
	"PuckHeader--leftSideBarVisible": "_PuckHeader--leftSideBarVisible_15xnq_28",
	"PuckHeader-leftSideBarToggle": "_PuckHeader-leftSideBarToggle_15xnq_28",
	"PuckHeader-title": "_PuckHeader-title_15xnq_32",
	"PuckHeader-path": "_PuckHeader-path_15xnq_36",
	"PuckHeader-tools": "_PuckHeader-tools_15xnq_43",
	"PuckHeader-menuButton": "_PuckHeader-menuButton_15xnq_49",
	"PuckHeader--menuOpen": "_PuckHeader--menuOpen_15xnq_54"
}), Header = memo(() => {
	let { onPublish: m, renderHeader: x, renderHeaderActions: S, headerTitle: C, headerPath: T, iframe: D } = usePropsContext(), O = useAppStore((m) => m.dispatch), k = useAppStoreApi(), A = useMemo(() => x ? (console.warn("`renderHeader` is deprecated. Please use `overrides.header` and the `usePuck` hook instead"), (m) => {
		var S = m, { actions: C } = S, T = __objRest(S, ["actions"]);
		let D = x, k = useAppStore((m) => m.state);
		return /* @__PURE__ */ jsx(D, __spreadProps(__spreadValues({}, T), {
			dispatch: O,
			state: k,
			children: C
		}));
	}) : DefaultOverride, [x]), j = useMemo(() => S ? (console.warn("`renderHeaderActions` is deprecated. Please use `overrides.headerActions` and the `usePuck` hook instead."), (m) => {
		let x = S, C = useAppStore((m) => m.state);
		return /* @__PURE__ */ jsx(x, __spreadProps(__spreadValues({}, m), {
			dispatch: O,
			state: C
		}));
	}) : DefaultOverride, [S]), N = useAppStore((m) => m.overrides.header || A), P = useAppStore((m) => m.overrides.headerActions || j), [F, I] = useState(!1), L = useAppStore((m) => (m.state.indexes.nodes.root?.data).props.title ?? ""), R = useAppStore((m) => m.state.ui.leftSideBarVisible), B = useAppStore((m) => m.state.ui.rightSideBarVisible), U = useCallback((m) => {
		let x = window.matchMedia("(min-width: 638px)").matches, S = m === "left" ? R : B, C = m === "left" ? "rightSideBarVisible" : "leftSideBarVisible";
		O({
			type: "setUi",
			ui: __spreadValues({ [`${m}SideBarVisible`]: !S }, x ? {} : { [C]: !1 })
		});
	}, [
		O,
		R,
		B
	]);
	return /* @__PURE__ */ jsx(N, {
		actions: /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(P, { children: /* @__PURE__ */ jsx(Button, {
			onClick: () => {
				let x = k.getState().state.data;
				m && m(x);
			},
			icon: /* @__PURE__ */ jsx(Globe, { size: "14px" }),
			children: "Publish"
		}) }) }),
		children: /* @__PURE__ */ jsx("header", {
			className: getClassName28({
				leftSideBarVisible: R,
				rightSideBarVisible: B
			}),
			children: /* @__PURE__ */ jsxs("div", {
				className: getClassName28("inner"),
				children: [
					/* @__PURE__ */ jsxs("div", {
						className: getClassName28("toggle"),
						children: [/* @__PURE__ */ jsx("div", {
							className: getClassName28("leftSideBarToggle"),
							children: /* @__PURE__ */ jsx(IconButton, {
								type: "button",
								onClick: () => {
									U("left");
								},
								title: "Toggle left sidebar",
								children: /* @__PURE__ */ jsx(PanelLeft, { focusable: "false" })
							})
						}), /* @__PURE__ */ jsx("div", {
							className: getClassName28("rightSideBarToggle"),
							children: /* @__PURE__ */ jsx(IconButton, {
								type: "button",
								onClick: () => {
									U("right");
								},
								title: "Toggle right sidebar",
								children: /* @__PURE__ */ jsx(PanelRight, { focusable: "false" })
							})
						})]
					}),
					/* @__PURE__ */ jsx("div", {
						className: getClassName28("title"),
						children: /* @__PURE__ */ jsxs(Heading, {
							rank: "2",
							size: "xs",
							children: [C || L || "Page", T && /* @__PURE__ */ jsxs(Fragment$1, { children: [" ", /* @__PURE__ */ jsx("code", {
								className: getClassName28("path"),
								children: T
							})] })]
						})
					}),
					/* @__PURE__ */ jsxs("div", {
						className: getClassName28("tools"),
						children: [/* @__PURE__ */ jsx("div", {
							className: getClassName28("menuButton"),
							children: /* @__PURE__ */ jsx(IconButton, {
								type: "button",
								onClick: () => I(!F),
								title: "Toggle menu bar",
								children: jsx(F ? ChevronUp : ChevronDown, { focusable: "false" })
							})
						}), /* @__PURE__ */ jsx(MenuBar, {
							dispatch: O,
							onPublish: m,
							menuOpen: F,
							renderHeaderActions: () => /* @__PURE__ */ jsx(P, { children: /* @__PURE__ */ jsx(Button, {
								onClick: () => {
									let x = k.getState().state.data;
									m && m(x);
								},
								icon: /* @__PURE__ */ jsx(Globe, { size: "14px" }),
								children: "Publish"
							}) }),
							setMenuOpen: I
						})]
					})
				]
			})
		})
	});
});
init_react_import(), init_react_import(), init_react_import();
var getClassName29 = get_class_name_factory_default("ResizeHandle", {
	ResizeHandle: "_ResizeHandle_144bf_2",
	"ResizeHandle--left": "_ResizeHandle--left_144bf_16",
	"ResizeHandle--right": "_ResizeHandle--right_144bf_20"
}), ResizeHandle = ({ position: m, sidebarRef: x, onResize: S, onResizeEnd: C }) => {
	let { frameRef: T } = useCanvasFrame(), D = useResetAutoZoom(T), O = useRef(null), k = useRef(!1), A = useRef(0), j = useRef(0), N = useCallback((x) => {
		if (!k.current) return;
		let C = x.clientX - A.current, T = m === "left" ? j.current + C : j.current - C;
		S(Math.max(192, T)), x.preventDefault();
	}, [S, m]), P = useCallback(() => {
		if (!k.current) return;
		k.current = !1, document.body.style.cursor = "", document.body.style.userSelect = "";
		let m = document.getElementById("resize-overlay");
		m && document.body.removeChild(m), document.removeEventListener("mousemove", N), document.removeEventListener("mouseup", P), C(x.current?.getBoundingClientRect().width || 0), D();
	}, [C]), F = useCallback((m) => {
		k.current = !0, A.current = m.clientX, j.current = x.current?.getBoundingClientRect().width || 0, document.body.style.cursor = "col-resize", document.body.style.userSelect = "none";
		let S = document.createElement("div");
		S.id = "resize-overlay", S.setAttribute("data-resize-overlay", ""), document.body.appendChild(S), document.addEventListener("mousemove", N), document.addEventListener("mouseup", P), m.preventDefault();
	}, [
		m,
		N,
		P
	]);
	return /* @__PURE__ */ jsx("div", {
		ref: O,
		className: getClassName29({ [m]: !0 }),
		onMouseDown: F
	});
};
init_react_import();
var getClassName30 = get_class_name_factory_default("Sidebar", {
	Sidebar: "_Sidebar_1xksb_1",
	"Sidebar--left": "_Sidebar--left_1xksb_8",
	"Sidebar--right": "_Sidebar--right_1xksb_14",
	"Sidebar-resizeHandle": "_Sidebar-resizeHandle_1xksb_20"
}), Sidebar = ({ position: m, sidebarRef: x, isVisible: S, onResize: C, onResizeEnd: T, children: D }) => S ? /* @__PURE__ */ jsxs(Fragment$1, { children: [/* @__PURE__ */ jsx("div", {
	ref: x,
	className: getClassName30({ [m]: !0 }),
	children: D
}), /* @__PURE__ */ jsx("div", {
	className: `${getClassName30("resizeHandle")}`,
	children: /* @__PURE__ */ jsx(ResizeHandle, {
		position: m,
		sidebarRef: x,
		onResize: C,
		onResizeEnd: T
	})
})] }) : null;
init_react_import();
function useSidebarResize(m, x) {
	let [S, C] = useState(null), T = useRef(null), D = useAppStore((x) => m === "left" ? x.state.ui.leftSideBarWidth : x.state.ui.rightSideBarWidth);
	return useEffect(() => {
		if (typeof window < "u" && !D) try {
			let S = localStorage.getItem("puck-sidebar-widths");
			if (S) {
				let C = JSON.parse(S)[m];
				C && x({
					type: "setUi",
					ui: { [m === "left" ? "leftSideBarWidth" : "rightSideBarWidth"]: C }
				});
			}
		} catch (x) {
			console.error(`Failed to load ${m} sidebar width from localStorage`, x);
		}
	}, [
		x,
		m,
		D
	]), useEffect(() => {
		D !== void 0 && C(D);
	}, [D]), {
		width: S,
		setWidth: C,
		sidebarRef: T,
		handleResizeEnd: useCallback((S) => {
			x({
				type: "setUi",
				ui: { [m === "left" ? "leftSideBarWidth" : "rightSideBarWidth"]: S }
			});
			let C = {};
			try {
				let m = localStorage.getItem("puck-sidebar-widths");
				C = m ? JSON.parse(m) : {};
			} catch (x) {
				console.error(`Failed to save ${m} sidebar width to localStorage`, x);
			} finally {
				localStorage.setItem("puck-sidebar-widths", JSON.stringify(__spreadProps(__spreadValues({}, C), { [m]: S })));
			}
			window.dispatchEvent(new CustomEvent("viewportchange", {
				bubbles: !0,
				cancelable: !1
			}));
		}, [x, m])
	};
}
var getClassName31 = get_class_name_factory_default("Puck", styles_module_default15), getLayoutClassName = get_class_name_factory_default("PuckLayout", styles_module_default15), FieldSideBar = () => /* @__PURE__ */ jsx(SidebarSection, {
	noPadding: !0,
	noBorderTop: !0,
	showBreadcrumbs: !0,
	title: useAppStore((m) => m.selectedItem ? m.config.components[m.selectedItem.type]?.label ?? m.selectedItem.type.toString() : "Page"),
	children: /* @__PURE__ */ jsx(Fields, {})
}), propsContext = createContext({});
function PropsProvider(m) {
	return /* @__PURE__ */ jsx(propsContext.Provider, {
		value: m,
		children: m.children
	});
}
var usePropsContext = () => useContext(propsContext);
function PuckProvider({ children: m }) {
	let { config: x, data: S, ui: C, onChange: T, permissions: D = {}, plugins: O, overrides: k, viewports: A = defaultViewports, iframe: j, initialHistory: N, metadata: F, onAction: I, fieldTransforms: L } = usePropsContext(), R = useMemo(() => __spreadValues({
		enabled: !0,
		waitForStyles: !0
	}, j), [j]), [U] = useState(() => {
		let m = __spreadValues(__spreadValues({}, defaultAppState.ui), C), T = {};
		if (typeof window < "u") {
			window.matchMedia("(max-width: 638px)").matches && (T = __spreadProps(__spreadValues({}, T), {
				leftSideBarVisible: !1,
				rightSideBarVisible: !1
			}));
			let x = window.innerWidth, S = Object.entries(A).map(([m, S]) => ({
				key: m,
				diff: Math.abs(x - S.width)
			})).sort((m, x) => m.diff > x.diff ? 1 : -1)[0].key;
			R.enabled && (T = __spreadProps(__spreadValues({}, T), { viewports: __spreadProps(__spreadValues({}, m.viewports), { current: __spreadProps(__spreadValues({}, m.viewports.current), {
				height: C?.viewports?.current?.height || A[S]?.height || "auto",
				width: C?.viewports?.current?.width || A[S]?.width
			}) }) }));
		}
		Object.keys(S?.root || {}).length > 0 && !S?.root?.props && console.warn("Warning: Defining props on `root` is deprecated. Please use `root.props`, or republish this page to migrate automatically.");
		let D = S?.root?.props || S?.root || {}, O = __spreadValues(__spreadValues({}, x.root?.defaultProps), D);
		return walkAppState(__spreadProps(__spreadValues({}, defaultAppState), {
			data: __spreadProps(__spreadValues({}, S), {
				root: __spreadProps(__spreadValues({}, S?.root), { props: O }),
				content: S.content || []
			}),
			ui: __spreadProps(__spreadValues(__spreadValues({}, m), T), { componentList: x.categories ? Object.entries(x.categories).reduce((m, [x, S]) => __spreadProps(__spreadValues({}, m), { [x]: {
				title: S.title,
				components: S.components,
				expanded: S.defaultExpanded,
				visible: S.visible
			} }), {}) : {} })
		}), x);
	}), { appendData: W = !0 } = N || {}, [K] = useState([...N?.histories || [], ...W ? [{ state: U }] : []].map((m) => {
		let S = __spreadValues(__spreadValues({}, U), m.state);
		return m.state.indexes || (S = walkAppState(S, x)), __spreadProps(__spreadValues({}, m), { state: S });
	})), q = N?.index || K.length - 1, J = K[q].state, Y = useLoadedOverrides({
		overrides: k,
		plugins: O
	}), X = useMemo(() => __spreadValues(__spreadValues({}, (O || []).reduce((m, x) => __spreadValues(__spreadValues({}, m), x.fieldTransforms), {})), L), [L, O]), Z = useCallback((m) => ({
		state: m,
		config: x,
		plugins: O || [],
		overrides: Y,
		viewports: A,
		iframe: R,
		onAction: I,
		metadata: F,
		fieldTransforms: X
	}), [
		J,
		x,
		O,
		Y,
		A,
		R,
		I,
		F,
		X
	]), [sH] = useState(() => createAppStore(Z(J)));
	useEffect(() => {
		process.env.NODE_ENV !== "production" && (window.__PUCK_INTERNAL_DO_NOT_USE = { appStore: sH });
	}, [sH]), useEffect(() => {
		let m = sH.getState().state;
		sH.setState(__spreadValues({}, Z(m)));
	}, [
		x,
		O,
		Y,
		A,
		R,
		I,
		F
	]), useRegisterHistorySlice(sH, {
		histories: K,
		index: q,
		initialAppState: J
	});
	let Q = useRef(null);
	useEffect(() => {
		sH.subscribe((m) => m.state.data, (m) => {
			if (T) {
				if ((0, import_fast_deep_equal.default)(m, Q.current)) return;
				T(m), Q.current = m;
			}
		});
	}, []), useRegisterPermissionsSlice(sH, D);
	let cH = useRegisterUsePuckStore(sH);
	return useEffect(() => {
		let { resolveAndCommitData: m } = sH.getState();
		m();
	}, []), /* @__PURE__ */ jsx(appStoreContext.Provider, {
		value: sH,
		children: /* @__PURE__ */ jsx(UsePuckStoreContext.Provider, {
			value: cH,
			children: m
		})
	});
}
function PuckLayout({ children: m }) {
	let { iframe: x, dnd: S, initialHistory: C } = usePropsContext(), T = useMemo(() => __spreadValues({
		enabled: !0,
		waitForStyles: !0
	}, x), [x]);
	useInjectGlobalCss(T.enabled);
	let D = useAppStore((m) => m.dispatch), O = useAppStore((m) => m.state.ui.leftSideBarVisible), k = useAppStore((m) => m.state.ui.rightSideBarVisible), { width: A, setWidth: j, sidebarRef: M, handleResizeEnd: N } = useSidebarResize("left", D), { width: F, setWidth: I, sidebarRef: L, handleResizeEnd: R } = useSidebarResize("right", D);
	useEffect(() => {
		window.matchMedia("(min-width: 638px)").matches || D({
			type: "setUi",
			ui: {
				leftSideBarVisible: !1,
				rightSideBarVisible: !1
			}
		});
		let m = () => {
			window.matchMedia("(min-width: 638px)").matches || D({
				type: "setUi",
				ui: (m) => __spreadValues(__spreadValues({}, m), m.rightSideBarVisible ? { leftSideBarVisible: !1 } : {})
			});
		};
		return window.addEventListener("resize", m), () => {
			window.removeEventListener("resize", m);
		};
	}, []);
	let B = useAppStore((m) => m.overrides), U = useMemo(() => B.puck || DefaultOverride, [B]), [W, q] = useState(!1);
	useEffect(() => {
		q(!0);
	}, []);
	let J = useAppStore((m) => m.status === "READY");
	useMonitorHotkeys(), useEffect(() => {
		if (J && T.enabled) {
			let m = getFrame();
			if (m) return monitorHotkeys(m);
		}
	}, [J, T.enabled]), usePreviewModeHotkeys();
	let Y = {};
	return A && (Y["--puck-user-left-side-bar-width"] = `${A}px`), F && (Y["--puck-user-right-side-bar-width"] = `${F}px`), /* @__PURE__ */ jsxs("div", {
		className: `Puck ${getClassName31()}`,
		children: [/* @__PURE__ */ jsx(DragDropContext, {
			disableAutoScroll: S?.disableAutoScroll,
			children: /* @__PURE__ */ jsx(U, { children: m || /* @__PURE__ */ jsx(FrameProvider, { children: /* @__PURE__ */ jsx("div", {
				className: getLayoutClassName({
					leftSideBarVisible: O,
					mounted: W,
					rightSideBarVisible: k
				}),
				children: /* @__PURE__ */ jsxs("div", {
					className: getLayoutClassName("inner"),
					style: Y,
					children: [
						/* @__PURE__ */ jsx(Header, {}),
						/* @__PURE__ */ jsxs(Sidebar, {
							position: "left",
							sidebarRef: M,
							isVisible: O,
							onResize: j,
							onResizeEnd: N,
							children: [/* @__PURE__ */ jsx(SidebarSection, {
								title: "Components",
								noBorderTop: !0,
								children: /* @__PURE__ */ jsx(Components, {})
							}), /* @__PURE__ */ jsx(SidebarSection, {
								title: "Outline",
								children: /* @__PURE__ */ jsx(Outline, {})
							})]
						}),
						/* @__PURE__ */ jsx(Canvas, {}),
						/* @__PURE__ */ jsx(Sidebar, {
							position: "right",
							sidebarRef: L,
							isVisible: k,
							onResize: I,
							onResizeEnd: R,
							children: /* @__PURE__ */ jsx(FieldSideBar, {})
						})
					]
				})
			}) }) })
		}), /* @__PURE__ */ jsx("div", {
			id: "puck-portal-root",
			className: getClassName31("portal")
		})]
	});
}
function Puck(m) {
	return /* @__PURE__ */ jsx(PropsProvider, __spreadProps(__spreadValues({}, m), { children: /* @__PURE__ */ jsx(PuckProvider, __spreadProps(__spreadValues({}, m), { children: /* @__PURE__ */ jsx(PuckLayout, __spreadValues({}, m)) })) }));
}
Puck.Components = Components, Puck.Fields = Fields, Puck.Outline = Outline, Puck.Preview = Preview2, init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import(), init_react_import();
function ColorPickerField({ name: m, label: x, value: S = "#000000", onChange: C }) {
	return /* @__PURE__ */ jsxs("div", { children: [/* @__PURE__ */ jsx(FieldLabel, { label: x }), /* @__PURE__ */ jsxs("div", {
		style: {
			display: "flex",
			alignItems: "center",
			gap: "8px",
			marginTop: "4px"
		},
		children: [/* @__PURE__ */ jsx("input", {
			type: "color",
			id: m,
			value: S,
			onChange: (m) => C(m.target.value),
			style: {
				width: "40px",
				height: "40px",
				border: "1px solid #e5e7eb",
				borderRadius: "4px",
				cursor: "pointer"
			}
		}), /* @__PURE__ */ jsx("input", {
			type: "text",
			value: S,
			onChange: (m) => C(m.target.value),
			placeholder: "#000000",
			style: {
				flex: 1,
				padding: "8px",
				border: "1px solid #e5e7eb",
				borderRadius: "4px",
				fontSize: "14px"
			}
		})]
	})] });
}
const colorPickerField = {
	type: "custom",
	render: ({ name: m, value: x, onChange: S, field: C }) => /* @__PURE__ */ jsx(ColorPickerField, {
		name: m,
		label: C?.label ?? "",
		value: x,
		onChange: (m) => S(m)
	})
};
var LayoutGroupContext = createContext({});
function useConstant(m) {
	let x = useRef(null);
	return x.current === null && (x.current = m()), x.current;
}
var isBrowser$1 = typeof window < "u", useIsomorphicLayoutEffect$2 = isBrowser$1 ? useLayoutEffect : useEffect, PresenceContext = /* @__PURE__ */ createContext(null);
function addUniqueItem(m, x) {
	m.indexOf(x) === -1 && m.push(x);
}
function removeItem(m, x) {
	let S = m.indexOf(x);
	S > -1 && m.splice(S, 1);
}
var clamp$1 = (m, x, S) => S > x ? x : S < m ? m : S;
function formatErrorMessage(m, x) {
	return x ? `${m}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${x}` : m;
}
var warning = () => {}, invariant = () => {};
process.env.NODE_ENV !== "production" && (warning = (m, x, S) => {
	!m && typeof console < "u" && console.warn(formatErrorMessage(x, S));
}, invariant = (m, x, S) => {
	if (!m) throw Error(formatErrorMessage(x, S));
});
var MotionGlobalConfig = {}, isNumericalString = (m) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(m);
function isObject$3(m) {
	return typeof m == "object" && !!m;
}
var isZeroValueString = (m) => /^0[^.\s]+$/u.test(m);
/* @__NO_SIDE_EFFECTS__ */
function memo$1(m) {
	let x;
	return () => (x === void 0 && (x = m()), x);
}
var noop$1 = /* @__NO_SIDE_EFFECTS__ */ (m) => m, combineFunctions = (m, x) => (S) => x(m(S)), pipe = (...m) => m.reduce(combineFunctions), progress = /* @__NO_SIDE_EFFECTS__ */ (m, x, S) => {
	let C = x - m;
	return C === 0 ? 1 : (S - m) / C;
}, SubscriptionManager = class {
	constructor() {
		this.subscriptions = [];
	}
	add(m) {
		return addUniqueItem(this.subscriptions, m), () => removeItem(this.subscriptions, m);
	}
	notify(m, x, S) {
		let C = this.subscriptions.length;
		if (C) if (C === 1) this.subscriptions[0](m, x, S);
		else for (let T = 0; T < C; T++) {
			let C = this.subscriptions[T];
			C && C(m, x, S);
		}
	}
	getSize() {
		return this.subscriptions.length;
	}
	clear() {
		this.subscriptions.length = 0;
	}
}, secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (m) => m * 1e3, millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (m) => m / 1e3;
function velocityPerSecond(m, x) {
	return x ? m * (1e3 / x) : 0;
}
var warned = /* @__PURE__ */ new Set();
function warnOnce(m, x, S) {
	m || warned.has(x) || (console.warn(formatErrorMessage(x, S)), warned.add(x));
}
var calcBezier = (m, x, S) => (((1 - 3 * S + 3 * x) * m + (3 * S - 6 * x)) * m + 3 * x) * m, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(m, x, S, C, T) {
	let D, O, k = 0;
	do
		O = x + (S - x) / 2, D = calcBezier(O, C, T) - m, D > 0 ? S = O : x = O;
	while (Math.abs(D) > subdivisionPrecision && ++k < subdivisionMaxIterations);
	return O;
}
function cubicBezier(m, x, S, C) {
	if (m === x && S === C) return noop$1;
	let T = (x) => binarySubdivide(x, 0, 1, m, S);
	return (m) => m === 0 || m === 1 ? m : calcBezier(T(m), x, C);
}
var mirrorEasing = (m) => (x) => x <= .5 ? m(2 * x) / 2 : (2 - m(2 * (1 - x))) / 2, reverseEasing = (m) => (x) => 1 - m(1 - x), backOut = /* @__PURE__ */ cubicBezier(.33, 1.53, .69, .99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (m) => (m *= 2) < 1 ? .5 * backIn(m) : .5 * (2 - 2 ** (-10 * (m - 1))), circIn = (m) => 1 - Math.sin(Math.acos(m)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), easeIn = /* @__PURE__ */ cubicBezier(.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, .58, 1), easeInOut = /* @__PURE__ */ cubicBezier(.42, 0, .58, 1), isEasingArray = (m) => Array.isArray(m) && typeof m[0] != "number", isBezierDefinition = (m) => Array.isArray(m) && typeof m[0] == "number", easingLookup = {
	linear: noop$1,
	easeIn,
	easeInOut,
	easeOut,
	circIn,
	circInOut,
	circOut,
	backIn,
	backInOut,
	backOut,
	anticipate
}, isValidEasing = (m) => typeof m == "string", easingDefinitionToFunction = (m) => {
	if (isBezierDefinition(m)) {
		invariant(m.length === 4, "Cubic bezier arrays must contain four numerical values.", "cubic-bezier-length");
		let [x, S, C, T] = m;
		return cubicBezier(x, S, C, T);
	} else if (isValidEasing(m)) return invariant(easingLookup[m] !== void 0, `Invalid easing type '${m}'`, "invalid-easing-type"), easingLookup[m];
	return m;
}, stepsOrder = [
	"setup",
	"read",
	"resolveKeyframes",
	"preUpdate",
	"update",
	"preRender",
	"render",
	"postRender"
], statsBuffer = {
	value: null,
	addProjectionMetrics: null
};
function createRenderStep(m, x) {
	let S = /* @__PURE__ */ new Set(), C = /* @__PURE__ */ new Set(), T = !1, D = !1, O = /* @__PURE__ */ new WeakSet(), k = {
		delta: 0,
		timestamp: 0,
		isProcessing: !1
	}, A = 0;
	function j(x) {
		O.has(x) && (M.schedule(x), m()), A++, x(k);
	}
	let M = {
		schedule: (m, x = !1, D = !1) => {
			let k = D && T ? S : C;
			return x && O.add(m), k.has(m) || k.add(m), m;
		},
		cancel: (m) => {
			C.delete(m), O.delete(m);
		},
		process: (m) => {
			if (k = m, T) {
				D = !0;
				return;
			}
			T = !0, [S, C] = [C, S], S.forEach(j), x && statsBuffer.value && statsBuffer.value.frameloop[x].push(A), A = 0, S.clear(), T = !1, D && (D = !1, M.process(m));
		}
	};
	return M;
}
var maxElapsed = 40;
function createRenderBatcher(m, x) {
	let S = !1, C = !0, T = {
		delta: 0,
		timestamp: 0,
		isProcessing: !1
	}, D = () => S = !0, O = stepsOrder.reduce((m, S) => (m[S] = createRenderStep(D, x ? S : void 0), m), {}), { setup: k, read: A, resolveKeyframes: j, preUpdate: M, update: N, preRender: P, render: F, postRender: I } = O, L = () => {
		let D = MotionGlobalConfig.useManualTiming ? T.timestamp : performance.now();
		S = !1, MotionGlobalConfig.useManualTiming || (T.delta = C ? 1e3 / 60 : Math.max(Math.min(D - T.timestamp, maxElapsed), 1)), T.timestamp = D, T.isProcessing = !0, k.process(T), A.process(T), j.process(T), M.process(T), N.process(T), P.process(T), F.process(T), I.process(T), T.isProcessing = !1, S && x && (C = !1, m(L));
	}, R = () => {
		S = !0, C = !0, T.isProcessing || m(L);
	};
	return {
		schedule: stepsOrder.reduce((m, x) => {
			let C = O[x];
			return m[x] = (m, x = !1, T = !1) => (S || R(), C.schedule(m, x, T)), m;
		}, {}),
		cancel: (m) => {
			for (let x = 0; x < stepsOrder.length; x++) O[stepsOrder[x]].cancel(m);
		},
		state: T,
		steps: O
	};
}
var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$1, !0), now$1;
function clearTime() {
	now$1 = void 0;
}
var time = {
	now: () => (now$1 === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now$1),
	set: (m) => {
		now$1 = m, queueMicrotask(clearTime);
	}
}, activeAnimations = {
	layout: 0,
	mainThread: 0,
	waapi: 0
}, checkStringStartsWith = (m) => (x) => typeof x == "string" && x.startsWith(m), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (m) => startsAsVariableToken(m) ? singleCssVariableRegex.test(m.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, number = {
	test: (m) => typeof m == "number",
	parse: parseFloat,
	transform: (m) => m
}, alpha = {
	...number,
	transform: (m) => clamp$1(0, 1, m)
}, scale = {
	...number,
	default: 1
}, sanitize = (m) => Math.round(m * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(m) {
	return m == null;
}
var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (m, x) => (S) => !!(typeof S == "string" && singleColorRegex.test(S) && S.startsWith(m) || x && !isNullish(S) && Object.prototype.hasOwnProperty.call(S, x)), splitColor = (m, x, S) => (C) => {
	if (typeof C != "string") return C;
	let [T, D, O, k] = C.match(floatRegex);
	return {
		[m]: parseFloat(T),
		[x]: parseFloat(D),
		[S]: parseFloat(O),
		alpha: k === void 0 ? 1 : parseFloat(k)
	};
}, clampRgbUnit = (m) => clamp$1(0, 255, m), rgbUnit = {
	...number,
	transform: (m) => Math.round(clampRgbUnit(m))
}, rgba = {
	test: /* @__PURE__ */ isColorString("rgb", "red"),
	parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
	transform: ({ red: m, green: x, blue: S, alpha: C = 1 }) => "rgba(" + rgbUnit.transform(m) + ", " + rgbUnit.transform(x) + ", " + rgbUnit.transform(S) + ", " + sanitize(alpha.transform(C)) + ")"
};
function parseHex(m) {
	let x = "", S = "", C = "", T = "";
	return m.length > 5 ? (x = m.substring(1, 3), S = m.substring(3, 5), C = m.substring(5, 7), T = m.substring(7, 9)) : (x = m.substring(1, 2), S = m.substring(2, 3), C = m.substring(3, 4), T = m.substring(4, 5), x += x, S += S, C += C, T += T), {
		red: parseInt(x, 16),
		green: parseInt(S, 16),
		blue: parseInt(C, 16),
		alpha: T ? parseInt(T, 16) / 255 : 1
	};
}
var hex = {
	test: /* @__PURE__ */ isColorString("#"),
	parse: parseHex,
	transform: rgba.transform
}, createUnitType = /* @__NO_SIDE_EFFECTS__ */ (m) => ({
	test: (x) => typeof x == "string" && x.endsWith(m) && x.split(" ").length === 1,
	parse: parseFloat,
	transform: (x) => `${x}${m}`
}), degrees = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = /* @__PURE__ */ (() => ({
	...percent,
	parse: (m) => percent.parse(m) / 100,
	transform: (m) => percent.transform(m * 100)
}))(), hsla = {
	test: /* @__PURE__ */ isColorString("hsl", "hue"),
	parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
	transform: ({ hue: m, saturation: x, lightness: S, alpha: C = 1 }) => "hsla(" + Math.round(m) + ", " + percent.transform(sanitize(x)) + ", " + percent.transform(sanitize(S)) + ", " + sanitize(alpha.transform(C)) + ")"
}, color = {
	test: (m) => rgba.test(m) || hex.test(m) || hsla.test(m),
	parse: (m) => rgba.test(m) ? rgba.parse(m) : hsla.test(m) ? hsla.parse(m) : hex.parse(m),
	transform: (m) => typeof m == "string" ? m : m.hasOwnProperty("red") ? rgba.transform(m) : hsla.transform(m),
	getAnimatableNone: (m) => {
		let x = color.parse(m);
		return x.alpha = 0, color.transform(x);
	}
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(m) {
	return isNaN(m) && typeof m == "string" && (m.match(floatRegex)?.length || 0) + (m.match(colorRegex)?.length || 0) > 0;
}
var NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(m) {
	let x = m.toString(), S = [], C = {
		color: [],
		number: [],
		var: []
	}, T = [], D = 0;
	return {
		values: S,
		split: x.replace(complexRegex, (m) => (color.test(m) ? (C.color.push(D), T.push(COLOR_TOKEN), S.push(color.parse(m))) : m.startsWith(VAR_FUNCTION_TOKEN) ? (C.var.push(D), T.push(VAR_TOKEN), S.push(m)) : (C.number.push(D), T.push(NUMBER_TOKEN), S.push(parseFloat(m))), ++D, SPLIT_TOKEN)).split(SPLIT_TOKEN),
		indexes: C,
		types: T
	};
}
function parseComplexValue(m) {
	return analyseComplexValue(m).values;
}
function createTransformer(m) {
	let { split: x, types: S } = analyseComplexValue(m), C = x.length;
	return (m) => {
		let T = "";
		for (let D = 0; D < C; D++) if (T += x[D], m[D] !== void 0) {
			let x = S[D];
			x === NUMBER_TOKEN ? T += sanitize(m[D]) : x === COLOR_TOKEN ? T += color.transform(m[D]) : T += m[D];
		}
		return T;
	};
}
var convertNumbersToZero = (m) => typeof m == "number" ? 0 : color.test(m) ? color.getAnimatableNone(m) : m;
function getAnimatableNone$1(m) {
	let x = parseComplexValue(m);
	return createTransformer(m)(x.map(convertNumbersToZero));
}
var complex = {
	test,
	parse: parseComplexValue,
	createTransformer,
	getAnimatableNone: getAnimatableNone$1
};
function hueToRgb(m, x, S) {
	return S < 0 && (S += 1), S > 1 && --S, S < 1 / 6 ? m + (x - m) * 6 * S : S < 1 / 2 ? x : S < 2 / 3 ? m + (x - m) * (2 / 3 - S) * 6 : m;
}
function hslaToRgba({ hue: m, saturation: x, lightness: S, alpha: C }) {
	m /= 360, x /= 100, S /= 100;
	let T = 0, D = 0, O = 0;
	if (!x) T = D = O = S;
	else {
		let C = S < .5 ? S * (1 + x) : S + x - S * x, k = 2 * S - C;
		T = hueToRgb(k, C, m + 1 / 3), D = hueToRgb(k, C, m), O = hueToRgb(k, C, m - 1 / 3);
	}
	return {
		red: Math.round(T * 255),
		green: Math.round(D * 255),
		blue: Math.round(O * 255),
		alpha: C
	};
}
function mixImmediate(m, x) {
	return (S) => S > 0 ? x : m;
}
var mixNumber = (m, x, S) => m + (x - m) * S, mixLinearColor = (m, x, S) => {
	let C = m * m, T = S * (x * x - C) + C;
	return T < 0 ? 0 : Math.sqrt(T);
}, colorTypes = [
	hex,
	rgba,
	hsla
], getColorType = (m) => colorTypes.find((x) => x.test(m));
function asRGBA(m) {
	let x = getColorType(m);
	if (warning(!!x, `'${m}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable"), !x) return !1;
	let S = x.parse(m);
	return x === hsla && (S = hslaToRgba(S)), S;
}
var mixColor = (m, x) => {
	let S = asRGBA(m), C = asRGBA(x);
	if (!S || !C) return mixImmediate(m, x);
	let T = { ...S };
	return (m) => (T.red = mixLinearColor(S.red, C.red, m), T.green = mixLinearColor(S.green, C.green, m), T.blue = mixLinearColor(S.blue, C.blue, m), T.alpha = mixNumber(S.alpha, C.alpha, m), rgba.transform(T));
}, invisibleValues = new Set(["none", "hidden"]);
function mixVisibility(m, x) {
	return invisibleValues.has(m) ? (S) => S <= 0 ? m : x : (S) => S >= 1 ? x : m;
}
function mixNumber$1(m, x) {
	return (S) => mixNumber(m, x, S);
}
function getMixer(m) {
	return typeof m == "number" ? mixNumber$1 : typeof m == "string" ? isCSSVariableToken(m) ? mixImmediate : color.test(m) ? mixColor : mixComplex : Array.isArray(m) ? mixArray : typeof m == "object" ? color.test(m) ? mixColor : mixObject : mixImmediate;
}
function mixArray(m, x) {
	let S = [...m], C = S.length, T = m.map((m, S) => getMixer(m)(m, x[S]));
	return (m) => {
		for (let x = 0; x < C; x++) S[x] = T[x](m);
		return S;
	};
}
function mixObject(m, x) {
	let S = {
		...m,
		...x
	}, C = {};
	for (let T in S) m[T] !== void 0 && x[T] !== void 0 && (C[T] = getMixer(m[T])(m[T], x[T]));
	return (m) => {
		for (let x in C) S[x] = C[x](m);
		return S;
	};
}
function matchOrder(m, x) {
	let S = [], C = {
		color: 0,
		var: 0,
		number: 0
	};
	for (let T = 0; T < x.values.length; T++) {
		let D = x.types[T], O = m.indexes[D][C[D]];
		S[T] = m.values[O] ?? 0, C[D]++;
	}
	return S;
}
var mixComplex = (m, x) => {
	let S = complex.createTransformer(x), C = analyseComplexValue(m), T = analyseComplexValue(x);
	return C.indexes.var.length === T.indexes.var.length && C.indexes.color.length === T.indexes.color.length && C.indexes.number.length >= T.indexes.number.length ? invisibleValues.has(m) && !T.values.length || invisibleValues.has(x) && !C.values.length ? mixVisibility(m, x) : pipe(mixArray(matchOrder(C, T), T.values), S) : (warning(!0, `Complex values '${m}' and '${x}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different"), mixImmediate(m, x));
};
function mix(m, x, S) {
	return typeof m == "number" && typeof x == "number" && typeof S == "number" ? mixNumber(m, x, S) : getMixer(m)(m, x);
}
var frameloopDriver = (m) => {
	let x = ({ timestamp: x }) => m(x);
	return {
		start: (m = !0) => frame.update(x, m),
		stop: () => cancelFrame(x),
		now: () => frameData.isProcessing ? frameData.timestamp : time.now()
	};
}, generateLinearEasing = (m, x, S = 10) => {
	let C = "", T = Math.max(Math.round(x / S), 2);
	for (let x = 0; x < T; x++) C += Math.round(m(x / (T - 1)) * 1e4) / 1e4 + ", ";
	return `linear(${C.substring(0, C.length - 2)})`;
}, maxGeneratorDuration = 2e4;
function calcGeneratorDuration(m) {
	let x = 0, S = m.next(x);
	for (; !S.done && x < 2e4;) x += 50, S = m.next(x);
	return x >= 2e4 ? Infinity : x;
}
function createGeneratorEasing(m, x = 100, S) {
	let C = S({
		...m,
		keyframes: [0, x]
	}), T = Math.min(calcGeneratorDuration(C), maxGeneratorDuration);
	return {
		type: "keyframes",
		ease: (m) => C.next(T * m).value / x,
		duration: /* @__PURE__ */ millisecondsToSeconds(T)
	};
}
var velocitySampleDuration = 5;
function calcGeneratorVelocity(m, x, S) {
	let C = Math.max(x - velocitySampleDuration, 0);
	return velocityPerSecond(S - m(C), x - C);
}
var springDefaults = {
	stiffness: 100,
	damping: 10,
	mass: 1,
	velocity: 0,
	duration: 800,
	bounce: .3,
	visualDuration: .3,
	restSpeed: {
		granular: .01,
		default: 2
	},
	restDelta: {
		granular: .005,
		default: .5
	},
	minDuration: .01,
	maxDuration: 10,
	minDamping: .05,
	maxDamping: 1
}, safeMin = .001;
function findSpring({ duration: m = springDefaults.duration, bounce: x = springDefaults.bounce, velocity: S = springDefaults.velocity, mass: C = springDefaults.mass }) {
	let T, D;
	warning(m <= /* @__PURE__ */ secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
	let O = 1 - x;
	O = clamp$1(springDefaults.minDamping, springDefaults.maxDamping, O), m = clamp$1(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(m)), O < 1 ? (T = (x) => {
		let C = x * O, T = C * m, D = C - S, k = calcAngularFreq(x, O), A = Math.exp(-T);
		return safeMin - D / k * A;
	}, D = (x) => {
		let C = x * O * m, D = C * S + S, k = O ** 2 * x ** 2 * m, A = Math.exp(-C), j = calcAngularFreq(x ** 2, O);
		return (-T(x) + safeMin > 0 ? -1 : 1) * ((D - k) * A) / j;
	}) : (T = (x) => {
		let C = Math.exp(-x * m), T = (x - S) * m + 1;
		return -safeMin + C * T;
	}, D = (x) => Math.exp(-x * m) * ((S - x) * (m * m)));
	let k = 5 / m, A = approximateRoot(T, D, k);
	if (m = /* @__PURE__ */ secondsToMilliseconds(m), isNaN(A)) return {
		stiffness: springDefaults.stiffness,
		damping: springDefaults.damping,
		duration: m
	};
	{
		let x = A ** 2 * C;
		return {
			stiffness: x,
			damping: O * 2 * Math.sqrt(C * x),
			duration: m
		};
	}
}
var rootIterations = 12;
function approximateRoot(m, x, S) {
	let C = S;
	for (let S = 1; S < rootIterations; S++) C -= m(C) / x(C);
	return C;
}
function calcAngularFreq(m, x) {
	return m * Math.sqrt(1 - x * x);
}
var durationKeys = ["duration", "bounce"], physicsKeys = [
	"stiffness",
	"damping",
	"mass"
];
function isSpringType(m, x) {
	return x.some((x) => m[x] !== void 0);
}
function getSpringOptions(m) {
	let x = {
		velocity: springDefaults.velocity,
		stiffness: springDefaults.stiffness,
		damping: springDefaults.damping,
		mass: springDefaults.mass,
		isResolvedFromDuration: !1,
		...m
	};
	if (!isSpringType(m, physicsKeys) && isSpringType(m, durationKeys)) if (m.visualDuration) {
		let S = m.visualDuration, C = 2 * Math.PI / (S * 1.2), T = C * C, D = 2 * clamp$1(.05, 1, 1 - (m.bounce || 0)) * Math.sqrt(T);
		x = {
			...x,
			mass: springDefaults.mass,
			stiffness: T,
			damping: D
		};
	} else {
		let S = findSpring(m);
		x = {
			...x,
			...S,
			mass: springDefaults.mass
		}, x.isResolvedFromDuration = !0;
	}
	return x;
}
function spring(m = springDefaults.visualDuration, x = springDefaults.bounce) {
	let S = typeof m == "object" ? m : {
		visualDuration: m,
		keyframes: [0, 1],
		bounce: x
	}, { restSpeed: C, restDelta: T } = S, D = S.keyframes[0], O = S.keyframes[S.keyframes.length - 1], k = {
		done: !1,
		value: D
	}, { stiffness: A, damping: j, mass: M, duration: N, velocity: P, isResolvedFromDuration: F } = getSpringOptions({
		...S,
		velocity: -/* @__PURE__ */ millisecondsToSeconds(S.velocity || 0)
	}), I = P || 0, L = j / (2 * Math.sqrt(A * M)), R = O - D, z = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(A / M)), B = Math.abs(R) < 5;
	C ||= B ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default, T ||= B ? springDefaults.restDelta.granular : springDefaults.restDelta.default;
	let H;
	if (L < 1) {
		let m = calcAngularFreq(z, L);
		H = (x) => O - Math.exp(-L * z * x) * ((I + L * z * R) / m * Math.sin(m * x) + R * Math.cos(m * x));
	} else if (L === 1) H = (m) => O - Math.exp(-z * m) * (R + (I + z * R) * m);
	else {
		let m = z * Math.sqrt(L * L - 1);
		H = (x) => {
			let S = Math.exp(-L * z * x), C = Math.min(m * x, 300);
			return O - S * ((I + L * z * R) * Math.sinh(C) + m * R * Math.cosh(C)) / m;
		};
	}
	let U = {
		calculatedDuration: F && N || null,
		next: (m) => {
			let x = H(m);
			if (F) k.done = m >= N;
			else {
				let S = m === 0 ? I : 0;
				L < 1 && (S = m === 0 ? /* @__PURE__ */ secondsToMilliseconds(I) : calcGeneratorVelocity(H, m, x));
				let D = Math.abs(S) <= C, A = Math.abs(O - x) <= T;
				k.done = D && A;
			}
			return k.value = k.done ? O : x, k;
		},
		toString: () => {
			let m = Math.min(calcGeneratorDuration(U), maxGeneratorDuration), x = generateLinearEasing((x) => U.next(m * x).value, m, 30);
			return m + "ms " + x;
		},
		toTransition: () => {}
	};
	return U;
}
spring.applyToOptions = (m) => {
	let x = createGeneratorEasing(m, 100, spring);
	return m.ease = x.ease, m.duration = /* @__PURE__ */ secondsToMilliseconds(x.duration), m.type = "keyframes", m;
};
function inertia({ keyframes: m, velocity: x = 0, power: S = .8, timeConstant: C = 325, bounceDamping: T = 10, bounceStiffness: D = 500, modifyTarget: O, min: k, max: A, restDelta: j = .5, restSpeed: M }) {
	let N = m[0], P = {
		done: !1,
		value: N
	}, F = (m) => k !== void 0 && m < k || A !== void 0 && m > A, I = (m) => k === void 0 ? A : A === void 0 || Math.abs(k - m) < Math.abs(A - m) ? k : A, L = S * x, R = N + L, z = O === void 0 ? R : O(R);
	z !== R && (L = z - N);
	let B = (m) => -L * Math.exp(-m / C), H = (m) => z + B(m), U = (m) => {
		let x = B(m), S = H(m);
		P.done = Math.abs(x) <= j, P.value = P.done ? z : S;
	}, W, G, K = (m) => {
		F(P.value) && (W = m, G = spring({
			keyframes: [P.value, I(P.value)],
			velocity: calcGeneratorVelocity(H, m, P.value),
			damping: T,
			stiffness: D,
			restDelta: j,
			restSpeed: M
		}));
	};
	return K(0), {
		calculatedDuration: null,
		next: (m) => {
			let x = !1;
			return !G && W === void 0 && (x = !0, U(m), K(m)), W !== void 0 && m >= W ? G.next(m - W) : (!x && U(m), P);
		}
	};
}
function createMixers(m, x, S) {
	let C = [], T = S || MotionGlobalConfig.mix || mix, D = m.length - 1;
	for (let S = 0; S < D; S++) {
		let D = T(m[S], m[S + 1]);
		x && (D = pipe(Array.isArray(x) ? x[S] || noop$1 : x, D)), C.push(D);
	}
	return C;
}
function interpolate(m, x, { clamp: S = !0, ease: C, mixer: T } = {}) {
	let D = m.length;
	if (invariant(D === x.length, "Both input and output ranges must be the same length", "range-length"), D === 1) return () => x[0];
	if (D === 2 && x[0] === x[1]) return () => x[1];
	let O = m[0] === m[1];
	m[0] > m[D - 1] && (m = [...m].reverse(), x = [...x].reverse());
	let k = createMixers(x, C, T), A = k.length, j = (S) => {
		if (O && S < m[0]) return x[0];
		let C = 0;
		if (A > 1) for (; C < m.length - 2 && !(S < m[C + 1]); C++);
		let T = /* @__PURE__ */ progress(m[C], m[C + 1], S);
		return k[C](T);
	};
	return S ? (x) => j(clamp$1(m[0], m[D - 1], x)) : j;
}
function fillOffset(m, x) {
	let S = m[m.length - 1];
	for (let C = 1; C <= x; C++) {
		let T = /* @__PURE__ */ progress(0, x, C);
		m.push(mixNumber(S, 1, T));
	}
}
function defaultOffset(m) {
	let x = [0];
	return fillOffset(x, m.length - 1), x;
}
function convertOffsetToTimes(m, x) {
	return m.map((m) => m * x);
}
function defaultEasing(m, x) {
	return m.map(() => x || easeInOut).splice(0, m.length - 1);
}
function keyframes({ duration: m = 300, keyframes: x, times: S, ease: C = "easeInOut" }) {
	let T = isEasingArray(C) ? C.map(easingDefinitionToFunction) : easingDefinitionToFunction(C), D = {
		done: !1,
		value: x[0]
	}, O = interpolate(convertOffsetToTimes(S && S.length === x.length ? S : defaultOffset(x), m), x, { ease: Array.isArray(T) ? T : defaultEasing(x, T) });
	return {
		calculatedDuration: m,
		next: (x) => (D.value = O(x), D.done = x >= m, D)
	};
}
var isNotNull$1 = (m) => m !== null;
function getFinalKeyframe$1(m, { repeat: x, repeatType: S = "loop" }, C, T = 1) {
	let D = m.filter(isNotNull$1), O = T < 0 || x && S !== "loop" && x % 2 == 1 ? 0 : D.length - 1;
	return !O || C === void 0 ? D[O] : C;
}
var transitionTypeMap = {
	decay: inertia,
	inertia,
	tween: keyframes,
	keyframes,
	spring
};
function replaceTransitionType(m) {
	typeof m.type == "string" && (m.type = transitionTypeMap[m.type]);
}
var WithPromise = class {
	constructor() {
		this.updateFinished();
	}
	get finished() {
		return this._finished;
	}
	updateFinished() {
		this._finished = new Promise((m) => {
			this.resolve = m;
		});
	}
	notifyFinished() {
		this.resolve();
	}
	then(m, x) {
		return this.finished.then(m, x);
	}
}, percentToProgress = (m) => m / 100, JSAnimation = class extends WithPromise {
	constructor(m) {
		super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
			let { motionValue: m } = this.options;
			m && m.updatedAt !== time.now() && this.tick(time.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
		}, activeAnimations.mainThread++, this.options = m, this.initAnimation(), this.play(), m.autoplay === !1 && this.pause();
	}
	initAnimation() {
		let { options: m } = this;
		replaceTransitionType(m);
		let { type: x = keyframes, repeat: S = 0, repeatDelay: C = 0, repeatType: T, velocity: D = 0 } = m, { keyframes: O } = m, k = x || keyframes;
		process.env.NODE_ENV !== "production" && k !== keyframes && invariant(O.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${O}`, "spring-two-frames"), k !== keyframes && typeof O[0] != "number" && (this.mixKeyframes = pipe(percentToProgress, mix(O[0], O[1])), O = [0, 100]);
		let A = k({
			...m,
			keyframes: O
		});
		T === "mirror" && (this.mirroredGenerator = k({
			...m,
			keyframes: [...O].reverse(),
			velocity: -D
		})), A.calculatedDuration === null && (A.calculatedDuration = calcGeneratorDuration(A));
		let { calculatedDuration: j } = A;
		this.calculatedDuration = j, this.resolvedDuration = j + C, this.totalDuration = this.resolvedDuration * (S + 1) - C, this.generator = A;
	}
	updateTime(m) {
		let x = Math.round(m - this.startTime) * this.playbackSpeed;
		this.holdTime === null ? this.currentTime = x : this.currentTime = this.holdTime;
	}
	tick(m, x = !1) {
		let { generator: S, totalDuration: C, mixKeyframes: T, mirroredGenerator: D, resolvedDuration: O, calculatedDuration: k } = this;
		if (this.startTime === null) return S.next(0);
		let { delay: A = 0, keyframes: j, repeat: M, repeatType: N, repeatDelay: P, type: F, onUpdate: I, finalKeyframe: L } = this.options;
		this.speed > 0 ? this.startTime = Math.min(this.startTime, m) : this.speed < 0 && (this.startTime = Math.min(m - C / this.speed, this.startTime)), x ? this.currentTime = m : this.updateTime(m);
		let R = this.currentTime - A * (this.playbackSpeed >= 0 ? 1 : -1), z = this.playbackSpeed >= 0 ? R < 0 : R > C;
		this.currentTime = Math.max(R, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = C);
		let B = this.currentTime, H = S;
		if (M) {
			let m = Math.min(this.currentTime, C) / O, x = Math.floor(m), S = m % 1;
			!S && m >= 1 && (S = 1), S === 1 && x--, x = Math.min(x, M + 1), x % 2 && (N === "reverse" ? (S = 1 - S, P && (S -= P / O)) : N === "mirror" && (H = D)), B = clamp$1(0, 1, S) * O;
		}
		let U = z ? {
			done: !1,
			value: j[0]
		} : H.next(B);
		T && (U.value = T(U.value));
		let { done: W } = U;
		!z && k !== null && (W = this.playbackSpeed >= 0 ? this.currentTime >= C : this.currentTime <= 0);
		let G = this.holdTime === null && (this.state === "finished" || this.state === "running" && W);
		return G && F !== inertia && (U.value = getFinalKeyframe$1(j, this.options, L, this.speed)), I && I(U.value), G && this.finish(), U;
	}
	then(m, x) {
		return this.finished.then(m, x);
	}
	get duration() {
		return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
	}
	get iterationDuration() {
		let { delay: m = 0 } = this.options || {};
		return this.duration + /* @__PURE__ */ millisecondsToSeconds(m);
	}
	get time() {
		return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
	}
	set time(m) {
		m = /* @__PURE__ */ secondsToMilliseconds(m), this.currentTime = m, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = m : this.driver && (this.startTime = this.driver.now() - m / this.playbackSpeed), this.driver?.start(!1);
	}
	get speed() {
		return this.playbackSpeed;
	}
	set speed(m) {
		this.updateTime(time.now());
		let x = this.playbackSpeed !== m;
		this.playbackSpeed = m, x && (this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime));
	}
	play() {
		if (this.isStopped) return;
		let { driver: m = frameloopDriver, startTime: x } = this.options;
		this.driver ||= m((m) => this.tick(m)), this.options.onPlay?.();
		let S = this.driver.now();
		this.state === "finished" ? (this.updateFinished(), this.startTime = S) : this.holdTime === null ? this.startTime ||= x ?? S : this.startTime = S - this.holdTime, this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
	}
	pause() {
		this.state = "paused", this.updateTime(time.now()), this.holdTime = this.currentTime;
	}
	complete() {
		this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
	}
	finish() {
		this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
	}
	cancel() {
		this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
	}
	teardown() {
		this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null, activeAnimations.mainThread--;
	}
	stopDriver() {
		this.driver &&= (this.driver.stop(), void 0);
	}
	sample(m) {
		return this.startTime = 0, this.tick(m, !0);
	}
	attachTimeline(m) {
		return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), m.observe(this);
	}
};
function fillWildcards(m) {
	for (let x = 1; x < m.length; x++) m[x] ?? (m[x] = m[x - 1]);
}
var radToDeg = (m) => m * 180 / Math.PI, rotate = (m) => rebaseAngle(radToDeg(Math.atan2(m[1], m[0]))), matrix2dParsers = {
	x: 4,
	y: 5,
	translateX: 4,
	translateY: 5,
	scaleX: 0,
	scaleY: 3,
	scale: (m) => (Math.abs(m[0]) + Math.abs(m[3])) / 2,
	rotate,
	rotateZ: rotate,
	skewX: (m) => radToDeg(Math.atan(m[1])),
	skewY: (m) => radToDeg(Math.atan(m[2])),
	skew: (m) => (Math.abs(m[1]) + Math.abs(m[2])) / 2
}, rebaseAngle = (m) => (m %= 360, m < 0 && (m += 360), m), rotateZ = rotate, scaleX = (m) => Math.sqrt(m[0] * m[0] + m[1] * m[1]), scaleY = (m) => Math.sqrt(m[4] * m[4] + m[5] * m[5]), matrix3dParsers = {
	x: 12,
	y: 13,
	z: 14,
	translateX: 12,
	translateY: 13,
	translateZ: 14,
	scaleX,
	scaleY,
	scale: (m) => (scaleX(m) + scaleY(m)) / 2,
	rotateX: (m) => rebaseAngle(radToDeg(Math.atan2(m[6], m[5]))),
	rotateY: (m) => rebaseAngle(radToDeg(Math.atan2(-m[2], m[0]))),
	rotateZ,
	rotate: rotateZ,
	skewX: (m) => radToDeg(Math.atan(m[4])),
	skewY: (m) => radToDeg(Math.atan(m[1])),
	skew: (m) => (Math.abs(m[1]) + Math.abs(m[4])) / 2
};
function defaultTransformValue(m) {
	return m.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(m, x) {
	if (!m || m === "none") return defaultTransformValue(x);
	let S = m.match(/^matrix3d\(([-\d.e\s,]+)\)$/u), C, T;
	if (S) C = matrix3dParsers, T = S;
	else {
		let x = m.match(/^matrix\(([-\d.e\s,]+)\)$/u);
		C = matrix2dParsers, T = x;
	}
	if (!T) return defaultTransformValue(x);
	let D = C[x], O = T[1].split(",").map(convertTransformToNumber);
	return typeof D == "function" ? D(O) : O[D];
}
var readTransformValue = (m, x) => {
	let { transform: S = "none" } = getComputedStyle(m);
	return parseValueFromTransform(S, x);
};
function convertTransformToNumber(m) {
	return parseFloat(m.trim());
}
var transformPropOrder = [
	"transformPerspective",
	"x",
	"y",
	"z",
	"translateX",
	"translateY",
	"translateZ",
	"scale",
	"scaleX",
	"scaleY",
	"rotate",
	"rotateX",
	"rotateY",
	"rotateZ",
	"skew",
	"skewX",
	"skewY"
], transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))(), isNumOrPxType = (m) => m === number || m === px, transformKeys = new Set([
	"x",
	"y",
	"z"
]), nonTranslationalTransformKeys = transformPropOrder.filter((m) => !transformKeys.has(m));
function removeNonTranslationalTransform(m) {
	let x = [];
	return nonTranslationalTransformKeys.forEach((S) => {
		let C = m.getValue(S);
		C !== void 0 && (x.push([S, C.get()]), C.set(S.startsWith("scale") ? 1 : 0));
	}), x;
}
var positionalValues = {
	width: ({ x: m }, { paddingLeft: x = "0", paddingRight: S = "0" }) => m.max - m.min - parseFloat(x) - parseFloat(S),
	height: ({ y: m }, { paddingTop: x = "0", paddingBottom: S = "0" }) => m.max - m.min - parseFloat(x) - parseFloat(S),
	top: (m, { top: x }) => parseFloat(x),
	left: (m, { left: x }) => parseFloat(x),
	bottom: ({ y: m }, { top: x }) => parseFloat(x) + (m.max - m.min),
	right: ({ x: m }, { left: x }) => parseFloat(x) + (m.max - m.min),
	x: (m, { transform: x }) => parseValueFromTransform(x, "x"),
	y: (m, { transform: x }) => parseValueFromTransform(x, "y")
};
positionalValues.translateX = positionalValues.x, positionalValues.translateY = positionalValues.y;
var toResolve = /* @__PURE__ */ new Set(), isScheduled = !1, anyNeedsMeasurement = !1, isForced = !1;
function measureAllKeyframes() {
	if (anyNeedsMeasurement) {
		let m = Array.from(toResolve).filter((m) => m.needsMeasurement), x = new Set(m.map((m) => m.element)), S = /* @__PURE__ */ new Map();
		x.forEach((m) => {
			let x = removeNonTranslationalTransform(m);
			x.length && (S.set(m, x), m.render());
		}), m.forEach((m) => m.measureInitialState()), x.forEach((m) => {
			m.render();
			let x = S.get(m);
			x && x.forEach(([x, S]) => {
				m.getValue(x)?.set(S);
			});
		}), m.forEach((m) => m.measureEndState()), m.forEach((m) => {
			m.suspendedScrollY !== void 0 && window.scrollTo(0, m.suspendedScrollY);
		});
	}
	anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((m) => m.complete(isForced)), toResolve.clear();
}
function readAllKeyframes() {
	toResolve.forEach((m) => {
		m.readKeyframes(), m.needsMeasurement && (anyNeedsMeasurement = !0);
	});
}
function flushKeyframeResolvers() {
	isForced = !0, readAllKeyframes(), measureAllKeyframes(), isForced = !1;
}
var KeyframeResolver = class {
	constructor(m, x, S, C, T, D = !1) {
		this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...m], this.onComplete = x, this.name = S, this.motionValue = C, this.element = T, this.isAsync = D;
	}
	scheduleResolve() {
		this.state = "scheduled", this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
	}
	readKeyframes() {
		let { unresolvedKeyframes: m, name: x, element: S, motionValue: C } = this;
		if (m[0] === null) {
			let T = C?.get(), D = m[m.length - 1];
			if (T !== void 0) m[0] = T;
			else if (S && x) {
				let C = S.readValue(x, D);
				C != null && (m[0] = C);
			}
			m[0] === void 0 && (m[0] = D), C && T === void 0 && C.set(m[0]);
		}
		fillWildcards(m);
	}
	setFinalKeyframe() {}
	measureInitialState() {}
	renderEndStyles() {}
	measureEndState() {}
	complete(m = !1) {
		this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, m), toResolve.delete(this);
	}
	cancel() {
		this.state === "scheduled" && (toResolve.delete(this), this.state = "pending");
	}
	resume() {
		this.state === "pending" && this.scheduleResolve();
	}
}, isCSSVar = (m) => m.startsWith("--");
function setStyle(m, x, S) {
	isCSSVar(x) ? m.style.setProperty(x, S) : m.style[x] = S;
}
var supportsScrollTimeline = /* @__PURE__ */ memo$1(() => window.ScrollTimeline !== void 0), supportsFlags = {};
function memoSupports(m, x) {
	let S = /* @__PURE__ */ memo$1(m);
	return () => supportsFlags[x] ?? S();
}
var supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
	try {
		document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
	} catch {
		return !1;
	}
	return !0;
}, "linearEasing"), cubicBezierAsString = ([m, x, S, C]) => `cubic-bezier(${m}, ${x}, ${S}, ${C})`, supportedWaapiEasing = {
	linear: "linear",
	ease: "ease",
	easeIn: "ease-in",
	easeOut: "ease-out",
	easeInOut: "ease-in-out",
	circIn: /* @__PURE__ */ cubicBezierAsString([
		0,
		.65,
		.55,
		1
	]),
	circOut: /* @__PURE__ */ cubicBezierAsString([
		.55,
		0,
		1,
		.45
	]),
	backIn: /* @__PURE__ */ cubicBezierAsString([
		.31,
		.01,
		.66,
		-.59
	]),
	backOut: /* @__PURE__ */ cubicBezierAsString([
		.33,
		1.53,
		.69,
		.99
	])
};
function mapEasingToNativeEasing(m, x) {
	if (m) return typeof m == "function" ? supportsLinearEasing() ? generateLinearEasing(m, x) : "ease-out" : isBezierDefinition(m) ? cubicBezierAsString(m) : Array.isArray(m) ? m.map((m) => mapEasingToNativeEasing(m, x) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[m];
}
function startWaapiAnimation(m, x, S, { delay: C = 0, duration: T = 300, repeat: D = 0, repeatType: O = "loop", ease: k = "easeOut", times: A } = {}, j = void 0) {
	let M = { [x]: S };
	A && (M.offset = A);
	let N = mapEasingToNativeEasing(k, T);
	Array.isArray(N) && (M.easing = N), statsBuffer.value && activeAnimations.waapi++;
	let P = {
		delay: C,
		duration: T,
		easing: Array.isArray(N) ? "linear" : N,
		fill: "both",
		iterations: D + 1,
		direction: O === "reverse" ? "alternate" : "normal"
	};
	j && (P.pseudoElement = j);
	let F = m.animate(M, P);
	return statsBuffer.value && F.finished.finally(() => {
		activeAnimations.waapi--;
	}), F;
}
function isGenerator(m) {
	return typeof m == "function" && "applyToOptions" in m;
}
function applyGeneratorOptions({ type: m, ...x }) {
	return isGenerator(m) && supportsLinearEasing() ? m.applyToOptions(x) : (x.duration ??= 300, x.ease ??= "easeOut", x);
}
var NativeAnimation = class extends WithPromise {
	constructor(m) {
		if (super(), this.finishedTime = null, this.isStopped = !1, !m) return;
		let { element: x, name: S, keyframes: C, pseudoElement: T, allowFlatten: D = !1, finalKeyframe: O, onComplete: k } = m;
		this.isPseudoElement = !!T, this.allowFlatten = D, this.options = m, invariant(typeof m.type != "string", "Mini animate() doesn't support \"type\" as a string.", "mini-spring");
		let A = applyGeneratorOptions(m);
		this.animation = startWaapiAnimation(x, S, C, A, T), A.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
			if (this.finishedTime = this.time, !T) {
				let m = getFinalKeyframe$1(C, this.options, O, this.speed);
				this.updateMotionValue ? this.updateMotionValue(m) : setStyle(x, S, m), this.animation.cancel();
			}
			k?.(), this.notifyFinished();
		};
	}
	play() {
		this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
	}
	pause() {
		this.animation.pause();
	}
	complete() {
		this.animation.finish?.();
	}
	cancel() {
		try {
			this.animation.cancel();
		} catch {}
	}
	stop() {
		if (this.isStopped) return;
		this.isStopped = !0;
		let { state: m } = this;
		m === "idle" || m === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
	}
	commitStyles() {
		this.isPseudoElement || this.animation.commitStyles?.();
	}
	get duration() {
		let m = this.animation.effect?.getComputedTiming?.().duration || 0;
		return /* @__PURE__ */ millisecondsToSeconds(Number(m));
	}
	get iterationDuration() {
		let { delay: m = 0 } = this.options || {};
		return this.duration + /* @__PURE__ */ millisecondsToSeconds(m);
	}
	get time() {
		return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
	}
	set time(m) {
		this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(m);
	}
	get speed() {
		return this.animation.playbackRate;
	}
	set speed(m) {
		m < 0 && (this.finishedTime = null), this.animation.playbackRate = m;
	}
	get state() {
		return this.finishedTime === null ? this.animation.playState : "finished";
	}
	get startTime() {
		return Number(this.animation.startTime);
	}
	set startTime(m) {
		this.animation.startTime = m;
	}
	attachTimeline({ timeline: m, observe: x }) {
		return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, m && supportsScrollTimeline() ? (this.animation.timeline = m, noop$1) : x(this);
	}
}, unsupportedEasingFunctions = {
	anticipate,
	backInOut,
	circInOut
};
function isUnsupportedEase(m) {
	return m in unsupportedEasingFunctions;
}
function replaceStringEasing(m) {
	typeof m.ease == "string" && isUnsupportedEase(m.ease) && (m.ease = unsupportedEasingFunctions[m.ease]);
}
var sampleDelta = 10, NativeAnimationExtended = class extends NativeAnimation {
	constructor(m) {
		replaceStringEasing(m), replaceTransitionType(m), super(m), m.startTime && (this.startTime = m.startTime), this.options = m;
	}
	updateMotionValue(m) {
		let { motionValue: x, onUpdate: S, onComplete: C, element: T, ...D } = this.options;
		if (!x) return;
		if (m !== void 0) {
			x.set(m);
			return;
		}
		let O = new JSAnimation({
			...D,
			autoplay: !1
		}), k = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
		x.setWithVelocity(O.sample(k - sampleDelta).value, O.sample(k).value, sampleDelta), O.stop();
	}
}, isAnimatable = (m, x) => x === "zIndex" ? !1 : !!(typeof m == "number" || Array.isArray(m) || typeof m == "string" && (complex.test(m) || m === "0") && !m.startsWith("url("));
function hasKeyframesChanged(m) {
	let x = m[0];
	if (m.length === 1) return !0;
	for (let S = 0; S < m.length; S++) if (m[S] !== x) return !0;
}
function canAnimate(m, x, S, C) {
	let T = m[0];
	if (T === null) return !1;
	if (x === "display" || x === "visibility") return !0;
	let D = m[m.length - 1], O = isAnimatable(T, x), k = isAnimatable(D, x);
	return warning(O === k, `You are trying to animate ${x} from "${T}" to "${D}". "${O ? D : T}" is not an animatable value.`, "value-not-animatable"), !O || !k ? !1 : hasKeyframesChanged(m) || (S === "spring" || isGenerator(S)) && C;
}
function makeAnimationInstant(m) {
	m.duration = 0, m.type = "keyframes";
}
var acceleratedValues = new Set([
	"opacity",
	"clipPath",
	"filter",
	"transform"
]), supportsWaapi = /* @__PURE__ */ memo$1(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(m) {
	let { motionValue: x, name: S, repeatDelay: C, repeatType: T, damping: D, type: O } = m;
	if (!(x?.owner?.current instanceof HTMLElement)) return !1;
	let { onUpdate: k, transformTemplate: A } = x.owner.getProps();
	return supportsWaapi() && S && acceleratedValues.has(S) && (S !== "transform" || !A) && !k && !C && T !== "mirror" && D !== 0 && O !== "inertia";
}
var MAX_RESOLVE_DELAY = 40, AsyncMotionValueAnimation = class extends WithPromise {
	constructor({ autoplay: m = !0, delay: x = 0, type: S = "keyframes", repeat: C = 0, repeatDelay: T = 0, repeatType: D = "loop", keyframes: O, name: k, motionValue: A, element: j, ...M }) {
		super(), this.stop = () => {
			this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
		}, this.createdAt = time.now();
		let N = {
			autoplay: m,
			delay: x,
			type: S,
			repeat: C,
			repeatDelay: T,
			repeatType: D,
			name: k,
			motionValue: A,
			element: j,
			...M
		};
		this.keyframeResolver = new (j?.KeyframeResolver || KeyframeResolver)(O, (m, x, S) => this.onKeyframesResolved(m, x, N, !S), k, A, j), this.keyframeResolver?.scheduleResolve();
	}
	onKeyframesResolved(m, x, S, C) {
		this.keyframeResolver = void 0;
		let { name: T, type: D, velocity: O, delay: k, isHandoff: A, onUpdate: j } = S;
		this.resolvedAt = time.now(), canAnimate(m, T, D, O) || ((MotionGlobalConfig.instantAnimations || !k) && j?.(getFinalKeyframe$1(m, S, x)), m[0] = m[m.length - 1], makeAnimationInstant(S), S.repeat = 0);
		let M = {
			startTime: C ? this.resolvedAt && this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0,
			finalKeyframe: x,
			...S,
			keyframes: m
		}, N = !A && supportsBrowserAnimation(M) ? new NativeAnimationExtended({
			...M,
			element: M.motionValue.owner.current
		}) : new JSAnimation(M);
		N.finished.then(() => this.notifyFinished()).catch(noop$1), this.pendingTimeline &&= (this.stopTimeline = N.attachTimeline(this.pendingTimeline), void 0), this._animation = N;
	}
	get finished() {
		return this._animation ? this.animation.finished : this._finished;
	}
	then(m, x) {
		return this.finished.finally(m).then(() => {});
	}
	get animation() {
		return this._animation || (this.keyframeResolver?.resume(), flushKeyframeResolvers()), this._animation;
	}
	get duration() {
		return this.animation.duration;
	}
	get iterationDuration() {
		return this.animation.iterationDuration;
	}
	get time() {
		return this.animation.time;
	}
	set time(m) {
		this.animation.time = m;
	}
	get speed() {
		return this.animation.speed;
	}
	get state() {
		return this.animation.state;
	}
	set speed(m) {
		this.animation.speed = m;
	}
	get startTime() {
		return this.animation.startTime;
	}
	attachTimeline(m) {
		return this._animation ? this.stopTimeline = this.animation.attachTimeline(m) : this.pendingTimeline = m, () => this.stop();
	}
	play() {
		this.animation.play();
	}
	pause() {
		this.animation.pause();
	}
	complete() {
		this.animation.complete();
	}
	cancel() {
		this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
	}
}, splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(m) {
	let x = splitCSSVariableRegex.exec(m);
	if (!x) return [,];
	let [, S, C, T] = x;
	return [`--${S ?? C}`, T];
}
var maxDepth = 4;
function getVariableValue(m, x, S = 1) {
	invariant(S <= maxDepth, `Max CSS variable fallback depth detected in property "${m}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
	let [C, T] = parseCSSVariable(m);
	if (!C) return;
	let D = window.getComputedStyle(x).getPropertyValue(C);
	if (D) {
		let m = D.trim();
		return isNumericalString(m) ? parseFloat(m) : m;
	}
	return isCSSVariableToken(T) ? getVariableValue(T, x, S + 1) : T;
}
function getValueTransition(m, x) {
	return m?.[x] ?? m?.default ?? m;
}
var positionalKeys = new Set([
	"width",
	"height",
	"top",
	"left",
	"right",
	"bottom",
	...transformPropOrder
]), auto = {
	test: (m) => m === "auto",
	parse: (m) => m
}, testValueType = (m) => (x) => x.test(m), dimensionValueTypes = [
	number,
	px,
	percent,
	degrees,
	vw,
	vh,
	auto
], findDimensionValueType = (m) => dimensionValueTypes.find(testValueType(m));
function isNone(m) {
	return typeof m == "number" ? m === 0 : m === null ? !0 : m === "none" || m === "0" || isZeroValueString(m);
}
var maxDefaults = new Set([
	"brightness",
	"contrast",
	"saturate",
	"opacity"
]);
function applyDefaultFilter(m) {
	let [x, S] = m.slice(0, -1).split("(");
	if (x === "drop-shadow") return m;
	let [C] = S.match(floatRegex) || [];
	if (!C) return m;
	let T = S.replace(C, ""), D = maxDefaults.has(x) ? 1 : 0;
	return C !== S && (D *= 100), x + "(" + D + T + ")";
}
var functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {
	...complex,
	getAnimatableNone: (m) => {
		let x = m.match(functionRegex);
		return x ? x.map(applyDefaultFilter).join(" ") : m;
	}
}, int = {
	...number,
	transform: Math.round
}, numberValueTypes = {
	borderWidth: px,
	borderTopWidth: px,
	borderRightWidth: px,
	borderBottomWidth: px,
	borderLeftWidth: px,
	borderRadius: px,
	radius: px,
	borderTopLeftRadius: px,
	borderTopRightRadius: px,
	borderBottomRightRadius: px,
	borderBottomLeftRadius: px,
	width: px,
	maxWidth: px,
	height: px,
	maxHeight: px,
	top: px,
	right: px,
	bottom: px,
	left: px,
	padding: px,
	paddingTop: px,
	paddingRight: px,
	paddingBottom: px,
	paddingLeft: px,
	margin: px,
	marginTop: px,
	marginRight: px,
	marginBottom: px,
	marginLeft: px,
	backgroundPositionX: px,
	backgroundPositionY: px,
	rotate: degrees,
	rotateX: degrees,
	rotateY: degrees,
	rotateZ: degrees,
	scale,
	scaleX: scale,
	scaleY: scale,
	scaleZ: scale,
	skew: degrees,
	skewX: degrees,
	skewY: degrees,
	distance: px,
	translateX: px,
	translateY: px,
	translateZ: px,
	x: px,
	y: px,
	z: px,
	perspective: px,
	transformPerspective: px,
	opacity: alpha,
	originX: progressPercentage,
	originY: progressPercentage,
	originZ: px,
	zIndex: int,
	fillOpacity: alpha,
	strokeOpacity: alpha,
	numOctaves: int
}, defaultValueTypes = {
	...numberValueTypes,
	color,
	backgroundColor: color,
	outlineColor: color,
	fill: color,
	stroke: color,
	borderColor: color,
	borderTopColor: color,
	borderRightColor: color,
	borderBottomColor: color,
	borderLeftColor: color,
	filter,
	WebkitFilter: filter
}, getDefaultValueType = (m) => defaultValueTypes[m];
function getAnimatableNone(m, x) {
	let S = getDefaultValueType(m);
	return S !== filter && (S = complex), S.getAnimatableNone ? S.getAnimatableNone(x) : void 0;
}
var invalidTemplates = new Set([
	"auto",
	"none",
	"0"
]);
function makeNoneKeyframesAnimatable(m, x, S) {
	let C = 0, T;
	for (; C < m.length && !T;) {
		let x = m[C];
		typeof x == "string" && !invalidTemplates.has(x) && analyseComplexValue(x).values.length && (T = m[C]), C++;
	}
	if (T && S) for (let C of x) m[C] = getAnimatableNone(S, T);
}
var DOMKeyframesResolver = class extends KeyframeResolver {
	constructor(m, x, S, C, T) {
		super(m, x, S, C, T, !0);
	}
	readKeyframes() {
		let { unresolvedKeyframes: m, element: x, name: S } = this;
		if (!x || !x.current) return;
		super.readKeyframes();
		for (let S = 0; S < m.length; S++) {
			let C = m[S];
			if (typeof C == "string" && (C = C.trim(), isCSSVariableToken(C))) {
				let T = getVariableValue(C, x.current);
				T !== void 0 && (m[S] = T), S === m.length - 1 && (this.finalKeyframe = C);
			}
		}
		if (this.resolveNoneKeyframes(), !positionalKeys.has(S) || m.length !== 2) return;
		let [C, T] = m, D = findDimensionValueType(C), O = findDimensionValueType(T);
		if (D !== O) if (isNumOrPxType(D) && isNumOrPxType(O)) for (let x = 0; x < m.length; x++) {
			let S = m[x];
			typeof S == "string" && (m[x] = parseFloat(S));
		}
		else positionalValues[S] && (this.needsMeasurement = !0);
	}
	resolveNoneKeyframes() {
		let { unresolvedKeyframes: m, name: x } = this, S = [];
		for (let x = 0; x < m.length; x++) (m[x] === null || isNone(m[x])) && S.push(x);
		S.length && makeNoneKeyframesAnimatable(m, S, x);
	}
	measureInitialState() {
		let { element: m, unresolvedKeyframes: x, name: S } = this;
		if (!m || !m.current) return;
		S === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[S](m.measureViewportBox(), window.getComputedStyle(m.current)), x[0] = this.measuredOrigin;
		let C = x[x.length - 1];
		C !== void 0 && m.getValue(S, C).jump(C, !1);
	}
	measureEndState() {
		let { element: m, name: x, unresolvedKeyframes: S } = this;
		if (!m || !m.current) return;
		let C = m.getValue(x);
		C && C.jump(this.measuredOrigin, !1);
		let T = S.length - 1, D = S[T];
		S[T] = positionalValues[x](m.measureViewportBox(), window.getComputedStyle(m.current)), D !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = D), this.removedTransforms?.length && this.removedTransforms.forEach(([x, S]) => {
			m.getValue(x).set(S);
		}), this.resolveNoneKeyframes();
	}
};
function resolveElements(m, x, S) {
	if (m instanceof EventTarget) return [m];
	if (typeof m == "string") {
		let C = document;
		x && (C = x.current);
		let T = S?.[m] ?? C.querySelectorAll(m);
		return T ? Array.from(T) : [];
	}
	return Array.from(m);
}
var getValueAsType = (m, x) => x && typeof m == "number" ? x.transform(m) : m;
function isHTMLElement(m) {
	return isObject$3(m) && "offsetHeight" in m;
}
var MAX_VELOCITY_DELTA = 30, isFloat = (m) => !isNaN(parseFloat(m)), collectMotionValues = { current: void 0 }, MotionValue = class {
	constructor(m, x = {}) {
		this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (m) => {
			let x = time.now();
			if (this.updatedAt !== x && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(m), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (let m of this.dependents) m.dirty();
		}, this.hasAnimated = !1, this.setCurrent(m), this.owner = x.owner;
	}
	setCurrent(m) {
		this.current = m, this.updatedAt = time.now(), this.canTrackVelocity === null && m !== void 0 && (this.canTrackVelocity = isFloat(this.current));
	}
	setPrevFrameValue(m = this.current) {
		this.prevFrameValue = m, this.prevUpdatedAt = this.updatedAt;
	}
	onChange(m) {
		return process.env.NODE_ENV !== "production" && warnOnce(!1, "value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback)."), this.on("change", m);
	}
	on(m, x) {
		this.events[m] || (this.events[m] = new SubscriptionManager());
		let S = this.events[m].add(x);
		return m === "change" ? () => {
			S(), frame.read(() => {
				this.events.change.getSize() || this.stop();
			});
		} : S;
	}
	clearListeners() {
		for (let m in this.events) this.events[m].clear();
	}
	attach(m, x) {
		this.passiveEffect = m, this.stopPassiveEffect = x;
	}
	set(m) {
		this.passiveEffect ? this.passiveEffect(m, this.updateAndNotify) : this.updateAndNotify(m);
	}
	setWithVelocity(m, x, S) {
		this.set(x), this.prev = void 0, this.prevFrameValue = m, this.prevUpdatedAt = this.updatedAt - S;
	}
	jump(m, x = !0) {
		this.updateAndNotify(m), this.prev = m, this.prevUpdatedAt = this.prevFrameValue = void 0, x && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
	}
	dirty() {
		this.events.change?.notify(this.current);
	}
	addDependent(m) {
		this.dependents ||= /* @__PURE__ */ new Set(), this.dependents.add(m);
	}
	removeDependent(m) {
		this.dependents && this.dependents.delete(m);
	}
	get() {
		return collectMotionValues.current && collectMotionValues.current.push(this), this.current;
	}
	getPrevious() {
		return this.prev;
	}
	getVelocity() {
		let m = time.now();
		if (!this.canTrackVelocity || this.prevFrameValue === void 0 || m - this.updatedAt > MAX_VELOCITY_DELTA) return 0;
		let x = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
		return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), x);
	}
	start(m) {
		return this.stop(), new Promise((x) => {
			this.hasAnimated = !0, this.animation = m(x), this.events.animationStart && this.events.animationStart.notify();
		}).then(() => {
			this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
		});
	}
	stop() {
		this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
	}
	isAnimating() {
		return !!this.animation;
	}
	clearAnimation() {
		delete this.animation;
	}
	destroy() {
		this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
	}
};
function motionValue(m, x) {
	return new MotionValue(m, x);
}
var { schedule: microtask, cancel: cancelMicrotask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, !1), isDragging = {
	x: !1,
	y: !1
};
function isDragActive() {
	return isDragging.x || isDragging.y;
}
function setDragLock(m) {
	return m === "x" || m === "y" ? isDragging[m] ? null : (isDragging[m] = !0, () => {
		isDragging[m] = !1;
	}) : isDragging.x || isDragging.y ? null : (isDragging.x = isDragging.y = !0, () => {
		isDragging.x = isDragging.y = !1;
	});
}
function setupGesture$1(m, x) {
	let S = resolveElements(m), C = new AbortController();
	return [
		S,
		{
			passive: !0,
			...x,
			signal: C.signal
		},
		() => C.abort()
	];
}
function isValidHover(m) {
	return !(m.pointerType === "touch" || isDragActive());
}
function hover(m, x, S = {}) {
	let [C, T, D] = setupGesture$1(m, S), O = (m) => {
		if (!isValidHover(m)) return;
		let { target: S } = m, C = x(S, m);
		if (typeof C != "function" || !S) return;
		let D = (m) => {
			isValidHover(m) && (C(m), S.removeEventListener("pointerleave", D));
		};
		S.addEventListener("pointerleave", D, T);
	};
	return C.forEach((m) => {
		m.addEventListener("pointerenter", O, T);
	}), D;
}
var isNodeOrChild = (m, x) => x ? m === x ? !0 : isNodeOrChild(m, x.parentElement) : !1, isPrimaryPointer = (m) => m.pointerType === "mouse" ? typeof m.button != "number" || m.button <= 0 : m.isPrimary !== !1, focusableElements = new Set([
	"BUTTON",
	"INPUT",
	"SELECT",
	"TEXTAREA",
	"A"
]);
function isElementKeyboardAccessible(m) {
	return focusableElements.has(m.tagName) || m.tabIndex !== -1;
}
var isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(m) {
	return (x) => {
		x.key === "Enter" && m(x);
	};
}
function firePointerEvent(m, x) {
	m.dispatchEvent(new PointerEvent("pointer" + x, {
		isPrimary: !0,
		bubbles: !0
	}));
}
var enableKeyboardPress = (m, x) => {
	let S = m.currentTarget;
	if (!S) return;
	let C = filterEvents(() => {
		if (isPressing.has(S)) return;
		firePointerEvent(S, "down");
		let m = filterEvents(() => {
			firePointerEvent(S, "up");
		});
		S.addEventListener("keyup", m, x), S.addEventListener("blur", () => firePointerEvent(S, "cancel"), x);
	});
	S.addEventListener("keydown", C, x), S.addEventListener("blur", () => S.removeEventListener("keydown", C), x);
};
function isValidPressEvent(m) {
	return isPrimaryPointer(m) && !isDragActive();
}
function press(m, x, S = {}) {
	let [C, T, D] = setupGesture$1(m, S), O = (m) => {
		let C = m.currentTarget;
		if (!isValidPressEvent(m)) return;
		isPressing.add(C);
		let D = x(C, m), O = (m, x) => {
			window.removeEventListener("pointerup", k), window.removeEventListener("pointercancel", A), isPressing.has(C) && isPressing.delete(C), isValidPressEvent(m) && typeof D == "function" && D(m, { success: x });
		}, k = (m) => {
			O(m, C === window || C === document || S.useGlobalTarget || isNodeOrChild(C, m.target));
		}, A = (m) => {
			O(m, !1);
		};
		window.addEventListener("pointerup", k, T), window.addEventListener("pointercancel", A, T);
	};
	return C.forEach((m) => {
		(S.useGlobalTarget ? window : m).addEventListener("pointerdown", O, T), isHTMLElement(m) && (m.addEventListener("focus", (m) => enableKeyboardPress(m, T)), !isElementKeyboardAccessible(m) && !m.hasAttribute("tabindex") && (m.tabIndex = 0));
	}), D;
}
function isSVGElement(m) {
	return isObject$3(m) && "ownerSVGElement" in m;
}
function isSVGSVGElement(m) {
	return isSVGElement(m) && m.tagName === "svg";
}
var isMotionValue = (m) => !!(m && m.getVelocity), valueTypes = [
	...dimensionValueTypes,
	color,
	complex
], findValueType = (m) => valueTypes.find(testValueType(m)), MotionConfigContext = createContext({
	transformPagePoint: (m) => m,
	isStatic: !1,
	reducedMotion: "never"
});
function usePresence(m = !0) {
	let x = useContext(PresenceContext);
	if (x === null) return [!0, null];
	let { isPresent: S, onExitComplete: C, register: T } = x, D = useId();
	useEffect(() => {
		if (m) return T(D);
	}, [m]);
	let O = useCallback(() => m && C && C(D), [
		D,
		C,
		m
	]);
	return !S && C ? [!1, O] : [!0];
}
var LazyContext = createContext({ strict: !1 }), featureProps = {
	animation: [
		"animate",
		"variants",
		"whileHover",
		"whileTap",
		"exit",
		"whileInView",
		"whileFocus",
		"whileDrag"
	],
	exit: ["exit"],
	drag: ["drag", "dragControls"],
	focus: ["whileFocus"],
	hover: [
		"whileHover",
		"onHoverStart",
		"onHoverEnd"
	],
	tap: [
		"whileTap",
		"onTap",
		"onTapStart",
		"onTapCancel"
	],
	pan: [
		"onPan",
		"onPanStart",
		"onPanSessionStart",
		"onPanEnd"
	],
	inView: [
		"whileInView",
		"onViewportEnter",
		"onViewportLeave"
	],
	layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (let m in featureProps) featureDefinitions[m] = { isEnabled: (x) => featureProps[m].some((m) => !!x[m]) };
function loadFeatures(m) {
	for (let x in m) featureDefinitions[x] = {
		...featureDefinitions[x],
		...m[x]
	};
}
var validMotionProps = new Set(/* @__PURE__ */ "animate.exit.variants.initial.style.values.variants.transition.transformTemplate.custom.inherit.onBeforeLayoutMeasure.onAnimationStart.onAnimationComplete.onUpdate.onDragStart.onDrag.onDragEnd.onMeasureDragConstraints.onDirectionLock.onDragTransitionEnd._dragX._dragY.onHoverStart.onHoverEnd.onViewportEnter.onViewportLeave.globalTapTarget.ignoreStrict.viewport".split("."));
function isValidMotionProp(m) {
	return m.startsWith("while") || m.startsWith("drag") && m !== "draggable" || m.startsWith("layout") || m.startsWith("onTap") || m.startsWith("onPan") || m.startsWith("onLayout") || validMotionProps.has(m);
}
var is_prop_valid_framer_motion_exports = /* @__PURE__ */ __export({ default: () => is_prop_valid_framer_motion_default }), is_prop_valid_framer_motion_default, init_is_prop_valid_framer_motion = __esmMin((() => {
	throw is_prop_valid_framer_motion_default = {}, Error("Could not resolve \"@emotion/is-prop-valid\" imported by \"framer-motion\". Is it installed?");
})), shouldForward = (m) => !isValidMotionProp(m);
function loadExternalIsValidProp(m) {
	typeof m == "function" && (shouldForward = (x) => x.startsWith("on") ? !isValidMotionProp(x) : m(x));
}
try {
	loadExternalIsValidProp((init_is_prop_valid_framer_motion(), __toCommonJS(is_prop_valid_framer_motion_exports)).default);
} catch {}
function filterProps(m, x, S) {
	let C = {};
	for (let T in m) T === "values" && typeof m.values == "object" || (shouldForward(T) || S === !0 && isValidMotionProp(T) || !x && !isValidMotionProp(T) || m.draggable && T.startsWith("onDrag")) && (C[T] = m[T]);
	return C;
}
var MotionContext = /* @__PURE__ */ createContext({});
function isAnimationControls(m) {
	return typeof m == "object" && !!m && typeof m.start == "function";
}
function isVariantLabel(m) {
	return typeof m == "string" || Array.isArray(m);
}
var variantPriorityOrder = [
	"animate",
	"whileInView",
	"whileFocus",
	"whileHover",
	"whileTap",
	"whileDrag",
	"exit"
], variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(m) {
	return isAnimationControls(m.animate) || variantProps.some((x) => isVariantLabel(m[x]));
}
function isVariantNode(m) {
	return !!(isControllingVariants(m) || m.variants);
}
function getCurrentTreeVariants(m, x) {
	if (isControllingVariants(m)) {
		let { initial: x, animate: S } = m;
		return {
			initial: x === !1 || isVariantLabel(x) ? x : void 0,
			animate: isVariantLabel(S) ? S : void 0
		};
	}
	return m.inherit === !1 ? {} : x;
}
function useCreateMotionContext(m) {
	let { initial: x, animate: S } = getCurrentTreeVariants(m, useContext(MotionContext));
	return useMemo(() => ({
		initial: x,
		animate: S
	}), [variantLabelsAsDependency(x), variantLabelsAsDependency(S)]);
}
function variantLabelsAsDependency(m) {
	return Array.isArray(m) ? m.join(" ") : m;
}
var scaleCorrectors = {};
function addScaleCorrector(m) {
	for (let x in m) scaleCorrectors[x] = m[x], isCSSVariableName(x) && (scaleCorrectors[x].isCSSVariable = !0);
}
function isForcedMotionValue(m, { layout: x, layoutId: S }) {
	return transformProps.has(m) || m.startsWith("origin") || (x || S !== void 0) && (!!scaleCorrectors[m] || m === "opacity");
}
var translateAlias = {
	x: "translateX",
	y: "translateY",
	z: "translateZ",
	transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(m, x, S) {
	let C = "", T = !0;
	for (let D = 0; D < numTransforms; D++) {
		let O = transformPropOrder[D], k = m[O];
		if (k === void 0) continue;
		let A = !0;
		if (A = typeof k == "number" ? k === (O.startsWith("scale") ? 1 : 0) : parseFloat(k) === 0, !A || S) {
			let m = getValueAsType(k, numberValueTypes[O]);
			if (!A) {
				T = !1;
				let x = translateAlias[O] || O;
				C += `${x}(${m}) `;
			}
			S && (x[O] = m);
		}
	}
	return C = C.trim(), S ? C = S(x, T ? "" : C) : T && (C = "none"), C;
}
function buildHTMLStyles(m, x, S) {
	let { style: C, vars: T, transformOrigin: D } = m, O = !1, k = !1;
	for (let m in x) {
		let S = x[m];
		if (transformProps.has(m)) {
			O = !0;
			continue;
		} else if (isCSSVariableName(m)) {
			T[m] = S;
			continue;
		} else {
			let x = getValueAsType(S, numberValueTypes[m]);
			m.startsWith("origin") ? (k = !0, D[m] = x) : C[m] = x;
		}
	}
	if (x.transform || (O || S ? C.transform = buildTransform(x, m.transform, S) : C.transform &&= "none"), k) {
		let { originX: m = "50%", originY: x = "50%", originZ: S = 0 } = D;
		C.transformOrigin = `${m} ${x} ${S}`;
	}
}
var createHtmlRenderState = () => ({
	style: {},
	transform: {},
	transformOrigin: {},
	vars: {}
});
function copyRawValuesOnly(m, x, S) {
	for (let C in x) !isMotionValue(x[C]) && !isForcedMotionValue(C, S) && (m[C] = x[C]);
}
function useInitialMotionValues({ transformTemplate: m }, x) {
	return useMemo(() => {
		let S = createHtmlRenderState();
		return buildHTMLStyles(S, x, m), Object.assign({}, S.vars, S.style);
	}, [x]);
}
function useStyle(m, x) {
	let S = m.style || {}, C = {};
	return copyRawValuesOnly(C, S, m), Object.assign(C, useInitialMotionValues(m, x)), C;
}
function useHTMLProps(m, x) {
	let S = {}, C = useStyle(m, x);
	return m.drag && m.dragListener !== !1 && (S.draggable = !1, C.userSelect = C.WebkitUserSelect = C.WebkitTouchCallout = "none", C.touchAction = m.drag === !0 ? "none" : `pan-${m.drag === "x" ? "y" : "x"}`), m.tabIndex === void 0 && (m.onTap || m.onTapStart || m.whileTap) && (S.tabIndex = 0), S.style = C, S;
}
var dashKeys = {
	offset: "stroke-dashoffset",
	array: "stroke-dasharray"
}, camelKeys = {
	offset: "strokeDashoffset",
	array: "strokeDasharray"
};
function buildSVGPath(m, x, S = 1, C = 0, T = !0) {
	m.pathLength = 1;
	let D = T ? dashKeys : camelKeys;
	m[D.offset] = px.transform(-C);
	let O = px.transform(x), k = px.transform(S);
	m[D.array] = `${O} ${k}`;
}
function buildSVGAttrs(m, { attrX: x, attrY: S, attrScale: C, pathLength: T, pathSpacing: D = 1, pathOffset: O = 0, ...k }, A, j, M) {
	if (buildHTMLStyles(m, k, j), A) {
		m.style.viewBox && (m.attrs.viewBox = m.style.viewBox);
		return;
	}
	m.attrs = m.style, m.style = {};
	let { attrs: N, style: P } = m;
	N.transform && (P.transform = N.transform, delete N.transform), (P.transform || N.transformOrigin) && (P.transformOrigin = N.transformOrigin ?? "50% 50%", delete N.transformOrigin), P.transform && (P.transformBox = M?.transformBox ?? "fill-box", delete N.transformBox), x !== void 0 && (N.x = x), S !== void 0 && (N.y = S), C !== void 0 && (N.scale = C), T !== void 0 && buildSVGPath(N, T, D, O, !1);
}
var createSvgRenderState = () => ({
	...createHtmlRenderState(),
	attrs: {}
}), isSVGTag = (m) => typeof m == "string" && m.toLowerCase() === "svg";
function useSVGProps(m, x, S, C) {
	let T = useMemo(() => {
		let S = createSvgRenderState();
		return buildSVGAttrs(S, x, isSVGTag(C), m.transformTemplate, m.style), {
			...S.attrs,
			style: { ...S.style }
		};
	}, [x]);
	if (m.style) {
		let x = {};
		copyRawValuesOnly(x, m.style, m), T.style = {
			...x,
			...T.style
		};
	}
	return T;
}
var lowercaseSVGElements = [
	"animate",
	"circle",
	"defs",
	"desc",
	"ellipse",
	"g",
	"image",
	"line",
	"filter",
	"marker",
	"mask",
	"metadata",
	"path",
	"pattern",
	"polygon",
	"polyline",
	"rect",
	"stop",
	"switch",
	"symbol",
	"svg",
	"text",
	"tspan",
	"use",
	"view"
];
function isSVGComponent(m) {
	return typeof m != "string" || m.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(m) > -1 || /[A-Z]/u.test(m));
}
function useRender(m, x, S, { latestValues: T }, O, k = !1) {
	let A = (isSVGComponent(m) ? useSVGProps : useHTMLProps)(x, T, O, m), j = filterProps(x, typeof m == "string", k), M = m === Fragment ? {} : {
		...j,
		...A,
		ref: S
	}, { children: N } = x, P = useMemo(() => isMotionValue(N) ? N.get() : N, [N]);
	return createElement(m, {
		...M,
		children: P
	});
}
function getValueState(m) {
	let x = [{}, {}];
	return m?.values.forEach((m, S) => {
		x[0][S] = m.get(), x[1][S] = m.getVelocity();
	}), x;
}
function resolveVariantFromProps(m, x, S, C) {
	if (typeof x == "function") {
		let [T, D] = getValueState(C);
		x = x(S === void 0 ? m.custom : S, T, D);
	}
	if (typeof x == "string" && (x = m.variants && m.variants[x]), typeof x == "function") {
		let [T, D] = getValueState(C);
		x = x(S === void 0 ? m.custom : S, T, D);
	}
	return x;
}
function resolveMotionValue(m) {
	return isMotionValue(m) ? m.get() : m;
}
function makeState({ scrapeMotionValuesFromProps: m, createRenderState: x }, S, C, T) {
	return {
		latestValues: makeLatestValues(S, C, T, m),
		renderState: x()
	};
}
function makeLatestValues(m, x, S, C) {
	let T = {}, D = C(m, {});
	for (let m in D) T[m] = resolveMotionValue(D[m]);
	let { initial: O, animate: k } = m, A = isControllingVariants(m), j = isVariantNode(m);
	x && j && !A && m.inherit !== !1 && (O === void 0 && (O = x.initial), k === void 0 && (k = x.animate));
	let M = S ? S.initial === !1 : !1;
	M ||= O === !1;
	let N = M ? k : O;
	if (N && typeof N != "boolean" && !isAnimationControls(N)) {
		let x = Array.isArray(N) ? N : [N];
		for (let S = 0; S < x.length; S++) {
			let C = resolveVariantFromProps(m, x[S]);
			if (C) {
				let { transitionEnd: m, transition: x, ...S } = C;
				for (let m in S) {
					let x = S[m];
					if (Array.isArray(x)) {
						let m = M ? x.length - 1 : 0;
						x = x[m];
					}
					x !== null && (T[m] = x);
				}
				for (let x in m) T[x] = m[x];
			}
		}
	}
	return T;
}
var makeUseVisualState = (m) => (x, S) => {
	let C = useContext(MotionContext), T = useContext(PresenceContext), D = () => makeState(m, x, C, T);
	return S ? D() : useConstant(D);
};
function scrapeMotionValuesFromProps$1(m, x, S) {
	let { style: C } = m, T = {};
	for (let D in C) (isMotionValue(C[D]) || x.style && isMotionValue(x.style[D]) || isForcedMotionValue(D, m) || S?.getValue(D)?.liveStyle !== void 0) && (T[D] = C[D]);
	return T;
}
var useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
	scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
	createRenderState: createHtmlRenderState
});
function scrapeMotionValuesFromProps(m, x, S) {
	let C = scrapeMotionValuesFromProps$1(m, x, S);
	for (let S in m) if (isMotionValue(m[S]) || isMotionValue(x[S])) {
		let x = transformPropOrder.indexOf(S) === -1 ? S : "attr" + S.charAt(0).toUpperCase() + S.substring(1);
		C[x] = m[S];
	}
	return C;
}
var useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
	scrapeMotionValuesFromProps,
	createRenderState: createSvgRenderState
}), motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(m) {
	return m && typeof m == "object" && Object.prototype.hasOwnProperty.call(m, "current");
}
function useMotionRef(m, x, S) {
	return useCallback((C) => {
		C && m.onMount && m.onMount(C), x && (C ? x.mount(C) : x.unmount()), S && (typeof S == "function" ? S(C) : isRefObject(S) && (S.current = C));
	}, [x]);
}
var camelToDash = (m) => m.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), optimizedAppearDataAttribute = "data-" + camelToDash("framerAppearId"), SwitchLayoutGroupContext = createContext({});
function useVisualElement(m, x, S, C, T) {
	let { visualElement: D } = useContext(MotionContext), O = useContext(LazyContext), k = useContext(PresenceContext), A = useContext(MotionConfigContext).reducedMotion, j = useRef(null);
	C ||= O.renderer, !j.current && C && (j.current = C(m, {
		visualState: x,
		parent: D,
		props: S,
		presenceContext: k,
		blockInitialAnimation: k ? k.initial === !1 : !1,
		reducedMotionConfig: A
	}));
	let M = j.current, F = useContext(SwitchLayoutGroupContext);
	M && !M.projection && T && (M.type === "html" || M.type === "svg") && createProjectionNode$1(j.current, S, T, F);
	let I = useRef(!1);
	useInsertionEffect(() => {
		M && I.current && M.update(S, k);
	});
	let R = S[optimizedAppearDataAttribute], z = useRef(!!R && !window.MotionHandoffIsComplete?.(R) && window.MotionHasOptimisedAnimation?.(R));
	return useIsomorphicLayoutEffect$2(() => {
		M && (I.current = !0, window.MotionIsMounted = !0, M.updateFeatures(), M.scheduleRenderMicrotask(), z.current && M.animationState && M.animationState.animateChanges());
	}), useEffect(() => {
		M && (!z.current && M.animationState && M.animationState.animateChanges(), z.current &&= (queueMicrotask(() => {
			window.MotionHandoffMarkAsComplete?.(R);
		}), !1), M.enteringChildren = void 0);
	}), M;
}
function createProjectionNode$1(m, x, S, C) {
	let { layoutId: T, layout: D, drag: O, dragConstraints: k, layoutScroll: A, layoutRoot: j, layoutCrossfade: M } = x;
	m.projection = new S(m.latestValues, x["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(m.parent)), m.projection.setOptions({
		layoutId: T,
		layout: D,
		alwaysMeasureLayout: !!O || k && isRefObject(k),
		visualElement: m,
		animationType: typeof D == "string" ? D : "both",
		initialPromotionConfig: C,
		crossfade: M,
		layoutScroll: A,
		layoutRoot: j
	});
}
function getClosestProjectingNode(m) {
	if (m) return m.options.allowProjection === !1 ? getClosestProjectingNode(m.parent) : m.projection;
}
function createMotionComponent(m, { forwardMotionProps: x = !1 } = {}, S, C) {
	S && loadFeatures(S);
	let T = isSVGComponent(m) ? useSVGVisualState : useHTMLVisualState;
	function D(D, O) {
		let k, A = {
			...useContext(MotionConfigContext),
			...D,
			layoutId: useLayoutId(D)
		}, { isStatic: j } = A, M = useCreateMotionContext(D), P = T(D, j);
		if (!j && isBrowser$1) {
			useStrictMode(A, S);
			let x = getProjectionFunctionality(A);
			k = x.MeasureLayout, M.visualElement = useVisualElement(m, P, A, C, x.ProjectionNode);
		}
		return jsxs(MotionContext.Provider, {
			value: M,
			children: [k && M.visualElement ? jsx(k, {
				visualElement: M.visualElement,
				...A
			}) : null, useRender(m, D, useMotionRef(P, M.visualElement, O), P, j, x)]
		});
	}
	D.displayName = `motion.${typeof m == "string" ? m : `create(${m.displayName ?? m.name ?? ""})`}`;
	let k = forwardRef(D);
	return k[motionComponentSymbol] = m, k;
}
function useLayoutId({ layoutId: m }) {
	let x = useContext(LayoutGroupContext).id;
	return x && m !== void 0 ? x + "-" + m : m;
}
function useStrictMode(m, x) {
	let S = useContext(LazyContext).strict;
	if (process.env.NODE_ENV !== "production" && x && S) {
		let x = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
		m.ignoreStrict ? warning(!1, x, "lazy-strict-mode") : invariant(!1, x, "lazy-strict-mode");
	}
}
function getProjectionFunctionality(m) {
	let { drag: x, layout: S } = featureDefinitions;
	if (!x && !S) return {};
	let C = {
		...x,
		...S
	};
	return {
		MeasureLayout: x?.isEnabled(m) || S?.isEnabled(m) ? C.MeasureLayout : void 0,
		ProjectionNode: C.ProjectionNode
	};
}
function createMotionProxy(m, x) {
	if (typeof Proxy > "u") return createMotionComponent;
	let S = /* @__PURE__ */ new Map(), C = (S, C) => createMotionComponent(S, C, m, x);
	return new Proxy((m, x) => (process.env.NODE_ENV !== "production" && warnOnce(!1, "motion() is deprecated. Use motion.create() instead."), C(m, x)), { get: (T, D) => D === "create" ? C : (S.has(D) || S.set(D, createMotionComponent(D, void 0, m, x)), S.get(D)) });
}
function convertBoundingBoxToBox({ top: m, left: x, right: S, bottom: C }) {
	return {
		x: {
			min: x,
			max: S
		},
		y: {
			min: m,
			max: C
		}
	};
}
function convertBoxToBoundingBox({ x: m, y: x }) {
	return {
		top: x.min,
		right: m.max,
		bottom: x.max,
		left: m.min
	};
}
function transformBoxPoints(m, x) {
	if (!x) return m;
	let S = x({
		x: m.left,
		y: m.top
	}), C = x({
		x: m.right,
		y: m.bottom
	});
	return {
		top: S.y,
		left: S.x,
		bottom: C.y,
		right: C.x
	};
}
function isIdentityScale(m) {
	return m === void 0 || m === 1;
}
function hasScale({ scale: m, scaleX: x, scaleY: S }) {
	return !isIdentityScale(m) || !isIdentityScale(x) || !isIdentityScale(S);
}
function hasTransform(m) {
	return hasScale(m) || has2DTranslate(m) || m.z || m.rotate || m.rotateX || m.rotateY || m.skewX || m.skewY;
}
function has2DTranslate(m) {
	return is2DTranslate(m.x) || is2DTranslate(m.y);
}
function is2DTranslate(m) {
	return m && m !== "0%";
}
function scalePoint(m, x, S) {
	return S + x * (m - S);
}
function applyPointDelta(m, x, S, C, T) {
	return T !== void 0 && (m = scalePoint(m, T, C)), scalePoint(m, S, C) + x;
}
function applyAxisDelta(m, x = 0, S = 1, C, T) {
	m.min = applyPointDelta(m.min, x, S, C, T), m.max = applyPointDelta(m.max, x, S, C, T);
}
function applyBoxDelta(m, { x, y: S }) {
	applyAxisDelta(m.x, x.translate, x.scale, x.originPoint), applyAxisDelta(m.y, S.translate, S.scale, S.originPoint);
}
var TREE_SCALE_SNAP_MIN = .999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(m, x, S, C = !1) {
	let T = S.length;
	if (!T) return;
	x.x = x.y = 1;
	let D, O;
	for (let k = 0; k < T; k++) {
		D = S[k], O = D.projectionDelta;
		let { visualElement: T } = D.options;
		T && T.props.style && T.props.style.display === "contents" || (C && D.options.layoutScroll && D.scroll && D !== D.root && transformBox(m, {
			x: -D.scroll.offset.x,
			y: -D.scroll.offset.y
		}), O && (x.x *= O.x.scale, x.y *= O.y.scale, applyBoxDelta(m, O)), C && hasTransform(D.latestValues) && transformBox(m, D.latestValues));
	}
	x.x < TREE_SCALE_SNAP_MAX && x.x > TREE_SCALE_SNAP_MIN && (x.x = 1), x.y < TREE_SCALE_SNAP_MAX && x.y > TREE_SCALE_SNAP_MIN && (x.y = 1);
}
function translateAxis(m, x) {
	m.min += x, m.max += x;
}
function transformAxis(m, x, S, C, T = .5) {
	applyAxisDelta(m, x, S, mixNumber(m.min, m.max, T), C);
}
function transformBox(m, x) {
	transformAxis(m.x, x.x, x.scaleX, x.scale, x.originX), transformAxis(m.y, x.y, x.scaleY, x.scale, x.originY);
}
function measureViewportBox(m, x) {
	return convertBoundingBoxToBox(transformBoxPoints(m.getBoundingClientRect(), x));
}
function measurePageBox(m, x, S) {
	let C = measureViewportBox(m, S), { scroll: T } = x;
	return T && (translateAxis(C.x, T.offset.x), translateAxis(C.y, T.offset.y)), C;
}
var createAxisDelta = () => ({
	translate: 0,
	scale: 1,
	origin: 0,
	originPoint: 0
}), createDelta = () => ({
	x: createAxisDelta(),
	y: createAxisDelta()
}), createAxis = () => ({
	min: 0,
	max: 0
}), createBox = () => ({
	x: createAxis(),
	y: createAxis()
}), prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
	if (hasReducedMotionListener.current = !0, isBrowser$1) if (window.matchMedia) {
		let m = window.matchMedia("(prefers-reduced-motion)"), x = () => prefersReducedMotion.current = m.matches;
		m.addEventListener("change", x), x();
	} else prefersReducedMotion.current = !1;
}
var visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(m, x, S) {
	for (let C in x) {
		let T = x[C], D = S[C];
		if (isMotionValue(T)) m.addValue(C, T);
		else if (isMotionValue(D)) m.addValue(C, motionValue(T, { owner: m }));
		else if (D !== T) if (m.hasValue(C)) {
			let x = m.getValue(C);
			x.liveStyle === !0 ? x.jump(T) : x.hasAnimated || x.set(T);
		} else {
			let x = m.getStaticValue(C);
			m.addValue(C, motionValue(x === void 0 ? T : x, { owner: m }));
		}
	}
	for (let C in S) x[C] === void 0 && m.removeValue(C);
	return x;
}
var propEventHandlers = [
	"AnimationStart",
	"AnimationComplete",
	"Update",
	"BeforeLayoutMeasure",
	"LayoutMeasure",
	"LayoutAnimationStart",
	"LayoutAnimationComplete"
], VisualElement = class {
	scrapeMotionValuesFromProps(m, x, S) {
		return {};
	}
	constructor({ parent: m, props: x, presenceContext: S, reducedMotionConfig: C, blockInitialAnimation: T, visualState: D }, O = {}) {
		this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
			this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
		}, this.renderScheduledAt = 0, this.scheduleRender = () => {
			let m = time.now();
			this.renderScheduledAt < m && (this.renderScheduledAt = m, frame.render(this.render, !1, !0));
		};
		let { latestValues: k, renderState: A } = D;
		this.latestValues = k, this.baseTarget = { ...k }, this.initialValues = x.initial ? { ...k } : {}, this.renderState = A, this.parent = m, this.props = x, this.presenceContext = S, this.depth = m ? m.depth + 1 : 0, this.reducedMotionConfig = C, this.options = O, this.blockInitialAnimation = !!T, this.isControllingVariants = isControllingVariants(x), this.isVariantNode = isVariantNode(x), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(m && m.current);
		let { willChange: j, ...M } = this.scrapeMotionValuesFromProps(x, {}, this);
		for (let m in M) {
			let x = M[m];
			k[m] !== void 0 && isMotionValue(x) && x.set(k[m]);
		}
	}
	mount(m) {
		this.current = m, visualElementStore.set(m, this), this.projection && !this.projection.instance && this.projection.mount(m), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((m, x) => this.bindToMotionValue(x, m)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, process.env.NODE_ENV !== "production" && warnOnce(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled"), this.parent?.addChild(this), this.update(this.props, this.presenceContext);
	}
	unmount() {
		for (let m in this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((m) => m()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this), this.events) this.events[m].clear();
		for (let m in this.features) {
			let x = this.features[m];
			x && (x.unmount(), x.isMounted = !1);
		}
		this.current = null;
	}
	addChild(m) {
		this.children.add(m), this.enteringChildren ??= /* @__PURE__ */ new Set(), this.enteringChildren.add(m);
	}
	removeChild(m) {
		this.children.delete(m), this.enteringChildren && this.enteringChildren.delete(m);
	}
	bindToMotionValue(m, x) {
		this.valueSubscriptions.has(m) && this.valueSubscriptions.get(m)();
		let S = transformProps.has(m);
		S && this.onBindTransform && this.onBindTransform();
		let C = x.on("change", (x) => {
			this.latestValues[m] = x, this.props.onUpdate && frame.preRender(this.notifyUpdate), S && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
		}), T;
		window.MotionCheckAppearSync && (T = window.MotionCheckAppearSync(this, m, x)), this.valueSubscriptions.set(m, () => {
			C(), T && T(), x.owner && x.stop();
		});
	}
	sortNodePosition(m) {
		return !this.current || !this.sortInstanceNodePosition || this.type !== m.type ? 0 : this.sortInstanceNodePosition(this.current, m.current);
	}
	updateFeatures() {
		let m = "animation";
		for (m in featureDefinitions) {
			let x = featureDefinitions[m];
			if (!x) continue;
			let { isEnabled: S, Feature: C } = x;
			if (!this.features[m] && C && S(this.props) && (this.features[m] = new C(this)), this.features[m]) {
				let x = this.features[m];
				x.isMounted ? x.update() : (x.mount(), x.isMounted = !0);
			}
		}
	}
	triggerBuild() {
		this.build(this.renderState, this.latestValues, this.props);
	}
	measureViewportBox() {
		return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
	}
	getStaticValue(m) {
		return this.latestValues[m];
	}
	setStaticValue(m, x) {
		this.latestValues[m] = x;
	}
	update(m, x) {
		(m.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = m, this.prevPresenceContext = this.presenceContext, this.presenceContext = x;
		for (let x = 0; x < propEventHandlers.length; x++) {
			let S = propEventHandlers[x];
			this.propEventSubscriptions[S] && (this.propEventSubscriptions[S](), delete this.propEventSubscriptions[S]);
			let C = m["on" + S];
			C && (this.propEventSubscriptions[S] = this.on(S, C));
		}
		this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(m, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
	}
	getProps() {
		return this.props;
	}
	getVariant(m) {
		return this.props.variants ? this.props.variants[m] : void 0;
	}
	getDefaultTransition() {
		return this.props.transition;
	}
	getTransformPagePoint() {
		return this.props.transformPagePoint;
	}
	getClosestVariantNode() {
		return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
	}
	addVariantChild(m) {
		let x = this.getClosestVariantNode();
		if (x) return x.variantChildren && x.variantChildren.add(m), () => x.variantChildren.delete(m);
	}
	addValue(m, x) {
		let S = this.values.get(m);
		x !== S && (S && this.removeValue(m), this.bindToMotionValue(m, x), this.values.set(m, x), this.latestValues[m] = x.get());
	}
	removeValue(m) {
		this.values.delete(m);
		let x = this.valueSubscriptions.get(m);
		x && (x(), this.valueSubscriptions.delete(m)), delete this.latestValues[m], this.removeValueFromRenderState(m, this.renderState);
	}
	hasValue(m) {
		return this.values.has(m);
	}
	getValue(m, x) {
		if (this.props.values && this.props.values[m]) return this.props.values[m];
		let S = this.values.get(m);
		return S === void 0 && x !== void 0 && (S = motionValue(x === null ? void 0 : x, { owner: this }), this.addValue(m, S)), S;
	}
	readValue(m, x) {
		let S = this.latestValues[m] !== void 0 || !this.current ? this.latestValues[m] : this.getBaseTargetFromProps(this.props, m) ?? this.readValueFromInstance(this.current, m, this.options);
		return S != null && (typeof S == "string" && (isNumericalString(S) || isZeroValueString(S)) ? S = parseFloat(S) : !findValueType(S) && complex.test(x) && (S = getAnimatableNone(m, x)), this.setBaseTarget(m, isMotionValue(S) ? S.get() : S)), isMotionValue(S) ? S.get() : S;
	}
	setBaseTarget(m, x) {
		this.baseTarget[m] = x;
	}
	getBaseTarget(m) {
		let { initial: x } = this.props, S;
		if (typeof x == "string" || typeof x == "object") {
			let C = resolveVariantFromProps(this.props, x, this.presenceContext?.custom);
			C && (S = C[m]);
		}
		if (x && S !== void 0) return S;
		let C = this.getBaseTargetFromProps(this.props, m);
		return C !== void 0 && !isMotionValue(C) ? C : this.initialValues[m] !== void 0 && S === void 0 ? void 0 : this.baseTarget[m];
	}
	on(m, x) {
		return this.events[m] || (this.events[m] = new SubscriptionManager()), this.events[m].add(x);
	}
	notify(m, ...x) {
		this.events[m] && this.events[m].notify(...x);
	}
	scheduleRenderMicrotask() {
		microtask.render(this.render);
	}
}, DOMVisualElement = class extends VisualElement {
	constructor() {
		super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
	}
	sortInstanceNodePosition(m, x) {
		return m.compareDocumentPosition(x) & 2 ? 1 : -1;
	}
	getBaseTargetFromProps(m, x) {
		return m.style ? m.style[x] : void 0;
	}
	removeValueFromRenderState(m, { vars: x, style: S }) {
		delete x[m], delete S[m];
	}
	handleChildMotionValue() {
		this.childSubscription && (this.childSubscription(), delete this.childSubscription);
		let { children: m } = this.props;
		isMotionValue(m) && (this.childSubscription = m.on("change", (m) => {
			this.current && (this.current.textContent = `${m}`);
		}));
	}
};
function renderHTML(m, { style: x, vars: S }, C, T) {
	let D = m.style, O;
	for (O in x) D[O] = x[O];
	for (O in T?.applyProjectionStyles(D, C), S) D.setProperty(O, S[O]);
}
function getComputedStyle$2(m) {
	return window.getComputedStyle(m);
}
var HTMLVisualElement = class extends DOMVisualElement {
	constructor() {
		super(...arguments), this.type = "html", this.renderInstance = renderHTML;
	}
	readValueFromInstance(m, x) {
		if (transformProps.has(x)) return this.projection?.isProjecting ? defaultTransformValue(x) : readTransformValue(m, x);
		{
			let S = getComputedStyle$2(m), C = (isCSSVariableName(x) ? S.getPropertyValue(x) : S[x]) || 0;
			return typeof C == "string" ? C.trim() : C;
		}
	}
	measureInstanceViewportBox(m, { transformPagePoint: x }) {
		return measureViewportBox(m, x);
	}
	build(m, x, S) {
		buildHTMLStyles(m, x, S.transformTemplate);
	}
	scrapeMotionValuesFromProps(m, x, S) {
		return scrapeMotionValuesFromProps$1(m, x, S);
	}
}, camelCaseAttributes = new Set([
	"baseFrequency",
	"diffuseConstant",
	"kernelMatrix",
	"kernelUnitLength",
	"keySplines",
	"keyTimes",
	"limitingConeAngle",
	"markerHeight",
	"markerWidth",
	"numOctaves",
	"targetX",
	"targetY",
	"surfaceScale",
	"specularConstant",
	"specularExponent",
	"stdDeviation",
	"tableValues",
	"viewBox",
	"gradientTransform",
	"pathLength",
	"startOffset",
	"textLength",
	"lengthAdjust"
]);
function renderSVG(m, x, S, C) {
	for (let S in renderHTML(m, x, void 0, C), x.attrs) m.setAttribute(camelCaseAttributes.has(S) ? S : camelToDash(S), x.attrs[S]);
}
var SVGVisualElement = class extends DOMVisualElement {
	constructor() {
		super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox;
	}
	getBaseTargetFromProps(m, x) {
		return m[x];
	}
	readValueFromInstance(m, x) {
		if (transformProps.has(x)) {
			let m = getDefaultValueType(x);
			return m && m.default || 0;
		}
		return x = camelCaseAttributes.has(x) ? x : camelToDash(x), m.getAttribute(x);
	}
	scrapeMotionValuesFromProps(m, x, S) {
		return scrapeMotionValuesFromProps(m, x, S);
	}
	build(m, x, S) {
		buildSVGAttrs(m, x, this.isSVGTag, S.transformTemplate, S.style);
	}
	renderInstance(m, x, S, C) {
		renderSVG(m, x, S, C);
	}
	mount(m) {
		this.isSVGTag = isSVGTag(m.tagName), super.mount(m);
	}
}, createDomVisualElement = (m, x) => isSVGComponent(m) ? new SVGVisualElement(x) : new HTMLVisualElement(x, { allowProjection: m !== Fragment });
function resolveVariant(m, x, S) {
	let C = m.getProps();
	return resolveVariantFromProps(C, x, S === void 0 ? C.custom : S, m);
}
var isKeyframesTarget = (m) => Array.isArray(m);
function setMotionValue(m, x, S) {
	m.hasValue(x) ? m.getValue(x).set(S) : m.addValue(x, motionValue(S));
}
function resolveFinalValueInKeyframes(m) {
	return isKeyframesTarget(m) ? m[m.length - 1] || 0 : m;
}
function setTarget(m, x) {
	let { transitionEnd: S = {}, transition: C = {}, ...T } = resolveVariant(m, x) || {};
	for (let x in T = {
		...T,
		...S
	}, T) setMotionValue(m, x, resolveFinalValueInKeyframes(T[x]));
}
function isWillChangeMotionValue(m) {
	return !!(isMotionValue(m) && m.add);
}
function addValueToWillChange(m, x) {
	let S = m.getValue("willChange");
	if (isWillChangeMotionValue(S)) return S.add(x);
	if (!S && MotionGlobalConfig.WillChange) {
		let S = new MotionGlobalConfig.WillChange("auto");
		m.addValue("willChange", S), S.add(x);
	}
}
function getOptimisedAppearId(m) {
	return m.props[optimizedAppearDataAttribute];
}
var isNotNull = (m) => m !== null;
function getFinalKeyframe(m, { repeat: x, repeatType: S = "loop" }, C) {
	let T = m.filter(isNotNull), D = x && S !== "loop" && x % 2 == 1 ? 0 : T.length - 1;
	return !D || C === void 0 ? T[D] : C;
}
var underDampedSpring = {
	type: "spring",
	stiffness: 500,
	damping: 25,
	restSpeed: 10
}, criticallyDampedSpring = (m) => ({
	type: "spring",
	stiffness: 550,
	damping: m === 0 ? 2 * Math.sqrt(550) : 30,
	restSpeed: 10
}), keyframesTransition = {
	type: "keyframes",
	duration: .8
}, ease = {
	type: "keyframes",
	ease: [
		.25,
		.1,
		.35,
		1
	],
	duration: .3
}, getDefaultTransition = (m, { keyframes: x }) => x.length > 2 ? keyframesTransition : transformProps.has(m) ? m.startsWith("scale") ? criticallyDampedSpring(x[1]) : underDampedSpring : ease;
function isTransitionDefined({ when: m, delay: x, delayChildren: S, staggerChildren: C, staggerDirection: T, repeat: D, repeatType: O, repeatDelay: k, from: A, elapsed: j, ...M }) {
	return !!Object.keys(M).length;
}
var animateMotionValue = (m, x, S, C = {}, T, D) => (O) => {
	let k = getValueTransition(C, m) || {}, A = k.delay || C.delay || 0, { elapsed: j = 0 } = C;
	j -= /* @__PURE__ */ secondsToMilliseconds(A);
	let M = {
		keyframes: Array.isArray(S) ? S : [null, S],
		ease: "easeOut",
		velocity: x.getVelocity(),
		...k,
		delay: -j,
		onUpdate: (m) => {
			x.set(m), k.onUpdate && k.onUpdate(m);
		},
		onComplete: () => {
			O(), k.onComplete && k.onComplete();
		},
		name: m,
		motionValue: x,
		element: D ? void 0 : T
	};
	isTransitionDefined(k) || Object.assign(M, getDefaultTransition(m, M)), M.duration &&= /* @__PURE__ */ secondsToMilliseconds(M.duration), M.repeatDelay &&= /* @__PURE__ */ secondsToMilliseconds(M.repeatDelay), M.from !== void 0 && (M.keyframes[0] = M.from);
	let N = !1;
	if ((M.type === !1 || M.duration === 0 && !M.repeatDelay) && (makeAnimationInstant(M), M.delay === 0 && (N = !0)), (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) && (N = !0, makeAnimationInstant(M), M.delay = 0), M.allowFlatten = !k.type && !k.ease, N && !D && x.get() !== void 0) {
		let m = getFinalKeyframe(M.keyframes, k);
		if (m !== void 0) {
			frame.update(() => {
				M.onUpdate(m), M.onComplete();
			});
			return;
		}
	}
	return k.isSync ? new JSAnimation(M) : new AsyncMotionValueAnimation(M);
};
function shouldBlockAnimation({ protectedKeys: m, needsAnimating: x }, S) {
	let C = m.hasOwnProperty(S) && x[S] !== !0;
	return x[S] = !1, C;
}
function animateTarget(m, x, { delay: S = 0, transitionOverride: C, type: T } = {}) {
	let { transition: D = m.getDefaultTransition(), transitionEnd: O, ...k } = x;
	C && (D = C);
	let A = [], j = T && m.animationState && m.animationState.getState()[T];
	for (let x in k) {
		let C = m.getValue(x, m.latestValues[x] ?? null), T = k[x];
		if (T === void 0 || j && shouldBlockAnimation(j, x)) continue;
		let O = {
			delay: S,
			...getValueTransition(D || {}, x)
		}, M = C.get();
		if (M !== void 0 && !C.isAnimating && !Array.isArray(T) && T === M && !O.velocity) continue;
		let N = !1;
		if (window.MotionHandoffAnimation) {
			let S = getOptimisedAppearId(m);
			if (S) {
				let m = window.MotionHandoffAnimation(S, x, frame);
				m !== null && (O.startTime = m, N = !0);
			}
		}
		addValueToWillChange(m, x), C.start(animateMotionValue(x, C, T, m.shouldReduceMotion && positionalKeys.has(x) ? { type: !1 } : O, m, N));
		let P = C.animation;
		P && A.push(P);
	}
	return O && Promise.all(A).then(() => {
		frame.update(() => {
			O && setTarget(m, O);
		});
	}), A;
}
function calcChildStagger(m, x, S, C = 0, T = 1) {
	let D = Array.from(m).sort((m, x) => m.sortNodePosition(x)).indexOf(x), O = m.size, k = (O - 1) * C;
	return typeof S == "function" ? S(D, O) : T === 1 ? D * C : k - D * C;
}
function animateVariant(m, x, S = {}) {
	let C = resolveVariant(m, x, S.type === "exit" ? m.presenceContext?.custom : void 0), { transition: T = m.getDefaultTransition() || {} } = C || {};
	S.transitionOverride && (T = S.transitionOverride);
	let D = C ? () => Promise.all(animateTarget(m, C, S)) : () => Promise.resolve(), O = m.variantChildren && m.variantChildren.size ? (C = 0) => {
		let { delayChildren: D = 0, staggerChildren: O, staggerDirection: k } = T;
		return animateChildren(m, x, C, D, O, k, S);
	} : () => Promise.resolve(), { when: k } = T;
	if (k) {
		let [m, x] = k === "beforeChildren" ? [D, O] : [O, D];
		return m().then(() => x());
	} else return Promise.all([D(), O(S.delay)]);
}
function animateChildren(m, x, S = 0, C = 0, T = 0, D = 1, O) {
	let k = [];
	for (let A of m.variantChildren) A.notify("AnimationStart", x), k.push(animateVariant(A, x, {
		...O,
		delay: S + (typeof C == "function" ? 0 : C) + calcChildStagger(m.variantChildren, A, C, T, D)
	}).then(() => A.notify("AnimationComplete", x)));
	return Promise.all(k);
}
function animateVisualElement(m, x, S = {}) {
	m.notify("AnimationStart", x);
	let C;
	if (Array.isArray(x)) {
		let T = x.map((x) => animateVariant(m, x, S));
		C = Promise.all(T);
	} else if (typeof x == "string") C = animateVariant(m, x, S);
	else {
		let T = typeof x == "function" ? resolveVariant(m, x, S.custom) : x;
		C = Promise.all(animateTarget(m, T, S));
	}
	return C.then(() => {
		m.notify("AnimationComplete", x);
	});
}
function shallowCompare(m, x) {
	if (!Array.isArray(x)) return !1;
	let S = x.length;
	if (S !== m.length) return !1;
	for (let C = 0; C < S; C++) if (x[C] !== m[C]) return !1;
	return !0;
}
var numVariantProps = variantProps.length;
function getVariantContext(m) {
	if (!m) return;
	if (!m.isControllingVariants) {
		let x = m.parent && getVariantContext(m.parent) || {};
		return m.props.initial !== void 0 && (x.initial = m.props.initial), x;
	}
	let x = {};
	for (let S = 0; S < numVariantProps; S++) {
		let C = variantProps[S], T = m.props[C];
		(isVariantLabel(T) || T === !1) && (x[C] = T);
	}
	return x;
}
var reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(m) {
	return (x) => Promise.all(x.map(({ animation: x, options: S }) => animateVisualElement(m, x, S)));
}
function createAnimationState(m) {
	let x = animateList(m), S = createState(), C = !0, T = (x) => (S, C) => {
		let T = resolveVariant(m, C, x === "exit" ? m.presenceContext?.custom : void 0);
		if (T) {
			let { transition: m, transitionEnd: x, ...C } = T;
			S = {
				...S,
				...C,
				...x
			};
		}
		return S;
	};
	function D(S) {
		x = S(m);
	}
	function O(D) {
		let { props: O } = m, k = getVariantContext(m.parent) || {}, A = [], j = /* @__PURE__ */ new Set(), M = {}, N = Infinity;
		for (let x = 0; x < numAnimationTypes; x++) {
			let P = reversePriorityOrder[x], F = S[P], I = O[P] === void 0 ? k[P] : O[P], L = isVariantLabel(I), R = P === D ? F.isActive : null;
			R === !1 && (N = x);
			let z = I === k[P] && I !== O[P] && L;
			if (z && C && m.manuallyAnimateOnMount && (z = !1), F.protectedKeys = { ...M }, !F.isActive && R === null || !I && !F.prevProp || isAnimationControls(I) || typeof I == "boolean") continue;
			let B = checkVariantsDidChange(F.prevProp, I), H = B || P === D && F.isActive && !z && L || x > N && L, U = !1, W = Array.isArray(I) ? I : [I], G = W.reduce(T(P), {});
			R === !1 && (G = {});
			let { prevResolvedValues: K = {} } = F, q = {
				...K,
				...G
			}, J = (x) => {
				H = !0, j.has(x) && (U = !0, j.delete(x)), F.needsAnimating[x] = !0;
				let S = m.getValue(x);
				S && (S.liveStyle = !1);
			};
			for (let m in q) {
				let x = G[m], S = K[m];
				if (M.hasOwnProperty(m)) continue;
				let C = !1;
				C = isKeyframesTarget(x) && isKeyframesTarget(S) ? !shallowCompare(x, S) : x !== S, C ? x == null ? j.add(m) : J(m) : x !== void 0 && j.has(m) ? J(m) : F.protectedKeys[m] = !0;
			}
			F.prevProp = I, F.prevResolvedValues = G, F.isActive && (M = {
				...M,
				...G
			}), C && m.blockInitialAnimation && (H = !1);
			let Y = z && B;
			H && (!Y || U) && A.push(...W.map((x) => {
				let S = { type: P };
				if (typeof x == "string" && C && !Y && m.manuallyAnimateOnMount && m.parent) {
					let { parent: C } = m, T = resolveVariant(C, x);
					if (C.enteringChildren && T) {
						let { delayChildren: x } = T.transition || {};
						S.delay = calcChildStagger(C.enteringChildren, m, x);
					}
				}
				return {
					animation: x,
					options: S
				};
			}));
		}
		if (j.size) {
			let x = {};
			if (typeof O.initial != "boolean") {
				let S = resolveVariant(m, Array.isArray(O.initial) ? O.initial[0] : O.initial);
				S && S.transition && (x.transition = S.transition);
			}
			j.forEach((S) => {
				let C = m.getBaseTarget(S), T = m.getValue(S);
				T && (T.liveStyle = !0), x[S] = C ?? null;
			}), A.push({ animation: x });
		}
		let P = !!A.length;
		return C && (O.initial === !1 || O.initial === O.animate) && !m.manuallyAnimateOnMount && (P = !1), C = !1, P ? x(A) : Promise.resolve();
	}
	function k(x, C) {
		if (S[x].isActive === C) return Promise.resolve();
		m.variantChildren?.forEach((m) => m.animationState?.setActive(x, C)), S[x].isActive = C;
		let T = O(x);
		for (let m in S) S[m].protectedKeys = {};
		return T;
	}
	return {
		animateChanges: O,
		setActive: k,
		setAnimateFunction: D,
		getState: () => S,
		reset: () => {
			S = createState();
		}
	};
}
function checkVariantsDidChange(m, x) {
	return typeof x == "string" ? x !== m : Array.isArray(x) ? !shallowCompare(x, m) : !1;
}
function createTypeState(m = !1) {
	return {
		isActive: m,
		protectedKeys: {},
		needsAnimating: {},
		prevResolvedValues: {}
	};
}
function createState() {
	return {
		animate: createTypeState(!0),
		whileInView: createTypeState(),
		whileHover: createTypeState(),
		whileTap: createTypeState(),
		whileDrag: createTypeState(),
		whileFocus: createTypeState(),
		exit: createTypeState()
	};
}
var Feature = class {
	constructor(m) {
		this.isMounted = !1, this.node = m;
	}
	update() {}
}, AnimationFeature = class extends Feature {
	constructor(m) {
		super(m), m.animationState ||= createAnimationState(m);
	}
	updateAnimationControlsSubscription() {
		let { animate: m } = this.node.getProps();
		isAnimationControls(m) && (this.unmountControls = m.subscribe(this.node));
	}
	mount() {
		this.updateAnimationControlsSubscription();
	}
	update() {
		let { animate: m } = this.node.getProps(), { animate: x } = this.node.prevProps || {};
		m !== x && this.updateAnimationControlsSubscription();
	}
	unmount() {
		this.node.animationState.reset(), this.unmountControls?.();
	}
}, id$1 = 0, animations = {
	animation: { Feature: AnimationFeature },
	exit: { Feature: class extends Feature {
		constructor() {
			super(...arguments), this.id = id$1++;
		}
		update() {
			if (!this.node.presenceContext) return;
			let { isPresent: m, onExitComplete: x } = this.node.presenceContext, { isPresent: S } = this.node.prevPresenceContext || {};
			if (!this.node.animationState || m === S) return;
			let C = this.node.animationState.setActive("exit", !m);
			x && !m && C.then(() => {
				x(this.id);
			});
		}
		mount() {
			let { register: m, onExitComplete: x } = this.node.presenceContext || {};
			x && x(this.id), m && (this.unmount = m(this.id));
		}
		unmount() {}
	} }
};
function addDomEvent(m, x, S, C = { passive: !0 }) {
	return m.addEventListener(x, S, C), () => m.removeEventListener(x, S);
}
function extractEventInfo(m) {
	return { point: {
		x: m.pageX,
		y: m.pageY
	} };
}
var addPointerInfo = (m) => (x) => isPrimaryPointer(x) && m(x, extractEventInfo(x));
function addPointerEvent(m, x, S, C) {
	return addDomEvent(m, x, addPointerInfo(S), C);
}
var SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = .01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(m) {
	return m.max - m.min;
}
function isNear(m, x, S) {
	return Math.abs(m - x) <= S;
}
function calcAxisDelta(m, x, S, C = .5) {
	m.origin = C, m.originPoint = mixNumber(x.min, x.max, m.origin), m.scale = calcLength(S) / calcLength(x), m.translate = mixNumber(S.min, S.max, m.origin) - m.originPoint, (m.scale >= SCALE_MIN && m.scale <= SCALE_MAX || isNaN(m.scale)) && (m.scale = 1), (m.translate >= TRANSLATE_MIN && m.translate <= TRANSLATE_MAX || isNaN(m.translate)) && (m.translate = 0);
}
function calcBoxDelta(m, x, S, C) {
	calcAxisDelta(m.x, x.x, S.x, C ? C.originX : void 0), calcAxisDelta(m.y, x.y, S.y, C ? C.originY : void 0);
}
function calcRelativeAxis(m, x, S) {
	m.min = S.min + x.min, m.max = m.min + calcLength(x);
}
function calcRelativeBox(m, x, S) {
	calcRelativeAxis(m.x, x.x, S.x), calcRelativeAxis(m.y, x.y, S.y);
}
function calcRelativeAxisPosition(m, x, S) {
	m.min = x.min - S.min, m.max = m.min + calcLength(x);
}
function calcRelativePosition(m, x, S) {
	calcRelativeAxisPosition(m.x, x.x, S.x), calcRelativeAxisPosition(m.y, x.y, S.y);
}
function eachAxis(m) {
	return [m("x"), m("y")];
}
var getContextWindow = ({ current: m }) => m ? m.ownerDocument.defaultView : null, distance = (m, x) => Math.abs(m - x);
function distance2D(m, x) {
	let S = distance(m.x, x.x), C = distance(m.y, x.y);
	return Math.sqrt(S ** 2 + C ** 2);
}
var PanSession = class {
	constructor(m, x, { transformPagePoint: S, contextWindow: C = window, dragSnapToOrigin: T = !1, distanceThreshold: D = 3 } = {}) {
		if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
			if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
			let m = getPanInfo(this.lastMoveEventInfo, this.history), x = this.startEvent !== null, S = distance2D(m.offset, {
				x: 0,
				y: 0
			}) >= this.distanceThreshold;
			if (!x && !S) return;
			let { point: C } = m, { timestamp: T } = frameData;
			this.history.push({
				...C,
				timestamp: T
			});
			let { onStart: D, onMove: O } = this.handlers;
			x || (D && D(this.lastMoveEvent, m), this.startEvent = this.lastMoveEvent), O && O(this.lastMoveEvent, m);
		}, this.handlePointerMove = (m, x) => {
			this.lastMoveEvent = m, this.lastMoveEventInfo = transformPoint(x, this.transformPagePoint), frame.update(this.updatePoint, !0);
		}, this.handlePointerUp = (m, x) => {
			this.end();
			let { onEnd: S, onSessionEnd: C, resumeAnimation: T } = this.handlers;
			if (this.dragSnapToOrigin && T && T(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
			let D = getPanInfo(m.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(x, this.transformPagePoint), this.history);
			this.startEvent && S && S(m, D), C && C(m, D);
		}, !isPrimaryPointer(m)) return;
		this.dragSnapToOrigin = T, this.handlers = x, this.transformPagePoint = S, this.distanceThreshold = D, this.contextWindow = C || window;
		let O = transformPoint(extractEventInfo(m), this.transformPagePoint), { point: k } = O, { timestamp: A } = frameData;
		this.history = [{
			...k,
			timestamp: A
		}];
		let { onSessionStart: j } = x;
		j && j(m, getPanInfo(O, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
	}
	updateHandlers(m) {
		this.handlers = m;
	}
	end() {
		this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
	}
};
function transformPoint(m, x) {
	return x ? { point: x(m.point) } : m;
}
function subtractPoint(m, x) {
	return {
		x: m.x - x.x,
		y: m.y - x.y
	};
}
function getPanInfo({ point: m }, x) {
	return {
		point: m,
		delta: subtractPoint(m, lastDevicePoint(x)),
		offset: subtractPoint(m, startDevicePoint(x)),
		velocity: getVelocity(x, .1)
	};
}
function startDevicePoint(m) {
	return m[0];
}
function lastDevicePoint(m) {
	return m[m.length - 1];
}
function getVelocity(m, x) {
	if (m.length < 2) return {
		x: 0,
		y: 0
	};
	let S = m.length - 1, C = null, T = lastDevicePoint(m);
	for (; S >= 0 && (C = m[S], !(T.timestamp - C.timestamp > /* @__PURE__ */ secondsToMilliseconds(x)));) S--;
	if (!C) return {
		x: 0,
		y: 0
	};
	let D = /* @__PURE__ */ millisecondsToSeconds(T.timestamp - C.timestamp);
	if (D === 0) return {
		x: 0,
		y: 0
	};
	let O = {
		x: (T.x - C.x) / D,
		y: (T.y - C.y) / D
	};
	return O.x === Infinity && (O.x = 0), O.y === Infinity && (O.y = 0), O;
}
function applyConstraints(m, { min: x, max: S }, C) {
	return x !== void 0 && m < x ? m = C ? mixNumber(x, m, C.min) : Math.max(m, x) : S !== void 0 && m > S && (m = C ? mixNumber(S, m, C.max) : Math.min(m, S)), m;
}
function calcRelativeAxisConstraints(m, x, S) {
	return {
		min: x === void 0 ? void 0 : m.min + x,
		max: S === void 0 ? void 0 : m.max + S - (m.max - m.min)
	};
}
function calcRelativeConstraints(m, { top: x, left: S, bottom: C, right: T }) {
	return {
		x: calcRelativeAxisConstraints(m.x, S, T),
		y: calcRelativeAxisConstraints(m.y, x, C)
	};
}
function calcViewportAxisConstraints(m, x) {
	let S = x.min - m.min, C = x.max - m.max;
	return x.max - x.min < m.max - m.min && ([S, C] = [C, S]), {
		min: S,
		max: C
	};
}
function calcViewportConstraints(m, x) {
	return {
		x: calcViewportAxisConstraints(m.x, x.x),
		y: calcViewportAxisConstraints(m.y, x.y)
	};
}
function calcOrigin(m, x) {
	let S = .5, C = calcLength(m), T = calcLength(x);
	return T > C ? S = /* @__PURE__ */ progress(x.min, x.max - C, m.min) : C > T && (S = /* @__PURE__ */ progress(m.min, m.max - T, x.min)), clamp$1(0, 1, S);
}
function rebaseAxisConstraints(m, x) {
	let S = {};
	return x.min !== void 0 && (S.min = x.min - m.min), x.max !== void 0 && (S.max = x.max - m.min), S;
}
var defaultElastic = .35;
function resolveDragElastic(m = defaultElastic) {
	return m === !1 ? m = 0 : m === !0 && (m = defaultElastic), {
		x: resolveAxisElastic(m, "left", "right"),
		y: resolveAxisElastic(m, "top", "bottom")
	};
}
function resolveAxisElastic(m, x, S) {
	return {
		min: resolvePointElastic(m, x),
		max: resolvePointElastic(m, S)
	};
}
function resolvePointElastic(m, x) {
	return typeof m == "number" ? m : m[x] || 0;
}
var elementDragControls = /* @__PURE__ */ new WeakMap(), VisualElementDragControls = class {
	constructor(m) {
		this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
			x: 0,
			y: 0
		}, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = m;
	}
	start(m, { snapToCursor: x = !1, distanceThreshold: S } = {}) {
		let { presenceContext: C } = this.visualElement;
		if (C && C.isPresent === !1) return;
		let T = (m) => {
			let { dragSnapToOrigin: S } = this.getProps();
			S ? this.pauseAnimation() : this.stopAnimation(), x && this.snapToCursor(extractEventInfo(m).point);
		}, D = (m, x) => {
			let { drag: S, dragPropagation: C, onDragStart: T } = this.getProps();
			if (S && !C && (this.openDragLock && this.openDragLock(), this.openDragLock = setDragLock(S), !this.openDragLock)) return;
			this.latestPointerEvent = m, this.latestPanInfo = x, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((m) => {
				let x = this.getAxisMotionValue(m).get() || 0;
				if (percent.test(x)) {
					let { projection: S } = this.visualElement;
					if (S && S.layout) {
						let C = S.layout.layoutBox[m];
						C && (x = calcLength(C) * (parseFloat(x) / 100));
					}
				}
				this.originPoint[m] = x;
			}), T && frame.postRender(() => T(m, x)), addValueToWillChange(this.visualElement, "transform");
			let { animationState: D } = this.visualElement;
			D && D.setActive("whileDrag", !0);
		}, O = (m, x) => {
			this.latestPointerEvent = m, this.latestPanInfo = x;
			let { dragPropagation: S, dragDirectionLock: C, onDirectionLock: T, onDrag: D } = this.getProps();
			if (!S && !this.openDragLock) return;
			let { offset: O } = x;
			if (C && this.currentDirection === null) {
				this.currentDirection = getCurrentDirection(O), this.currentDirection !== null && T && T(this.currentDirection);
				return;
			}
			this.updateAxis("x", x.point, O), this.updateAxis("y", x.point, O), this.visualElement.render(), D && D(m, x);
		}, k = (m, x) => {
			this.latestPointerEvent = m, this.latestPanInfo = x, this.stop(m, x), this.latestPointerEvent = null, this.latestPanInfo = null;
		}, A = () => eachAxis((m) => this.getAnimationState(m) === "paused" && this.getAxisMotionValue(m).animation?.play()), { dragSnapToOrigin: j } = this.getProps();
		this.panSession = new PanSession(m, {
			onSessionStart: T,
			onStart: D,
			onMove: O,
			onSessionEnd: k,
			resumeAnimation: A
		}, {
			transformPagePoint: this.visualElement.getTransformPagePoint(),
			dragSnapToOrigin: j,
			distanceThreshold: S,
			contextWindow: getContextWindow(this.visualElement)
		});
	}
	stop(m, x) {
		let S = m || this.latestPointerEvent, C = x || this.latestPanInfo, T = this.isDragging;
		if (this.cancel(), !T || !C || !S) return;
		let { velocity: D } = C;
		this.startAnimation(D);
		let { onDragEnd: O } = this.getProps();
		O && frame.postRender(() => O(S, C));
	}
	cancel() {
		this.isDragging = !1;
		let { projection: m, animationState: x } = this.visualElement;
		m && (m.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
		let { dragPropagation: S } = this.getProps();
		!S && this.openDragLock && (this.openDragLock(), this.openDragLock = null), x && x.setActive("whileDrag", !1);
	}
	updateAxis(m, x, S) {
		let { drag: C } = this.getProps();
		if (!S || !shouldDrag(m, C, this.currentDirection)) return;
		let T = this.getAxisMotionValue(m), D = this.originPoint[m] + S[m];
		this.constraints && this.constraints[m] && (D = applyConstraints(D, this.constraints[m], this.elastic[m])), T.set(D);
	}
	resolveConstraints() {
		let { dragConstraints: m, dragElastic: x } = this.getProps(), S = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, C = this.constraints;
		m && isRefObject(m) ? this.constraints ||= this.resolveRefConstraints() : m && S ? this.constraints = calcRelativeConstraints(S.layoutBox, m) : this.constraints = !1, this.elastic = resolveDragElastic(x), C !== this.constraints && S && this.constraints && !this.hasMutatedConstraints && eachAxis((m) => {
			this.constraints !== !1 && this.getAxisMotionValue(m) && (this.constraints[m] = rebaseAxisConstraints(S.layoutBox[m], this.constraints[m]));
		});
	}
	resolveRefConstraints() {
		let { dragConstraints: m, onMeasureDragConstraints: x } = this.getProps();
		if (!m || !isRefObject(m)) return !1;
		let S = m.current;
		invariant(S !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
		let { projection: C } = this.visualElement;
		if (!C || !C.layout) return !1;
		let T = measurePageBox(S, C.root, this.visualElement.getTransformPagePoint()), D = calcViewportConstraints(C.layout.layoutBox, T);
		if (x) {
			let m = x(convertBoxToBoundingBox(D));
			this.hasMutatedConstraints = !!m, m && (D = convertBoundingBoxToBox(m));
		}
		return D;
	}
	startAnimation(m) {
		let { drag: x, dragMomentum: S, dragElastic: C, dragTransition: T, dragSnapToOrigin: D, onDragTransitionEnd: O } = this.getProps(), k = this.constraints || {}, A = eachAxis((O) => {
			if (!shouldDrag(O, x, this.currentDirection)) return;
			let A = k && k[O] || {};
			D && (A = {
				min: 0,
				max: 0
			});
			let j = C ? 200 : 1e6, M = C ? 40 : 1e7, N = {
				type: "inertia",
				velocity: S ? m[O] : 0,
				bounceStiffness: j,
				bounceDamping: M,
				timeConstant: 750,
				restDelta: 1,
				restSpeed: 10,
				...T,
				...A
			};
			return this.startAxisValueAnimation(O, N);
		});
		return Promise.all(A).then(O);
	}
	startAxisValueAnimation(m, x) {
		let S = this.getAxisMotionValue(m);
		return addValueToWillChange(this.visualElement, m), S.start(animateMotionValue(m, S, 0, x, this.visualElement, !1));
	}
	stopAnimation() {
		eachAxis((m) => this.getAxisMotionValue(m).stop());
	}
	pauseAnimation() {
		eachAxis((m) => this.getAxisMotionValue(m).animation?.pause());
	}
	getAnimationState(m) {
		return this.getAxisMotionValue(m).animation?.state;
	}
	getAxisMotionValue(m) {
		let x = `_drag${m.toUpperCase()}`, S = this.visualElement.getProps();
		return S[x] || this.visualElement.getValue(m, (S.initial ? S.initial[m] : void 0) || 0);
	}
	snapToCursor(m) {
		eachAxis((x) => {
			let { drag: S } = this.getProps();
			if (!shouldDrag(x, S, this.currentDirection)) return;
			let { projection: C } = this.visualElement, T = this.getAxisMotionValue(x);
			if (C && C.layout) {
				let { min: S, max: D } = C.layout.layoutBox[x];
				T.set(m[x] - mixNumber(S, D, .5));
			}
		});
	}
	scalePositionWithinConstraints() {
		if (!this.visualElement.current) return;
		let { drag: m, dragConstraints: x } = this.getProps(), { projection: S } = this.visualElement;
		if (!isRefObject(x) || !S || !this.constraints) return;
		this.stopAnimation();
		let C = {
			x: 0,
			y: 0
		};
		eachAxis((m) => {
			let x = this.getAxisMotionValue(m);
			if (x && this.constraints !== !1) {
				let S = x.get();
				C[m] = calcOrigin({
					min: S,
					max: S
				}, this.constraints[m]);
			}
		});
		let { transformTemplate: T } = this.visualElement.getProps();
		this.visualElement.current.style.transform = T ? T({}, "") : "none", S.root && S.root.updateScroll(), S.updateLayout(), this.resolveConstraints(), eachAxis((x) => {
			if (!shouldDrag(x, m, null)) return;
			let S = this.getAxisMotionValue(x), { min: T, max: D } = this.constraints[x];
			S.set(mixNumber(T, D, C[x]));
		});
	}
	addListeners() {
		if (!this.visualElement.current) return;
		elementDragControls.set(this.visualElement, this);
		let m = this.visualElement.current, x = addPointerEvent(m, "pointerdown", (m) => {
			let { drag: x, dragListener: S = !0 } = this.getProps();
			x && S && this.start(m);
		}), S = () => {
			let { dragConstraints: m } = this.getProps();
			isRefObject(m) && m.current && (this.constraints = this.resolveRefConstraints());
		}, { projection: C } = this.visualElement, T = C.addEventListener("measure", S);
		C && !C.layout && (C.root && C.root.updateScroll(), C.updateLayout()), frame.read(S);
		let D = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), O = C.addEventListener("didUpdate", (({ delta: m, hasLayoutChanged: x }) => {
			this.isDragging && x && (eachAxis((x) => {
				let S = this.getAxisMotionValue(x);
				S && (this.originPoint[x] += m[x].translate, S.set(S.get() + m[x].translate));
			}), this.visualElement.render());
		}));
		return () => {
			D(), x(), T(), O && O();
		};
	}
	getProps() {
		let m = this.visualElement.getProps(), { drag: x = !1, dragDirectionLock: S = !1, dragPropagation: C = !1, dragConstraints: T = !1, dragElastic: D = defaultElastic, dragMomentum: O = !0 } = m;
		return {
			...m,
			drag: x,
			dragDirectionLock: S,
			dragPropagation: C,
			dragConstraints: T,
			dragElastic: D,
			dragMomentum: O
		};
	}
};
function shouldDrag(m, x, S) {
	return (x === !0 || x === m) && (S === null || S === m);
}
function getCurrentDirection(m, x = 10) {
	let S = null;
	return Math.abs(m.y) > x ? S = "y" : Math.abs(m.x) > x && (S = "x"), S;
}
var DragGesture = class extends Feature {
	constructor(m) {
		super(m), this.removeGroupControls = noop$1, this.removeListeners = noop$1, this.controls = new VisualElementDragControls(m);
	}
	mount() {
		let { dragControls: m } = this.node.getProps();
		m && (this.removeGroupControls = m.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop$1;
	}
	unmount() {
		this.removeGroupControls(), this.removeListeners();
	}
}, asyncHandler = (m) => (x, S) => {
	m && frame.postRender(() => m(x, S));
}, PanGesture = class extends Feature {
	constructor() {
		super(...arguments), this.removePointerDownListener = noop$1;
	}
	onPointerDown(m) {
		this.session = new PanSession(m, this.createPanHandlers(), {
			transformPagePoint: this.node.getTransformPagePoint(),
			contextWindow: getContextWindow(this.node)
		});
	}
	createPanHandlers() {
		let { onPanSessionStart: m, onPanStart: x, onPan: S, onPanEnd: C } = this.node.getProps();
		return {
			onSessionStart: asyncHandler(m),
			onStart: asyncHandler(x),
			onMove: S,
			onEnd: (m, x) => {
				delete this.session, C && frame.postRender(() => C(m, x));
			}
		};
	}
	mount() {
		this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (m) => this.onPointerDown(m));
	}
	update() {
		this.session && this.session.updateHandlers(this.createPanHandlers());
	}
	unmount() {
		this.removePointerDownListener(), this.session && this.session.end();
	}
}, globalProjectionState = {
	hasAnimatedSinceResize: !0,
	hasEverUpdated: !1
};
function pixelsToPercent(m, x) {
	return x.max === x.min ? 0 : m / (x.max - x.min) * 100;
}
var correctBorderRadius = { correct: (m, x) => {
	if (!x.target) return m;
	if (typeof m == "string") if (px.test(m)) m = parseFloat(m);
	else return m;
	return `${pixelsToPercent(m, x.target.x)}% ${pixelsToPercent(m, x.target.y)}%`;
} }, correctBoxShadow = { correct: (m, { treeScale: x, projectionDelta: S }) => {
	let C = m, T = complex.parse(m);
	if (T.length > 5) return C;
	let D = complex.createTransformer(m), O = typeof T[0] == "number" ? 0 : 1, k = S.x.scale * x.x, A = S.y.scale * x.y;
	T[0 + O] /= k, T[1 + O] /= A;
	let j = mixNumber(k, A, .5);
	return typeof T[2 + O] == "number" && (T[2 + O] /= j), typeof T[3 + O] == "number" && (T[3 + O] /= j), D(T);
} }, hasTakenAnySnapshot = !1, MeasureLayoutWithContext = class extends Component {
	componentDidMount() {
		let { visualElement: m, layoutGroup: x, switchLayoutGroup: S, layoutId: C } = this.props, { projection: T } = m;
		addScaleCorrector(defaultScaleCorrectors), T && (x.group && x.group.add(T), S && S.register && C && S.register(T), hasTakenAnySnapshot && T.root.didUpdate(), T.addEventListener("animationComplete", () => {
			this.safeToRemove();
		}), T.setOptions({
			...T.options,
			onExitComplete: () => this.safeToRemove()
		})), globalProjectionState.hasEverUpdated = !0;
	}
	getSnapshotBeforeUpdate(m) {
		let { layoutDependency: x, visualElement: S, drag: C, isPresent: T } = this.props, { projection: D } = S;
		return D ? (D.isPresent = T, hasTakenAnySnapshot = !0, C || m.layoutDependency !== x || x === void 0 || m.isPresent !== T ? D.willUpdate() : this.safeToRemove(), m.isPresent !== T && (T ? D.promote() : D.relegate() || frame.postRender(() => {
			let m = D.getStack();
			(!m || !m.members.length) && this.safeToRemove();
		})), null) : null;
	}
	componentDidUpdate() {
		let { projection: m } = this.props.visualElement;
		m && (m.root.didUpdate(), microtask.postRender(() => {
			!m.currentAnimation && m.isLead() && this.safeToRemove();
		}));
	}
	componentWillUnmount() {
		let { visualElement: m, layoutGroup: x, switchLayoutGroup: S } = this.props, { projection: C } = m;
		hasTakenAnySnapshot = !0, C && (C.scheduleCheckAfterUnmount(), x && x.group && x.group.remove(C), S && S.deregister && S.deregister(C));
	}
	safeToRemove() {
		let { safeToRemove: m } = this.props;
		m && m();
	}
	render() {
		return null;
	}
};
function MeasureLayout(m) {
	let [x, S] = usePresence(), C = useContext(LayoutGroupContext);
	return jsx(MeasureLayoutWithContext, {
		...m,
		layoutGroup: C,
		switchLayoutGroup: useContext(SwitchLayoutGroupContext),
		isPresent: x,
		safeToRemove: S
	});
}
var defaultScaleCorrectors = {
	borderRadius: {
		...correctBorderRadius,
		applyTo: [
			"borderTopLeftRadius",
			"borderTopRightRadius",
			"borderBottomLeftRadius",
			"borderBottomRightRadius"
		]
	},
	borderTopLeftRadius: correctBorderRadius,
	borderTopRightRadius: correctBorderRadius,
	borderBottomLeftRadius: correctBorderRadius,
	borderBottomRightRadius: correctBorderRadius,
	boxShadow: correctBoxShadow
};
function animateSingleValue(m, x, S) {
	let C = isMotionValue(m) ? m : motionValue(m);
	return C.start(animateMotionValue("", C, x, S)), C.animation;
}
var compareByDepth = (m, x) => m.depth - x.depth, FlatTree = class {
	constructor() {
		this.children = [], this.isDirty = !1;
	}
	add(m) {
		addUniqueItem(this.children, m), this.isDirty = !0;
	}
	remove(m) {
		removeItem(this.children, m), this.isDirty = !0;
	}
	forEach(m) {
		this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(m);
	}
};
function delay(m, x) {
	let S = time.now(), C = ({ timestamp: T }) => {
		let D = T - S;
		D >= x && (cancelFrame(C), m(D - x));
	};
	return frame.setup(C, !0), () => cancelFrame(C);
}
var borders = [
	"TopLeft",
	"TopRight",
	"BottomLeft",
	"BottomRight"
], numBorders = borders.length, asNumber = (m) => typeof m == "string" ? parseFloat(m) : m, isPx = (m) => typeof m == "number" || px.test(m);
function mixValues(m, x, S, C, T, D) {
	T ? (m.opacity = mixNumber(0, S.opacity ?? 1, easeCrossfadeIn(C)), m.opacityExit = mixNumber(x.opacity ?? 1, 0, easeCrossfadeOut(C))) : D && (m.opacity = mixNumber(x.opacity ?? 1, S.opacity ?? 1, C));
	for (let T = 0; T < numBorders; T++) {
		let D = `border${borders[T]}Radius`, O = getRadius(x, D), k = getRadius(S, D);
		O === void 0 && k === void 0 || (O ||= 0, k ||= 0, O === 0 || k === 0 || isPx(O) === isPx(k) ? (m[D] = Math.max(mixNumber(asNumber(O), asNumber(k), C), 0), (percent.test(k) || percent.test(O)) && (m[D] += "%")) : m[D] = k);
	}
	(x.rotate || S.rotate) && (m.rotate = mixNumber(x.rotate || 0, S.rotate || 0, C));
}
function getRadius(m, x) {
	return m[x] === void 0 ? m.borderRadius : m[x];
}
var easeCrossfadeIn = /* @__PURE__ */ compress(0, .5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(.5, .95, noop$1);
function compress(m, x, S) {
	return (C) => C < m ? 0 : C > x ? 1 : S(/* @__PURE__ */ progress(m, x, C));
}
function copyAxisInto(m, x) {
	m.min = x.min, m.max = x.max;
}
function copyBoxInto(m, x) {
	copyAxisInto(m.x, x.x), copyAxisInto(m.y, x.y);
}
function copyAxisDeltaInto(m, x) {
	m.translate = x.translate, m.scale = x.scale, m.originPoint = x.originPoint, m.origin = x.origin;
}
function removePointDelta(m, x, S, C, T) {
	return m -= x, m = scalePoint(m, 1 / S, C), T !== void 0 && (m = scalePoint(m, 1 / T, C)), m;
}
function removeAxisDelta(m, x = 0, S = 1, C = .5, T, D = m, O = m) {
	if (percent.test(x) && (x = parseFloat(x), x = mixNumber(O.min, O.max, x / 100) - O.min), typeof x != "number") return;
	let k = mixNumber(D.min, D.max, C);
	m === D && (k -= x), m.min = removePointDelta(m.min, x, S, k, T), m.max = removePointDelta(m.max, x, S, k, T);
}
function removeAxisTransforms(m, x, [S, C, T], D, O) {
	removeAxisDelta(m, x[S], x[C], x[T], x.scale, D, O);
}
var xKeys = [
	"x",
	"scaleX",
	"originX"
], yKeys = [
	"y",
	"scaleY",
	"originY"
];
function removeBoxTransforms(m, x, S, C) {
	removeAxisTransforms(m.x, x, xKeys, S ? S.x : void 0, C ? C.x : void 0), removeAxisTransforms(m.y, x, yKeys, S ? S.y : void 0, C ? C.y : void 0);
}
function isAxisDeltaZero(m) {
	return m.translate === 0 && m.scale === 1;
}
function isDeltaZero(m) {
	return isAxisDeltaZero(m.x) && isAxisDeltaZero(m.y);
}
function axisEquals(m, x) {
	return m.min === x.min && m.max === x.max;
}
function boxEquals(m, x) {
	return axisEquals(m.x, x.x) && axisEquals(m.y, x.y);
}
function axisEqualsRounded(m, x) {
	return Math.round(m.min) === Math.round(x.min) && Math.round(m.max) === Math.round(x.max);
}
function boxEqualsRounded(m, x) {
	return axisEqualsRounded(m.x, x.x) && axisEqualsRounded(m.y, x.y);
}
function aspectRatio(m) {
	return calcLength(m.x) / calcLength(m.y);
}
function axisDeltaEquals(m, x) {
	return m.translate === x.translate && m.scale === x.scale && m.originPoint === x.originPoint;
}
var NodeStack = class {
	constructor() {
		this.members = [];
	}
	add(m) {
		addUniqueItem(this.members, m), m.scheduleRender();
	}
	remove(m) {
		if (removeItem(this.members, m), m === this.prevLead && (this.prevLead = void 0), m === this.lead) {
			let m = this.members[this.members.length - 1];
			m && this.promote(m);
		}
	}
	relegate(m) {
		let x = this.members.findIndex((x) => m === x);
		if (x === 0) return !1;
		let S;
		for (let m = x; m >= 0; m--) {
			let x = this.members[m];
			if (x.isPresent !== !1) {
				S = x;
				break;
			}
		}
		return S ? (this.promote(S), !0) : !1;
	}
	promote(m, x) {
		let S = this.lead;
		if (m !== S && (this.prevLead = S, this.lead = m, m.show(), S)) {
			S.instance && S.scheduleRender(), m.scheduleRender(), m.resumeFrom = S, x && (m.resumeFrom.preserveOpacity = !0), S.snapshot && (m.snapshot = S.snapshot, m.snapshot.latestValues = S.animationValues || S.latestValues), m.root && m.root.isUpdating && (m.isLayoutDirty = !0);
			let { crossfade: C } = m.options;
			C === !1 && S.hide();
		}
	}
	exitAnimationComplete() {
		this.members.forEach((m) => {
			let { options: x, resumingFrom: S } = m;
			x.onExitComplete && x.onExitComplete(), S && S.options.onExitComplete && S.options.onExitComplete();
		});
	}
	scheduleRender() {
		this.members.forEach((m) => {
			m.instance && m.scheduleRender(!1);
		});
	}
	removeLeadSnapshot() {
		this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
	}
};
function buildProjectionTransform(m, x, S) {
	let C = "", T = m.x.translate / x.x, D = m.y.translate / x.y, O = S?.z || 0;
	if ((T || D || O) && (C = `translate3d(${T}px, ${D}px, ${O}px) `), (x.x !== 1 || x.y !== 1) && (C += `scale(${1 / x.x}, ${1 / x.y}) `), S) {
		let { transformPerspective: m, rotate: x, rotateX: T, rotateY: D, skewX: O, skewY: k } = S;
		m && (C = `perspective(${m}px) ${C}`), x && (C += `rotate(${x}deg) `), T && (C += `rotateX(${T}deg) `), D && (C += `rotateY(${D}deg) `), O && (C += `skewX(${O}deg) `), k && (C += `skewY(${k}deg) `);
	}
	let k = m.x.scale * x.x, A = m.y.scale * x.y;
	return (k !== 1 || A !== 1) && (C += `scale(${k}, ${A})`), C || "none";
}
var metrics = {
	nodes: 0,
	calculatedTargetDeltas: 0,
	calculatedProjections: 0
}, transformAxes = [
	"",
	"X",
	"Y",
	"Z"
], animationTarget = 1e3, id = 0;
function resetDistortingTransform(m, x, S, C) {
	let { latestValues: T } = x;
	T[m] && (S[m] = T[m], x.setStaticValue(m, 0), C && (C[m] = 0));
}
function cancelTreeOptimisedTransformAnimations(m) {
	if (m.hasCheckedOptimisedAppear = !0, m.root === m) return;
	let { visualElement: x } = m.options;
	if (!x) return;
	let S = getOptimisedAppearId(x);
	if (window.MotionHasOptimisedAnimation(S, "transform")) {
		let { layout: x, layoutId: C } = m.options;
		window.MotionCancelOptimisedAnimation(S, "transform", frame, !(x || C));
	}
	let { parent: C } = m;
	C && !C.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(C);
}
function createProjectionNode({ attachResizeListener: m, defaultParent: x, measureScroll: S, checkIsScrollRoot: C, resetTransform: T }) {
	return class {
		constructor(m = {}, S = x?.()) {
			this.id = id++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
				x: 1,
				y: 1
			}, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
				this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
			}, this.updateProjection = () => {
				this.projectionUpdateScheduled = !1, statsBuffer.value && (metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0), this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), statsBuffer.addProjectionMetrics && statsBuffer.addProjectionMetrics(metrics);
			}, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = m, this.root = S ? S.root || S : this, this.path = S ? [...S.path, S] : [], this.parent = S, this.depth = S ? S.depth + 1 : 0;
			for (let m = 0; m < this.path.length; m++) this.path[m].shouldResetTransform = !0;
			this.root === this && (this.nodes = new FlatTree());
		}
		addEventListener(m, x) {
			return this.eventHandlers.has(m) || this.eventHandlers.set(m, new SubscriptionManager()), this.eventHandlers.get(m).add(x);
		}
		notifyListeners(m, ...x) {
			let S = this.eventHandlers.get(m);
			S && S.notify(...x);
		}
		hasListeners(m) {
			return this.eventHandlers.has(m);
		}
		mount(x) {
			if (this.instance) return;
			this.isSVG = isSVGElement(x) && !isSVGSVGElement(x), this.instance = x;
			let { layoutId: S, layout: C, visualElement: T } = this.options;
			if (T && !T.current && T.mount(x), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (C || S) && (this.isLayoutDirty = !0), m) {
				let S, C = 0, T = () => this.root.updateBlockedByResize = !1;
				frame.read(() => {
					C = window.innerWidth;
				}), m(x, () => {
					let m = window.innerWidth;
					m !== C && (C = m, this.root.updateBlockedByResize = !0, S && S(), S = delay(T, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation)));
				});
			}
			S && this.root.registerSharedNode(S, this), this.options.animate !== !1 && T && (S || C) && this.addEventListener("didUpdate", ({ delta: m, hasLayoutChanged: x, hasRelativeLayoutChanged: S, layout: C }) => {
				if (this.isTreeAnimationBlocked()) {
					this.target = void 0, this.relativeTarget = void 0;
					return;
				}
				let D = this.options.transition || T.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart: O, onLayoutAnimationComplete: k } = T.getProps(), A = !this.targetLayout || !boxEqualsRounded(this.targetLayout, C), j = !x && S;
				if (this.options.layoutRoot || this.resumeFrom || j || x && (A || !this.currentAnimation)) {
					this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
					let x = {
						...getValueTransition(D, "layout"),
						onPlay: O,
						onComplete: k
					};
					(T.shouldReduceMotion || this.options.layoutRoot) && (x.delay = 0, x.type = !1), this.startAnimation(x), this.setAnimationOrigin(m, j);
				} else x || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
				this.targetLayout = C;
			});
		}
		unmount() {
			this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
			let m = this.getStack();
			m && m.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), cancelFrame(this.updateProjection);
		}
		blockUpdate() {
			this.updateManuallyBlocked = !0;
		}
		unblockUpdate() {
			this.updateManuallyBlocked = !1;
		}
		isUpdateBlocked() {
			return this.updateManuallyBlocked || this.updateBlockedByResize;
		}
		isTreeAnimationBlocked() {
			return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
		}
		startUpdate() {
			this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
		}
		getTransformTemplate() {
			let { visualElement: m } = this.options;
			return m && m.getProps().transformTemplate;
		}
		willUpdate(m = !0) {
			if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
				this.options.onExitComplete && this.options.onExitComplete();
				return;
			}
			if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
			this.isLayoutDirty = !0;
			for (let m = 0; m < this.path.length; m++) {
				let x = this.path[m];
				x.shouldResetTransform = !0, x.updateScroll("snapshot"), x.options.layoutRoot && x.willUpdate(!1);
			}
			let { layoutId: x, layout: S } = this.options;
			if (x === void 0 && !S) return;
			let C = this.getTransformTemplate();
			this.prevTransformTemplateValue = C ? C(this.latestValues, "") : void 0, this.updateSnapshot(), m && this.notifyListeners("willUpdate");
		}
		update() {
			if (this.updateScheduled = !1, this.isUpdateBlocked()) {
				this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
				return;
			}
			if (this.animationId <= this.animationCommitId) {
				this.nodes.forEach(clearIsLayoutDirty);
				return;
			}
			this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate)) : this.nodes.forEach(clearIsLayoutDirty), this.clearAllSnapshots();
			let m = time.now();
			frameData.delta = clamp$1(0, 1e3 / 60, m - frameData.timestamp), frameData.timestamp = m, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
		}
		didUpdate() {
			this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
		}
		clearAllSnapshots() {
			this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
		}
		scheduleUpdateProjection() {
			this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
		}
		scheduleCheckAfterUnmount() {
			frame.postRender(() => {
				this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
			});
		}
		updateSnapshot() {
			this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
		}
		updateLayout() {
			if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
			if (this.resumeFrom && !this.resumeFrom.instance) for (let m = 0; m < this.path.length; m++) this.path[m].updateScroll();
			let m = this.layout;
			this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
			let { visualElement: x } = this.options;
			x && x.notify("LayoutMeasure", this.layout.layoutBox, m ? m.layoutBox : void 0);
		}
		updateScroll(m = "measure") {
			let x = !!(this.options.layoutScroll && this.instance);
			if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === m && (x = !1), x && this.instance) {
				let x = C(this.instance);
				this.scroll = {
					animationId: this.root.animationId,
					phase: m,
					isRoot: x,
					offset: S(this.instance),
					wasRoot: this.scroll ? this.scroll.isRoot : x
				};
			}
		}
		resetTransform() {
			if (!T) return;
			let m = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, x = this.projectionDelta && !isDeltaZero(this.projectionDelta), S = this.getTransformTemplate(), C = S ? S(this.latestValues, "") : void 0, D = C !== this.prevTransformTemplateValue;
			m && this.instance && (x || hasTransform(this.latestValues) || D) && (T(this.instance, C), this.shouldResetTransform = !1, this.scheduleRender());
		}
		measure(m = !0) {
			let x = this.measurePageBox(), S = this.removeElementScroll(x);
			return m && (S = this.removeTransform(S)), roundBox(S), {
				animationId: this.root.animationId,
				measuredBox: x,
				layoutBox: S,
				latestValues: {},
				source: this.id
			};
		}
		measurePageBox() {
			let { visualElement: m } = this.options;
			if (!m) return createBox();
			let x = m.measureViewportBox();
			if (!(this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot))) {
				let { scroll: m } = this.root;
				m && (translateAxis(x.x, m.offset.x), translateAxis(x.y, m.offset.y));
			}
			return x;
		}
		removeElementScroll(m) {
			let x = createBox();
			if (copyBoxInto(x, m), this.scroll?.wasRoot) return x;
			for (let S = 0; S < this.path.length; S++) {
				let C = this.path[S], { scroll: T, options: D } = C;
				C !== this.root && T && D.layoutScroll && (T.wasRoot && copyBoxInto(x, m), translateAxis(x.x, T.offset.x), translateAxis(x.y, T.offset.y));
			}
			return x;
		}
		applyTransform(m, x = !1) {
			let S = createBox();
			copyBoxInto(S, m);
			for (let m = 0; m < this.path.length; m++) {
				let C = this.path[m];
				!x && C.options.layoutScroll && C.scroll && C !== C.root && transformBox(S, {
					x: -C.scroll.offset.x,
					y: -C.scroll.offset.y
				}), hasTransform(C.latestValues) && transformBox(S, C.latestValues);
			}
			return hasTransform(this.latestValues) && transformBox(S, this.latestValues), S;
		}
		removeTransform(m) {
			let x = createBox();
			copyBoxInto(x, m);
			for (let m = 0; m < this.path.length; m++) {
				let S = this.path[m];
				if (!S.instance || !hasTransform(S.latestValues)) continue;
				hasScale(S.latestValues) && S.updateSnapshot();
				let C = createBox();
				copyBoxInto(C, S.measurePageBox()), removeBoxTransforms(x, S.latestValues, S.snapshot ? S.snapshot.layoutBox : void 0, C);
			}
			return hasTransform(this.latestValues) && removeBoxTransforms(x, this.latestValues), x;
		}
		setTargetDelta(m) {
			this.targetDelta = m, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
		}
		setOptions(m) {
			this.options = {
				...this.options,
				...m,
				crossfade: m.crossfade === void 0 ? !0 : m.crossfade
			};
		}
		clearMeasurements() {
			this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
		}
		forceRelativeParentToResolveTarget() {
			this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
		}
		resolveTargetDelta(m = !1) {
			let x = this.getLead();
			this.isProjectionDirty ||= x.isProjectionDirty, this.isTransformDirty ||= x.isTransformDirty, this.isSharedProjectionDirty ||= x.isSharedProjectionDirty;
			let S = !!this.resumingFrom || this !== x;
			if (!(m || S && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
			let { layout: C, layoutId: T } = this.options;
			if (!this.layout || !(C || T)) return;
			this.resolvedRelativeTargetAt = frameData.timestamp;
			let D = this.getClosestProjectingParent();
			D && this.linkedParentVersion !== D.layoutVersion && !D.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (D && D.layout ? this.createRelativeTarget(D, this.layout.layoutBox, D.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, D && !!D.resumingFrom == !!this.resumingFrom && !D.options.layoutScroll && D.target && this.animationProgress !== 1 ? this.createRelativeTarget(D, this.target, D.target) : this.relativeParent = this.relativeTarget = void 0), statsBuffer.value && metrics.calculatedTargetDeltas++);
		}
		getClosestProjectingParent() {
			if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
		}
		isProjecting() {
			return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
		}
		createRelativeTarget(m, x, S) {
			this.relativeParent = m, this.linkedParentVersion = m.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, x, S), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
		}
		removeRelativeTarget() {
			this.relativeParent = this.relativeTarget = void 0;
		}
		calcProjection() {
			let m = this.getLead(), x = !!this.resumingFrom || this !== m, S = !0;
			if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (S = !1), x && (this.isSharedProjectionDirty || this.isTransformDirty) && (S = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (S = !1), S) return;
			let { layout: C, layoutId: T } = this.options;
			if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(C || T)) return;
			copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
			let D = this.treeScale.x, O = this.treeScale.y;
			applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, x), m.layout && !m.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (m.target = m.layout.layoutBox, m.targetWithTransforms = createBox());
			let { target: k } = m;
			if (!k) {
				this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
				return;
			}
			!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, k, this.latestValues), (this.treeScale.x !== D || this.treeScale.y !== O || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", k)), statsBuffer.value && metrics.calculatedProjections++;
		}
		hide() {
			this.isVisible = !1;
		}
		show() {
			this.isVisible = !0;
		}
		scheduleRender(m = !0) {
			if (this.options.visualElement?.scheduleRender(), m) {
				let m = this.getStack();
				m && m.scheduleRender();
			}
			this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
		}
		createProjectionDeltas() {
			this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
		}
		setAnimationOrigin(m, x = !1) {
			let S = this.snapshot, C = S ? S.latestValues : {}, T = { ...this.latestValues }, D = createDelta();
			(!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !x;
			let O = createBox(), k = (S ? S.source : void 0) !== (this.layout ? this.layout.source : void 0), A = this.getStack(), j = !A || A.members.length <= 1, M = !!(k && !j && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
			this.animationProgress = 0;
			let N;
			this.mixTargetDelta = (x) => {
				let S = x / 1e3;
				mixAxisDelta(D.x, m.x, S), mixAxisDelta(D.y, m.y, S), this.setTargetDelta(D), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(O, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, O, S), N && boxEquals(this.relativeTarget, N) && (this.isProjectionDirty = !1), N ||= createBox(), copyBoxInto(N, this.relativeTarget)), k && (this.animationValues = T, mixValues(T, C, this.latestValues, S, M, j)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = S;
			}, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
		}
		startAnimation(m) {
			this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation &&= (cancelFrame(this.pendingAnimation), void 0), this.pendingAnimation = frame.update(() => {
				globalProjectionState.hasAnimatedSinceResize = !0, activeAnimations.layout++, this.motionValue ||= motionValue(0), this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
					...m,
					velocity: 0,
					isSync: !0,
					onUpdate: (x) => {
						this.mixTargetDelta(x), m.onUpdate && m.onUpdate(x);
					},
					onStop: () => {
						activeAnimations.layout--;
					},
					onComplete: () => {
						activeAnimations.layout--, m.onComplete && m.onComplete(), this.completeAnimation();
					}
				}), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
			});
		}
		completeAnimation() {
			this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
			let m = this.getStack();
			m && m.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
		}
		finishAnimation() {
			this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
		}
		applyTransformsToTarget() {
			let m = this.getLead(), { targetWithTransforms: x, target: S, layout: C, latestValues: T } = m;
			if (!(!x || !S || !C)) {
				if (this !== m && this.layout && C && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, C.layoutBox)) {
					S = this.target || createBox();
					let x = calcLength(this.layout.layoutBox.x);
					S.x.min = m.target.x.min, S.x.max = S.x.min + x;
					let C = calcLength(this.layout.layoutBox.y);
					S.y.min = m.target.y.min, S.y.max = S.y.min + C;
				}
				copyBoxInto(x, S), transformBox(x, T), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, x, T);
			}
		}
		registerSharedNode(m, x) {
			this.sharedNodes.has(m) || this.sharedNodes.set(m, new NodeStack()), this.sharedNodes.get(m).add(x);
			let S = x.options.initialPromotionConfig;
			x.promote({
				transition: S ? S.transition : void 0,
				preserveFollowOpacity: S && S.shouldPreserveFollowOpacity ? S.shouldPreserveFollowOpacity(x) : void 0
			});
		}
		isLead() {
			let m = this.getStack();
			return m ? m.lead === this : !0;
		}
		getLead() {
			let { layoutId: m } = this.options;
			return m && this.getStack()?.lead || this;
		}
		getPrevLead() {
			let { layoutId: m } = this.options;
			return m ? this.getStack()?.prevLead : void 0;
		}
		getStack() {
			let { layoutId: m } = this.options;
			if (m) return this.root.sharedNodes.get(m);
		}
		promote({ needsReset: m, transition: x, preserveFollowOpacity: S } = {}) {
			let C = this.getStack();
			C && C.promote(this, S), m && (this.projectionDelta = void 0, this.needsReset = !0), x && this.setOptions({ transition: x });
		}
		relegate() {
			let m = this.getStack();
			return m ? m.relegate(this) : !1;
		}
		resetSkewAndRotation() {
			let { visualElement: m } = this.options;
			if (!m) return;
			let x = !1, { latestValues: S } = m;
			if ((S.z || S.rotate || S.rotateX || S.rotateY || S.rotateZ || S.skewX || S.skewY) && (x = !0), !x) return;
			let C = {};
			S.z && resetDistortingTransform("z", m, C, this.animationValues);
			for (let x = 0; x < transformAxes.length; x++) resetDistortingTransform(`rotate${transformAxes[x]}`, m, C, this.animationValues), resetDistortingTransform(`skew${transformAxes[x]}`, m, C, this.animationValues);
			for (let x in m.render(), C) m.setStaticValue(x, C[x]), this.animationValues && (this.animationValues[x] = C[x]);
			m.scheduleRender();
		}
		applyProjectionStyles(m, x) {
			if (!this.instance || this.isSVG) return;
			if (!this.isVisible) {
				m.visibility = "hidden";
				return;
			}
			let S = this.getTransformTemplate();
			if (this.needsReset) {
				this.needsReset = !1, m.visibility = "", m.opacity = "", m.pointerEvents = resolveMotionValue(x?.pointerEvents) || "", m.transform = S ? S(this.latestValues, "") : "none";
				return;
			}
			let C = this.getLead();
			if (!this.projectionDelta || !this.layout || !C.target) {
				this.options.layoutId && (m.opacity = this.latestValues.opacity === void 0 ? 1 : this.latestValues.opacity, m.pointerEvents = resolveMotionValue(x?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (m.transform = S ? S({}, "") : "none", this.hasProjected = !1);
				return;
			}
			m.visibility = "";
			let T = C.animationValues || C.latestValues;
			this.applyTransformsToTarget();
			let D = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, T);
			S && (D = S(T, D)), m.transform = D;
			let { x: O, y: k } = this.projectionDelta;
			for (let x in m.transformOrigin = `${O.origin * 100}% ${k.origin * 100}% 0`, C.animationValues ? m.opacity = C === this ? T.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : T.opacityExit : m.opacity = C === this ? T.opacity === void 0 ? "" : T.opacity : T.opacityExit === void 0 ? 0 : T.opacityExit, scaleCorrectors) {
				if (T[x] === void 0) continue;
				let { correct: S, applyTo: O, isCSSVariable: k } = scaleCorrectors[x], A = D === "none" ? T[x] : S(T[x], C);
				if (O) {
					let x = O.length;
					for (let S = 0; S < x; S++) m[O[S]] = A;
				} else k ? this.options.visualElement.renderState.vars[x] = A : m[x] = A;
			}
			this.options.layoutId && (m.pointerEvents = C === this ? resolveMotionValue(x?.pointerEvents) || "" : "none");
		}
		clearSnapshot() {
			this.resumeFrom = this.snapshot = void 0;
		}
		resetTree() {
			this.root.nodes.forEach((m) => m.currentAnimation?.stop()), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
		}
	};
}
function updateLayout(m) {
	m.updateLayout();
}
function notifyLayoutUpdate(m) {
	let x = m.resumeFrom?.snapshot || m.snapshot;
	if (m.isLead() && m.layout && x && m.hasListeners("didUpdate")) {
		let { layoutBox: S, measuredBox: C } = m.layout, { animationType: T } = m.options, D = x.source !== m.layout.source;
		T === "size" ? eachAxis((m) => {
			let C = D ? x.measuredBox[m] : x.layoutBox[m], T = calcLength(C);
			C.min = S[m].min, C.max = C.min + T;
		}) : shouldAnimatePositionOnly(T, x.layoutBox, S) && eachAxis((C) => {
			let T = D ? x.measuredBox[C] : x.layoutBox[C], O = calcLength(S[C]);
			T.max = T.min + O, m.relativeTarget && !m.currentAnimation && (m.isProjectionDirty = !0, m.relativeTarget[C].max = m.relativeTarget[C].min + O);
		});
		let O = createDelta();
		calcBoxDelta(O, S, x.layoutBox);
		let k = createDelta();
		D ? calcBoxDelta(k, m.applyTransform(C, !0), x.measuredBox) : calcBoxDelta(k, S, x.layoutBox);
		let A = !isDeltaZero(O), j = !1;
		if (!m.resumeFrom) {
			let C = m.getClosestProjectingParent();
			if (C && !C.resumeFrom) {
				let { snapshot: T, layout: D } = C;
				if (T && D) {
					let O = createBox();
					calcRelativePosition(O, x.layoutBox, T.layoutBox);
					let k = createBox();
					calcRelativePosition(k, S, D.layoutBox), boxEqualsRounded(O, k) || (j = !0), C.options.layoutRoot && (m.relativeTarget = k, m.relativeTargetOrigin = O, m.relativeParent = C);
				}
			}
		}
		m.notifyListeners("didUpdate", {
			layout: S,
			snapshot: x,
			delta: k,
			layoutDelta: O,
			hasLayoutChanged: A,
			hasRelativeLayoutChanged: j
		});
	} else if (m.isLead()) {
		let { onExitComplete: x } = m.options;
		x && x();
	}
	m.options.transition = void 0;
}
function propagateDirtyNodes(m) {
	statsBuffer.value && metrics.nodes++, m.parent && (m.isProjecting() || (m.isProjectionDirty = m.parent.isProjectionDirty), m.isSharedProjectionDirty ||= !!(m.isProjectionDirty || m.parent.isProjectionDirty || m.parent.isSharedProjectionDirty), m.isTransformDirty ||= m.parent.isTransformDirty);
}
function cleanDirtyNodes(m) {
	m.isProjectionDirty = m.isSharedProjectionDirty = m.isTransformDirty = !1;
}
function clearSnapshot(m) {
	m.clearSnapshot();
}
function clearMeasurements(m) {
	m.clearMeasurements();
}
function clearIsLayoutDirty(m) {
	m.isLayoutDirty = !1;
}
function resetTransformStyle(m) {
	let { visualElement: x } = m.options;
	x && x.getProps().onBeforeLayoutMeasure && x.notify("BeforeLayoutMeasure"), m.resetTransform();
}
function finishAnimation(m) {
	m.finishAnimation(), m.targetDelta = m.relativeTarget = m.target = void 0, m.isProjectionDirty = !0;
}
function resolveTargetDelta(m) {
	m.resolveTargetDelta();
}
function calcProjection(m) {
	m.calcProjection();
}
function resetSkewAndRotation(m) {
	m.resetSkewAndRotation();
}
function removeLeadSnapshots(m) {
	m.removeLeadSnapshot();
}
function mixAxisDelta(m, x, S) {
	m.translate = mixNumber(x.translate, 0, S), m.scale = mixNumber(x.scale, 1, S), m.origin = x.origin, m.originPoint = x.originPoint;
}
function mixAxis(m, x, S, C) {
	m.min = mixNumber(x.min, S.min, C), m.max = mixNumber(x.max, S.max, C);
}
function mixBox(m, x, S, C) {
	mixAxis(m.x, x.x, S.x, C), mixAxis(m.y, x.y, S.y, C);
}
function hasOpacityCrossfade(m) {
	return m.animationValues && m.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
	duration: .45,
	ease: [
		.4,
		0,
		.1,
		1
	]
}, userAgentContains = (m) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(m), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;
function roundAxis(m) {
	m.min = roundPoint(m.min), m.max = roundPoint(m.max);
}
function roundBox(m) {
	roundAxis(m.x), roundAxis(m.y);
}
function shouldAnimatePositionOnly(m, x, S) {
	return m === "position" || m === "preserve-aspect" && !isNear(aspectRatio(x), aspectRatio(S), .2);
}
function checkNodeWasScrollRoot(m) {
	return m !== m.root && m.scroll?.wasRoot;
}
var DocumentProjectionNode = createProjectionNode({
	attachResizeListener: (m, x) => addDomEvent(m, "resize", x),
	measureScroll: () => ({
		x: document.documentElement.scrollLeft || document.body.scrollLeft,
		y: document.documentElement.scrollTop || document.body.scrollTop
	}),
	checkIsScrollRoot: () => !0
}), rootProjectionNode = { current: void 0 }, HTMLProjectionNode = createProjectionNode({
	measureScroll: (m) => ({
		x: m.scrollLeft,
		y: m.scrollTop
	}),
	defaultParent: () => {
		if (!rootProjectionNode.current) {
			let m = new DocumentProjectionNode({});
			m.mount(window), m.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = m;
		}
		return rootProjectionNode.current;
	},
	resetTransform: (m, x) => {
		m.style.transform = x === void 0 ? "none" : x;
	},
	checkIsScrollRoot: (m) => window.getComputedStyle(m).position === "fixed"
}), drag = {
	pan: { Feature: PanGesture },
	drag: {
		Feature: DragGesture,
		ProjectionNode: HTMLProjectionNode,
		MeasureLayout
	}
};
function handleHoverEvent(m, x, S) {
	let { props: C } = m;
	m.animationState && C.whileHover && m.animationState.setActive("whileHover", S === "Start");
	let T = C["onHover" + S];
	T && frame.postRender(() => T(x, extractEventInfo(x)));
}
var HoverGesture = class extends Feature {
	mount() {
		let { current: m } = this.node;
		m && (this.unmount = hover(m, (m, x) => (handleHoverEvent(this.node, x, "Start"), (m) => handleHoverEvent(this.node, m, "End"))));
	}
	unmount() {}
}, FocusGesture = class extends Feature {
	constructor() {
		super(...arguments), this.isActive = !1;
	}
	onFocus() {
		let m = !1;
		try {
			m = this.node.current.matches(":focus-visible");
		} catch {
			m = !0;
		}
		!m || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
	}
	onBlur() {
		!this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
	}
	mount() {
		this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
	}
	unmount() {}
};
function handlePressEvent(m, x, S) {
	let { props: C } = m;
	if (m.current instanceof HTMLButtonElement && m.current.disabled) return;
	m.animationState && C.whileTap && m.animationState.setActive("whileTap", S === "Start");
	let T = C["onTap" + (S === "End" ? "" : S)];
	T && frame.postRender(() => T(x, extractEventInfo(x)));
}
var PressGesture = class extends Feature {
	mount() {
		let { current: m } = this.node;
		m && (this.unmount = press(m, (m, x) => (handlePressEvent(this.node, x, "Start"), (m, { success: x }) => handlePressEvent(this.node, m, x ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
	}
	unmount() {}
}, observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (m) => {
	let x = observerCallbacks.get(m.target);
	x && x(m);
}, fireAllObserverCallbacks = (m) => {
	m.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: m, ...x }) {
	let S = m || document;
	observers.has(S) || observers.set(S, {});
	let C = observers.get(S), T = JSON.stringify(x);
	return C[T] || (C[T] = new IntersectionObserver(fireAllObserverCallbacks, {
		root: m,
		...x
	})), C[T];
}
function observeIntersection(m, x, S) {
	let C = initIntersectionObserver(x);
	return observerCallbacks.set(m, S), C.observe(m), () => {
		observerCallbacks.delete(m), C.unobserve(m);
	};
}
var thresholdNames = {
	some: 0,
	all: 1
}, InViewFeature = class extends Feature {
	constructor() {
		super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
	}
	startObserver() {
		this.unmount();
		let { viewport: m = {} } = this.node.getProps(), { root: x, margin: S, amount: C = "some", once: T } = m, D = {
			root: x ? x.current : void 0,
			rootMargin: S,
			threshold: typeof C == "number" ? C : thresholdNames[C]
		};
		return observeIntersection(this.node.current, D, (m) => {
			let { isIntersecting: x } = m;
			if (this.isInView === x || (this.isInView = x, T && !x && this.hasEnteredView)) return;
			x && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", x);
			let { onViewportEnter: S, onViewportLeave: C } = this.node.getProps(), D = x ? S : C;
			D && D(m);
		});
	}
	mount() {
		this.startObserver();
	}
	update() {
		if (typeof IntersectionObserver > "u") return;
		let { props: m, prevProps: x } = this.node;
		[
			"amount",
			"margin",
			"root"
		].some(hasViewportOptionChanged(m, x)) && this.startObserver();
	}
	unmount() {}
};
function hasViewportOptionChanged({ viewport: m = {} }, { viewport: x = {} } = {}) {
	return (S) => m[S] !== x[S];
}
var gestureAnimations = {
	inView: { Feature: InViewFeature },
	tap: { Feature: PressGesture },
	focus: { Feature: FocusGesture },
	hover: { Feature: HoverGesture }
}, layout = { layout: {
	ProjectionNode: HTMLProjectionNode,
	MeasureLayout
} }, motion = /* @__PURE__ */ createMotionProxy({
	...animations,
	...gestureAnimations,
	...drag,
	...layout
}, createDomVisualElement);
function BackgroundMedia({ backgroundData: m, projectName: x }) {
	return !m || !m.backgroundUrl ? /* @__PURE__ */ jsx("div", { className: "absolute z-10 top-0 left-0 w-full h-full object-cover bg-gray-700" }) : m.isVideo ? /* @__PURE__ */ jsx("video", {
		src: m.backgroundUrl,
		autoPlay: !0,
		loop: !0,
		muted: !0,
		playsInline: !0,
		preload: "auto",
		className: "absolute z-10 top-0 left-0 w-full h-full object-cover"
	}) : /* @__PURE__ */ jsx("img", {
		loading: "eager",
		alt: x,
		src: m.backgroundUrl,
		style: { objectFit: "cover" },
		className: "absolute z-10 top-0 left-0 w-full h-full object-cover"
	});
}
var background_default$1 = "data:image/webp;base64,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";
function HomeFirstSection({ projectName: m, projectDescription: x, backgroundData: S, scrollIndicatorText: C = "Scroll down", scrollIndicatorOpacity: T = 1 }) {
	return /* @__PURE__ */ jsx("div", {
		className: "panel absolute left-0 top-0 will-change-transform w-full h-full z-30",
		children: /* @__PURE__ */ jsxs("div", {
			className: "pt-17.5 flex flex-col justify-end lg:justify-center px-5 bg-gray-300 relative h-[100vh] w-[100vw] bg-no-repeat bg-cover",
			children: [
				/* @__PURE__ */ jsx(BackgroundMedia, {
					backgroundData: S?.backgroundUrl ? {
						isVideo: S.isVideo,
						backgroundUrl: S.backgroundUrl
					} : {
						isVideo: !1,
						backgroundUrl: background_default$1
					},
					projectName: m
				}),
				/* @__PURE__ */ jsx("div", {
					className: "absolute z-20 top-0 left-0 h-[100vh] w-[100vw]",
					style: {
						opacity: .5,
						backgroundColor: "black"
					}
				}),
				/* @__PURE__ */ jsx(motion.div, {
					className: "absolute z-30 top-0 left-0 h-[100vh] w-[100vw]",
					style: {
						opacity: 0,
						background: "linear-gradient(0deg, var(--menuBgColor), var(--menuBgColor)), linear-gradient(180deg, var(--menuBgColor) 0%, rgba(0, 53, 110, 0) 100%)"
					}
				}),
				/* @__PURE__ */ jsxs("div", {
					className: "page-container z-30 justify-end lg:justify-center px-5 py-5 lg:px-7.5 lg:py-7.5 mobile:p-0",
					children: [/* @__PURE__ */ jsxs("div", {
						className: "mb-12.5 flex flex-col justify-end lg:justify-center lg:grow",
						children: [/* @__PURE__ */ jsx("h1", {
							className: "font-bold text-5xl mb-2.5 text-[#FAF9FD]",
							children: m
						}), /* @__PURE__ */ jsx("h3", {
							className: "text-[1rem] mobile:text-[0.8rem] mobile:leading-[1.2rem] leading-[1.45rem] w-[37.5rem] mobile:w-[100%] text-[#FAF9FD] font-light whitespace-pre-wrap",
							children: x
						})]
					}), /* @__PURE__ */ jsxs(motion.div, {
						id: "scroll-indicator",
						className: "flex space-x-2.5 rtl:space-x-reverse items-center py-5 lg:mt-auto",
						style: { opacity: T },
						children: [/* @__PURE__ */ jsx(MouseIcon, {}), /* @__PURE__ */ jsx("span", {
							className: "text-base font-light justify-self-end text-[#FAF9FD]",
							children: C
						})]
					})]
				})
			]
		})
	});
}
function MouseIcon() {
	return /* @__PURE__ */ jsxs("svg", {
		width: "16",
		height: "24",
		viewBox: "0 0 16 24",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		"aria-hidden": "true",
		children: [
			/* @__PURE__ */ jsx("rect", {
				x: "0.5",
				y: "0.5",
				width: "15",
				height: "23",
				rx: "7.5",
				stroke: "white"
			}),
			/* @__PURE__ */ jsx("circle", {
				cx: "8",
				cy: "6",
				r: "1",
				fill: "white"
			}),
			/* @__PURE__ */ jsx("line", {
				x1: "8",
				y1: "7.5",
				x2: "8",
				y2: "11.5",
				stroke: "white"
			})
		]
	});
}
function HomeFirstSectionWrapper(m) {
	let { projectName: x = "Right Property", projectDescription: S = "Discover thoughtfully designed homes with seamless connections and serene green spaces.", backgroundUrl: C = "", mediaType: T = "image", scrollIndicatorText: D = "Scroll down", scrollIndicatorOpacity: O = 1 } = m;
	return /* @__PURE__ */ jsx(HomeFirstSection, {
		projectName: x,
		projectDescription: S,
		backgroundData: {
			isVideo: T === "video",
			backgroundUrl: C
		},
		scrollIndicatorText: D,
		scrollIndicatorOpacity: O
	});
}
function Image({ src: m, fallbackSrc: x, alt: S, width: C, height: T, className: D }) {
	return m ? /* @__PURE__ */ jsx("img", {
		src: m,
		alt: S,
		className: D
	}) : x ? /* @__PURE__ */ jsx("img", {
		src: x,
		alt: S,
		className: D
	}) : /* @__PURE__ */ jsx("div", {
		className: cn(D, " bg-gray-400"),
		style: {
			width: C,
			height: T
		}
	});
}
var wimbledon_content_main_default = "data:image/avif;base64,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", wimbledon_content_left_default = "data:image/avif;base64,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", wimbledon_content_right_default = "data:image/avif;base64,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";
function HomePageContent({ title: m, titleColor: x = "#1a1a1a", subtitle: S, paragraphs: C, image1: T, image2: D, image3: O }) {
	let k = { color: x };
	return /* @__PURE__ */ jsxs("div", {
		className: "font-fira",
		children: [/* @__PURE__ */ jsx("div", {
			className: "hidden md:block pb-15 px-24 pt-20 max-w-[1440px] mx-auto",
			children: /* @__PURE__ */ jsxs("div", {
				className: "grid grid-cols-2 gap-10",
				children: [/* @__PURE__ */ jsxs("div", {
					className: "col-span-1 flex flex-col space-y-5",
					children: [
						/* @__PURE__ */ jsx("h1", {
							className: "font-bold text-5xl",
							style: k,
							children: m
						}),
						/* @__PURE__ */ jsx("h4", {
							className: "font-light text-xl text-primary-dark-1",
							children: S
						}),
						C.map((m, x) => /* @__PURE__ */ jsx("div", {
							className: "w-full font-light text-primary-dark-1",
							children: m.text
						}, x))
					]
				}), /* @__PURE__ */ jsx("div", {
					className: "col-span-1",
					children: /* @__PURE__ */ jsxs("div", {
						className: "flex flex-col space-y-5",
						children: [/* @__PURE__ */ jsx("div", {
							className: "w-full",
							children: /* @__PURE__ */ jsx(Image, {
								width: 600,
								height: 400,
								src: T,
								fallbackSrc: wimbledon_content_main_default,
								className: "h-60 lg:h-100 w-full",
								alt: ""
							})
						}), /* @__PURE__ */ jsxs("div", {
							className: "w-full grid grid-cols-2 gap-5",
							children: [/* @__PURE__ */ jsx("div", {
								className: "col-span-1",
								children: /* @__PURE__ */ jsx(Image, {
									width: 290,
									height: 180,
									src: D,
									fallbackSrc: wimbledon_content_left_default,
									className: "h-auto w-full",
									alt: ""
								})
							}), /* @__PURE__ */ jsx("div", {
								className: "col-span-1",
								children: /* @__PURE__ */ jsx(Image, {
									width: 290,
									height: 180,
									src: O,
									fallbackSrc: wimbledon_content_right_default,
									className: "h-auto w-full",
									alt: ""
								})
							})]
						})]
					})
				})]
			})
		}), /* @__PURE__ */ jsx("div", {
			className: "md:hidden",
			children: /* @__PURE__ */ jsxs("div", {
				className: "flex flex-wrap mb-5",
				children: [/* @__PURE__ */ jsxs("div", {
					className: "flex-auto w-full md:w-1/2 p-5",
					children: [/* @__PURE__ */ jsx("h1", {
						className: "font-bold text-5xl mb-5",
						style: k,
						children: m
					}), /* @__PURE__ */ jsx("h4", {
						className: "font-light text-xl text-primary-dark-1",
						children: S
					})]
				}), /* @__PURE__ */ jsx("div", {
					className: "flex-auto w-full md:w-1/2 p-5",
					children: /* @__PURE__ */ jsxs("div", {
						className: "flex flex-wrap space-y-5",
						children: [/* @__PURE__ */ jsx("div", {
							className: "w-full",
							children: /* @__PURE__ */ jsx(Image, {
								width: 400,
								height: 280,
								src: T,
								fallbackSrc: wimbledon_content_main_default,
								className: "h-60 lg:h-100 w-full",
								alt: ""
							})
						}), /* @__PURE__ */ jsxs("div", {
							className: "flex space-x-5",
							children: [/* @__PURE__ */ jsx("div", {
								className: "flex-auto w-1/2",
								children: /* @__PURE__ */ jsx(Image, {
									width: 290,
									height: 120,
									src: D,
									fallbackSrc: wimbledon_content_left_default,
									className: "h-30 w-full",
									alt: ""
								})
							}), /* @__PURE__ */ jsx("div", {
								className: "flex-auto w-1/2",
								children: /* @__PURE__ */ jsx(Image, {
									width: 290,
									height: 120,
									src: O,
									fallbackSrc: wimbledon_content_right_default,
									className: "h-30 w-full",
									alt: ""
								})
							})]
						})]
					})
				})]
			})
		})]
	});
}
function HomePageContentWrapper(m) {
	let { title: x = "", titleColor: S = "#1a1a1a", subtitle: C = "", paragraphs: T = [], image1: D = "", image2: O = "", image3: k = "" } = m;
	return /* @__PURE__ */ jsx(HomePageContent, {
		title: x,
		titleColor: S,
		subtitle: C,
		paragraphs: T,
		image1: D,
		image2: O,
		image3: k
	});
}
function isObject$2(m) {
	return typeof m == "object" && !!m && "constructor" in m && m.constructor === Object;
}
function extend$2(m = {}, x = {}) {
	let S = [
		"__proto__",
		"constructor",
		"prototype"
	];
	Object.keys(x).filter((m) => S.indexOf(m) < 0).forEach((S) => {
		m[S] === void 0 ? m[S] = x[S] : isObject$2(x[S]) && isObject$2(m[S]) && Object.keys(x[S]).length > 0 && extend$2(m[S], x[S]);
	});
}
var ssrDocument = {
	body: {},
	addEventListener() {},
	removeEventListener() {},
	activeElement: {
		blur() {},
		nodeName: ""
	},
	querySelector() {
		return null;
	},
	querySelectorAll() {
		return [];
	},
	getElementById() {
		return null;
	},
	createEvent() {
		return { initEvent() {} };
	},
	createElement() {
		return {
			children: [],
			childNodes: [],
			style: {},
			setAttribute() {},
			getElementsByTagName() {
				return [];
			}
		};
	},
	createElementNS() {
		return {};
	},
	importNode() {
		return null;
	},
	location: {
		hash: "",
		host: "",
		hostname: "",
		href: "",
		origin: "",
		pathname: "",
		protocol: "",
		search: ""
	}
};
function getDocument() {
	let m = typeof document < "u" ? document : {};
	return extend$2(m, ssrDocument), m;
}
var ssrWindow = {
	document: ssrDocument,
	navigator: { userAgent: "" },
	location: {
		hash: "",
		host: "",
		hostname: "",
		href: "",
		origin: "",
		pathname: "",
		protocol: "",
		search: ""
	},
	history: {
		replaceState() {},
		pushState() {},
		go() {},
		back() {}
	},
	CustomEvent: function() {
		return this;
	},
	addEventListener() {},
	removeEventListener() {},
	getComputedStyle() {
		return { getPropertyValue() {
			return "";
		} };
	},
	Image() {},
	Date() {},
	screen: {},
	setTimeout() {},
	clearTimeout() {},
	matchMedia() {
		return {};
	},
	requestAnimationFrame(m) {
		return typeof setTimeout > "u" ? (m(), null) : setTimeout(m, 0);
	},
	cancelAnimationFrame(m) {
		typeof setTimeout > "u" || clearTimeout(m);
	}
};
function getWindow() {
	let m = typeof window < "u" ? window : {};
	return extend$2(m, ssrWindow), m;
}
function classesToTokens(m = "") {
	return m.trim().split(" ").filter((m) => !!m.trim());
}
function deleteProps(m) {
	let x = m;
	Object.keys(x).forEach((m) => {
		try {
			x[m] = null;
		} catch {}
		try {
			delete x[m];
		} catch {}
	});
}
function nextTick(m, x = 0) {
	return setTimeout(m, x);
}
function now() {
	return Date.now();
}
function getComputedStyle$1(m) {
	let x = getWindow(), S;
	return x.getComputedStyle && (S = x.getComputedStyle(m, null)), !S && m.currentStyle && (S = m.currentStyle), S ||= m.style, S;
}
function getTranslate(m, x = "x") {
	let S = getWindow(), C, T, D, O = getComputedStyle$1(m);
	return S.WebKitCSSMatrix ? (T = O.transform || O.webkitTransform, T.split(",").length > 6 && (T = T.split(", ").map((m) => m.replace(",", ".")).join(", ")), D = new S.WebKitCSSMatrix(T === "none" ? "" : T)) : (D = O.MozTransform || O.OTransform || O.MsTransform || O.msTransform || O.transform || O.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), C = D.toString().split(",")), x === "x" && (T = S.WebKitCSSMatrix ? D.m41 : C.length === 16 ? parseFloat(C[12]) : parseFloat(C[4])), x === "y" && (T = S.WebKitCSSMatrix ? D.m42 : C.length === 16 ? parseFloat(C[13]) : parseFloat(C[5])), T || 0;
}
function isObject$1(m) {
	return typeof m == "object" && !!m && m.constructor && Object.prototype.toString.call(m).slice(8, -1) === "Object";
}
function isNode(m) {
	return typeof window < "u" && window.HTMLElement !== void 0 ? m instanceof HTMLElement : m && (m.nodeType === 1 || m.nodeType === 11);
}
function extend$1(...m) {
	let x = Object(m[0]), S = [
		"__proto__",
		"constructor",
		"prototype"
	];
	for (let C = 1; C < m.length; C += 1) {
		let T = m[C];
		if (T != null && !isNode(T)) {
			let m = Object.keys(Object(T)).filter((m) => S.indexOf(m) < 0);
			for (let S = 0, C = m.length; S < C; S += 1) {
				let C = m[S], D = Object.getOwnPropertyDescriptor(T, C);
				D !== void 0 && D.enumerable && (isObject$1(x[C]) && isObject$1(T[C]) ? T[C].__swiper__ ? x[C] = T[C] : extend$1(x[C], T[C]) : !isObject$1(x[C]) && isObject$1(T[C]) ? (x[C] = {}, T[C].__swiper__ ? x[C] = T[C] : extend$1(x[C], T[C])) : x[C] = T[C]);
			}
		}
	}
	return x;
}
function setCSSProperty(m, x, S) {
	m.style.setProperty(x, S);
}
function animateCSSModeScroll({ swiper: m, targetPosition: x, side: S }) {
	let C = getWindow(), T = -m.translate, D = null, O, k = m.params.speed;
	m.wrapperEl.style.scrollSnapType = "none", C.cancelAnimationFrame(m.cssModeFrameID);
	let A = x > T ? "next" : "prev", j = (m, x) => A === "next" && m >= x || A === "prev" && m <= x, M = () => {
		O = (/* @__PURE__ */ new Date()).getTime(), D === null && (D = O);
		let A = Math.max(Math.min((O - D) / k, 1), 0), N = T + (.5 - Math.cos(A * Math.PI) / 2) * (x - T);
		if (j(N, x) && (N = x), m.wrapperEl.scrollTo({ [S]: N }), j(N, x)) {
			m.wrapperEl.style.overflow = "hidden", m.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
				m.wrapperEl.style.overflow = "", m.wrapperEl.scrollTo({ [S]: N });
			}), C.cancelAnimationFrame(m.cssModeFrameID);
			return;
		}
		m.cssModeFrameID = C.requestAnimationFrame(M);
	};
	M();
}
function elementChildren(m, x = "") {
	let S = getWindow(), C = [...m.children];
	return S.HTMLSlotElement && m instanceof HTMLSlotElement && C.push(...m.assignedElements()), x ? C.filter((m) => m.matches(x)) : C;
}
function elementIsChildOfSlot(m, x) {
	let S = [x];
	for (; S.length > 0;) {
		let x = S.shift();
		if (m === x) return !0;
		S.push(...x.children, ...x.shadowRoot ? x.shadowRoot.children : [], ...x.assignedElements ? x.assignedElements() : []);
	}
}
function elementIsChildOf(m, x) {
	let S = getWindow(), C = x.contains(m);
	return !C && S.HTMLSlotElement && x instanceof HTMLSlotElement && (C = [...x.assignedElements()].includes(m), C ||= elementIsChildOfSlot(m, x)), C;
}
function showWarning(m) {
	try {
		console.warn(m);
		return;
	} catch {}
}
function createElement$1(m, x = []) {
	let S = document.createElement(m);
	return S.classList.add(...Array.isArray(x) ? x : classesToTokens(x)), S;
}
function elementPrevAll(m, x) {
	let S = [];
	for (; m.previousElementSibling;) {
		let C = m.previousElementSibling;
		x ? C.matches(x) && S.push(C) : S.push(C), m = C;
	}
	return S;
}
function elementNextAll(m, x) {
	let S = [];
	for (; m.nextElementSibling;) {
		let C = m.nextElementSibling;
		x ? C.matches(x) && S.push(C) : S.push(C), m = C;
	}
	return S;
}
function elementStyle(m, x) {
	return getWindow().getComputedStyle(m, null).getPropertyValue(x);
}
function elementIndex(m) {
	let x = m, S;
	if (x) {
		for (S = 0; (x = x.previousSibling) !== null;) x.nodeType === 1 && (S += 1);
		return S;
	}
}
function elementParents(m, x) {
	let S = [], C = m.parentElement;
	for (; C;) x ? C.matches(x) && S.push(C) : S.push(C), C = C.parentElement;
	return S;
}
function elementOuterSize(m, x, S) {
	let C = getWindow();
	return S ? m[x === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(C.getComputedStyle(m, null).getPropertyValue(x === "width" ? "margin-right" : "margin-top")) + parseFloat(C.getComputedStyle(m, null).getPropertyValue(x === "width" ? "margin-left" : "margin-bottom")) : m.offsetWidth;
}
function setInnerHTML(m, x = "") {
	typeof trustedTypes < "u" ? m.innerHTML = trustedTypes.createPolicy("html", { createHTML: (m) => m }).createHTML(x) : m.innerHTML = x;
}
var support;
function calcSupport() {
	let m = getWindow(), x = getDocument();
	return {
		smoothScroll: x.documentElement && x.documentElement.style && "scrollBehavior" in x.documentElement.style,
		touch: !!("ontouchstart" in m || m.DocumentTouch && x instanceof m.DocumentTouch)
	};
}
function getSupport() {
	return support ||= calcSupport(), support;
}
var deviceCached;
function calcDevice({ userAgent: m } = {}) {
	let x = getSupport(), S = getWindow(), C = S.navigator.platform, T = m || S.navigator.userAgent, D = {
		ios: !1,
		android: !1
	}, O = S.screen.width, k = S.screen.height, A = T.match(/(Android);?[\s\/]+([\d.]+)?/), j = T.match(/(iPad)(?!\1).*OS\s([\d_]+)/), M = T.match(/(iPod)(.*OS\s([\d_]+))?/), N = !j && T.match(/(iPhone\sOS|iOS)\s([\d_]+)/), P = C === "Win32", F = C === "MacIntel";
	return !j && F && x.touch && [
		"1024x1366",
		"1366x1024",
		"834x1194",
		"1194x834",
		"834x1112",
		"1112x834",
		"768x1024",
		"1024x768",
		"820x1180",
		"1180x820",
		"810x1080",
		"1080x810"
	].indexOf(`${O}x${k}`) >= 0 && (j = T.match(/(Version)\/([\d.]+)/), j ||= [
		0,
		1,
		"13_0_0"
	], F = !1), A && !P && (D.os = "android", D.android = !0), (j || N || M) && (D.os = "ios", D.ios = !0), D;
}
function getDevice(m = {}) {
	return deviceCached ||= calcDevice(m), deviceCached;
}
var browser;
function calcBrowser() {
	let m = getWindow(), x = getDevice(), S = !1;
	function C() {
		let x = m.navigator.userAgent.toLowerCase();
		return x.indexOf("safari") >= 0 && x.indexOf("chrome") < 0 && x.indexOf("android") < 0;
	}
	if (C()) {
		let x = String(m.navigator.userAgent);
		if (x.includes("Version/")) {
			let [m, C] = x.split("Version/")[1].split(" ")[0].split(".").map((m) => Number(m));
			S = m < 16 || m === 16 && C < 2;
		}
	}
	let T = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(m.navigator.userAgent), D = C(), O = D || T && x.ios;
	return {
		isSafari: S || D,
		needPerspectiveFix: S,
		need3dFix: O,
		isWebView: T
	};
}
function getBrowser() {
	return browser ||= calcBrowser(), browser;
}
function Resize({ swiper: m, on: x, emit: S }) {
	let C = getWindow(), T = null, D = null, O = () => {
		!m || m.destroyed || !m.initialized || (S("beforeResize"), S("resize"));
	}, k = () => {
		!m || m.destroyed || !m.initialized || (T = new ResizeObserver((x) => {
			D = C.requestAnimationFrame(() => {
				let { width: S, height: C } = m, T = S, D = C;
				x.forEach(({ contentBoxSize: x, contentRect: S, target: C }) => {
					C && C !== m.el || (T = S ? S.width : (x[0] || x).inlineSize, D = S ? S.height : (x[0] || x).blockSize);
				}), (T !== S || D !== C) && O();
			});
		}), T.observe(m.el));
	}, A = () => {
		D && C.cancelAnimationFrame(D), T && T.unobserve && m.el && (T.unobserve(m.el), T = null);
	}, j = () => {
		!m || m.destroyed || !m.initialized || S("orientationchange");
	};
	x("init", () => {
		if (m.params.resizeObserver && C.ResizeObserver !== void 0) {
			k();
			return;
		}
		C.addEventListener("resize", O), C.addEventListener("orientationchange", j);
	}), x("destroy", () => {
		A(), C.removeEventListener("resize", O), C.removeEventListener("orientationchange", j);
	});
}
function Observer({ swiper: m, extendParams: x, on: S, emit: C }) {
	let T = [], D = getWindow(), O = (x, S = {}) => {
		let O = new (D.MutationObserver || D.WebkitMutationObserver)((x) => {
			if (m.__preventObserver__) return;
			if (x.length === 1) {
				C("observerUpdate", x[0]);
				return;
			}
			let S = function() {
				C("observerUpdate", x[0]);
			};
			D.requestAnimationFrame ? D.requestAnimationFrame(S) : D.setTimeout(S, 0);
		});
		O.observe(x, {
			attributes: S.attributes === void 0 ? !0 : S.attributes,
			childList: m.isElement || (S.childList === void 0 ? !0 : S).childList,
			characterData: S.characterData === void 0 ? !0 : S.characterData
		}), T.push(O);
	};
	x({
		observer: !1,
		observeParents: !1,
		observeSlideChildren: !1
	}), S("init", () => {
		if (m.params.observer) {
			if (m.params.observeParents) {
				let x = elementParents(m.hostEl);
				for (let m = 0; m < x.length; m += 1) O(x[m]);
			}
			O(m.hostEl, { childList: m.params.observeSlideChildren }), O(m.wrapperEl, { attributes: !1 });
		}
	}), S("destroy", () => {
		T.forEach((m) => {
			m.disconnect();
		}), T.splice(0, T.length);
	});
}
var eventsEmitter = {
	on(m, x, S) {
		let C = this;
		if (!C.eventsListeners || C.destroyed || typeof x != "function") return C;
		let T = S ? "unshift" : "push";
		return m.split(" ").forEach((m) => {
			C.eventsListeners[m] || (C.eventsListeners[m] = []), C.eventsListeners[m][T](x);
		}), C;
	},
	once(m, x, S) {
		let C = this;
		if (!C.eventsListeners || C.destroyed || typeof x != "function") return C;
		function T(...S) {
			C.off(m, T), T.__emitterProxy && delete T.__emitterProxy, x.apply(C, S);
		}
		return T.__emitterProxy = x, C.on(m, T, S);
	},
	onAny(m, x) {
		let S = this;
		if (!S.eventsListeners || S.destroyed || typeof m != "function") return S;
		let C = x ? "unshift" : "push";
		return S.eventsAnyListeners.indexOf(m) < 0 && S.eventsAnyListeners[C](m), S;
	},
	offAny(m) {
		let x = this;
		if (!x.eventsListeners || x.destroyed || !x.eventsAnyListeners) return x;
		let S = x.eventsAnyListeners.indexOf(m);
		return S >= 0 && x.eventsAnyListeners.splice(S, 1), x;
	},
	off(m, x) {
		let S = this;
		return !S.eventsListeners || S.destroyed || !S.eventsListeners || m.split(" ").forEach((m) => {
			x === void 0 ? S.eventsListeners[m] = [] : S.eventsListeners[m] && S.eventsListeners[m].forEach((C, T) => {
				(C === x || C.__emitterProxy && C.__emitterProxy === x) && S.eventsListeners[m].splice(T, 1);
			});
		}), S;
	},
	emit(...m) {
		let x = this;
		if (!x.eventsListeners || x.destroyed || !x.eventsListeners) return x;
		let S, C, T;
		return typeof m[0] == "string" || Array.isArray(m[0]) ? (S = m[0], C = m.slice(1, m.length), T = x) : (S = m[0].events, C = m[0].data, T = m[0].context || x), C.unshift(T), (Array.isArray(S) ? S : S.split(" ")).forEach((m) => {
			x.eventsAnyListeners && x.eventsAnyListeners.length && x.eventsAnyListeners.forEach((x) => {
				x.apply(T, [m, ...C]);
			}), x.eventsListeners && x.eventsListeners[m] && x.eventsListeners[m].forEach((m) => {
				m.apply(T, C);
			});
		}), x;
	}
};
function updateSize() {
	let m = this, x, S, C = m.el;
	x = m.params.width !== void 0 && m.params.width !== null ? m.params.width : C.clientWidth, S = m.params.height !== void 0 && m.params.height !== null ? m.params.height : C.clientHeight, !(x === 0 && m.isHorizontal() || S === 0 && m.isVertical()) && (x = x - parseInt(elementStyle(C, "padding-left") || 0, 10) - parseInt(elementStyle(C, "padding-right") || 0, 10), S = S - parseInt(elementStyle(C, "padding-top") || 0, 10) - parseInt(elementStyle(C, "padding-bottom") || 0, 10), Number.isNaN(x) && (x = 0), Number.isNaN(S) && (S = 0), Object.assign(m, {
		width: x,
		height: S,
		size: m.isHorizontal() ? x : S
	}));
}
function updateSlides() {
	let m = this;
	function x(x, S) {
		return parseFloat(x.getPropertyValue(m.getDirectionLabel(S)) || 0);
	}
	let S = m.params, { wrapperEl: C, slidesEl: T, rtlTranslate: D, wrongRTL: O } = m, k = m.virtual && S.virtual.enabled, A = k ? m.virtual.slides.length : m.slides.length, j = elementChildren(T, `.${m.params.slideClass}, swiper-slide`), M = k ? m.virtual.slides.length : j.length, N = [], P = [], F = [], I = S.slidesOffsetBefore;
	typeof I == "function" && (I = S.slidesOffsetBefore.call(m));
	let L = S.slidesOffsetAfter;
	typeof L == "function" && (L = S.slidesOffsetAfter.call(m));
	let R = m.snapGrid.length, z = m.slidesGrid.length, B = m.size - I - L, H = S.spaceBetween, U = -I, W = 0, G = 0;
	if (B === void 0) return;
	typeof H == "string" && H.indexOf("%") >= 0 ? H = parseFloat(H.replace("%", "")) / 100 * B : typeof H == "string" && (H = parseFloat(H)), m.virtualSize = -H - I - L, j.forEach((m) => {
		D ? m.style.marginLeft = "" : m.style.marginRight = "", m.style.marginBottom = "", m.style.marginTop = "";
	}), S.centeredSlides && S.cssMode && (setCSSProperty(C, "--swiper-centered-offset-before", ""), setCSSProperty(C, "--swiper-centered-offset-after", ""));
	let K = S.grid && S.grid.rows > 1 && m.grid;
	K ? m.grid.initSlides(j) : m.grid && m.grid.unsetSlides();
	let q, J = S.slidesPerView === "auto" && S.breakpoints && Object.keys(S.breakpoints).filter((m) => S.breakpoints[m].slidesPerView !== void 0).length > 0;
	for (let C = 0; C < M; C += 1) {
		q = 0;
		let T = j[C];
		if (!(T && (K && m.grid.updateSlide(C, T, j), elementStyle(T, "display") === "none"))) {
			if (k && S.slidesPerView === "auto") S.virtual.slidesPerViewAutoSlideSize && (q = S.virtual.slidesPerViewAutoSlideSize), q && T && (S.roundLengths && (q = Math.floor(q)), T.style[m.getDirectionLabel("width")] = `${q}px`);
			else if (S.slidesPerView === "auto") {
				J && (T.style[m.getDirectionLabel("width")] = "");
				let C = getComputedStyle(T), D = T.style.transform, O = T.style.webkitTransform;
				if (D && (T.style.transform = "none"), O && (T.style.webkitTransform = "none"), S.roundLengths) q = m.isHorizontal() ? elementOuterSize(T, "width", !0) : elementOuterSize(T, "height", !0);
				else {
					let m = x(C, "width"), S = x(C, "padding-left"), D = x(C, "padding-right"), O = x(C, "margin-left"), k = x(C, "margin-right"), A = C.getPropertyValue("box-sizing");
					if (A && A === "border-box") q = m + O + k;
					else {
						let { clientWidth: x, offsetWidth: C } = T;
						q = m + S + D + O + k + (C - x);
					}
				}
				D && (T.style.transform = D), O && (T.style.webkitTransform = O), S.roundLengths && (q = Math.floor(q));
			} else q = (B - (S.slidesPerView - 1) * H) / S.slidesPerView, S.roundLengths && (q = Math.floor(q)), T && (T.style[m.getDirectionLabel("width")] = `${q}px`);
			T && (T.swiperSlideSize = q), F.push(q), S.centeredSlides ? (U = U + q / 2 + W / 2 + H, W === 0 && C !== 0 && (U = U - B / 2 - H), C === 0 && (U = U - B / 2 - H), Math.abs(U) < 1 / 1e3 && (U = 0), S.roundLengths && (U = Math.floor(U)), G % S.slidesPerGroup === 0 && N.push(U), P.push(U)) : (S.roundLengths && (U = Math.floor(U)), (G - Math.min(m.params.slidesPerGroupSkip, G)) % m.params.slidesPerGroup === 0 && N.push(U), P.push(U), U = U + q + H), m.virtualSize += q + H, W = q, G += 1;
		}
	}
	if (m.virtualSize = Math.max(m.virtualSize, B) + L, D && O && (S.effect === "slide" || S.effect === "coverflow") && (C.style.width = `${m.virtualSize + H}px`), S.setWrapperSize && (C.style[m.getDirectionLabel("width")] = `${m.virtualSize + H}px`), K && m.grid.updateWrapperSize(q, N), !S.centeredSlides) {
		let x = [];
		for (let C = 0; C < N.length; C += 1) {
			let T = N[C];
			S.roundLengths && (T = Math.floor(T)), N[C] <= m.virtualSize - B && x.push(T);
		}
		N = x, Math.floor(m.virtualSize - B) - Math.floor(N[N.length - 1]) > 1 && N.push(m.virtualSize - B);
	}
	if (k && S.loop) {
		let x = F[0] + H;
		if (S.slidesPerGroup > 1) {
			let C = Math.ceil((m.virtual.slidesBefore + m.virtual.slidesAfter) / S.slidesPerGroup), T = x * S.slidesPerGroup;
			for (let m = 0; m < C; m += 1) N.push(N[N.length - 1] + T);
		}
		for (let C = 0; C < m.virtual.slidesBefore + m.virtual.slidesAfter; C += 1) S.slidesPerGroup === 1 && N.push(N[N.length - 1] + x), P.push(P[P.length - 1] + x), m.virtualSize += x;
	}
	if (N.length === 0 && (N = [0]), H !== 0) {
		let x = m.isHorizontal() && D ? "marginLeft" : m.getDirectionLabel("marginRight");
		j.filter((m, x) => !S.cssMode || S.loop ? !0 : x !== j.length - 1).forEach((m) => {
			m.style[x] = `${H}px`;
		});
	}
	if (S.centeredSlides && S.centeredSlidesBounds) {
		let m = 0;
		F.forEach((x) => {
			m += x + (H || 0);
		}), m -= H;
		let x = m > B ? m - B : 0;
		N = N.map((m) => m <= 0 ? -I : m > x ? x + L : m);
	}
	if (S.centerInsufficientSlides) {
		let m = 0;
		F.forEach((x) => {
			m += x + (H || 0);
		}), m -= H;
		let x = (I || 0) + (L || 0);
		if (m + x < B) {
			let S = (B - m - x) / 2;
			N.forEach((m, x) => {
				N[x] = m - S;
			}), P.forEach((m, x) => {
				P[x] = m + S;
			});
		}
	}
	if (Object.assign(m, {
		slides: j,
		snapGrid: N,
		slidesGrid: P,
		slidesSizesGrid: F
	}), S.centeredSlides && S.cssMode && !S.centeredSlidesBounds) {
		setCSSProperty(C, "--swiper-centered-offset-before", `${-N[0]}px`), setCSSProperty(C, "--swiper-centered-offset-after", `${m.size / 2 - F[F.length - 1] / 2}px`);
		let x = -m.snapGrid[0], S = -m.slidesGrid[0];
		m.snapGrid = m.snapGrid.map((m) => m + x), m.slidesGrid = m.slidesGrid.map((m) => m + S);
	}
	if (M !== A && m.emit("slidesLengthChange"), N.length !== R && (m.params.watchOverflow && m.checkOverflow(), m.emit("snapGridLengthChange")), P.length !== z && m.emit("slidesGridLengthChange"), S.watchSlidesProgress && m.updateSlidesOffset(), m.emit("slidesUpdated"), !k && !S.cssMode && (S.effect === "slide" || S.effect === "fade")) {
		let x = `${S.containerModifierClass}backface-hidden`, C = m.el.classList.contains(x);
		M <= S.maxBackfaceHiddenSlides ? C || m.el.classList.add(x) : C && m.el.classList.remove(x);
	}
}
function updateAutoHeight(m) {
	let x = this, S = [], C = x.virtual && x.params.virtual.enabled, T = 0, D;
	typeof m == "number" ? x.setTransition(m) : m === !0 && x.setTransition(x.params.speed);
	let O = (m) => C ? x.slides[x.getSlideIndexByData(m)] : x.slides[m];
	if (x.params.slidesPerView !== "auto" && x.params.slidesPerView > 1) if (x.params.centeredSlides) (x.visibleSlides || []).forEach((m) => {
		S.push(m);
	});
	else for (D = 0; D < Math.ceil(x.params.slidesPerView); D += 1) {
		let m = x.activeIndex + D;
		if (m > x.slides.length && !C) break;
		S.push(O(m));
	}
	else S.push(O(x.activeIndex));
	for (D = 0; D < S.length; D += 1) if (S[D] !== void 0) {
		let m = S[D].offsetHeight;
		T = m > T ? m : T;
	}
	(T || T === 0) && (x.wrapperEl.style.height = `${T}px`);
}
function updateSlidesOffset() {
	let m = this, x = m.slides, S = m.isElement ? m.isHorizontal() ? m.wrapperEl.offsetLeft : m.wrapperEl.offsetTop : 0;
	for (let C = 0; C < x.length; C += 1) x[C].swiperSlideOffset = (m.isHorizontal() ? x[C].offsetLeft : x[C].offsetTop) - S - m.cssOverflowAdjustment();
}
var toggleSlideClasses$1 = (m, x, S) => {
	x && !m.classList.contains(S) ? m.classList.add(S) : !x && m.classList.contains(S) && m.classList.remove(S);
};
function updateSlidesProgress(m = this && this.translate || 0) {
	let x = this, S = x.params, { slides: C, rtlTranslate: T, snapGrid: D } = x;
	if (C.length === 0) return;
	C[0].swiperSlideOffset === void 0 && x.updateSlidesOffset();
	let O = -m;
	T && (O = m), x.visibleSlidesIndexes = [], x.visibleSlides = [];
	let k = S.spaceBetween;
	typeof k == "string" && k.indexOf("%") >= 0 ? k = parseFloat(k.replace("%", "")) / 100 * x.size : typeof k == "string" && (k = parseFloat(k));
	for (let m = 0; m < C.length; m += 1) {
		let A = C[m], j = A.swiperSlideOffset;
		S.cssMode && S.centeredSlides && (j -= C[0].swiperSlideOffset);
		let M = (O + (S.centeredSlides ? x.minTranslate() : 0) - j) / (A.swiperSlideSize + k), N = (O - D[0] + (S.centeredSlides ? x.minTranslate() : 0) - j) / (A.swiperSlideSize + k), P = -(O - j), F = P + x.slidesSizesGrid[m], I = P >= 0 && P <= x.size - x.slidesSizesGrid[m], L = P >= 0 && P < x.size - 1 || F > 1 && F <= x.size || P <= 0 && F >= x.size;
		L && (x.visibleSlides.push(A), x.visibleSlidesIndexes.push(m)), toggleSlideClasses$1(A, L, S.slideVisibleClass), toggleSlideClasses$1(A, I, S.slideFullyVisibleClass), A.progress = T ? -M : M, A.originalProgress = T ? -N : N;
	}
}
function updateProgress(m) {
	let x = this;
	if (m === void 0) {
		let S = x.rtlTranslate ? -1 : 1;
		m = x && x.translate && x.translate * S || 0;
	}
	let S = x.params, C = x.maxTranslate() - x.minTranslate(), { progress: T, isBeginning: D, isEnd: O, progressLoop: k } = x, A = D, j = O;
	if (C === 0) T = 0, D = !0, O = !0;
	else {
		T = (m - x.minTranslate()) / C;
		let S = Math.abs(m - x.minTranslate()) < 1, k = Math.abs(m - x.maxTranslate()) < 1;
		D = S || T <= 0, O = k || T >= 1, S && (T = 0), k && (T = 1);
	}
	if (S.loop) {
		let S = x.getSlideIndexByData(0), C = x.getSlideIndexByData(x.slides.length - 1), T = x.slidesGrid[S], D = x.slidesGrid[C], O = x.slidesGrid[x.slidesGrid.length - 1], A = Math.abs(m);
		k = A >= T ? (A - T) / O : (A + O - D) / O, k > 1 && --k;
	}
	Object.assign(x, {
		progress: T,
		progressLoop: k,
		isBeginning: D,
		isEnd: O
	}), (S.watchSlidesProgress || S.centeredSlides && S.autoHeight) && x.updateSlidesProgress(m), D && !A && x.emit("reachBeginning toEdge"), O && !j && x.emit("reachEnd toEdge"), (A && !D || j && !O) && x.emit("fromEdge"), x.emit("progress", T);
}
var toggleSlideClasses = (m, x, S) => {
	x && !m.classList.contains(S) ? m.classList.add(S) : !x && m.classList.contains(S) && m.classList.remove(S);
};
function updateSlidesClasses() {
	let m = this, { slides: x, params: S, slidesEl: C, activeIndex: T } = m, D = m.virtual && S.virtual.enabled, O = m.grid && S.grid && S.grid.rows > 1, k = (m) => elementChildren(C, `.${S.slideClass}${m}, swiper-slide${m}`)[0], A, j, M;
	if (D) if (S.loop) {
		let x = T - m.virtual.slidesBefore;
		x < 0 && (x = m.virtual.slides.length + x), x >= m.virtual.slides.length && (x -= m.virtual.slides.length), A = k(`[data-swiper-slide-index="${x}"]`);
	} else A = k(`[data-swiper-slide-index="${T}"]`);
	else O ? (A = x.find((m) => m.column === T), M = x.find((m) => m.column === T + 1), j = x.find((m) => m.column === T - 1)) : A = x[T];
	A && (O || (M = elementNextAll(A, `.${S.slideClass}, swiper-slide`)[0], S.loop && !M && (M = x[0]), j = elementPrevAll(A, `.${S.slideClass}, swiper-slide`)[0], S.loop)), x.forEach((m) => {
		toggleSlideClasses(m, m === A, S.slideActiveClass), toggleSlideClasses(m, m === M, S.slideNextClass), toggleSlideClasses(m, m === j, S.slidePrevClass);
	}), m.emitSlidesClasses();
}
var processLazyPreloader = (m, x) => {
	if (!m || m.destroyed || !m.params) return;
	let S = x.closest((() => m.isElement ? "swiper-slide" : `.${m.params.slideClass}`)());
	if (S) {
		let x = S.querySelector(`.${m.params.lazyPreloaderClass}`);
		!x && m.isElement && (S.shadowRoot ? x = S.shadowRoot.querySelector(`.${m.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
			S.shadowRoot && (x = S.shadowRoot.querySelector(`.${m.params.lazyPreloaderClass}`), x && x.remove());
		})), x && x.remove();
	}
}, unlazy = (m, x) => {
	if (!m.slides[x]) return;
	let S = m.slides[x].querySelector("[loading=\"lazy\"]");
	S && S.removeAttribute("loading");
}, preload = (m) => {
	if (!m || m.destroyed || !m.params) return;
	let x = m.params.lazyPreloadPrevNext, S = m.slides.length;
	if (!S || !x || x < 0) return;
	x = Math.min(x, S);
	let C = m.params.slidesPerView === "auto" ? m.slidesPerViewDynamic() : Math.ceil(m.params.slidesPerView), T = m.activeIndex;
	if (m.params.grid && m.params.grid.rows > 1) {
		let S = T, D = [S - x];
		D.push(...Array.from({ length: x }).map((m, x) => S + C + x)), m.slides.forEach((x, S) => {
			D.includes(x.column) && unlazy(m, S);
		});
		return;
	}
	let D = T + C - 1;
	if (m.params.rewind || m.params.loop) for (let C = T - x; C <= D + x; C += 1) {
		let x = (C % S + S) % S;
		(x < T || x > D) && unlazy(m, x);
	}
	else for (let C = Math.max(T - x, 0); C <= Math.min(D + x, S - 1); C += 1) C !== T && (C > D || C < T) && unlazy(m, C);
};
function getActiveIndexByTranslate(m) {
	let { slidesGrid: x, params: S } = m, C = m.rtlTranslate ? m.translate : -m.translate, T;
	for (let m = 0; m < x.length; m += 1) x[m + 1] === void 0 ? C >= x[m] && (T = m) : C >= x[m] && C < x[m + 1] - (x[m + 1] - x[m]) / 2 ? T = m : C >= x[m] && C < x[m + 1] && (T = m + 1);
	return S.normalizeSlideIndex && (T < 0 || T === void 0) && (T = 0), T;
}
function updateActiveIndex(m) {
	let x = this, S = x.rtlTranslate ? x.translate : -x.translate, { snapGrid: C, params: T, activeIndex: D, realIndex: O, snapIndex: k } = x, A = m, j, M = (m) => {
		let S = m - x.virtual.slidesBefore;
		return S < 0 && (S = x.virtual.slides.length + S), S >= x.virtual.slides.length && (S -= x.virtual.slides.length), S;
	};
	if (A === void 0 && (A = getActiveIndexByTranslate(x)), C.indexOf(S) >= 0) j = C.indexOf(S);
	else {
		let m = Math.min(T.slidesPerGroupSkip, A);
		j = m + Math.floor((A - m) / T.slidesPerGroup);
	}
	if (j >= C.length && (j = C.length - 1), A === D && !x.params.loop) {
		j !== k && (x.snapIndex = j, x.emit("snapIndexChange"));
		return;
	}
	if (A === D && x.params.loop && x.virtual && x.params.virtual.enabled) {
		x.realIndex = M(A);
		return;
	}
	let N = x.grid && T.grid && T.grid.rows > 1, P;
	if (x.virtual && T.virtual.enabled && T.loop) P = M(A);
	else if (N) {
		let m = x.slides.find((m) => m.column === A), S = parseInt(m.getAttribute("data-swiper-slide-index"), 10);
		Number.isNaN(S) && (S = Math.max(x.slides.indexOf(m), 0)), P = Math.floor(S / T.grid.rows);
	} else if (x.slides[A]) {
		let m = x.slides[A].getAttribute("data-swiper-slide-index");
		P = m ? parseInt(m, 10) : A;
	} else P = A;
	Object.assign(x, {
		previousSnapIndex: k,
		snapIndex: j,
		previousRealIndex: O,
		realIndex: P,
		previousIndex: D,
		activeIndex: A
	}), x.initialized && preload(x), x.emit("activeIndexChange"), x.emit("snapIndexChange"), (x.initialized || x.params.runCallbacksOnInit) && (O !== P && x.emit("realIndexChange"), x.emit("slideChange"));
}
function updateClickedSlide(m, x) {
	let S = this, C = S.params, T = m.closest(`.${C.slideClass}, swiper-slide`);
	!T && S.isElement && x && x.length > 1 && x.includes(m) && [...x.slice(x.indexOf(m) + 1, x.length)].forEach((m) => {
		!T && m.matches && m.matches(`.${C.slideClass}, swiper-slide`) && (T = m);
	});
	let D = !1, O;
	if (T) {
		for (let m = 0; m < S.slides.length; m += 1) if (S.slides[m] === T) {
			D = !0, O = m;
			break;
		}
	}
	if (T && D) S.clickedSlide = T, S.virtual && S.params.virtual.enabled ? S.clickedIndex = parseInt(T.getAttribute("data-swiper-slide-index"), 10) : S.clickedIndex = O;
	else {
		S.clickedSlide = void 0, S.clickedIndex = void 0;
		return;
	}
	C.slideToClickedSlide && S.clickedIndex !== void 0 && S.clickedIndex !== S.activeIndex && S.slideToClickedSlide();
}
var update = {
	updateSize,
	updateSlides,
	updateAutoHeight,
	updateSlidesOffset,
	updateSlidesProgress,
	updateProgress,
	updateSlidesClasses,
	updateActiveIndex,
	updateClickedSlide
};
function getSwiperTranslate(m = this.isHorizontal() ? "x" : "y") {
	let x = this, { params: S, rtlTranslate: C, translate: T, wrapperEl: D } = x;
	if (S.virtualTranslate) return C ? -T : T;
	if (S.cssMode) return T;
	let O = getTranslate(D, m);
	return O += x.cssOverflowAdjustment(), C && (O = -O), O || 0;
}
function setTranslate(m, x) {
	let S = this, { rtlTranslate: C, params: T, wrapperEl: D, progress: O } = S, k = 0, A = 0;
	S.isHorizontal() ? k = C ? -m : m : A = m, T.roundLengths && (k = Math.floor(k), A = Math.floor(A)), S.previousTranslate = S.translate, S.translate = S.isHorizontal() ? k : A, T.cssMode ? D[S.isHorizontal() ? "scrollLeft" : "scrollTop"] = S.isHorizontal() ? -k : -A : T.virtualTranslate || (S.isHorizontal() ? k -= S.cssOverflowAdjustment() : A -= S.cssOverflowAdjustment(), D.style.transform = `translate3d(${k}px, ${A}px, 0px)`);
	let j, M = S.maxTranslate() - S.minTranslate();
	j = M === 0 ? 0 : (m - S.minTranslate()) / M, j !== O && S.updateProgress(m), S.emit("setTranslate", S.translate, x);
}
function minTranslate() {
	return -this.snapGrid[0];
}
function maxTranslate() {
	return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(m = 0, x = this.params.speed, S = !0, C = !0, T) {
	let D = this, { params: O, wrapperEl: k } = D;
	if (D.animating && O.preventInteractionOnTransition) return !1;
	let A = D.minTranslate(), j = D.maxTranslate(), M;
	if (M = C && m > A ? A : C && m < j ? j : m, D.updateProgress(M), O.cssMode) {
		let m = D.isHorizontal();
		if (x === 0) k[m ? "scrollLeft" : "scrollTop"] = -M;
		else {
			if (!D.support.smoothScroll) return animateCSSModeScroll({
				swiper: D,
				targetPosition: -M,
				side: m ? "left" : "top"
			}), !0;
			k.scrollTo({
				[m ? "left" : "top"]: -M,
				behavior: "smooth"
			});
		}
		return !0;
	}
	return x === 0 ? (D.setTransition(0), D.setTranslate(M), S && (D.emit("beforeTransitionStart", x, T), D.emit("transitionEnd"))) : (D.setTransition(x), D.setTranslate(M), S && (D.emit("beforeTransitionStart", x, T), D.emit("transitionStart")), D.animating || (D.animating = !0, D.onTranslateToWrapperTransitionEnd ||= function(m) {
		!D || D.destroyed || m.target === this && (D.wrapperEl.removeEventListener("transitionend", D.onTranslateToWrapperTransitionEnd), D.onTranslateToWrapperTransitionEnd = null, delete D.onTranslateToWrapperTransitionEnd, D.animating = !1, S && D.emit("transitionEnd"));
	}, D.wrapperEl.addEventListener("transitionend", D.onTranslateToWrapperTransitionEnd))), !0;
}
var translate = {
	getTranslate: getSwiperTranslate,
	setTranslate,
	minTranslate,
	maxTranslate,
	translateTo
};
function setTransition(m, x) {
	let S = this;
	S.params.cssMode || (S.wrapperEl.style.transitionDuration = `${m}ms`, S.wrapperEl.style.transitionDelay = m === 0 ? "0ms" : ""), S.emit("setTransition", m, x);
}
function transitionEmit({ swiper: m, runCallbacks: x, direction: S, step: C }) {
	let { activeIndex: T, previousIndex: D } = m, O = S;
	O ||= T > D ? "next" : T < D ? "prev" : "reset", m.emit(`transition${C}`), x && O === "reset" ? m.emit(`slideResetTransition${C}`) : x && T !== D && (m.emit(`slideChangeTransition${C}`), O === "next" ? m.emit(`slideNextTransition${C}`) : m.emit(`slidePrevTransition${C}`));
}
function transitionStart(m = !0, x) {
	let S = this, { params: C } = S;
	C.cssMode || (C.autoHeight && S.updateAutoHeight(), transitionEmit({
		swiper: S,
		runCallbacks: m,
		direction: x,
		step: "Start"
	}));
}
function transitionEnd(m = !0, x) {
	let S = this, { params: C } = S;
	S.animating = !1, !C.cssMode && (S.setTransition(0), transitionEmit({
		swiper: S,
		runCallbacks: m,
		direction: x,
		step: "End"
	}));
}
var transition = {
	setTransition,
	transitionStart,
	transitionEnd
};
function slideTo(m = 0, x, S = !0, C, T) {
	typeof m == "string" && (m = parseInt(m, 10));
	let D = this, O = m;
	O < 0 && (O = 0);
	let { params: k, snapGrid: A, slidesGrid: j, previousIndex: M, activeIndex: N, rtlTranslate: P, wrapperEl: F, enabled: I } = D;
	if (!I && !C && !T || D.destroyed || D.animating && k.preventInteractionOnTransition) return !1;
	x === void 0 && (x = D.params.speed);
	let L = Math.min(D.params.slidesPerGroupSkip, O), R = L + Math.floor((O - L) / D.params.slidesPerGroup);
	R >= A.length && (R = A.length - 1);
	let z = -A[R];
	if (k.normalizeSlideIndex) for (let m = 0; m < j.length; m += 1) {
		let x = -Math.floor(z * 100), S = Math.floor(j[m] * 100), C = Math.floor(j[m + 1] * 100);
		j[m + 1] === void 0 ? x >= S && (O = m) : x >= S && x < C - (C - S) / 2 ? O = m : x >= S && x < C && (O = m + 1);
	}
	if (D.initialized && O !== N && (!D.allowSlideNext && (P ? z > D.translate && z > D.minTranslate() : z < D.translate && z < D.minTranslate()) || !D.allowSlidePrev && z > D.translate && z > D.maxTranslate() && (N || 0) !== O)) return !1;
	O !== (M || 0) && S && D.emit("beforeSlideChangeStart"), D.updateProgress(z);
	let B;
	B = O > N ? "next" : O < N ? "prev" : "reset";
	let H = D.virtual && D.params.virtual.enabled;
	if (!(H && T) && (P && -z === D.translate || !P && z === D.translate)) return D.updateActiveIndex(O), k.autoHeight && D.updateAutoHeight(), D.updateSlidesClasses(), k.effect !== "slide" && D.setTranslate(z), B !== "reset" && (D.transitionStart(S, B), D.transitionEnd(S, B)), !1;
	if (k.cssMode) {
		let m = D.isHorizontal(), S = P ? z : -z;
		if (x === 0) H && (D.wrapperEl.style.scrollSnapType = "none", D._immediateVirtual = !0), H && !D._cssModeVirtualInitialSet && D.params.initialSlide > 0 ? (D._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
			F[m ? "scrollLeft" : "scrollTop"] = S;
		})) : F[m ? "scrollLeft" : "scrollTop"] = S, H && requestAnimationFrame(() => {
			D.wrapperEl.style.scrollSnapType = "", D._immediateVirtual = !1;
		});
		else {
			if (!D.support.smoothScroll) return animateCSSModeScroll({
				swiper: D,
				targetPosition: S,
				side: m ? "left" : "top"
			}), !0;
			F.scrollTo({
				[m ? "left" : "top"]: S,
				behavior: "smooth"
			});
		}
		return !0;
	}
	let U = getBrowser().isSafari;
	return H && !T && U && D.isElement && D.virtual.update(!1, !1, O), D.setTransition(x), D.setTranslate(z), D.updateActiveIndex(O), D.updateSlidesClasses(), D.emit("beforeTransitionStart", x, C), D.transitionStart(S, B), x === 0 ? D.transitionEnd(S, B) : D.animating || (D.animating = !0, D.onSlideToWrapperTransitionEnd ||= function(m) {
		!D || D.destroyed || m.target === this && (D.wrapperEl.removeEventListener("transitionend", D.onSlideToWrapperTransitionEnd), D.onSlideToWrapperTransitionEnd = null, delete D.onSlideToWrapperTransitionEnd, D.transitionEnd(S, B));
	}, D.wrapperEl.addEventListener("transitionend", D.onSlideToWrapperTransitionEnd)), !0;
}
function slideToLoop(m = 0, x, S = !0, C) {
	typeof m == "string" && (m = parseInt(m, 10));
	let T = this;
	if (T.destroyed) return;
	x === void 0 && (x = T.params.speed);
	let D = T.grid && T.params.grid && T.params.grid.rows > 1, O = m;
	if (T.params.loop) if (T.virtual && T.params.virtual.enabled) O += T.virtual.slidesBefore;
	else {
		let m;
		if (D) {
			let x = O * T.params.grid.rows;
			m = T.slides.find((m) => m.getAttribute("data-swiper-slide-index") * 1 === x).column;
		} else m = T.getSlideIndexByData(O);
		let x = D ? Math.ceil(T.slides.length / T.params.grid.rows) : T.slides.length, { centeredSlides: S, slidesOffsetBefore: k, slidesOffsetAfter: A } = T.params, j = S || !!k || !!A, M = T.params.slidesPerView;
		M === "auto" ? M = T.slidesPerViewDynamic() : (M = Math.ceil(parseFloat(T.params.slidesPerView, 10)), j && M % 2 == 0 && (M += 1));
		let N = x - m < M;
		if (j && (N ||= m < Math.ceil(M / 2)), C && j && T.params.slidesPerView !== "auto" && !D && (N = !1), N) {
			let S = j ? m < T.activeIndex ? "prev" : "next" : m - T.activeIndex - 1 < T.params.slidesPerView ? "next" : "prev";
			T.loopFix({
				direction: S,
				slideTo: !0,
				activeSlideIndex: S === "next" ? m + 1 : m - x + 1,
				slideRealIndex: S === "next" ? T.realIndex : void 0
			});
		}
		if (D) {
			let m = O * T.params.grid.rows;
			O = T.slides.find((x) => x.getAttribute("data-swiper-slide-index") * 1 === m).column;
		} else O = T.getSlideIndexByData(O);
	}
	return requestAnimationFrame(() => {
		T.slideTo(O, x, S, C);
	}), T;
}
function slideNext(m, x = !0, S) {
	let C = this, { enabled: T, params: D, animating: O } = C;
	if (!T || C.destroyed) return C;
	m === void 0 && (m = C.params.speed);
	let k = D.slidesPerGroup;
	D.slidesPerView === "auto" && D.slidesPerGroup === 1 && D.slidesPerGroupAuto && (k = Math.max(C.slidesPerViewDynamic("current", !0), 1));
	let A = C.activeIndex < D.slidesPerGroupSkip ? 1 : k, j = C.virtual && D.virtual.enabled;
	if (D.loop) {
		if (O && !j && D.loopPreventsSliding) return !1;
		if (C.loopFix({ direction: "next" }), C._clientLeft = C.wrapperEl.clientLeft, C.activeIndex === C.slides.length - 1 && D.cssMode) return requestAnimationFrame(() => {
			C.slideTo(C.activeIndex + A, m, x, S);
		}), !0;
	}
	return D.rewind && C.isEnd ? C.slideTo(0, m, x, S) : C.slideTo(C.activeIndex + A, m, x, S);
}
function slidePrev(m, x = !0, S) {
	let C = this, { params: T, snapGrid: D, slidesGrid: O, rtlTranslate: k, enabled: A, animating: j } = C;
	if (!A || C.destroyed) return C;
	m === void 0 && (m = C.params.speed);
	let M = C.virtual && T.virtual.enabled;
	if (T.loop) {
		if (j && !M && T.loopPreventsSliding) return !1;
		C.loopFix({ direction: "prev" }), C._clientLeft = C.wrapperEl.clientLeft;
	}
	let N = k ? C.translate : -C.translate;
	function P(m) {
		return m < 0 ? -Math.floor(Math.abs(m)) : Math.floor(m);
	}
	let F = P(N), I = D.map((m) => P(m)), L = T.freeMode && T.freeMode.enabled, R = D[I.indexOf(F) - 1];
	if (R === void 0 && (T.cssMode || L)) {
		let m;
		D.forEach((x, S) => {
			F >= x && (m = S);
		}), m !== void 0 && (R = L ? D[m] : D[m > 0 ? m - 1 : m]);
	}
	let z = 0;
	if (R !== void 0 && (z = O.indexOf(R), z < 0 && (z = C.activeIndex - 1), T.slidesPerView === "auto" && T.slidesPerGroup === 1 && T.slidesPerGroupAuto && (z = z - C.slidesPerViewDynamic("previous", !0) + 1, z = Math.max(z, 0))), T.rewind && C.isBeginning) {
		let T = C.params.virtual && C.params.virtual.enabled && C.virtual ? C.virtual.slides.length - 1 : C.slides.length - 1;
		return C.slideTo(T, m, x, S);
	} else if (T.loop && C.activeIndex === 0 && T.cssMode) return requestAnimationFrame(() => {
		C.slideTo(z, m, x, S);
	}), !0;
	return C.slideTo(z, m, x, S);
}
function slideReset(m, x = !0, S) {
	let C = this;
	if (!C.destroyed) return m === void 0 && (m = C.params.speed), C.slideTo(C.activeIndex, m, x, S);
}
function slideToClosest(m, x = !0, S, C = .5) {
	let T = this;
	if (T.destroyed) return;
	m === void 0 && (m = T.params.speed);
	let D = T.activeIndex, O = Math.min(T.params.slidesPerGroupSkip, D), k = O + Math.floor((D - O) / T.params.slidesPerGroup), A = T.rtlTranslate ? T.translate : -T.translate;
	if (A >= T.snapGrid[k]) {
		let m = T.snapGrid[k], x = T.snapGrid[k + 1];
		A - m > (x - m) * C && (D += T.params.slidesPerGroup);
	} else {
		let m = T.snapGrid[k - 1], x = T.snapGrid[k];
		A - m <= (x - m) * C && (D -= T.params.slidesPerGroup);
	}
	return D = Math.max(D, 0), D = Math.min(D, T.slidesGrid.length - 1), T.slideTo(D, m, x, S);
}
function slideToClickedSlide() {
	let m = this;
	if (m.destroyed) return;
	let { params: x, slidesEl: S } = m, C = x.slidesPerView === "auto" ? m.slidesPerViewDynamic() : x.slidesPerView, T = m.getSlideIndexWhenGrid(m.clickedIndex), D, O = m.isElement ? "swiper-slide" : `.${x.slideClass}`, k = m.grid && m.params.grid && m.params.grid.rows > 1;
	if (x.loop) {
		if (m.animating) return;
		D = parseInt(m.clickedSlide.getAttribute("data-swiper-slide-index"), 10), x.centeredSlides ? m.slideToLoop(D) : T > (k ? (m.slides.length - C) / 2 - (m.params.grid.rows - 1) : m.slides.length - C) ? (m.loopFix(), T = m.getSlideIndex(elementChildren(S, `${O}[data-swiper-slide-index="${D}"]`)[0]), nextTick(() => {
			m.slideTo(T);
		})) : m.slideTo(T);
	} else m.slideTo(T);
}
var slide = {
	slideTo,
	slideToLoop,
	slideNext,
	slidePrev,
	slideReset,
	slideToClosest,
	slideToClickedSlide
};
function loopCreate(m, x) {
	let S = this, { params: C, slidesEl: T } = S;
	if (!C.loop || S.virtual && S.params.virtual.enabled) return;
	let D = () => {
		elementChildren(T, `.${C.slideClass}, swiper-slide`).forEach((m, x) => {
			m.setAttribute("data-swiper-slide-index", x);
		});
	}, O = () => {
		let m = elementChildren(T, `.${C.slideBlankClass}`);
		m.forEach((m) => {
			m.remove();
		}), m.length > 0 && (S.recalcSlides(), S.updateSlides());
	}, k = S.grid && C.grid && C.grid.rows > 1;
	C.loopAddBlankSlides && (C.slidesPerGroup > 1 || k) && O();
	let A = C.slidesPerGroup * (k ? C.grid.rows : 1), j = S.slides.length % A !== 0, M = k && S.slides.length % C.grid.rows !== 0, N = (m) => {
		for (let x = 0; x < m; x += 1) {
			let m = S.isElement ? createElement$1("swiper-slide", [C.slideBlankClass]) : createElement$1("div", [C.slideClass, C.slideBlankClass]);
			S.slidesEl.append(m);
		}
	};
	j ? (C.loopAddBlankSlides ? (N(A - S.slides.length % A), S.recalcSlides(), S.updateSlides()) : showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), D()) : (M && (C.loopAddBlankSlides ? (N(C.grid.rows - S.slides.length % C.grid.rows), S.recalcSlides(), S.updateSlides()) : showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)")), D());
	let P = C.centeredSlides || !!C.slidesOffsetBefore || !!C.slidesOffsetAfter;
	S.loopFix({
		slideRealIndex: m,
		direction: P ? void 0 : "next",
		initial: x
	});
}
function loopFix({ slideRealIndex: m, slideTo: x = !0, direction: S, setTranslate: C, activeSlideIndex: T, initial: D, byController: O, byMousewheel: k } = {}) {
	let A = this;
	if (!A.params.loop) return;
	A.emit("beforeLoopFix");
	let { slides: j, allowSlidePrev: M, allowSlideNext: N, slidesEl: P, params: F } = A, { centeredSlides: I, slidesOffsetBefore: L, slidesOffsetAfter: R, initialSlide: z } = F, B = I || !!L || !!R;
	if (A.allowSlidePrev = !0, A.allowSlideNext = !0, A.virtual && F.virtual.enabled) {
		x && (!B && A.snapIndex === 0 ? A.slideTo(A.virtual.slides.length, 0, !1, !0) : B && A.snapIndex < F.slidesPerView ? A.slideTo(A.virtual.slides.length + A.snapIndex, 0, !1, !0) : A.snapIndex === A.snapGrid.length - 1 && A.slideTo(A.virtual.slidesBefore, 0, !1, !0)), A.allowSlidePrev = M, A.allowSlideNext = N, A.emit("loopFix");
		return;
	}
	let H = F.slidesPerView;
	H === "auto" ? H = A.slidesPerViewDynamic() : (H = Math.ceil(parseFloat(F.slidesPerView, 10)), B && H % 2 == 0 && (H += 1));
	let U = F.slidesPerGroupAuto ? H : F.slidesPerGroup, W = B ? Math.max(U, Math.ceil(H / 2)) : U;
	W % U !== 0 && (W += U - W % U), W += F.loopAdditionalSlides, A.loopedSlides = W;
	let G = A.grid && F.grid && F.grid.rows > 1;
	j.length < H + W || A.params.effect === "cards" && j.length < H + W * 2 ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : G && F.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
	let K = [], q = [], J = G ? Math.ceil(j.length / F.grid.rows) : j.length, Y = D && J - z < H && !B, X = Y ? z : A.activeIndex;
	T === void 0 ? T = A.getSlideIndex(j.find((m) => m.classList.contains(F.slideActiveClass))) : X = T;
	let Z = S === "next" || !S, sH = S === "prev" || !S, Q = 0, cH = 0, lH = (G ? j[T].column : T) + (B && C === void 0 ? -H / 2 + .5 : 0);
	if (lH < W) {
		Q = Math.max(W - lH, U);
		for (let m = 0; m < W - lH; m += 1) {
			let x = m - Math.floor(m / J) * J;
			if (G) {
				let m = J - x - 1;
				for (let x = j.length - 1; x >= 0; --x) j[x].column === m && K.push(x);
			} else K.push(J - x - 1);
		}
	} else if (lH + H > J - W) {
		cH = Math.max(lH - (J - W * 2), U), Y && (cH = Math.max(cH, H - J + z + 1));
		for (let m = 0; m < cH; m += 1) {
			let x = m - Math.floor(m / J) * J;
			G ? j.forEach((m, S) => {
				m.column === x && q.push(S);
			}) : q.push(x);
		}
	}
	if (A.__preventObserver__ = !0, requestAnimationFrame(() => {
		A.__preventObserver__ = !1;
	}), A.params.effect === "cards" && j.length < H + W * 2 && (q.includes(T) && q.splice(q.indexOf(T), 1), K.includes(T) && K.splice(K.indexOf(T), 1)), sH && K.forEach((m) => {
		j[m].swiperLoopMoveDOM = !0, P.prepend(j[m]), j[m].swiperLoopMoveDOM = !1;
	}), Z && q.forEach((m) => {
		j[m].swiperLoopMoveDOM = !0, P.append(j[m]), j[m].swiperLoopMoveDOM = !1;
	}), A.recalcSlides(), F.slidesPerView === "auto" ? A.updateSlides() : G && (K.length > 0 && sH || q.length > 0 && Z) && A.slides.forEach((m, x) => {
		A.grid.updateSlide(x, m, A.slides);
	}), F.watchSlidesProgress && A.updateSlidesOffset(), x) {
		if (K.length > 0 && sH) {
			if (m === void 0) {
				let m = A.slidesGrid[X], x = A.slidesGrid[X + Q] - m;
				k ? A.setTranslate(A.translate - x) : (A.slideTo(X + Math.ceil(Q), 0, !1, !0), C && (A.touchEventsData.startTranslate = A.touchEventsData.startTranslate - x, A.touchEventsData.currentTranslate = A.touchEventsData.currentTranslate - x));
			} else if (C) {
				let m = G ? K.length / F.grid.rows : K.length;
				A.slideTo(A.activeIndex + m, 0, !1, !0), A.touchEventsData.currentTranslate = A.translate;
			}
		} else if (q.length > 0 && Z) if (m === void 0) {
			let m = A.slidesGrid[X], x = A.slidesGrid[X - cH] - m;
			k ? A.setTranslate(A.translate - x) : (A.slideTo(X - cH, 0, !1, !0), C && (A.touchEventsData.startTranslate = A.touchEventsData.startTranslate - x, A.touchEventsData.currentTranslate = A.touchEventsData.currentTranslate - x));
		} else {
			let m = G ? q.length / F.grid.rows : q.length;
			A.slideTo(A.activeIndex - m, 0, !1, !0);
		}
	}
	if (A.allowSlidePrev = M, A.allowSlideNext = N, A.controller && A.controller.control && !O) {
		let D = {
			slideRealIndex: m,
			direction: S,
			setTranslate: C,
			activeSlideIndex: T,
			byController: !0
		};
		Array.isArray(A.controller.control) ? A.controller.control.forEach((m) => {
			!m.destroyed && m.params.loop && m.loopFix({
				...D,
				slideTo: m.params.slidesPerView === F.slidesPerView ? x : !1
			});
		}) : A.controller.control instanceof A.constructor && A.controller.control.params.loop && A.controller.control.loopFix({
			...D,
			slideTo: A.controller.control.params.slidesPerView === F.slidesPerView ? x : !1
		});
	}
	A.emit("loopFix");
}
function loopDestroy() {
	let m = this, { params: x, slidesEl: S } = m;
	if (!x.loop || !S || m.virtual && m.params.virtual.enabled) return;
	m.recalcSlides();
	let C = [];
	m.slides.forEach((m) => {
		let x = m.swiperSlideIndex === void 0 ? m.getAttribute("data-swiper-slide-index") * 1 : m.swiperSlideIndex;
		C[x] = m;
	}), m.slides.forEach((m) => {
		m.removeAttribute("data-swiper-slide-index");
	}), C.forEach((m) => {
		S.append(m);
	}), m.recalcSlides(), m.slideTo(m.realIndex, 0);
}
var loop = {
	loopCreate,
	loopFix,
	loopDestroy
};
function setGrabCursor(m) {
	let x = this;
	if (!x.params.simulateTouch || x.params.watchOverflow && x.isLocked || x.params.cssMode) return;
	let S = x.params.touchEventsTarget === "container" ? x.el : x.wrapperEl;
	x.isElement && (x.__preventObserver__ = !0), S.style.cursor = "move", S.style.cursor = m ? "grabbing" : "grab", x.isElement && requestAnimationFrame(() => {
		x.__preventObserver__ = !1;
	});
}
function unsetGrabCursor() {
	let m = this;
	m.params.watchOverflow && m.isLocked || m.params.cssMode || (m.isElement && (m.__preventObserver__ = !0), m[m.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", m.isElement && requestAnimationFrame(() => {
		m.__preventObserver__ = !1;
	}));
}
var grabCursor = {
	setGrabCursor,
	unsetGrabCursor
};
function closestElement(m, x = this) {
	function S(x) {
		if (!x || x === getDocument() || x === getWindow()) return null;
		x.assignedSlot && (x = x.assignedSlot);
		let C = x.closest(m);
		return !C && !x.getRootNode ? null : C || S(x.getRootNode().host);
	}
	return S(x);
}
function preventEdgeSwipe(m, x, S) {
	let C = getWindow(), { params: T } = m, D = T.edgeSwipeDetection, O = T.edgeSwipeThreshold;
	return D && (S <= O || S >= C.innerWidth - O) ? D === "prevent" ? (x.preventDefault(), !0) : !1 : !0;
}
function onTouchStart(m) {
	let x = this, S = getDocument(), C = m;
	C.originalEvent && (C = C.originalEvent);
	let T = x.touchEventsData;
	if (C.type === "pointerdown") {
		if (T.pointerId !== null && T.pointerId !== C.pointerId) return;
		T.pointerId = C.pointerId;
	} else C.type === "touchstart" && C.targetTouches.length === 1 && (T.touchId = C.targetTouches[0].identifier);
	if (C.type === "touchstart") {
		preventEdgeSwipe(x, C, C.targetTouches[0].pageX);
		return;
	}
	let { params: D, touches: O, enabled: k } = x;
	if (!k || !D.simulateTouch && C.pointerType === "mouse" || x.animating && D.preventInteractionOnTransition) return;
	!x.animating && D.cssMode && D.loop && x.loopFix();
	let A = C.target;
	if (D.touchEventsTarget === "wrapper" && !elementIsChildOf(A, x.wrapperEl) || "which" in C && C.which === 3 || "button" in C && C.button > 0 || T.isTouched && T.isMoved) return;
	let j = !!D.noSwipingClass && D.noSwipingClass !== "", M = C.composedPath ? C.composedPath() : C.path;
	j && C.target && C.target.shadowRoot && M && (A = M[0]);
	let N = D.noSwipingSelector ? D.noSwipingSelector : `.${D.noSwipingClass}`, P = !!(C.target && C.target.shadowRoot);
	if (D.noSwiping && (P ? closestElement(N, A) : A.closest(N))) {
		x.allowClick = !0;
		return;
	}
	if (D.swipeHandler && !A.closest(D.swipeHandler)) return;
	O.currentX = C.pageX, O.currentY = C.pageY;
	let F = O.currentX, I = O.currentY;
	if (!preventEdgeSwipe(x, C, F)) return;
	Object.assign(T, {
		isTouched: !0,
		isMoved: !1,
		allowTouchCallbacks: !0,
		isScrolling: void 0,
		startMoving: void 0
	}), O.startX = F, O.startY = I, T.touchStartTime = now(), x.allowClick = !0, x.updateSize(), x.swipeDirection = void 0, D.threshold > 0 && (T.allowThresholdMove = !1);
	let L = !0;
	A.matches(T.focusableElements) && (L = !1, A.nodeName === "SELECT" && (T.isTouched = !1)), S.activeElement && S.activeElement.matches(T.focusableElements) && S.activeElement !== A && (C.pointerType === "mouse" || C.pointerType !== "mouse" && !A.matches(T.focusableElements)) && S.activeElement.blur();
	let R = L && x.allowTouchMove && D.touchStartPreventDefault;
	(D.touchStartForcePreventDefault || R) && !A.isContentEditable && C.preventDefault(), D.freeMode && D.freeMode.enabled && x.freeMode && x.animating && !D.cssMode && x.freeMode.onTouchStart(), x.emit("touchStart", C);
}
function onTouchMove(m) {
	let x = getDocument(), S = this, C = S.touchEventsData, { params: T, touches: D, rtlTranslate: O, enabled: k } = S;
	if (!k || !T.simulateTouch && m.pointerType === "mouse") return;
	let A = m;
	if (A.originalEvent && (A = A.originalEvent), A.type === "pointermove" && (C.touchId !== null || A.pointerId !== C.pointerId)) return;
	let j;
	if (A.type === "touchmove") {
		if (j = [...A.changedTouches].find((m) => m.identifier === C.touchId), !j || j.identifier !== C.touchId) return;
	} else j = A;
	if (!C.isTouched) {
		C.startMoving && C.isScrolling && S.emit("touchMoveOpposite", A);
		return;
	}
	let M = j.pageX, N = j.pageY;
	if (A.preventedByNestedSwiper) {
		D.startX = M, D.startY = N;
		return;
	}
	if (!S.allowTouchMove) {
		A.target.matches(C.focusableElements) || (S.allowClick = !1), C.isTouched && (Object.assign(D, {
			startX: M,
			startY: N,
			currentX: M,
			currentY: N
		}), C.touchStartTime = now());
		return;
	}
	if (T.touchReleaseOnEdges && !T.loop) {
		if (S.isVertical()) {
			if (N < D.startY && S.translate <= S.maxTranslate() || N > D.startY && S.translate >= S.minTranslate()) {
				C.isTouched = !1, C.isMoved = !1;
				return;
			}
		} else if (O && (M > D.startX && -S.translate <= S.maxTranslate() || M < D.startX && -S.translate >= S.minTranslate())) return;
		else if (!O && (M < D.startX && S.translate <= S.maxTranslate() || M > D.startX && S.translate >= S.minTranslate())) return;
	}
	if (x.activeElement && x.activeElement.matches(C.focusableElements) && x.activeElement !== A.target && A.pointerType !== "mouse" && x.activeElement.blur(), x.activeElement && A.target === x.activeElement && A.target.matches(C.focusableElements)) {
		C.isMoved = !0, S.allowClick = !1;
		return;
	}
	C.allowTouchCallbacks && S.emit("touchMove", A), D.previousX = D.currentX, D.previousY = D.currentY, D.currentX = M, D.currentY = N;
	let P = D.currentX - D.startX, F = D.currentY - D.startY;
	if (S.params.threshold && Math.sqrt(P ** 2 + F ** 2) < S.params.threshold) return;
	if (C.isScrolling === void 0) {
		let m;
		S.isHorizontal() && D.currentY === D.startY || S.isVertical() && D.currentX === D.startX ? C.isScrolling = !1 : P * P + F * F >= 25 && (m = Math.atan2(Math.abs(F), Math.abs(P)) * 180 / Math.PI, C.isScrolling = S.isHorizontal() ? m > T.touchAngle : 90 - m > T.touchAngle);
	}
	if (C.isScrolling && S.emit("touchMoveOpposite", A), C.startMoving === void 0 && (D.currentX !== D.startX || D.currentY !== D.startY) && (C.startMoving = !0), C.isScrolling || A.type === "touchmove" && C.preventTouchMoveFromPointerMove) {
		C.isTouched = !1;
		return;
	}
	if (!C.startMoving) return;
	S.allowClick = !1, !T.cssMode && A.cancelable && A.preventDefault(), T.touchMoveStopPropagation && !T.nested && A.stopPropagation();
	let I = S.isHorizontal() ? P : F, L = S.isHorizontal() ? D.currentX - D.previousX : D.currentY - D.previousY;
	T.oneWayMovement && (I = Math.abs(I) * (O ? 1 : -1), L = Math.abs(L) * (O ? 1 : -1)), D.diff = I, I *= T.touchRatio, O && (I = -I, L = -L);
	let R = S.touchesDirection;
	S.swipeDirection = I > 0 ? "prev" : "next", S.touchesDirection = L > 0 ? "prev" : "next";
	let z = S.params.loop && !T.cssMode, B = S.touchesDirection === "next" && S.allowSlideNext || S.touchesDirection === "prev" && S.allowSlidePrev;
	if (!C.isMoved) {
		if (z && B && S.loopFix({ direction: S.swipeDirection }), C.startTranslate = S.getTranslate(), S.setTransition(0), S.animating) {
			let m = new window.CustomEvent("transitionend", {
				bubbles: !0,
				cancelable: !0,
				detail: { bySwiperTouchMove: !0 }
			});
			S.wrapperEl.dispatchEvent(m);
		}
		C.allowMomentumBounce = !1, T.grabCursor && (S.allowSlideNext === !0 || S.allowSlidePrev === !0) && S.setGrabCursor(!0), S.emit("sliderFirstMove", A);
	}
	if ((/* @__PURE__ */ new Date()).getTime(), T._loopSwapReset !== !1 && C.isMoved && C.allowThresholdMove && R !== S.touchesDirection && z && B && Math.abs(I) >= 1) {
		Object.assign(D, {
			startX: M,
			startY: N,
			currentX: M,
			currentY: N,
			startTranslate: C.currentTranslate
		}), C.loopSwapReset = !0, C.startTranslate = C.currentTranslate;
		return;
	}
	S.emit("sliderMove", A), C.isMoved = !0, C.currentTranslate = I + C.startTranslate;
	let H = !0, U = T.resistanceRatio;
	if (T.touchReleaseOnEdges && (U = 0), I > 0 ? (z && B && C.allowThresholdMove && C.currentTranslate > (T.centeredSlides ? S.minTranslate() - S.slidesSizesGrid[S.activeIndex + 1] - (T.slidesPerView !== "auto" && S.slides.length - T.slidesPerView >= 2 ? S.slidesSizesGrid[S.activeIndex + 1] + S.params.spaceBetween : 0) - S.params.spaceBetween : S.minTranslate()) && S.loopFix({
		direction: "prev",
		setTranslate: !0,
		activeSlideIndex: 0
	}), C.currentTranslate > S.minTranslate() && (H = !1, T.resistance && (C.currentTranslate = S.minTranslate() - 1 + (-S.minTranslate() + C.startTranslate + I) ** U))) : I < 0 && (z && B && C.allowThresholdMove && C.currentTranslate < (T.centeredSlides ? S.maxTranslate() + S.slidesSizesGrid[S.slidesSizesGrid.length - 1] + S.params.spaceBetween + (T.slidesPerView !== "auto" && S.slides.length - T.slidesPerView >= 2 ? S.slidesSizesGrid[S.slidesSizesGrid.length - 1] + S.params.spaceBetween : 0) : S.maxTranslate()) && S.loopFix({
		direction: "next",
		setTranslate: !0,
		activeSlideIndex: S.slides.length - (T.slidesPerView === "auto" ? S.slidesPerViewDynamic() : Math.ceil(parseFloat(T.slidesPerView, 10)))
	}), C.currentTranslate < S.maxTranslate() && (H = !1, T.resistance && (C.currentTranslate = S.maxTranslate() + 1 - (S.maxTranslate() - C.startTranslate - I) ** U))), H && (A.preventedByNestedSwiper = !0), !S.allowSlideNext && S.swipeDirection === "next" && C.currentTranslate < C.startTranslate && (C.currentTranslate = C.startTranslate), !S.allowSlidePrev && S.swipeDirection === "prev" && C.currentTranslate > C.startTranslate && (C.currentTranslate = C.startTranslate), !S.allowSlidePrev && !S.allowSlideNext && (C.currentTranslate = C.startTranslate), T.threshold > 0) if (Math.abs(I) > T.threshold || C.allowThresholdMove) {
		if (!C.allowThresholdMove) {
			C.allowThresholdMove = !0, D.startX = D.currentX, D.startY = D.currentY, C.currentTranslate = C.startTranslate, D.diff = S.isHorizontal() ? D.currentX - D.startX : D.currentY - D.startY;
			return;
		}
	} else {
		C.currentTranslate = C.startTranslate;
		return;
	}
	!T.followFinger || T.cssMode || ((T.freeMode && T.freeMode.enabled && S.freeMode || T.watchSlidesProgress) && (S.updateActiveIndex(), S.updateSlidesClasses()), T.freeMode && T.freeMode.enabled && S.freeMode && S.freeMode.onTouchMove(), S.updateProgress(C.currentTranslate), S.setTranslate(C.currentTranslate));
}
function onTouchEnd(m) {
	let x = this, S = x.touchEventsData, C = m;
	C.originalEvent && (C = C.originalEvent);
	let T;
	if (C.type === "touchend" || C.type === "touchcancel") {
		if (T = [...C.changedTouches].find((m) => m.identifier === S.touchId), !T || T.identifier !== S.touchId) return;
	} else {
		if (S.touchId !== null || C.pointerId !== S.pointerId) return;
		T = C;
	}
	if ([
		"pointercancel",
		"pointerout",
		"pointerleave",
		"contextmenu"
	].includes(C.type) && !(["pointercancel", "contextmenu"].includes(C.type) && (x.browser.isSafari || x.browser.isWebView))) return;
	S.pointerId = null, S.touchId = null;
	let { params: D, touches: O, rtlTranslate: k, slidesGrid: A, enabled: j } = x;
	if (!j || !D.simulateTouch && C.pointerType === "mouse") return;
	if (S.allowTouchCallbacks && x.emit("touchEnd", C), S.allowTouchCallbacks = !1, !S.isTouched) {
		S.isMoved && D.grabCursor && x.setGrabCursor(!1), S.isMoved = !1, S.startMoving = !1;
		return;
	}
	D.grabCursor && S.isMoved && S.isTouched && (x.allowSlideNext === !0 || x.allowSlidePrev === !0) && x.setGrabCursor(!1);
	let M = now(), N = M - S.touchStartTime;
	if (x.allowClick) {
		let m = C.path || C.composedPath && C.composedPath();
		x.updateClickedSlide(m && m[0] || C.target, m), x.emit("tap click", C), N < 300 && M - S.lastClickTime < 300 && x.emit("doubleTap doubleClick", C);
	}
	if (S.lastClickTime = now(), nextTick(() => {
		x.destroyed || (x.allowClick = !0);
	}), !S.isTouched || !S.isMoved || !x.swipeDirection || O.diff === 0 && !S.loopSwapReset || S.currentTranslate === S.startTranslate && !S.loopSwapReset) {
		S.isTouched = !1, S.isMoved = !1, S.startMoving = !1;
		return;
	}
	S.isTouched = !1, S.isMoved = !1, S.startMoving = !1;
	let P;
	if (P = D.followFinger ? k ? x.translate : -x.translate : -S.currentTranslate, D.cssMode) return;
	if (D.freeMode && D.freeMode.enabled) {
		x.freeMode.onTouchEnd({ currentPos: P });
		return;
	}
	let F = P >= -x.maxTranslate() && !x.params.loop, I = 0, L = x.slidesSizesGrid[0];
	for (let m = 0; m < A.length; m += m < D.slidesPerGroupSkip ? 1 : D.slidesPerGroup) {
		let x = m < D.slidesPerGroupSkip - 1 ? 1 : D.slidesPerGroup;
		A[m + x] === void 0 ? (F || P >= A[m]) && (I = m, L = A[A.length - 1] - A[A.length - 2]) : (F || P >= A[m] && P < A[m + x]) && (I = m, L = A[m + x] - A[m]);
	}
	let R = null, z = null;
	D.rewind && (x.isBeginning ? z = D.virtual && D.virtual.enabled && x.virtual ? x.virtual.slides.length - 1 : x.slides.length - 1 : x.isEnd && (R = 0));
	let B = (P - A[I]) / L, H = I < D.slidesPerGroupSkip - 1 ? 1 : D.slidesPerGroup;
	if (N > D.longSwipesMs) {
		if (!D.longSwipes) {
			x.slideTo(x.activeIndex);
			return;
		}
		x.swipeDirection === "next" && (B >= D.longSwipesRatio ? x.slideTo(D.rewind && x.isEnd ? R : I + H) : x.slideTo(I)), x.swipeDirection === "prev" && (B > 1 - D.longSwipesRatio ? x.slideTo(I + H) : z !== null && B < 0 && Math.abs(B) > D.longSwipesRatio ? x.slideTo(z) : x.slideTo(I));
	} else {
		if (!D.shortSwipes) {
			x.slideTo(x.activeIndex);
			return;
		}
		x.navigation && (C.target === x.navigation.nextEl || C.target === x.navigation.prevEl) ? C.target === x.navigation.nextEl ? x.slideTo(I + H) : x.slideTo(I) : (x.swipeDirection === "next" && x.slideTo(R === null ? I + H : R), x.swipeDirection === "prev" && x.slideTo(z === null ? I : z));
	}
}
function onResize() {
	let m = this, { params: x, el: S } = m;
	if (S && S.offsetWidth === 0) return;
	x.breakpoints && m.setBreakpoint();
	let { allowSlideNext: C, allowSlidePrev: T, snapGrid: D } = m, O = m.virtual && m.params.virtual.enabled;
	m.allowSlideNext = !0, m.allowSlidePrev = !0, m.updateSize(), m.updateSlides(), m.updateSlidesClasses();
	let k = O && x.loop;
	(x.slidesPerView === "auto" || x.slidesPerView > 1) && m.isEnd && !m.isBeginning && !m.params.centeredSlides && !k ? m.slideTo(m.slides.length - 1, 0, !1, !0) : m.params.loop && !O ? m.slideToLoop(m.realIndex, 0, !1, !0) : m.slideTo(m.activeIndex, 0, !1, !0), m.autoplay && m.autoplay.running && m.autoplay.paused && (clearTimeout(m.autoplay.resizeTimeout), m.autoplay.resizeTimeout = setTimeout(() => {
		m.autoplay && m.autoplay.running && m.autoplay.paused && m.autoplay.resume();
	}, 500)), m.allowSlidePrev = T, m.allowSlideNext = C, m.params.watchOverflow && D !== m.snapGrid && m.checkOverflow();
}
function onClick(m) {
	let x = this;
	x.enabled && (x.allowClick || (x.params.preventClicks && m.preventDefault(), x.params.preventClicksPropagation && x.animating && (m.stopPropagation(), m.stopImmediatePropagation())));
}
function onScroll() {
	let m = this, { wrapperEl: x, rtlTranslate: S, enabled: C } = m;
	if (!C) return;
	m.previousTranslate = m.translate, m.isHorizontal() ? m.translate = -x.scrollLeft : m.translate = -x.scrollTop, m.translate === 0 && (m.translate = 0), m.updateActiveIndex(), m.updateSlidesClasses();
	let T, D = m.maxTranslate() - m.minTranslate();
	T = D === 0 ? 0 : (m.translate - m.minTranslate()) / D, T !== m.progress && m.updateProgress(S ? -m.translate : m.translate), m.emit("setTranslate", m.translate, !1);
}
function onLoad(m) {
	let x = this;
	processLazyPreloader(x, m.target), !(x.params.cssMode || x.params.slidesPerView !== "auto" && !x.params.autoHeight) && x.update();
}
function onDocumentTouchStart() {
	let m = this;
	m.documentTouchHandlerProceeded || (m.documentTouchHandlerProceeded = !0, m.params.touchReleaseOnEdges && (m.el.style.touchAction = "auto"));
}
var events = (m, x) => {
	let S = getDocument(), { params: C, el: T, wrapperEl: D, device: O } = m, k = !!C.nested, A = x === "on" ? "addEventListener" : "removeEventListener", j = x;
	!T || typeof T == "string" || (S[A]("touchstart", m.onDocumentTouchStart, {
		passive: !1,
		capture: k
	}), T[A]("touchstart", m.onTouchStart, { passive: !1 }), T[A]("pointerdown", m.onTouchStart, { passive: !1 }), S[A]("touchmove", m.onTouchMove, {
		passive: !1,
		capture: k
	}), S[A]("pointermove", m.onTouchMove, {
		passive: !1,
		capture: k
	}), S[A]("touchend", m.onTouchEnd, { passive: !0 }), S[A]("pointerup", m.onTouchEnd, { passive: !0 }), S[A]("pointercancel", m.onTouchEnd, { passive: !0 }), S[A]("touchcancel", m.onTouchEnd, { passive: !0 }), S[A]("pointerout", m.onTouchEnd, { passive: !0 }), S[A]("pointerleave", m.onTouchEnd, { passive: !0 }), S[A]("contextmenu", m.onTouchEnd, { passive: !0 }), (C.preventClicks || C.preventClicksPropagation) && T[A]("click", m.onClick, !0), C.cssMode && D[A]("scroll", m.onScroll), C.updateOnWindowResize ? m[j](O.ios || O.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : m[j]("observerUpdate", onResize, !0), T[A]("load", m.onLoad, { capture: !0 }));
};
function attachEvents() {
	let m = this, { params: x } = m;
	m.onTouchStart = onTouchStart.bind(m), m.onTouchMove = onTouchMove.bind(m), m.onTouchEnd = onTouchEnd.bind(m), m.onDocumentTouchStart = onDocumentTouchStart.bind(m), x.cssMode && (m.onScroll = onScroll.bind(m)), m.onClick = onClick.bind(m), m.onLoad = onLoad.bind(m), events(m, "on");
}
function detachEvents() {
	events(this, "off");
}
var events$1 = {
	attachEvents,
	detachEvents
}, isGridEnabled = (m, x) => m.grid && x.grid && x.grid.rows > 1;
function setBreakpoint() {
	let m = this, { realIndex: x, initialized: S, params: C, el: T } = m, D = C.breakpoints;
	if (!D || D && Object.keys(D).length === 0) return;
	let O = getDocument(), k = C.breakpointsBase === "window" || !C.breakpointsBase ? C.breakpointsBase : "container", A = ["window", "container"].includes(C.breakpointsBase) || !C.breakpointsBase ? m.el : O.querySelector(C.breakpointsBase), j = m.getBreakpoint(D, k, A);
	if (!j || m.currentBreakpoint === j) return;
	let M = (j in D ? D[j] : void 0) || m.originalParams, N = isGridEnabled(m, C), P = isGridEnabled(m, M), F = m.params.grabCursor, I = M.grabCursor, L = C.enabled;
	N && !P ? (T.classList.remove(`${C.containerModifierClass}grid`, `${C.containerModifierClass}grid-column`), m.emitContainerClasses()) : !N && P && (T.classList.add(`${C.containerModifierClass}grid`), (M.grid.fill && M.grid.fill === "column" || !M.grid.fill && C.grid.fill === "column") && T.classList.add(`${C.containerModifierClass}grid-column`), m.emitContainerClasses()), F && !I ? m.unsetGrabCursor() : !F && I && m.setGrabCursor(), [
		"navigation",
		"pagination",
		"scrollbar"
	].forEach((x) => {
		if (M[x] === void 0) return;
		let S = C[x] && C[x].enabled, T = M[x] && M[x].enabled;
		S && !T && m[x].disable(), !S && T && m[x].enable();
	});
	let R = M.direction && M.direction !== C.direction, z = C.loop && (M.slidesPerView !== C.slidesPerView || R), B = C.loop;
	R && S && m.changeDirection(), extend$1(m.params, M);
	let H = m.params.enabled, U = m.params.loop;
	Object.assign(m, {
		allowTouchMove: m.params.allowTouchMove,
		allowSlideNext: m.params.allowSlideNext,
		allowSlidePrev: m.params.allowSlidePrev
	}), L && !H ? m.disable() : !L && H && m.enable(), m.currentBreakpoint = j, m.emit("_beforeBreakpoint", M), S && (z ? (m.loopDestroy(), m.loopCreate(x), m.updateSlides()) : !B && U ? (m.loopCreate(x), m.updateSlides()) : B && !U && m.loopDestroy()), m.emit("breakpoint", M);
}
function getBreakpoint(m, x = "window", S) {
	if (!m || x === "container" && !S) return;
	let C = !1, T = getWindow(), D = x === "window" ? T.innerHeight : S.clientHeight, O = Object.keys(m).map((m) => typeof m == "string" && m.indexOf("@") === 0 ? {
		value: D * parseFloat(m.substr(1)),
		point: m
	} : {
		value: m,
		point: m
	});
	O.sort((m, x) => parseInt(m.value, 10) - parseInt(x.value, 10));
	for (let m = 0; m < O.length; m += 1) {
		let { point: D, value: k } = O[m];
		x === "window" ? T.matchMedia(`(min-width: ${k}px)`).matches && (C = D) : k <= S.clientWidth && (C = D);
	}
	return C || "max";
}
var breakpoints = {
	setBreakpoint,
	getBreakpoint
};
function prepareClasses(m, x) {
	let S = [];
	return m.forEach((m) => {
		typeof m == "object" ? Object.keys(m).forEach((C) => {
			m[C] && S.push(x + C);
		}) : typeof m == "string" && S.push(x + m);
	}), S;
}
function addClasses() {
	let m = this, { classNames: x, params: S, rtl: C, el: T, device: D } = m, O = prepareClasses([
		"initialized",
		S.direction,
		{ "free-mode": m.params.freeMode && S.freeMode.enabled },
		{ autoheight: S.autoHeight },
		{ rtl: C },
		{ grid: S.grid && S.grid.rows > 1 },
		{ "grid-column": S.grid && S.grid.rows > 1 && S.grid.fill === "column" },
		{ android: D.android },
		{ ios: D.ios },
		{ "css-mode": S.cssMode },
		{ centered: S.cssMode && S.centeredSlides },
		{ "watch-progress": S.watchSlidesProgress }
	], S.containerModifierClass);
	x.push(...O), T.classList.add(...x), m.emitContainerClasses();
}
function removeClasses() {
	let m = this, { el: x, classNames: S } = m;
	!x || typeof x == "string" || (x.classList.remove(...S), m.emitContainerClasses());
}
var classes = {
	addClasses,
	removeClasses
};
function checkOverflow() {
	let m = this, { isLocked: x, params: S } = m, { slidesOffsetBefore: C } = S;
	if (C) {
		let x = m.slides.length - 1, S = m.slidesGrid[x] + m.slidesSizesGrid[x] + C * 2;
		m.isLocked = m.size > S;
	} else m.isLocked = m.snapGrid.length === 1;
	S.allowSlideNext === !0 && (m.allowSlideNext = !m.isLocked), S.allowSlidePrev === !0 && (m.allowSlidePrev = !m.isLocked), x && x !== m.isLocked && (m.isEnd = !1), x !== m.isLocked && m.emit(m.isLocked ? "lock" : "unlock");
}
var checkOverflow$1 = { checkOverflow }, defaults = {
	init: !0,
	direction: "horizontal",
	oneWayMovement: !1,
	swiperElementNodeName: "SWIPER-CONTAINER",
	touchEventsTarget: "wrapper",
	initialSlide: 0,
	speed: 300,
	cssMode: !1,
	updateOnWindowResize: !0,
	resizeObserver: !0,
	nested: !1,
	createElements: !1,
	eventsPrefix: "swiper",
	enabled: !0,
	focusableElements: "input, select, option, textarea, button, video, label",
	width: null,
	height: null,
	preventInteractionOnTransition: !1,
	userAgent: null,
	url: null,
	edgeSwipeDetection: !1,
	edgeSwipeThreshold: 20,
	autoHeight: !1,
	setWrapperSize: !1,
	virtualTranslate: !1,
	effect: "slide",
	breakpoints: void 0,
	breakpointsBase: "window",
	spaceBetween: 0,
	slidesPerView: 1,
	slidesPerGroup: 1,
	slidesPerGroupSkip: 0,
	slidesPerGroupAuto: !1,
	centeredSlides: !1,
	centeredSlidesBounds: !1,
	slidesOffsetBefore: 0,
	slidesOffsetAfter: 0,
	normalizeSlideIndex: !0,
	centerInsufficientSlides: !1,
	watchOverflow: !0,
	roundLengths: !1,
	touchRatio: 1,
	touchAngle: 45,
	simulateTouch: !0,
	shortSwipes: !0,
	longSwipes: !0,
	longSwipesRatio: .5,
	longSwipesMs: 300,
	followFinger: !0,
	allowTouchMove: !0,
	threshold: 5,
	touchMoveStopPropagation: !1,
	touchStartPreventDefault: !0,
	touchStartForcePreventDefault: !1,
	touchReleaseOnEdges: !1,
	uniqueNavElements: !0,
	resistance: !0,
	resistanceRatio: .85,
	watchSlidesProgress: !1,
	grabCursor: !1,
	preventClicks: !0,
	preventClicksPropagation: !0,
	slideToClickedSlide: !1,
	loop: !1,
	loopAddBlankSlides: !0,
	loopAdditionalSlides: 0,
	loopPreventsSliding: !0,
	rewind: !1,
	allowSlidePrev: !0,
	allowSlideNext: !0,
	swipeHandler: null,
	noSwiping: !0,
	noSwipingClass: "swiper-no-swiping",
	noSwipingSelector: null,
	passiveListeners: !0,
	maxBackfaceHiddenSlides: 10,
	containerModifierClass: "swiper-",
	slideClass: "swiper-slide",
	slideBlankClass: "swiper-slide-blank",
	slideActiveClass: "swiper-slide-active",
	slideVisibleClass: "swiper-slide-visible",
	slideFullyVisibleClass: "swiper-slide-fully-visible",
	slideNextClass: "swiper-slide-next",
	slidePrevClass: "swiper-slide-prev",
	wrapperClass: "swiper-wrapper",
	lazyPreloaderClass: "swiper-lazy-preloader",
	lazyPreloadPrevNext: 0,
	runCallbacksOnInit: !0,
	_emitClasses: !1
};
function moduleExtendParams(m, x) {
	return function(S = {}) {
		let C = Object.keys(S)[0], T = S[C];
		if (typeof T != "object" || !T) {
			extend$1(x, S);
			return;
		}
		if (m[C] === !0 && (m[C] = { enabled: !0 }), C === "navigation" && m[C] && m[C].enabled && !m[C].prevEl && !m[C].nextEl && (m[C].auto = !0), ["pagination", "scrollbar"].indexOf(C) >= 0 && m[C] && m[C].enabled && !m[C].el && (m[C].auto = !0), !(C in m && "enabled" in T)) {
			extend$1(x, S);
			return;
		}
		typeof m[C] == "object" && !("enabled" in m[C]) && (m[C].enabled = !0), m[C] || (m[C] = { enabled: !1 }), extend$1(x, S);
	};
}
var prototypes = {
	eventsEmitter,
	update,
	translate,
	transition,
	slide,
	loop,
	grabCursor,
	events: events$1,
	breakpoints,
	checkOverflow: checkOverflow$1,
	classes
}, extendedDefaults = {}, Swiper$1 = class m {
	constructor(...x) {
		let S, C;
		x.length === 1 && x[0].constructor && Object.prototype.toString.call(x[0]).slice(8, -1) === "Object" ? C = x[0] : [S, C] = x, C ||= {}, C = extend$1({}, C), S && !C.el && (C.el = S);
		let T = getDocument();
		if (C.el && typeof C.el == "string" && T.querySelectorAll(C.el).length > 1) {
			let x = [];
			return T.querySelectorAll(C.el).forEach((S) => {
				let T = extend$1({}, C, { el: S });
				x.push(new m(T));
			}), x;
		}
		let D = this;
		D.__swiper__ = !0, D.support = getSupport(), D.device = getDevice({ userAgent: C.userAgent }), D.browser = getBrowser(), D.eventsListeners = {}, D.eventsAnyListeners = [], D.modules = [...D.__modules__], C.modules && Array.isArray(C.modules) && D.modules.push(...C.modules);
		let O = {};
		return D.modules.forEach((m) => {
			m({
				params: C,
				swiper: D,
				extendParams: moduleExtendParams(C, O),
				on: D.on.bind(D),
				once: D.once.bind(D),
				off: D.off.bind(D),
				emit: D.emit.bind(D)
			});
		}), D.params = extend$1({}, extend$1({}, defaults, O), extendedDefaults, C), D.originalParams = extend$1({}, D.params), D.passedParams = extend$1({}, C), D.params && D.params.on && Object.keys(D.params.on).forEach((m) => {
			D.on(m, D.params.on[m]);
		}), D.params && D.params.onAny && D.onAny(D.params.onAny), Object.assign(D, {
			enabled: D.params.enabled,
			el: S,
			classNames: [],
			slides: [],
			slidesGrid: [],
			snapGrid: [],
			slidesSizesGrid: [],
			isHorizontal() {
				return D.params.direction === "horizontal";
			},
			isVertical() {
				return D.params.direction === "vertical";
			},
			activeIndex: 0,
			realIndex: 0,
			isBeginning: !0,
			isEnd: !1,
			translate: 0,
			previousTranslate: 0,
			progress: 0,
			velocity: 0,
			animating: !1,
			cssOverflowAdjustment() {
				return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
			},
			allowSlideNext: D.params.allowSlideNext,
			allowSlidePrev: D.params.allowSlidePrev,
			touchEventsData: {
				isTouched: void 0,
				isMoved: void 0,
				allowTouchCallbacks: void 0,
				touchStartTime: void 0,
				isScrolling: void 0,
				currentTranslate: void 0,
				startTranslate: void 0,
				allowThresholdMove: void 0,
				focusableElements: D.params.focusableElements,
				lastClickTime: 0,
				clickTimeout: void 0,
				velocities: [],
				allowMomentumBounce: void 0,
				startMoving: void 0,
				pointerId: null,
				touchId: null
			},
			allowClick: !0,
			allowTouchMove: D.params.allowTouchMove,
			touches: {
				startX: 0,
				startY: 0,
				currentX: 0,
				currentY: 0,
				diff: 0
			},
			imagesToLoad: [],
			imagesLoaded: 0
		}), D.emit("_swiper"), D.params.init && D.init(), D;
	}
	getDirectionLabel(m) {
		return this.isHorizontal() ? m : {
			width: "height",
			"margin-top": "margin-left",
			"margin-bottom ": "margin-right",
			"margin-left": "margin-top",
			"margin-right": "margin-bottom",
			"padding-left": "padding-top",
			"padding-right": "padding-bottom",
			marginRight: "marginBottom"
		}[m];
	}
	getSlideIndex(m) {
		let { slidesEl: x, params: S } = this, C = elementIndex(elementChildren(x, `.${S.slideClass}, swiper-slide`)[0]);
		return elementIndex(m) - C;
	}
	getSlideIndexByData(m) {
		return this.getSlideIndex(this.slides.find((x) => x.getAttribute("data-swiper-slide-index") * 1 === m));
	}
	getSlideIndexWhenGrid(m) {
		return this.grid && this.params.grid && this.params.grid.rows > 1 && (this.params.grid.fill === "column" ? m = Math.floor(m / this.params.grid.rows) : this.params.grid.fill === "row" && (m %= Math.ceil(this.slides.length / this.params.grid.rows))), m;
	}
	recalcSlides() {
		let m = this, { slidesEl: x, params: S } = m;
		m.slides = elementChildren(x, `.${S.slideClass}, swiper-slide`);
	}
	enable() {
		let m = this;
		m.enabled || (m.enabled = !0, m.params.grabCursor && m.setGrabCursor(), m.emit("enable"));
	}
	disable() {
		let m = this;
		m.enabled && (m.enabled = !1, m.params.grabCursor && m.unsetGrabCursor(), m.emit("disable"));
	}
	setProgress(m, x) {
		let S = this;
		m = Math.min(Math.max(m, 0), 1);
		let C = S.minTranslate(), T = (S.maxTranslate() - C) * m + C;
		S.translateTo(T, x === void 0 ? 0 : x), S.updateActiveIndex(), S.updateSlidesClasses();
	}
	emitContainerClasses() {
		let m = this;
		if (!m.params._emitClasses || !m.el) return;
		let x = m.el.className.split(" ").filter((x) => x.indexOf("swiper") === 0 || x.indexOf(m.params.containerModifierClass) === 0);
		m.emit("_containerClasses", x.join(" "));
	}
	getSlideClasses(m) {
		let x = this;
		return x.destroyed ? "" : m.className.split(" ").filter((m) => m.indexOf("swiper-slide") === 0 || m.indexOf(x.params.slideClass) === 0).join(" ");
	}
	emitSlidesClasses() {
		let m = this;
		if (!m.params._emitClasses || !m.el) return;
		let x = [];
		m.slides.forEach((S) => {
			let C = m.getSlideClasses(S);
			x.push({
				slideEl: S,
				classNames: C
			}), m.emit("_slideClass", S, C);
		}), m.emit("_slideClasses", x);
	}
	slidesPerViewDynamic(m = "current", x = !1) {
		let { params: S, slides: C, slidesGrid: T, slidesSizesGrid: D, size: O, activeIndex: k } = this, A = 1;
		if (typeof S.slidesPerView == "number") return S.slidesPerView;
		if (S.centeredSlides) {
			let m = C[k] ? Math.ceil(C[k].swiperSlideSize) : 0, x;
			for (let S = k + 1; S < C.length; S += 1) C[S] && !x && (m += Math.ceil(C[S].swiperSlideSize), A += 1, m > O && (x = !0));
			for (let S = k - 1; S >= 0; --S) C[S] && !x && (m += C[S].swiperSlideSize, A += 1, m > O && (x = !0));
		} else if (m === "current") for (let m = k + 1; m < C.length; m += 1) (x ? T[m] + D[m] - T[k] < O : T[m] - T[k] < O) && (A += 1);
		else for (let m = k - 1; m >= 0; --m) T[k] - T[m] < O && (A += 1);
		return A;
	}
	update() {
		let m = this;
		if (!m || m.destroyed) return;
		let { snapGrid: x, params: S } = m;
		S.breakpoints && m.setBreakpoint(), [...m.el.querySelectorAll("[loading=\"lazy\"]")].forEach((x) => {
			x.complete && processLazyPreloader(m, x);
		}), m.updateSize(), m.updateSlides(), m.updateProgress(), m.updateSlidesClasses();
		function C() {
			let x = m.rtlTranslate ? m.translate * -1 : m.translate, S = Math.min(Math.max(x, m.maxTranslate()), m.minTranslate());
			m.setTranslate(S), m.updateActiveIndex(), m.updateSlidesClasses();
		}
		let T;
		if (S.freeMode && S.freeMode.enabled && !S.cssMode) C(), S.autoHeight && m.updateAutoHeight();
		else {
			if ((S.slidesPerView === "auto" || S.slidesPerView > 1) && m.isEnd && !S.centeredSlides) {
				let x = m.virtual && S.virtual.enabled ? m.virtual.slides : m.slides;
				T = m.slideTo(x.length - 1, 0, !1, !0);
			} else T = m.slideTo(m.activeIndex, 0, !1, !0);
			T || C();
		}
		S.watchOverflow && x !== m.snapGrid && m.checkOverflow(), m.emit("update");
	}
	changeDirection(m, x = !0) {
		let S = this, C = S.params.direction;
		return m ||= C === "horizontal" ? "vertical" : "horizontal", m === C || m !== "horizontal" && m !== "vertical" ? S : (S.el.classList.remove(`${S.params.containerModifierClass}${C}`), S.el.classList.add(`${S.params.containerModifierClass}${m}`), S.emitContainerClasses(), S.params.direction = m, S.slides.forEach((x) => {
			m === "vertical" ? x.style.width = "" : x.style.height = "";
		}), S.emit("changeDirection"), x && S.update(), S);
	}
	changeLanguageDirection(m) {
		let x = this;
		x.rtl && m === "rtl" || !x.rtl && m === "ltr" || (x.rtl = m === "rtl", x.rtlTranslate = x.params.direction === "horizontal" && x.rtl, x.rtl ? (x.el.classList.add(`${x.params.containerModifierClass}rtl`), x.el.dir = "rtl") : (x.el.classList.remove(`${x.params.containerModifierClass}rtl`), x.el.dir = "ltr"), x.update());
	}
	mount(m) {
		let x = this;
		if (x.mounted) return !0;
		let S = m || x.params.el;
		if (typeof S == "string" && (S = document.querySelector(S)), !S) return !1;
		S.swiper = x, S.parentNode && S.parentNode.host && S.parentNode.host.nodeName === x.params.swiperElementNodeName.toUpperCase() && (x.isElement = !0);
		let C = () => `.${(x.params.wrapperClass || "").trim().split(" ").join(".")}`, T = (() => S && S.shadowRoot && S.shadowRoot.querySelector ? S.shadowRoot.querySelector(C()) : elementChildren(S, C())[0])();
		return !T && x.params.createElements && (T = createElement$1("div", x.params.wrapperClass), S.append(T), elementChildren(S, `.${x.params.slideClass}`).forEach((m) => {
			T.append(m);
		})), Object.assign(x, {
			el: S,
			wrapperEl: T,
			slidesEl: x.isElement && !S.parentNode.host.slideSlots ? S.parentNode.host : T,
			hostEl: x.isElement ? S.parentNode.host : S,
			mounted: !0,
			rtl: S.dir.toLowerCase() === "rtl" || elementStyle(S, "direction") === "rtl",
			rtlTranslate: x.params.direction === "horizontal" && (S.dir.toLowerCase() === "rtl" || elementStyle(S, "direction") === "rtl"),
			wrongRTL: elementStyle(T, "display") === "-webkit-box"
		}), !0;
	}
	init(m) {
		let x = this;
		if (x.initialized || x.mount(m) === !1) return x;
		x.emit("beforeInit"), x.params.breakpoints && x.setBreakpoint(), x.addClasses(), x.updateSize(), x.updateSlides(), x.params.watchOverflow && x.checkOverflow(), x.params.grabCursor && x.enabled && x.setGrabCursor(), x.params.loop && x.virtual && x.params.virtual.enabled ? x.slideTo(x.params.initialSlide + x.virtual.slidesBefore, 0, x.params.runCallbacksOnInit, !1, !0) : x.slideTo(x.params.initialSlide, 0, x.params.runCallbacksOnInit, !1, !0), x.params.loop && x.loopCreate(void 0, !0), x.attachEvents();
		let S = [...x.el.querySelectorAll("[loading=\"lazy\"]")];
		return x.isElement && S.push(...x.hostEl.querySelectorAll("[loading=\"lazy\"]")), S.forEach((m) => {
			m.complete ? processLazyPreloader(x, m) : m.addEventListener("load", (m) => {
				processLazyPreloader(x, m.target);
			});
		}), preload(x), x.initialized = !0, preload(x), x.emit("init"), x.emit("afterInit"), x;
	}
	destroy(m = !0, x = !0) {
		let S = this, { params: C, el: T, wrapperEl: D, slides: O } = S;
		return S.params === void 0 || S.destroyed ? null : (S.emit("beforeDestroy"), S.initialized = !1, S.detachEvents(), C.loop && S.loopDestroy(), x && (S.removeClasses(), T && typeof T != "string" && T.removeAttribute("style"), D && D.removeAttribute("style"), O && O.length && O.forEach((m) => {
			m.classList.remove(C.slideVisibleClass, C.slideFullyVisibleClass, C.slideActiveClass, C.slideNextClass, C.slidePrevClass), m.removeAttribute("style"), m.removeAttribute("data-swiper-slide-index");
		})), S.emit("destroy"), Object.keys(S.eventsListeners).forEach((m) => {
			S.off(m);
		}), m !== !1 && (S.el && typeof S.el != "string" && (S.el.swiper = null), deleteProps(S)), S.destroyed = !0, null);
	}
	static extendDefaults(m) {
		extend$1(extendedDefaults, m);
	}
	static get extendedDefaults() {
		return extendedDefaults;
	}
	static get defaults() {
		return defaults;
	}
	static installModule(x) {
		m.prototype.__modules__ || (m.prototype.__modules__ = []);
		let S = m.prototype.__modules__;
		typeof x == "function" && S.indexOf(x) < 0 && S.push(x);
	}
	static use(x) {
		return Array.isArray(x) ? (x.forEach((x) => m.installModule(x)), m) : (m.installModule(x), m);
	}
};
Object.keys(prototypes).forEach((m) => {
	Object.keys(prototypes[m]).forEach((x) => {
		Swiper$1.prototype[x] = prototypes[m][x];
	});
}), Swiper$1.use([Resize, Observer]);
var paramsList = /* @__PURE__ */ "eventsPrefix.injectStyles.injectStylesUrls.modules.init._direction.oneWayMovement.swiperElementNodeName.touchEventsTarget.initialSlide._speed.cssMode.updateOnWindowResize.resizeObserver.nested.focusableElements._enabled._width._height.preventInteractionOnTransition.userAgent.url._edgeSwipeDetection._edgeSwipeThreshold._freeMode._autoHeight.setWrapperSize.virtualTranslate._effect.breakpoints.breakpointsBase._spaceBetween._slidesPerView.maxBackfaceHiddenSlides._grid._slidesPerGroup._slidesPerGroupSkip._slidesPerGroupAuto._centeredSlides._centeredSlidesBounds._slidesOffsetBefore._slidesOffsetAfter.normalizeSlideIndex._centerInsufficientSlides._watchOverflow.roundLengths.touchRatio.touchAngle.simulateTouch._shortSwipes._longSwipes.longSwipesRatio.longSwipesMs._followFinger.allowTouchMove._threshold.touchMoveStopPropagation.touchStartPreventDefault.touchStartForcePreventDefault.touchReleaseOnEdges.uniqueNavElements._resistance._resistanceRatio._watchSlidesProgress._grabCursor.preventClicks.preventClicksPropagation._slideToClickedSlide._loop.loopAdditionalSlides.loopAddBlankSlides.loopPreventsSliding._rewind._allowSlidePrev._allowSlideNext._swipeHandler._noSwiping.noSwipingClass.noSwipingSelector.passiveListeners.containerModifierClass.slideClass.slideActiveClass.slideVisibleClass.slideFullyVisibleClass.slideNextClass.slidePrevClass.slideBlankClass.wrapperClass.lazyPreloaderClass.lazyPreloadPrevNext.runCallbacksOnInit.observer.observeParents.observeSlideChildren.a11y._autoplay._controller.coverflowEffect.cubeEffect.fadeEffect.flipEffect.creativeEffect.cardsEffect.hashNavigation.history.keyboard.mousewheel._navigation._pagination.parallax._scrollbar._thumbs.virtual.zoom.control".split(".");
function isObject(m) {
	return typeof m == "object" && !!m && m.constructor && Object.prototype.toString.call(m).slice(8, -1) === "Object" && !m.__swiper__;
}
function extend(m, x) {
	let S = [
		"__proto__",
		"constructor",
		"prototype"
	];
	Object.keys(x).filter((m) => S.indexOf(m) < 0).forEach((S) => {
		m[S] === void 0 ? m[S] = x[S] : isObject(x[S]) && isObject(m[S]) && Object.keys(x[S]).length > 0 ? x[S].__swiper__ ? m[S] = x[S] : extend(m[S], x[S]) : m[S] = x[S];
	});
}
function needsNavigation(m = {}) {
	return m.navigation && m.navigation.nextEl === void 0 && m.navigation.prevEl === void 0;
}
function needsPagination(m = {}) {
	return m.pagination && m.pagination.el === void 0;
}
function needsScrollbar(m = {}) {
	return m.scrollbar && m.scrollbar.el === void 0;
}
function uniqueClasses(m = "") {
	let x = m.split(" ").map((m) => m.trim()).filter((m) => !!m), S = [];
	return x.forEach((m) => {
		S.indexOf(m) < 0 && S.push(m);
	}), S.join(" ");
}
function wrapperClass(m = "") {
	return m ? m.includes("swiper-wrapper") ? m : `swiper-wrapper ${m}` : "swiper-wrapper";
}
function updateSwiper({ swiper: m, slides: x, passedParams: S, changedParams: C, nextEl: T, prevEl: D, scrollbarEl: O, paginationEl: k }) {
	let A = C.filter((m) => m !== "children" && m !== "direction" && m !== "wrapperClass"), { params: j, pagination: M, navigation: N, scrollbar: P, virtual: F, thumbs: I } = m, L, R, z, B, H, U, W, G;
	C.includes("thumbs") && S.thumbs && S.thumbs.swiper && !S.thumbs.swiper.destroyed && j.thumbs && (!j.thumbs.swiper || j.thumbs.swiper.destroyed) && (L = !0), C.includes("controller") && S.controller && S.controller.control && j.controller && !j.controller.control && (R = !0), C.includes("pagination") && S.pagination && (S.pagination.el || k) && (j.pagination || j.pagination === !1) && M && !M.el && (z = !0), C.includes("scrollbar") && S.scrollbar && (S.scrollbar.el || O) && (j.scrollbar || j.scrollbar === !1) && P && !P.el && (B = !0), C.includes("navigation") && S.navigation && (S.navigation.prevEl || D) && (S.navigation.nextEl || T) && (j.navigation || j.navigation === !1) && N && !N.prevEl && !N.nextEl && (H = !0);
	let K = (x) => {
		m[x] && (m[x].destroy(), x === "navigation" ? (m.isElement && (m[x].prevEl.remove(), m[x].nextEl.remove()), j[x].prevEl = void 0, j[x].nextEl = void 0, m[x].prevEl = void 0, m[x].nextEl = void 0) : (m.isElement && m[x].el.remove(), j[x].el = void 0, m[x].el = void 0));
	};
	C.includes("loop") && m.isElement && (j.loop && !S.loop ? U = !0 : !j.loop && S.loop ? W = !0 : G = !0), A.forEach((m) => {
		if (isObject(j[m]) && isObject(S[m])) Object.assign(j[m], S[m]), (m === "navigation" || m === "pagination" || m === "scrollbar") && "enabled" in S[m] && !S[m].enabled && K(m);
		else {
			let x = S[m];
			(x === !0 || x === !1) && (m === "navigation" || m === "pagination" || m === "scrollbar") ? x === !1 && K(m) : j[m] = S[m];
		}
	}), A.includes("controller") && !R && m.controller && m.controller.control && j.controller && j.controller.control && (m.controller.control = j.controller.control), C.includes("children") && x && F && j.virtual.enabled ? (F.slides = x, F.update(!0)) : C.includes("virtual") && F && j.virtual.enabled && (x && (F.slides = x), F.update(!0)), C.includes("children") && x && j.loop && (G = !0), L && I.init() && I.update(!0), R && (m.controller.control = j.controller.control), z && (m.isElement && (!k || typeof k == "string") && (k = document.createElement("div"), k.classList.add("swiper-pagination"), k.part.add("pagination"), m.el.appendChild(k)), k && (j.pagination.el = k), M.init(), M.render(), M.update()), B && (m.isElement && (!O || typeof O == "string") && (O = document.createElement("div"), O.classList.add("swiper-scrollbar"), O.part.add("scrollbar"), m.el.appendChild(O)), O && (j.scrollbar.el = O), P.init(), P.updateSize(), P.setTranslate()), H && (m.isElement && ((!T || typeof T == "string") && (T = document.createElement("div"), T.classList.add("swiper-button-next"), setInnerHTML(T, m.navigation.arrowSvg), T.part.add("button-next"), m.el.appendChild(T)), (!D || typeof D == "string") && (D = document.createElement("div"), D.classList.add("swiper-button-prev"), setInnerHTML(D, m.navigation.arrowSvg), D.part.add("button-prev"), m.el.appendChild(D))), T && (j.navigation.nextEl = T), D && (j.navigation.prevEl = D), N.init(), N.update()), C.includes("allowSlideNext") && (m.allowSlideNext = S.allowSlideNext), C.includes("allowSlidePrev") && (m.allowSlidePrev = S.allowSlidePrev), C.includes("direction") && m.changeDirection(S.direction, !1), (U || G) && m.loopDestroy(), (W || G) && m.loopCreate(), m.update();
}
function getParams(m = {}, x = !0) {
	let S = { on: {} }, C = {}, T = {};
	extend(S, defaults), S._emitClasses = !0, S.init = !1;
	let D = {}, O = paramsList.map((m) => m.replace(/_/, "")), k = Object.assign({}, m);
	return Object.keys(k).forEach((k) => {
		m[k] !== void 0 && (O.indexOf(k) >= 0 ? isObject(m[k]) ? (S[k] = {}, T[k] = {}, extend(S[k], m[k]), extend(T[k], m[k])) : (S[k] = m[k], T[k] = m[k]) : k.search(/on[A-Z]/) === 0 && typeof m[k] == "function" ? x ? C[`${k[2].toLowerCase()}${k.substr(3)}`] = m[k] : S.on[`${k[2].toLowerCase()}${k.substr(3)}`] = m[k] : D[k] = m[k]);
	}), [
		"navigation",
		"pagination",
		"scrollbar"
	].forEach((m) => {
		S[m] === !0 && (S[m] = {}), S[m] === !1 && delete S[m];
	}), {
		params: S,
		passedParams: T,
		rest: D,
		events: C
	};
}
function mountSwiper({ el: m, nextEl: x, prevEl: S, paginationEl: C, scrollbarEl: T, swiper: D }, O) {
	needsNavigation(O) && x && S && (D.params.navigation.nextEl = x, D.originalParams.navigation.nextEl = x, D.params.navigation.prevEl = S, D.originalParams.navigation.prevEl = S), needsPagination(O) && C && (D.params.pagination.el = C, D.originalParams.pagination.el = C), needsScrollbar(O) && T && (D.params.scrollbar.el = T, D.originalParams.scrollbar.el = T), D.init(m);
}
function getChangedParams(m, x, S, C, T) {
	let D = [];
	if (!x) return D;
	let O = (m) => {
		D.indexOf(m) < 0 && D.push(m);
	};
	if (S && C) {
		let m = C.map(T), x = S.map(T);
		m.join("") !== x.join("") && O("children"), C.length !== S.length && O("children");
	}
	return paramsList.filter((m) => m[0] === "_").map((m) => m.replace(/_/, "")).forEach((S) => {
		if (S in m && S in x) if (isObject(m[S]) && isObject(x[S])) {
			let C = Object.keys(m[S]), T = Object.keys(x[S]);
			C.length === T.length ? (C.forEach((C) => {
				m[S][C] !== x[S][C] && O(S);
			}), T.forEach((C) => {
				m[S][C] !== x[S][C] && O(S);
			})) : O(S);
		} else m[S] !== x[S] && O(S);
	}), D;
}
var updateOnVirtualData = (m) => {
	!m || m.destroyed || !m.params.virtual || m.params.virtual && !m.params.virtual.enabled || (m.updateSlides(), m.updateProgress(), m.updateSlidesClasses(), m.emit("_virtualUpdated"), m.parallax && m.params.parallax && m.params.parallax.enabled && m.parallax.setTranslate());
};
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(m) {
		for (var x = 1; x < arguments.length; x++) {
			var S = arguments[x];
			for (var C in S) Object.prototype.hasOwnProperty.call(S, C) && (m[C] = S[C]);
		}
		return m;
	}, _extends.apply(this, arguments);
}
function isChildSwiperSlide(m) {
	return m.type && m.type.displayName && m.type.displayName.includes("SwiperSlide");
}
function processChildren(m) {
	let S = [];
	return React.Children.toArray(m).forEach((m) => {
		isChildSwiperSlide(m) ? S.push(m) : m.props && m.props.children && processChildren(m.props.children).forEach((m) => S.push(m));
	}), S;
}
function getChildren(m) {
	let S = [], C = {
		"container-start": [],
		"container-end": [],
		"wrapper-start": [],
		"wrapper-end": []
	};
	return React.Children.toArray(m).forEach((m) => {
		if (isChildSwiperSlide(m)) S.push(m);
		else if (m.props && m.props.slot && C[m.props.slot]) C[m.props.slot].push(m);
		else if (m.props && m.props.children) {
			let x = processChildren(m.props.children);
			x.length > 0 ? x.forEach((m) => S.push(m)) : C["container-end"].push(m);
		} else C["container-end"].push(m);
	}), {
		slides: S,
		slots: C
	};
}
function renderVirtual(m, S, C) {
	if (!C) return null;
	let T = (m) => {
		let x = m;
		return m < 0 ? x = S.length + m : x >= S.length && (x -= S.length), x;
	}, D = m.isHorizontal() ? { [m.rtlTranslate ? "right" : "left"]: `${C.offset}px` } : { top: `${C.offset}px` }, { from: O, to: k } = C, A = m.params.loop ? -S.length : 0, j = m.params.loop ? S.length * 2 : S.length, M = [];
	for (let m = A; m < j; m += 1) m >= O && m <= k && M.push(S[T(m)]);
	return M.map((S, C) => /* @__PURE__ */ React.cloneElement(S, {
		swiper: m,
		style: D,
		key: S.props.virtualIndex || S.key || `slide-${C}`
	}));
}
function useIsomorphicLayoutEffect$1(m, x) {
	return typeof window > "u" ? useEffect(m, x) : useLayoutEffect(m, x);
}
var SwiperSlideContext = /* @__PURE__ */ createContext(null), SwiperContext = /* @__PURE__ */ createContext(null), Swiper = /* @__PURE__ */ forwardRef(({ className: m, tag: S = "div", wrapperTag: C = "div", children: T, onSwiper: D, ...O } = {}, k) => {
	let A = !1, [j, M] = useState("swiper"), [N, F] = useState(null), [I, L] = useState(!1), R = useRef(!1), z = useRef(null), U = useRef(null), W = useRef(null), G = useRef(null), K = useRef(null), q = useRef(null), J = useRef(null), Y = useRef(null), { params: X, passedParams: Z, rest: sH, events: Q } = getParams(O), { slides: cH, slots: lH } = getChildren(T), uH = () => {
		L(!I);
	};
	Object.assign(X.on, { _containerClasses(m, x) {
		M(x);
	} });
	let dH = () => {
		Object.assign(X.on, Q), A = !0;
		let m = { ...X };
		if (delete m.wrapperClass, U.current = new Swiper$1(m), U.current.virtual && U.current.params.virtual.enabled) {
			U.current.virtual.slides = cH;
			let m = {
				cache: !1,
				slides: cH,
				renderExternal: F,
				renderExternalUpdate: !1
			};
			extend(U.current.params.virtual, m), extend(U.current.originalParams.virtual, m);
		}
	};
	z.current || dH(), U.current && U.current.on("_beforeBreakpoint", uH);
	let fH = () => {
		A || !Q || !U.current || Object.keys(Q).forEach((m) => {
			U.current.on(m, Q[m]);
		});
	}, pH = () => {
		!Q || !U.current || Object.keys(Q).forEach((m) => {
			U.current.off(m, Q[m]);
		});
	};
	useEffect(() => () => {
		U.current && U.current.off("_beforeBreakpoint", uH);
	}), useEffect(() => {
		!R.current && U.current && (U.current.emitSlidesClasses(), R.current = !0);
	}), useIsomorphicLayoutEffect$1(() => {
		if (k && (k.current = z.current), z.current) return U.current.destroyed && dH(), mountSwiper({
			el: z.current,
			nextEl: K.current,
			prevEl: q.current,
			paginationEl: J.current,
			scrollbarEl: Y.current,
			swiper: U.current
		}, X), D && !U.current.destroyed && D(U.current), () => {
			U.current && !U.current.destroyed && U.current.destroy(!0, !1);
		};
	}, []), useIsomorphicLayoutEffect$1(() => {
		fH();
		let m = getChangedParams(Z, W.current, cH, G.current, (m) => m.key);
		return W.current = Z, G.current = cH, m.length && U.current && !U.current.destroyed && updateSwiper({
			swiper: U.current,
			slides: cH,
			passedParams: Z,
			changedParams: m,
			nextEl: K.current,
			prevEl: q.current,
			scrollbarEl: Y.current,
			paginationEl: J.current
		}), () => {
			pH();
		};
	}), useIsomorphicLayoutEffect$1(() => {
		updateOnVirtualData(U.current);
	}, [N]);
	function mH() {
		return X.virtual ? renderVirtual(U.current, cH, N) : cH.map((m, S) => /* @__PURE__ */ React.cloneElement(m, {
			swiper: U.current,
			swiperSlideIndex: S
		}));
	}
	return /* @__PURE__ */ React.createElement(S, _extends({
		ref: z,
		className: uniqueClasses(`${j}${m ? ` ${m}` : ""}`)
	}, sH), /* @__PURE__ */ React.createElement(SwiperContext.Provider, { value: U.current }, lH["container-start"], /* @__PURE__ */ React.createElement(C, { className: wrapperClass(X.wrapperClass) }, lH["wrapper-start"], mH(), lH["wrapper-end"]), needsNavigation(X) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
		ref: q,
		className: "swiper-button-prev"
	}), /* @__PURE__ */ React.createElement("div", {
		ref: K,
		className: "swiper-button-next"
	})), needsScrollbar(X) && /* @__PURE__ */ React.createElement("div", {
		ref: Y,
		className: "swiper-scrollbar"
	}), needsPagination(X) && /* @__PURE__ */ React.createElement("div", {
		ref: J,
		className: "swiper-pagination"
	}), lH["container-end"]));
});
Swiper.displayName = "Swiper";
var SwiperSlide = /* @__PURE__ */ forwardRef(({ tag: m = "div", children: S, className: C = "", swiper: T, zoom: D, lazy: O, virtualIndex: k, swiperSlideIndex: A, ...j } = {}, M) => {
	let N = useRef(null), [P, F] = useState("swiper-slide"), [I, L] = useState(!1);
	function R(m, x, S) {
		x === N.current && F(S);
	}
	useIsomorphicLayoutEffect$1(() => {
		if (A !== void 0 && (N.current.swiperSlideIndex = A), M && (M.current = N.current), !(!N.current || !T)) {
			if (T.destroyed) {
				P !== "swiper-slide" && F("swiper-slide");
				return;
			}
			return T.on("_slideClass", R), () => {
				T && T.off("_slideClass", R);
			};
		}
	}), useIsomorphicLayoutEffect$1(() => {
		T && N.current && !T.destroyed && F(T.getSlideClasses(N.current));
	}, [T]);
	let z = {
		isActive: P.indexOf("swiper-slide-active") >= 0,
		isVisible: P.indexOf("swiper-slide-visible") >= 0,
		isPrev: P.indexOf("swiper-slide-prev") >= 0,
		isNext: P.indexOf("swiper-slide-next") >= 0
	}, U = () => typeof S == "function" ? S(z) : S, W = () => {
		L(!0);
	};
	return /* @__PURE__ */ React.createElement(m, _extends({
		ref: N,
		className: uniqueClasses(`${P}${C ? ` ${C}` : ""}`),
		"data-swiper-slide-index": k,
		onLoad: W
	}, j), D && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, { value: z }, /* @__PURE__ */ React.createElement("div", {
		className: "swiper-zoom-container",
		"data-swiper-zoom": typeof D == "number" ? D : void 0
	}, U(), O && !I && /* @__PURE__ */ React.createElement("div", { className: "swiper-lazy-preloader" }))), !D && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, { value: z }, U(), O && !I && /* @__PURE__ */ React.createElement("div", { className: "swiper-lazy-preloader" })));
});
SwiperSlide.displayName = "SwiperSlide";
function ItemSlider({ items: m, variant: x = "default", language: S = "en" }) {
	let [C, T] = useState("desktop"), D = `viewport-${C}`;
	switch (useEffect(() => {
		let m = document?.getElementById("puck-canvas-root"), x = null, S = () => {
			let x = m ? m.getBoundingClientRect().width : window.innerWidth;
			T(x > 1024 ? "desktop" : x > 768 ? "tablet" : "mobile");
		};
		return m ? (x = new ResizeObserver(S), x.observe(m)) : (S(), window.addEventListener("resize", S)), () => {
			x && m ? (x.unobserve(m), x.disconnect()) : window.removeEventListener("resize", S);
		};
	}, []), x) {
		case "voodvale": return /* @__PURE__ */ jsx(VoodvaleItemSlider, {
			items: m,
			language: S,
			viewPort: C
		}, D);
		case "skyscrapper": return /* @__PURE__ */ jsx(SkyscrapperItemSlider, {
			items: m,
			language: S,
			viewPort: C
		}, D);
		default: return /* @__PURE__ */ jsx(DefaultItemSlider, {
			items: m,
			language: S,
			viewPort: C
		}, D);
	}
}
var DefaultItemSlider = ({ items: m, language: x, viewPort: S }) => {
	let C = x === "ar", T = S === "desktop" ? {
		spaceBetween: 60,
		slidesPerView: 4,
		slidesOffsetAfter: 60
	} : {
		spaceBetween: 15,
		slidesPerView: 1.3,
		slidesOffsetAfter: 15
	};
	return /* @__PURE__ */ jsx(Swiper, {
		dir: C ? "rtl" : "ltr",
		spaceBetween: T.spaceBetween,
		slidesPerView: T.slidesPerView,
		slidesOffsetAfter: T.slidesOffsetAfter,
		preventClicks: !1,
		preventClicksPropagation: !1,
		children: m.map((m, x) => /* @__PURE__ */ jsx(SwiperSlide, { children: m }, `swiperSlider${x}`))
	}, C ? "rtl" : "ltr");
}, VoodvaleItemSlider = ({ items: m, language: x, viewPort: S }) => {
	let C = x === "ar", T = S === "desktop" ? {
		spaceBetween: 30,
		slidesPerView: 3,
		slidesOffsetAfter: 0
	} : {
		spaceBetween: 30,
		slidesPerView: 1.2,
		slidesOffsetAfter: 30
	};
	return /* @__PURE__ */ jsx(Swiper, {
		dir: C ? "rtl" : "ltr",
		spaceBetween: T.spaceBetween,
		slidesPerView: T.slidesPerView,
		slidesOffsetAfter: T.slidesOffsetAfter,
		preventClicks: !1,
		preventClicksPropagation: !1,
		children: m.map((m, x) => /* @__PURE__ */ jsx(SwiperSlide, { children: m }, `swiperSlider${x}`))
	});
}, SkyscrapperItemSlider = ({ items: m, language: x, viewPort: S }) => {
	let C = x === "ar", T = S === "desktop" ? {
		spaceBetween: 60,
		slidesPerView: 2.2,
		slidesOffsetAfter: 60
	} : {
		spaceBetween: 13,
		slidesPerView: 1.2,
		slidesOffsetAfter: 90
	};
	return /* @__PURE__ */ jsx(Swiper, {
		dir: C ? "rtl" : "ltr",
		spaceBetween: T.spaceBetween,
		slidesPerView: T.slidesPerView,
		slidesOffsetAfter: T.slidesOffsetAfter,
		preventClicks: !1,
		preventClicksPropagation: !1,
		children: m.map((m, x) => /* @__PURE__ */ jsx(SwiperSlide, { children: m }, `swiperSlider${x}`))
	}, C ? "rtl" : "ltr");
};
const PlotThumbCardRoot = ({ children: m }) => /* @__PURE__ */ jsx("div", {
	className: "flex flex-grow flex-col space-y-2.5",
	children: m
}), PlotThumbCardImage = ({ imageUrl: m }) => m ? /* @__PURE__ */ jsx("img", {
	src: m,
	alt: "Plot Image",
	className: "mobile:w-full w-full h-[156px] object-cover"
}) : /* @__PURE__ */ jsx("div", {
	className: "mobile:w-full w-full h-[156px] bg-gray-300 rounded flex items-center justify-center",
	children: /* @__PURE__ */ jsx("span", {
		className: "text-gray-500",
		children: "Image"
	})
}), PlotThumbCardBody = ({ plot: m }) => /* @__PURE__ */ jsxs("div", {
	className: "flex justify-between items-end",
	children: [/* @__PURE__ */ jsxs("div", {
		className: "flex space-x-2.5 rtl:space-x-reverse items-end",
		children: [/* @__PURE__ */ jsx("div", {
			style: { lineHeight: "1rem" },
			children: m.plotName || `Plot ${m.plotNumber || m.id}`
		}), m.price && /* @__PURE__ */ jsxs("div", {
			className: "text-xs opacity-50",
			children: ["$", m.price.toLocaleString()]
		})]
	}), m.plotStatus && /* @__PURE__ */ jsx("div", {
		className: "text-xs px-2 py-1 bg-gray-200 rounded",
		children: m.plotStatus
	})]
}), VoodvalePlotThumbCardRoot = ({ children: m, plot: x }) => /* @__PURE__ */ jsxs("div", {
	className: "flex flex-grow flex-col rounded-[12px] overflow-hidden relative border border-[#E6E6E6]",
	children: [m, x.plotStatus && /* @__PURE__ */ jsx("div", {
		className: "absolute top-[1.25rem] left-[1.25rem]",
		children: /* @__PURE__ */ jsx("div", {
			className: "px-[1.25rem] py-[0.625rem] rounded-[7px] text-[0.75rem] leading-[normal] font-medium text-[#FFF] min-w-0 min-h-0 bg-gray-600",
			children: x.plotStatus
		})
	})]
}), VoodvalePlotThumbCardImage = ({ imageUrl: m }) => m ? /* @__PURE__ */ jsx("img", {
	src: m,
	alt: "Plot Image",
	className: "w-full h-[240px] object-cover"
}) : /* @__PURE__ */ jsx("div", {
	className: "w-full h-[240px] object-cover bg-gray-300 rounded flex items-center justify-center",
	children: /* @__PURE__ */ jsx("span", {
		className: "text-gray-500",
		children: "Image "
	})
}), VoodvalePlotThumbCardBody = ({ plot: m }) => /* @__PURE__ */ jsxs("div", {
	className: "flex justify-between items-center bg-white px-[1.25rem] pt-[1.4018rem] pb-[1.625rem]",
	children: [/* @__PURE__ */ jsx("div", {
		className: "text-[1.125rem] leading-[100%] text-[#181A20] font-medium",
		children: m.plotName || `Plot ${m.plotNumber || m.id}`
	}), m.price && /* @__PURE__ */ jsxs("div", {
		className: "text-[1.125rem] leading-[158.333%] text-[#A87D6F] font-medium",
		children: ["$", m.price.toLocaleString()]
	})]
}), SkyscrapperPlotThumbCardRoot = ({ children: m }) => /* @__PURE__ */ jsx("div", {
	className: "flex flex-grow flex-col space-y-[1.5rem]",
	children: m
}), SkyscrapperPlotThumbCardImage = ({ plot: m }) => {
	let x = !m.imageUrl;
	return /* @__PURE__ */ jsxs("div", {
		className: "rounded-[24px] overflow-hidden relative",
		children: [/* @__PURE__ */ jsx("div", {
			className: "h-[19.375rem] w-full",
			style: { background: x ? "black" : `linear-gradient(0deg, rgba(0, 0, 0, 0.50) 0%, rgba(0, 0, 0, 0.50) 100%), url(${m.imageUrl ?? ""}) lightgray -76.39px 0.265px / 114.913% 99.858% no-repeat` },
			children: x && /* @__PURE__ */ jsx("div", {
				className: "w-full h-full flex items-center justify-center",
				children: /* @__PURE__ */ jsx("span", {
					className: "text-gray-400",
					children: "Loading..."
				})
			})
		}), m.plotStatus && /* @__PURE__ */ jsx(SkyscrapperBadge, {
			plot: m,
			className: "absolute top-[1.5rem] left-[1.5rem]"
		})]
	});
}, SkyscrapperPlotThumbCardBody = ({ plot: m }) => /* @__PURE__ */ jsx("div", {
	className: "flex justify-between items-end",
	children: /* @__PURE__ */ jsxs("div", {
		className: "flex justify-between w-full items-center text-[1.125rem]",
		children: [/* @__PURE__ */ jsx("div", {
			style: { lineHeight: "1rem" },
			children: m.plotName || `Plot ${m.plotNumber || m.id}`
		}), m.price && /* @__PURE__ */ jsxs("div", {
			className: "text-[#FABA6C] text-[1.375rem]",
			children: ["$", m.price.toLocaleString()]
		})]
	})
});
var SkyscrapperBadge = ({ plot: m, className: x }) => /* @__PURE__ */ jsxs("div", {
	className: cn("border flex items-center gap-[0.5rem] border-white/17 rounded-[11px] px-[0.75rem] py-[0.62rem] font-general-sans text-[0.625rem] text-white tracking-[0.01875rem]", x),
	style: { backgroundColor: "#00000066" },
	children: [/* @__PURE__ */ jsx("div", { className: "w-[5px] h-[5px] rounded-full bg-white" }), /* @__PURE__ */ jsx("div", { children: m.plotStatus || "Available" })]
});
function PlotThumbCard({ plot: m, variant: x = "default" }) {
	switch (x) {
		case "voodvale": return /* @__PURE__ */ jsx(VoodvalePlotThumbCard, { plot: m });
		case "skyscrapper": return /* @__PURE__ */ jsx(SkyscrapperPlotThumbCard, { plot: m });
		default: return /* @__PURE__ */ jsx(DefaultPlotThumbCard, { plot: m });
	}
}
var DefaultPlotThumbCard = ({ plot: m }) => /* @__PURE__ */ jsxs(PlotThumbCardRoot, {
	plot: m,
	children: [/* @__PURE__ */ jsx(PlotThumbCardImage, { imageUrl: m.imageUrl }), /* @__PURE__ */ jsx(PlotThumbCardBody, { plot: m })]
});
const SkyscrapperPlotThumbCard = ({ plot: m }) => /* @__PURE__ */ jsxs(SkyscrapperPlotThumbCardRoot, {
	plot: m,
	children: [/* @__PURE__ */ jsx(SkyscrapperPlotThumbCardImage, { plot: m }), /* @__PURE__ */ jsx(SkyscrapperPlotThumbCardBody, { plot: m })]
});
function VoodvalePlotThumbCard({ plot: m }) {
	return /* @__PURE__ */ jsxs(VoodvalePlotThumbCardRoot, {
		plot: m,
		children: [/* @__PURE__ */ jsx(VoodvalePlotThumbCardImage, { imageUrl: m.imageUrl }), /* @__PURE__ */ jsx(VoodvalePlotThumbCardBody, { plot: m })]
	});
}
function PlotsShowcase({ plots: m, title: x = "Available Units", showAllLink: S, language: C = "en" }) {
	let T = m.map((m, x) => /* @__PURE__ */ jsx("a", {
		href: m.href,
		children: /* @__PURE__ */ jsx(PlotThumbCard, {
			plot: m,
			variant: "default"
		}, `showcase_card${x}`)
	}, `detail_link${x}`));
	return /* @__PURE__ */ jsx("div", {
		className: "w-full mx-auto flex flex-col",
		children: /* @__PURE__ */ jsx("div", {
			className: "page-container",
			children: /* @__PURE__ */ jsxs("div", {
				className: "space-y-5 px-5 lg:px-7.5 py-5 lg:py-10",
				children: [/* @__PURE__ */ jsxs("div", {
					className: "flex justify-between items-end",
					children: [/* @__PURE__ */ jsxs("div", {
						className: "space-x-2.5 rtl:space-x-reverse flex items-end",
						children: [/* @__PURE__ */ jsx("h3", {
							className: "text-2xl",
							suppressHydrationWarning: !0,
							children: x
						}), /* @__PURE__ */ jsx("h6", {
							className: "opacity-50 text-xs",
							suppressHydrationWarning: !0,
							children: `${m.length} units`
						})]
					}), S && /* @__PURE__ */ jsx("a", {
						href: S,
						children: /* @__PURE__ */ jsx("div", {
							suppressHydrationWarning: !0,
							children: "Show All"
						})
					})]
				}), /* @__PURE__ */ jsx(ItemSlider, {
					items: T.slice(0, 5),
					variant: "default",
					language: C
				})]
			})
		})
	});
}
function PlotsShowcaseWrapper(m) {
	let { plots: x = [], title: S = "Available Units", showAllLink: C = "/availability", locale: T = "en", language: D = "en" } = m;
	return /* @__PURE__ */ jsx(PlotsShowcase, {
		plots: x,
		title: S,
		showAllLink: C,
		locale: T,
		language: D
	});
}
var background_default = "data:image/webp;base64,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";
function SkyscrapperHomeFirstSection({ projectName: m, heading: x, subheadingLine1: S, subheadingLine2: C, description: T, buttonLabel: D, buttonHref: O, backgroundData: k }) {
	let A = k?.backgroundUrl ? {
		isVideo: k.isVideo,
		backgroundUrl: k.backgroundUrl
	} : {
		isVideo: !1,
		backgroundUrl: background_default
	};
	return /* @__PURE__ */ jsx("div", {
		className: "panel absolute font-instrument-serif left-0 top-0 will-change-transform w-full h-full z-30",
		children: /* @__PURE__ */ jsxs(motion.div, {
			className: "pt-17.5 pb-[2rem] flex flex-col justify-end lg:justify-center px-5 bg-gray-300 relative h-[100vh] w-[100vw] bg-no-repeat bg-cover",
			children: [
				/* @__PURE__ */ jsx(BackgroundMedia, {
					backgroundData: A,
					projectName: m
				}),
				/* @__PURE__ */ jsx(motion.div, {
					className: "absolute z-20 top-0 left-0",
					style: {
						opacity: .1,
						backgroundColor: "black",
						height: "100vh",
						width: "100vw"
					}
				}),
				/* @__PURE__ */ jsxs("div", {
					className: "page-container z-30 text-white",
					children: [/* @__PURE__ */ jsx("h1", {
						className: "skyscrapper-text-gradient w-[58.3125rem] mobile:w-[19.875rem] text-[10.44rem] mobile:text-[5rem] ml-[11.86rem] mobile:ml-[0] mt-[8.5rem] text-white leading-[1.1em] tracking-[-0.20881rem]",
						children: x
					}), /* @__PURE__ */ jsxs("div", {
						className: "mt-[1.56rem] mobile:mt-[5.19rem] ml-[58.56rem] mobile:ml-0",
						children: [
							/* @__PURE__ */ jsxs("h3", {
								className: "mb-[2.75rem] mobile:mb-[2.87rem] max-w-[34rem] mobile:max-w-[23.125rem] text-[3.40rem] text-[#CED7D8] leading-[3.5rem] tracking-[-0.06em]",
								children: [
									S,
									/* @__PURE__ */ jsx("br", {}),
									C
								]
							}),
							/* @__PURE__ */ jsx("p", {
								className: "mb-[2rem] text-[#CED7D8] max-w-[21.5625rem] font-general-sans",
								children: T
							}),
							/* @__PURE__ */ jsx(GradientBorderButton, {
								href: O,
								children: D
							})
						]
					})]
				})
			]
		})
	});
}
function GradientBorderButton({ children: m, href: x }) {
	return /* @__PURE__ */ jsx("a", {
		href: x,
		children: /* @__PURE__ */ jsx("div", {
			className: "gradient-border-button",
			children: /* @__PURE__ */ jsx("div", {
				className: "px-6 py-3 h-[49px] flex items-center justify-center",
				children: /* @__PURE__ */ jsx("span", {
					className: "text-white font-general-sans text-[0.875rem] font-medium",
					children: m
				})
			})
		})
	});
}
function SkyscrapperHomeFirstSectionWrapper(m) {
	let { projectName: x = "Skyscrapper", heading: S = "A New Peak.", subheadingLine1: C = "in the City", subheadingLine2: T = "of Impossibles", description: D = "Experience contemporary homes crafted with finesse, surrounded by green spaces and effortless connections.", buttonLabel: O = "Explore Listing", buttonHref: k = "/availability", backgroundUrl: A = "", mediaType: j = "image", scrollIndicatorText: M = "Scroll down", scrollIndicatorOpacity: N = 1 } = m;
	return /* @__PURE__ */ jsx(SkyscrapperHomeFirstSection, {
		projectName: x,
		heading: S,
		subheadingLine1: C,
		subheadingLine2: T,
		description: D,
		buttonLabel: O,
		buttonHref: k,
		backgroundData: {
			isVideo: j === "video",
			backgroundUrl: A
		},
		scrollIndicatorText: M,
		scrollIndicatorOpacity: N
	});
}
var skyscrapper_content_1_default = "data:image/webp;base64,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", skyscrapper_content_2_default = "data:image/webp;base64,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", skyscrapper_content_3_default = "data:image/webp;base64,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";
function SkyscrapperHomesSecondSection({ introText: m, image1: x, image2: S, image3: C, gridTitle: T, gridLead: D, gridItems: O }) {
	return /* @__PURE__ */ jsx("div", {
		id: "second-section",
		className: "bg-black text-[#CED7D8] font-instrument-serif second-section left-0 top-0 w-full min-h-[100vh] flex flex-col z-10 pt-[12rem] mobile:pt-[8.5rem]",
		children: /* @__PURE__ */ jsxs("div", { children: [/* @__PURE__ */ jsxs("div", {
			className: "w-full mx-auto flex flex-col px-[5rem] mobile:px-5 max-w-[1440px]",
			children: [/* @__PURE__ */ jsx("p", {
				className: "mx-auto w-[57.48rem] mobile:w-full text-center text-[3.75rem] mobile:text-[2.25rem] leading-[108%] text-[#CED7D8]",
				children: m
			}), /* @__PURE__ */ jsxs("div", {
				className: "mb-[5rem] mobile:mb-[0rem] relative h-[46.875rem] mobile:h-[55vh]",
				children: [
					/* @__PURE__ */ jsx(Image, {
						width: 233,
						height: 288,
						src: x,
						fallbackSrc: skyscrapper_content_1_default,
						alt: "content-1",
						className: "absolute right-1/2 -translate-x-[10%] top-1/2 -translate-y-[80%] w-[14.55rem] mobile:w-[10rem] h-[17.98rem] mobile:h-[12.3025rem] object-cover skyscrapper-image-mask"
					}),
					/* @__PURE__ */ jsx(Image, {
						width: 233,
						height: 288,
						src: S,
						fallbackSrc: skyscrapper_content_2_default,
						alt: "content-2",
						className: "absolute right-1/2 translate-x-[105%] top-1/2 -translate-y-[115%] w-[14.55rem] mobile:w-[10rem] h-[17.98rem] mobile:h-[12.3025rem] object-cover skyscrapper-image-mask"
					}),
					/* @__PURE__ */ jsx(Image, {
						width: 233,
						height: 288,
						src: C,
						fallbackSrc: skyscrapper_content_3_default,
						alt: "content-3",
						className: "absolute right-1/2 translate-x-[75%] top-1/2 -translate-y-[2%] w-[19.57rem] h-[24.20rem] mobile:w-[13.375rem] mobile:h-[16.625rem] object-cover skyscrapper-image-mask lg"
					})
				]
			})]
		}), /* @__PURE__ */ jsxs("div", {
			className: "pt-[10rem] mobile:pt-[0rem] pb-[12rem] mobile:pb-[9rem] pl-[11.57rem] pr-[22.27rem] mobile:px-[1.3rem] mx-auto max-w-[1440px]",
			children: [
				/* @__PURE__ */ jsx("div", {
					className: "text-[3.75rem] mobile:text-[2.25rem] mb-[3rem] mobile:mb-[2.25rem]",
					children: T
				}),
				/* @__PURE__ */ jsx("div", {
					className: "mb-[10.69rem] mobile:mb-[4.19rem] font-general-sans text-[1.125rem] mobile:text-[1rem]",
					children: D
				}),
				/* @__PURE__ */ jsx("div", {
					className: "grid grid-cols-2 mobile:grid-cols-1 gap-[15.20rem] mobile:gap-[3.75rem]",
					children: O.map((m, x) => /* @__PURE__ */ jsx(GridCell$1, { ...m }, x))
				})
			]
		})] })
	});
}
var GridCell$1 = ({ description: m, increase: x, className: S }) => /* @__PURE__ */ jsxs("div", {
	className: cn("", S),
	children: [
		/* @__PURE__ */ jsx("div", {
			className: "skyscrapper-text-gradient leading-[100%] tracking-[-0.1rem] text-[5rem] mb-[1.25rem]",
			children: x
		}),
		/* @__PURE__ */ jsx("div", {
			className: "font-general-sans text-[1rem] leading-[162%] h-[7.75rem]",
			children: m
		}),
		/* @__PURE__ */ jsx("div", { className: "h-[1px] bg-[#FABA6C4D] w-full" })
	]
});
function SkyscrapperHomesSecondSectionWrapper(m) {
	let { introText: x = "A new icon rises on Dubais horizon  a sculpted tower where architecture, luxury, and imagination collide.", image1: S = "", image2: C = "", image3: T = "", gridTitle: D = "In the Numbers", gridLead: O = "Our numbers reflect steady growth, strong engagement, and increasing trust from our users. Heres a quick look at the key metrics driving our progress.", gridItems: k = [
		{
			increase: "50+",
			description: "Families who've found their perfect home in communities like Woodvale Quarters."
		},
		{
			increase: "100%",
			description: "Built on lasting trust and attention to detail in every development."
		},
		{
			increase: "100%",
			description: "Resident satisfaction through quality, care, and commitment."
		},
		{
			increase: "15+",
			description: "Years of expertise shaping elegant, well-crafted homes."
		}
	] } = m;
	return /* @__PURE__ */ jsx(SkyscrapperHomesSecondSection, {
		introText: x,
		image1: S,
		image2: C,
		image3: T,
		gridTitle: D,
		gridLead: O,
		gridItems: k
	});
}
function SkyscrapperShowcaseCard({ plot: m, index: x, variant: S }) {
	switch (S) {
		case "first": return /* @__PURE__ */ jsx(FirstShowcaseCard, {
			plot: m,
			index: x
		});
		case "default": return /* @__PURE__ */ jsx(DefaultShowcaseCard, {
			plot: m,
			index: x
		});
	}
}
var FirstShowcaseCard = ({ plot: m, index: x }) => {
	let S = !m.imageUrl;
	return /* @__PURE__ */ jsxs("div", {
		className: "group rounded-[24px] bg-[#1A1A1A] w-full h-[29.9375rem] mobile:h-[15.18rem] pl-[1.75rem] mobile:pl-[0.89rem]\n        pr-[1.82rem] mobile:pr-[0.92rem] pt-[2rem] mobile:pt-[1.17rem] pb-[1.62rem] mobile:pb-[0.82rem] relative",
		children: [
			/* @__PURE__ */ jsx("div", {
				className: "absolute top-[1.13rem] right-[0.69rem] invisible group-hover:visible transition-all duration-300",
				children: /* @__PURE__ */ jsx(Arrow$1, {})
			}),
			/* @__PURE__ */ jsx("div", {
				className: "mb-[2.2rem] mobile:mb-[0.99rem] pl-[1.22rem] mobile:pl-[0.62rem] flex gap-[1.75rem] items-center",
				children: /* @__PURE__ */ jsx("div", {
					className: "text-[#CED7D8] text-[1.5rem] tracking-[0.045rem] mobile:text-[0.875rem] mobile:tracking-[0.02rem]",
					children: (x + 1).toString().padStart(2, "0")
				})
			}),
			/* @__PURE__ */ jsx(Name, {
				name: m.plotName ?? "",
				className: "pl-[1.22rem] mobile:pl-[0.62rem] mb-[2.49rem] mobile:mb-[1.11rem]"
			}),
			S ? /* @__PURE__ */ jsx(LoaderComp, { className: "w-full h-[15.437rem]" }) : /* @__PURE__ */ jsx("div", {
				className: "object-cover object-center w-full h-[15.437rem] mobile:h-[7.83rem] rounded-[11px] bg-gray-700 flex items-center justify-center",
				style: {
					backgroundImage: m.imageUrl ? `url(${m.imageUrl})` : void 0,
					backgroundSize: "cover",
					backgroundPosition: "center"
				},
				children: !m.imageUrl && /* @__PURE__ */ jsx("span", {
					className: "text-gray-400",
					children: "No Image"
				})
			})
		]
	});
}, DefaultShowcaseCard = ({ plot: m, index: x }) => /* @__PURE__ */ jsxs("div", {
	className: "group rounded-[24px] flex flex-col justify-between h-[29.9375rem] mobile:h-[15.18rem] relative",
	children: [
		/* @__PURE__ */ jsx("div", {
			style: { background: m.imageUrl ? `linear-gradient(0deg, rgba(0, 0, 0, 0.50) 0%, rgba(0, 0, 0, 0.50) 100%), url(${m.imageUrl ?? ""}) lightgray -76.39px 0.265px / 114.913% 99.858% no-repeat` : "black" },
			className: "absolute rounded-[24px] overflow-hidden top-0 left-0 w-full h-full !bg-cover !bg-center z-[4]"
		}),
		/* @__PURE__ */ jsx("div", {
			className: "absolute z-[6] top-[1.13rem] right-[0.69rem] invisible group-hover:visible transition-all duration-300",
			children: /* @__PURE__ */ jsx(Arrow$1, {})
		}),
		/* @__PURE__ */ jsx("div", {
			className: "pl-[2.02rem] mobile:pl-[1.02rem] pr-[1.82rem] mobile:pr-[0.92rem] pt-[2rem] mobile:pt-[1.17rem] pb-[1.62rem]\n          mobile:pb-[0.82rem] flex gap-[1.75rem] items-center z-[6]",
			children: /* @__PURE__ */ jsx("div", {
				className: "text-[#CED7D8] text-[1.5rem] tracking-[0.045rem] mobile:text-[0.875rem] mobile:tracking-[0.02rem]",
				children: (x + 1).toString().padStart(2, "0")
			})
		}),
		/* @__PURE__ */ jsx(Name, {
			name: m.plotName ?? "",
			className: "pl-[2.02rem] mobile:pl-[1.02rem] mb-[2.49rem] mobile:mb-[1.11rem] z-[6]"
		})
	]
}), LoaderComp = ({ className: m }) => /* @__PURE__ */ jsx("div", {
	className: cn("select-none w-full min-h-[11.25rem] max-w-full h-full flex grow", m),
	children: /* @__PURE__ */ jsx("div", {
		className: "w-full max-w-full grow flex animate-pulse items-center justify-center bg-gray-300 rounded dark:bg-gray-700",
		children: /* @__PURE__ */ jsx("svg", {
			className: "w-12 h-12 text-gray-200",
			xmlns: "http://www.w3.org/2000/svg",
			"aria-hidden": "true",
			fill: "currentColor",
			viewBox: "0 0 640 512",
			children: /* @__PURE__ */ jsx("path", { d: "M480 80C480 35.82 515.8 0 560 0C604.2 0 640 35.82 640 80C640 124.2 604.2 160 560 160C515.8 160 480 124.2 480 80zM0 456.1C0 445.6 2.964 435.3 8.551 426.4L225.3 81.01C231.9 70.42 243.5 64 256 64C268.5 64 280.1 70.42 286.8 81.01L412.7 281.7L460.9 202.7C464.1 196.1 472.2 192 480 192C487.8 192 495 196.1 499.1 202.7L631.1 419.1C636.9 428.6 640 439.7 640 450.9C640 484.6 612.6 512 578.9 512H55.91C25.03 512 .0006 486.1 .0006 456.1L0 456.1z" })
		})
	})
}), Name = ({ name: m, className: x }) => /* @__PURE__ */ jsx("div", {
	className: cn("text-[2.5rem] mobile:text-[1.25rem] mobile:tracking-[-0.0125rem] leading-[75%] tracking-[-0.025rem] text-[#CED7D8]", x),
	children: m
}), Arrow$1 = () => /* @__PURE__ */ jsxs("svg", {
	width: "72",
	height: "72",
	viewBox: "0 0 72 72",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg",
	children: [/* @__PURE__ */ jsx("path", {
		d: "M21 51L51 21",
		stroke: "#EFB76F",
		strokeWidth: "2",
		strokeLinecap: "round",
		strokeLinejoin: "round"
	}), /* @__PURE__ */ jsx("path", {
		d: "M21 21H51V51",
		stroke: "#EFB76F",
		strokeWidth: "2",
		strokeLinecap: "round",
		strokeLinejoin: "round"
	})]
});
function SkyscrapperPlotsShowcase({ plots: m, title: x = "Available Units", subtitle: S = "Five distinct residence types, tailored to your needs.", language: C = "en" }) {
	let T = m.map((m, x) => /* @__PURE__ */ jsx("a", {
		href: m.href,
		children: /* @__PURE__ */ jsx(SkyscrapperShowcaseCard, {
			plot: m,
			index: x,
			variant: x === 0 ? "first" : "default"
		})
	}, `detail_link${x}`));
	return /* @__PURE__ */ jsx("div", {
		className: "relative w-full mx-auto flex flex-col bg-black",
		children: /* @__PURE__ */ jsx("div", {
			className: "relative z-[1] page-container",
			children: /* @__PURE__ */ jsxs("div", {
				className: "pt-[6.8125rem] mobile:pt-[4.1875rem] pb-[7.5rem] mobile:pb-[9rem] mobile:pl-[1.3rem] mobile:pr-0",
				children: [/* @__PURE__ */ jsx("div", {
					className: "mb-[3.875rem] mobile:mb-[2rem] flex justify-between items-center",
					children: /* @__PURE__ */ jsx("div", {
						suppressHydrationWarning: !0,
						children: /* @__PURE__ */ jsxs("div", {
							className: "pl-[11.57rem] mobile:pl-0",
							children: [/* @__PURE__ */ jsx("div", {
								className: "mb-[2.87rem] mobile:mb-[2.25rem] text-[2.75rem] mobile:text-[2.25rem] leading-[100%] text-[#FFF]\n                    font-medium",
								children: x
							}), /* @__PURE__ */ jsx("p", {
								className: "text-[1.25rem] mobile:text-[1rem] text-white",
								children: S
							})]
						})
					})
				}), /* @__PURE__ */ jsx("div", {
					className: "pl-[3.87rem] mobile:pl-0",
					children: /* @__PURE__ */ jsx(ItemSlider, {
						items: T.slice(0, 5),
						variant: "skyscrapper",
						language: C
					})
				})]
			})
		})
	});
}
function SkyscrapperPlotsShowcaseWrapper(m) {
	let { plots: x = [], title: S = "Available Units", subtitle: C = "Five distinct residence types, tailored to your needs.", locale: T = "en", language: D = "en" } = m;
	return /* @__PURE__ */ jsx(SkyscrapperPlotsShowcase, {
		plots: x,
		title: S,
		subtitle: C,
		locale: T,
		language: D
	});
}
function HeaderSection({ title: m, description: x, animationEase: S = "easeOut" }) {
	return /* @__PURE__ */ jsxs(motion.div, {
		initial: {
			opacity: 0,
			y: 20
		},
		animate: {
			opacity: 1,
			y: 0
		},
		transition: {
			duration: .6,
			ease: S
		},
		className: "mt-[3rem] mb-[5rem] mobile:mb-[3.125rem] flex mobile:flex-col mobile:gap-[1.875rem] justify-between",
		children: [/* @__PURE__ */ jsx("div", {
			className: "w-[34.5rem] mobile:w-[19.6875rem] text-[3rem] mobile:text-[2.25rem] leading-[122%] tracking-[-0.01em] text-[#12161D] font-medium capitalize",
			children: m
		}), /* @__PURE__ */ jsx("div", {
			className: "w-[39.125rem] mobile:w-full text-[1.125rem] mobile:text-[1rem] leading-[144.444%] text-[#4A4A4A] font-normal",
			children: x
		})]
	});
}
function HeaderSectionWrapper(m) {
	let { title: x = "", description: S = "", animationEase: C = "easeOut" } = m;
	return /* @__PURE__ */ jsx(HeaderSection, {
		title: x,
		description: S,
		animationEase: C
	});
}
var GridCell = ({ title: m, description: x, increase: S, className: C }) => /* @__PURE__ */ jsxs("div", {
	className: cn("flex flex-col bg-white", C),
	children: [/* @__PURE__ */ jsx("div", {
		className: "pt-[1.6875rem] pl-[1.9375rem] mobile:pl-0 mobile:pb-[0.875rem] text-[1.125rem] leading-[144.444%] text-[#4A4A4A] font-normal",
		children: m
	}), /* @__PURE__ */ jsxs("div", {
		className: "pl-[15.875rem] pb-[1.9375rem] mobile:pl-0 ",
		children: [/* @__PURE__ */ jsx("div", {
			className: "mb-[0.75rem] text-[2.25rem] leading-[133.333%] text-[#C6A195] font-semibold",
			children: S
		}), /* @__PURE__ */ jsx("div", {
			className: "text-[1.125rem] leading-[144.444%] text-[#61656E] font-medium mobile:w-full",
			children: x
		})]
	})]
});
function GridSection({ gridData: m }) {
	return /* @__PURE__ */ jsx("div", {
		className: "grid grid-cols-2 mobile:grid-cols-1",
		children: m.map((m, x) => /* @__PURE__ */ jsx(GridCell, {
			...m,
			className: `hover:bg-[#C7A093]/10 transition-all duration-300 border-t border-[#E3E3E3] ${x === 0 ? "mobile:border-t-1" : ""} mobile:border-b-1 mobile:border-r-0 ${x < 2 ? "border-b" : ""} ${x % 2 == 0 ? "border-r" : ""}`
		}, x))
	});
}
function GridSectionWrapper(m) {
	let { gridData: x = [] } = m;
	return /* @__PURE__ */ jsx(GridSection, { gridData: x });
}
var voodvale_content_1_default = "data:image/avif;base64,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", voodvale_content_2_default = "data:image/avif;base64,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", voodvale_content_3_default = "data:image/avif;base64,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";
function ContentSection({ sectionTitle: m, sectionDescription: x, contentImage1: S, contentImage2: C, contentImage3: T }) {
	return /* @__PURE__ */ jsxs("div", {
		className: "mt-[11.5rem] mobile:mt-[6.250rem] mb-[7.5rem] flex mobile:flex-col gap-[3.125rem] mobile:gap-0 ",
		children: [
			/* @__PURE__ */ jsxs("div", {
				className: "flex-shrink-0 w-[34.375rem] mobile:w-full",
				children: [
					/* @__PURE__ */ jsx("div", {
						className: "mb-[1.5rem] text-[3rem] mobile:text-[2.25rem] mobile:w-[19.6875rem] leading-[108.333%] text-[#12161D] font-medium capitalize",
						children: m
					}),
					/* @__PURE__ */ jsx("div", {
						className: "mb-[3.75rem] text-[1.125rem] mobile:text-[1rem] leading-[144.444%] text-[#4A4A4A] font-normal",
						children: x
					}),
					/* @__PURE__ */ jsx("div", {
						className: "w-full h-auto mobile:hidden",
						children: /* @__PURE__ */ jsx(Image, {
							width: 550,
							height: 640,
							src: S,
							fallbackSrc: voodvale_content_1_default,
							alt: "content",
							className: "w-full h-auto object-contain"
						})
					})
				]
			}),
			/* @__PURE__ */ jsxs("div", {
				className: "flex-grow mobile:hidden",
				children: [/* @__PURE__ */ jsx("div", {
					className: "w-full h-auto mb-[4.25rem]",
					children: /* @__PURE__ */ jsx(Image, {
						width: 680,
						height: 734,
						src: C,
						fallbackSrc: voodvale_content_2_default,
						alt: "content",
						className: "w-full h-auto object-contain"
					})
				}), /* @__PURE__ */ jsx("div", {
					className: "w-full h-auto",
					children: /* @__PURE__ */ jsx(Image, {
						width: 461,
						height: 309,
						src: T,
						fallbackSrc: voodvale_content_3_default,
						alt: "content",
						className: "w-full h-auto object-contain"
					})
				})]
			}),
			/* @__PURE__ */ jsxs("div", {
				className: "hidden mobile:flex justify-center mobile:gap-[0.903125rem]",
				children: [/* @__PURE__ */ jsx("div", {
					className: "mt-[5.375rem] w-[39.8vw] h-auto",
					children: /* @__PURE__ */ jsx(Image, {
						width: 133,
						height: 154,
						src: S,
						fallbackSrc: voodvale_content_1_default,
						alt: "content",
						className: "w-full h-auto object-contain"
					})
				}), /* @__PURE__ */ jsxs("div", {
					className: "flex flex-col gap-[1.25rem]",
					children: [/* @__PURE__ */ jsx("div", {
						className: "w-[48.75vw] h-auto",
						children: /* @__PURE__ */ jsx(Image, {
							width: 197,
							height: 212,
							src: C,
							fallbackSrc: voodvale_content_2_default,
							alt: "content",
							className: "w-full h-auto object-contain"
						})
					}), /* @__PURE__ */ jsx("div", {
						className: "w-[33.08vw] h-auto",
						children: /* @__PURE__ */ jsx(Image, {
							width: 133,
							height: 212,
							src: T,
							fallbackSrc: voodvale_content_3_default,
							alt: "content",
							className: "w-full h-auto object-contain"
						})
					})]
				})]
			})
		]
	});
}
function ContentSectionWrapper(m) {
	let { sectionTitle: x = "", sectionDescription: S = "", contentImage1: C = "", contentImage2: T = "", contentImage3: D = "" } = m;
	return /* @__PURE__ */ jsx(ContentSection, {
		sectionTitle: x,
		sectionDescription: S,
		contentImage1: C,
		contentImage2: T,
		contentImage3: D
	});
}
var wodvale_bg_default = "data:image/avif;base64,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";
function VoodvaleHomeFirstSection({ projectName: m, heading: x, subheading: S, buttonLabel: C, buttonHref: T, backgroundData: D }) {
	let O = D?.backgroundUrl ? {
		isVideo: D.isVideo,
		backgroundUrl: D.backgroundUrl
	} : {
		isVideo: !1,
		backgroundUrl: wodvale_bg_default
	};
	return /* @__PURE__ */ jsx("div", {
		className: "panel absolute left-0 top-0 will-change-transform w-full h-full z-30",
		children: /* @__PURE__ */ jsxs(motion.div, {
			className: "pt-17.5 pb-[2rem] flex flex-col justify-end lg:justify-center px-5 bg-gray-300 relative h-[100vh] w-[100vw] bg-no-repeat bg-cover",
			children: [
				/* @__PURE__ */ jsx(BackgroundMedia, {
					backgroundData: O,
					projectName: m
				}),
				/* @__PURE__ */ jsx(motion.div, {
					className: "absolute z-20 top-0 left-0",
					style: {
						opacity: .5,
						backgroundColor: "black",
						height: "100vh",
						width: "100vw"
					}
				}),
				/* @__PURE__ */ jsxs("div", {
					className: "page-container z-30 text-white",
					children: [/* @__PURE__ */ jsx("h1", {
						className: "w-[58.3125rem] mobile:w-[19.875rem] font-medium text-[5.625rem] mobile:text-[3rem] ml-[7.875rem] mobile:ml-[0] mt-[8.5rem] text-white leading-[107%] tracking-[-0.01em] capitalize",
						children: x
					}), /* @__PURE__ */ jsxs("div", {
						className: "mt-[5rem] mobile:mt-[2.5rem] ml-[45.9375rem] mobile:ml-0",
						children: [/* @__PURE__ */ jsx("h3", {
							className: "mb-[1.0625rem] mobile:mb-[3.125rem] w-[34rem] mobile:w-[23.125rem] text-[1.25rem] leading-[135%] tracking-[0.03em]",
							children: S
						}), /* @__PURE__ */ jsx("a", {
							href: T,
							style: { boxShadow: "0 72px 20px 0 rgba(0, 0, 0, 0.00), 0 46px 18px 0 rgba(0, 0, 0, 0.01), 0 26px 16px 0 rgba(0, 0, 0, 0.05), 0 12px 12px 0 rgba(0, 0, 0, 0.09), 0 3px 6px 0 rgba(0, 0, 0, 0.10)" },
							className: "bg-white rounded-[7px] text-[#484848] flex items-center justify-center w-[10.0625rem] h-[3.125rem]",
							children: C
						})]
					})]
				})
			]
		})
	});
}
function VoodvaleHomeFirstSectionWrapper(m) {
	let { projectName: x = "Voodvale", heading: S = "A New Benchmark of Refined Living.", subheading: C = "Experience contemporary homes crafted with finesse, surrounded by green spaces and effortless connections.", buttonLabel: T = "Explore Listing", buttonHref: D = "/availability", backgroundUrl: O = "", mediaType: k = "image", scrollIndicatorText: A = "Scroll down", scrollIndicatorOpacity: j = 1 } = m;
	return /* @__PURE__ */ jsx(VoodvaleHomeFirstSection, {
		projectName: x,
		heading: S,
		subheading: C,
		buttonLabel: T,
		buttonHref: D,
		backgroundData: {
			isVideo: k === "video",
			backgroundUrl: O
		},
		scrollIndicatorText: A,
		scrollIndicatorOpacity: j
	});
}
function VoodvaleHomeSecondSection({ title: m, description: x, gridData: S, sectionTitle: C, sectionDescription: T, contentImage1: D, contentImage2: O, contentImage3: k }) {
	return /* @__PURE__ */ jsxs("div", {
		className: "w-full mx-auto flex flex-col pt-[3rem] px-[5rem] mobile:px-5 max-w-[1440px]",
		children: [
			/* @__PURE__ */ jsx(HeaderSection, {
				title: m,
				description: x
			}),
			/* @__PURE__ */ jsx(GridSection, { gridData: S }),
			/* @__PURE__ */ jsx(ContentSection, {
				sectionTitle: C,
				sectionDescription: T,
				contentImage1: D,
				contentImage2: O,
				contentImage3: k
			})
		]
	});
}
function VoodvaleHomeSecondSectionWrapper(m) {
	let { title: x = "A Neighbourhood That Feels Like Home", description: S = "Woodvale Quarters brings together the charm of classic British architecture and the convenience of modern living. Surrounded by landscaped gardens and walkable streets, the development celebrates thoughtful design and quality finishes that make every home feel exceptional.", gridData: C = [
		{
			title: "Dream Homes Realised",
			increase: "50+",
			description: "Families who've found their perfect home in communities like Woodvale Quarters."
		},
		{
			title: "Trusted by Homeowners",
			increase: "100%",
			description: "Built on lasting trust and attention to detail in every development."
		},
		{
			title: "Pride in Every Home",
			increase: "100%",
			description: "Resident satisfaction through quality, care, and commitment."
		},
		{
			title: "Built on Experience",
			increase: "15+",
			description: "Years of expertise shaping elegant, well-crafted homes."
		}
	], sectionTitle: T = "Find Your Dream\nHome Here", sectionDescription: D = "Experience the charm and comfort of life at Woodvale Quarters.\n\nBrowse our gallery to explore the architecture, surroundings, and amenities that make this community a beautiful place to call home.", contentImage1: O = "", contentImage2: k = "", contentImage3: A = "" } = m;
	return /* @__PURE__ */ jsx(VoodvaleHomeSecondSection, {
		title: x,
		description: S,
		gridData: C,
		sectionTitle: T,
		sectionDescription: D,
		contentImage1: O,
		contentImage2: k,
		contentImage3: A
	});
}
function VoodvalePlotsShowcase({ plots: m, title: x = "Available Units", seeAllTitle: S = "See All Properties", showAllLink: C, language: T = "en", showcaseVectorUrl: D, showcaseMobileVectorUrl: O }) {
	let k = m.map((m, x) => /* @__PURE__ */ jsx("a", {
		href: m.href,
		children: /* @__PURE__ */ jsx(VoodvalePlotThumbCard, { plot: m }, `showcase_card${x}`)
	}, `detail_link${x}`));
	return /* @__PURE__ */ jsxs("div", {
		className: "relative w-full mx-auto flex flex-col",
		style: { background: "radial-gradient(113.94% 104.88% at 55.95% -2.12%, #DECFCD 0%, #B38A82 56.73%, #988289 100%)" },
		children: [
			/* @__PURE__ */ jsx("div", {
				className: "relative z-[1] page-container",
				children: /* @__PURE__ */ jsxs("div", {
					className: "pt-[6.8125rem] mobile:pt-[4.1875rem] pb-[7.8125rem] mobile:pb-[9rem] px-[8.4375rem] mobile:pl-[1rem] mobile:pr-0",
					children: [/* @__PURE__ */ jsxs("div", {
						className: "mb-[3.875rem] mobile:mb-[2rem] flex justify-between items-center",
						children: [/* @__PURE__ */ jsx("h3", {
							className: "text-[2.75rem] mobile:text-[2.25rem] leading-[118.182%] text-[#FFF] font-medium",
							suppressHydrationWarning: !0,
							children: x
						}), /* @__PURE__ */ jsx(SeeAllProperties, {
							className: "mobile:hidden",
							pathname: C || "",
							title: S || "See All Properties"
						})]
					}), /* @__PURE__ */ jsx(ItemSlider, {
						items: k.slice(0, 3),
						variant: "voodvale",
						language: T
					})]
				})
			}),
			/* @__PURE__ */ jsx(SeeAllProperties, {
				className: "hidden mobile:block absolute z-[1] left-1/2 -translate-x-1/2 bottom-[4.1875rem]",
				pathname: C || "",
				title: S || "See All Properties"
			}),
			D && /* @__PURE__ */ jsx("div", {
				className: "mobile:hidden z-[0] absolute w-[100vw] h-auto object-contain -bottom-[12.72vw] left-1/2 -translate-x-1/2",
				children: /* @__PURE__ */ jsx("img", {
					src: D,
					alt: "showcase vector",
					className: "w-full h-full object-contain"
				})
			}),
			O && /* @__PURE__ */ jsx("div", {
				className: "mobile:block hidden z-[0] absolute w-[100vw] h-auto object-contain -bottom-[21vw] left-1/2 -translate-x-1/2",
				children: /* @__PURE__ */ jsx("img", {
					src: O,
					alt: "showcase mobile vector",
					className: "w-full h-full object-contain"
				})
			})
		]
	});
}
var SeeAllProperties = ({ pathname: m, title: x, className: S }) => /* @__PURE__ */ jsx("a", {
	className: cn("mobile:hidden", S),
	href: m,
	children: /* @__PURE__ */ jsxs("div", {
		className: "flex items-center gap-4",
		children: [/* @__PURE__ */ jsx("div", {
			className: "text-[1rem] text-[#FFF]",
			children: x
		}), /* @__PURE__ */ jsx(Arrow, {})]
	})
}), Arrow = () => /* @__PURE__ */ jsxs("svg", {
	width: "15",
	height: "15",
	viewBox: "0 0 15 15",
	fill: "none",
	xmlns: "http://www.w3.org/2000/svg",
	children: [/* @__PURE__ */ jsx("g", {
		clipPath: "url(#clip0_4171_3931)",
		children: /* @__PURE__ */ jsx("path", {
			d: "M15 0.65V10.35C15 10.5167 14.9417 10.6667 14.825 10.8C14.7083 10.9333 14.5583 11 14.375 11C14.1917 11 14.0333 10.9333 13.9 10.8C13.7667 10.6667 13.7 10.5167 13.7 10.35V2.2L1.1 14.8C0.966667 14.9333 0.808333 15 0.625 15C0.441667 15 0.291667 14.9417 0.175 14.825C0.0583333 14.7083 0 14.5583 0 14.375C0 14.1917 0.0666667 14.0333 0.2 13.9L12.8 1.3H4.65C4.48333 1.3 4.33333 1.23333 4.2 1.1C4.06667 0.966666 4 0.808333 4 0.625C4 0.441667 4.06667 0.291666 4.2 0.175C4.33333 0.0583334 4.48333 0 4.65 0H14.35C14.55 0 14.7083 0.0583334 14.825 0.175C14.9417 0.291666 15 0.45 15 0.65Z",
			fill: "white"
		})
	}), /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", {
		id: "clip0_4171_3931",
		children: /* @__PURE__ */ jsx("rect", {
			width: "15",
			height: "15",
			fill: "white",
			transform: "matrix(1 0 0 -1 0 15)"
		})
	}) })]
});
function VoodvalePlotsShowcaseWrapper(m) {
	let { plots: x = [], title: S = "Available Units", showAllLink: C = "/availability", locale: T = "en", language: D = "en", showcaseVectorUrl: O = "", showcaseMobileVectorUrl: k = "" } = m;
	return /* @__PURE__ */ jsx(VoodvalePlotsShowcase, {
		plots: x,
		title: S,
		showAllLink: C,
		locale: T,
		language: D,
		showcaseVectorUrl: O,
		showcaseMobileVectorUrl: k
	});
}
function VoodvaleSection(m) {
	let { title: x = "", description: S = "", sectionTitle: C = "", sectionDescription: T = "", gridData: D = [], contentImage1: O = "", contentImage2: k = "", contentImage3: A = "" } = m;
	return /* @__PURE__ */ jsxs("div", {
		className: "w-full mx-auto flex flex-col pt-[3rem] px-[5rem] mobile:px-5 max-w-[1440px]",
		children: [
			/* @__PURE__ */ jsx(HeaderSection, {
				title: x,
				description: S
			}),
			/* @__PURE__ */ jsx(GridSection, { gridData: D }),
			/* @__PURE__ */ jsx(ContentSection, {
				sectionTitle: C,
				sectionDescription: T,
				contentImage1: O,
				contentImage2: k,
				contentImage3: A
			})
		]
	});
}
var require___vite_browser_external = /* @__PURE__ */ __commonJSMin(((m, x) => {
	x.exports = {};
})), require_fabric = /* @__PURE__ */ __commonJSMin(((m) => {
	var x = x || { version: "5.5.2" };
	if (m === void 0 ? typeof define == "function" && define.amd && define([], function() {
		return x;
	}) : m.fabric = x, typeof document < "u" && typeof window < "u") document instanceof (typeof HTMLDocument < "u" ? HTMLDocument : Document) ? x.document = document : x.document = document.implementation.createHTMLDocument(""), x.window = window;
	else {
		var S = new (require___vite_browser_external()).JSDOM("<!DOCTYPE html><html><head></head><body></body></html>", {
			features: { FetchExternalResources: ["img"] },
			resources: "usable"
		}).window;
		x.document = S.document, x.jsdomImplForWrapper = require___vite_browser_external().implForWrapper, x.nodeCanvas = require___vite_browser_external().Canvas, x.window = S, DOMParser = x.window.DOMParser;
	}
	x.isTouchSupported = "ontouchstart" in x.window || "ontouchstart" in x.document || x.window && x.window.navigator && x.window.navigator.maxTouchPoints > 0, x.isLikelyNode = typeof Buffer < "u" && typeof window > "u", x.SHARED_ATTRIBUTES = [
		"display",
		"transform",
		"fill",
		"fill-opacity",
		"fill-rule",
		"opacity",
		"stroke",
		"stroke-dasharray",
		"stroke-linecap",
		"stroke-dashoffset",
		"stroke-linejoin",
		"stroke-miterlimit",
		"stroke-opacity",
		"stroke-width",
		"id",
		"paint-order",
		"vector-effect",
		"instantiated_by_use",
		"clip-path"
	], x.DPI = 96, x.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", x.commaWsp = "(?:\\s+,?\\s*|,\\s*)", x.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi, x.reNonWord = /[ \n\.,;!\?\-]/, x.fontPaths = {}, x.iMatrix = [
		1,
		0,
		0,
		1,
		0,
		0
	], x.svgNS = "http://www.w3.org/2000/svg", x.perfLimitSizeTotal = 2097152, x.maxCacheSideLimit = 4096, x.minCacheSideLimit = 256, x.charWidthsCache = {}, x.textureSize = 2048, x.disableStyleCopyPaste = !1, x.enableGLFiltering = !0, x.devicePixelRatio = x.window.devicePixelRatio || x.window.webkitDevicePixelRatio || x.window.mozDevicePixelRatio || 1, x.browserShadowBlurConstant = 1, x.arcToSegmentsCache = {}, x.boundsOfCurveCache = {}, x.cachesBoundsOfCurve = !0, x.forceGLPutImageData = !1, x.initFilterBackend = function() {
		if (x.enableGLFiltering && x.isWebglSupported && x.isWebglSupported(x.textureSize)) return console.log("max texture size: " + x.maxTextureSize), new x.WebglFilterBackend({ tileSize: x.textureSize });
		if (x.Canvas2dFilterBackend) return new x.Canvas2dFilterBackend();
	}, typeof document < "u" && typeof window < "u" && (window.fabric = x), (function() {
		function m(m, S) {
			if (this.__eventListeners[m]) {
				var C = this.__eventListeners[m];
				S ? C[C.indexOf(S)] = !1 : x.util.array.fill(C, !1);
			}
		}
		function S(m, x) {
			if (this.__eventListeners ||= {}, arguments.length === 1) for (var S in m) this.on(S, m[S]);
			else this.__eventListeners[m] || (this.__eventListeners[m] = []), this.__eventListeners[m].push(x);
			return this;
		}
		function C(m, x) {
			var S = function() {
				x.apply(this, arguments), this.off(m, S);
			}.bind(this);
			this.on(m, S);
		}
		function T(m, x) {
			if (arguments.length === 1) for (var S in m) C.call(this, S, m[S]);
			else C.call(this, m, x);
			return this;
		}
		function D(x, S) {
			if (!this.__eventListeners) return this;
			if (arguments.length === 0) for (x in this.__eventListeners) m.call(this, x);
			else if (arguments.length === 1 && typeof arguments[0] == "object") for (var C in x) m.call(this, C, x[C]);
			else m.call(this, x, S);
			return this;
		}
		function O(m, x) {
			if (!this.__eventListeners) return this;
			var S = this.__eventListeners[m];
			if (!S) return this;
			for (var C = 0, T = S.length; C < T; C++) S[C] && S[C].call(this, x || {});
			return this.__eventListeners[m] = S.filter(function(m) {
				return m !== !1;
			}), this;
		}
		x.Observable = {
			fire: O,
			on: S,
			once: T,
			off: D
		};
	})(), x.Collection = {
		_objects: [],
		add: function() {
			if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var m = 0, x = arguments.length; m < x; m++) this._onObjectAdded(arguments[m]);
			return this.renderOnAddRemove && this.requestRenderAll(), this;
		},
		insertAt: function(m, x, S) {
			var C = this._objects;
			return S ? C[x] = m : C.splice(x, 0, m), this._onObjectAdded && this._onObjectAdded(m), this.renderOnAddRemove && this.requestRenderAll(), this;
		},
		remove: function() {
			for (var m = this._objects, x, S = !1, C = 0, T = arguments.length; C < T; C++) x = m.indexOf(arguments[C]), x !== -1 && (S = !0, m.splice(x, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[C]));
			return this.renderOnAddRemove && S && this.requestRenderAll(), this;
		},
		forEachObject: function(m, x) {
			for (var S = this.getObjects(), C = 0, T = S.length; C < T; C++) m.call(x, S[C], C, S);
			return this;
		},
		getObjects: function(m) {
			return m === void 0 ? this._objects.concat() : this._objects.filter(function(x) {
				return x.type === m;
			});
		},
		item: function(m) {
			return this._objects[m];
		},
		isEmpty: function() {
			return this._objects.length === 0;
		},
		size: function() {
			return this._objects.length;
		},
		contains: function(m, x) {
			return this._objects.indexOf(m) > -1 ? !0 : x ? this._objects.some(function(x) {
				return typeof x.contains == "function" && x.contains(m, !0);
			}) : !1;
		},
		complexity: function() {
			return this._objects.reduce(function(m, x) {
				return m += x.complexity ? x.complexity() : 0, m;
			}, 0);
		}
	}, x.CommonMethods = {
		_setOptions: function(m) {
			for (var x in m) this.set(x, m[x]);
		},
		_initGradient: function(m, S) {
			m && m.colorStops && !(m instanceof x.Gradient) && this.set(S, new x.Gradient(m));
		},
		_initPattern: function(m, S, C) {
			m && m.source && !(m instanceof x.Pattern) ? this.set(S, new x.Pattern(m, C)) : C && C();
		},
		_setObject: function(m) {
			for (var x in m) this._set(x, m[x]);
		},
		set: function(m, x) {
			return typeof m == "object" ? this._setObject(m) : this._set(m, x), this;
		},
		_set: function(m, x) {
			this[m] = x;
		},
		toggle: function(m) {
			var x = this.get(m);
			return typeof x == "boolean" && this.set(m, !x), this;
		},
		get: function(m) {
			return this[m];
		}
	}, (function(m) {
		var S = Math.sqrt, C = Math.atan2, T = Math.pow, D = Math.PI / 180, O = Math.PI / 2;
		x.util = {
			cos: function(m) {
				if (m === 0) return 1;
				switch (m < 0 && (m = -m), m / O) {
					case 1:
					case 3: return 0;
					case 2: return -1;
				}
				return Math.cos(m);
			},
			sin: function(m) {
				if (m === 0) return 0;
				var x = m / O, S = 1;
				switch (m < 0 && (S = -1), x) {
					case 1: return S;
					case 2: return 0;
					case 3: return -S;
				}
				return Math.sin(m);
			},
			removeFromArray: function(m, x) {
				var S = m.indexOf(x);
				return S !== -1 && m.splice(S, 1), m;
			},
			getRandomInt: function(m, x) {
				return Math.floor(Math.random() * (x - m + 1)) + m;
			},
			degreesToRadians: function(m) {
				return m * D;
			},
			radiansToDegrees: function(m) {
				return m / D;
			},
			rotatePoint: function(m, S, C) {
				var T = new x.Point(m.x - S.x, m.y - S.y), D = x.util.rotateVector(T, C);
				return new x.Point(D.x, D.y).addEquals(S);
			},
			rotateVector: function(m, S) {
				var C = x.util.sin(S), T = x.util.cos(S);
				return {
					x: m.x * T - m.y * C,
					y: m.x * C + m.y * T
				};
			},
			createVector: function(m, S) {
				return new x.Point(S.x - m.x, S.y - m.y);
			},
			calcAngleBetweenVectors: function(m, x) {
				return Math.acos((m.x * x.x + m.y * x.y) / (Math.hypot(m.x, m.y) * Math.hypot(x.x, x.y)));
			},
			getHatVector: function(m) {
				return new x.Point(m.x, m.y).multiply(1 / Math.hypot(m.x, m.y));
			},
			getBisector: function(m, S, C) {
				var T = x.util.createVector(m, S), D = x.util.createVector(m, C), O = x.util.calcAngleBetweenVectors(T, D), k = O * (x.util.calcAngleBetweenVectors(x.util.rotateVector(T, O), D) === 0 ? 1 : -1) / 2;
				return {
					vector: x.util.getHatVector(x.util.rotateVector(T, k)),
					angle: O
				};
			},
			projectStrokeOnPoints: function(m, S, C) {
				var T = [], D = S.strokeWidth / 2, O = S.strokeUniform ? new x.Point(1 / S.scaleX, 1 / S.scaleY) : new x.Point(1, 1), k = function(m) {
					var S = D / Math.hypot(m.x, m.y);
					return new x.Point(m.x * S * O.x, m.y * S * O.y);
				};
				return m.length <= 1 || m.forEach(function(A, j) {
					var M = new x.Point(A.x, A.y), N, P;
					j === 0 ? (P = m[j + 1], N = C ? k(x.util.createVector(P, M)).addEquals(M) : m[m.length - 1]) : j === m.length - 1 ? (N = m[j - 1], P = C ? k(x.util.createVector(N, M)).addEquals(M) : m[0]) : (N = m[j - 1], P = m[j + 1]);
					var F = x.util.getBisector(M, N, P), I = F.vector, L = F.angle, R, z;
					if (S.strokeLineJoin === "miter" && (R = -D / Math.sin(L / 2), z = new x.Point(I.x * R * O.x, I.y * R * O.y), Math.hypot(z.x, z.y) / D <= S.strokeMiterLimit)) {
						T.push(M.add(z)), T.push(M.subtract(z));
						return;
					}
					R = -D * Math.SQRT2, z = new x.Point(I.x * R * O.x, I.y * R * O.y), T.push(M.add(z)), T.push(M.subtract(z));
				}), T;
			},
			transformPoint: function(m, S, C) {
				return C ? new x.Point(S[0] * m.x + S[2] * m.y, S[1] * m.x + S[3] * m.y) : new x.Point(S[0] * m.x + S[2] * m.y + S[4], S[1] * m.x + S[3] * m.y + S[5]);
			},
			makeBoundingBoxFromPoints: function(m, S) {
				if (S) for (var C = 0; C < m.length; C++) m[C] = x.util.transformPoint(m[C], S);
				var T = [
					m[0].x,
					m[1].x,
					m[2].x,
					m[3].x
				], D = x.util.array.min(T), O = x.util.array.max(T) - D, k = [
					m[0].y,
					m[1].y,
					m[2].y,
					m[3].y
				], A = x.util.array.min(k);
				return {
					left: D,
					top: A,
					width: O,
					height: x.util.array.max(k) - A
				};
			},
			invertTransform: function(m) {
				var S = 1 / (m[0] * m[3] - m[1] * m[2]), C = [
					S * m[3],
					-S * m[1],
					-S * m[2],
					S * m[0]
				], T = x.util.transformPoint({
					x: m[4],
					y: m[5]
				}, C, !0);
				return C[4] = -T.x, C[5] = -T.y, C;
			},
			toFixed: function(m, x) {
				return parseFloat(Number(m).toFixed(x));
			},
			parseUnit: function(m, S) {
				var C = /\D{0,2}$/.exec(m), T = parseFloat(m);
				switch (S ||= x.Text.DEFAULT_SVG_FONT_SIZE, C[0]) {
					case "mm": return T * x.DPI / 25.4;
					case "cm": return T * x.DPI / 2.54;
					case "in": return T * x.DPI;
					case "pt": return T * x.DPI / 72;
					case "pc": return T * x.DPI / 72 * 12;
					case "em": return T * S;
					default: return T;
				}
			},
			falseFunction: function() {
				return !1;
			},
			getKlass: function(m, S) {
				return m = x.util.string.camelize(m.charAt(0).toUpperCase() + m.slice(1)), x.util.resolveNamespace(S)[m];
			},
			getSvgAttributes: function(m) {
				var x = [
					"instantiated_by_use",
					"style",
					"id",
					"class"
				];
				switch (m) {
					case "linearGradient":
						x = x.concat([
							"x1",
							"y1",
							"x2",
							"y2",
							"gradientUnits",
							"gradientTransform"
						]);
						break;
					case "radialGradient":
						x = x.concat([
							"gradientUnits",
							"gradientTransform",
							"cx",
							"cy",
							"r",
							"fx",
							"fy",
							"fr"
						]);
						break;
					case "stop":
						x = x.concat([
							"offset",
							"stop-color",
							"stop-opacity"
						]);
						break;
				}
				return x;
			},
			resolveNamespace: function(S) {
				if (!S) return x;
				var C = S.split("."), T = C.length, D, O = m || x.window;
				for (D = 0; D < T; ++D) O = O[C[D]];
				return O;
			},
			loadImage: function(m, S, C, T) {
				if (!m) {
					S && S.call(C, m);
					return;
				}
				var D = x.util.createImage(), O = function() {
					S && S.call(C, D, !1), D = D.onload = D.onerror = null;
				};
				D.onload = O, D.onerror = function() {
					x.log("Error loading " + D.src), S && S.call(C, null, !0), D = D.onload = D.onerror = null;
				}, m.indexOf("data") !== 0 && T != null && (D.crossOrigin = T), m.substring(0, 14) === "data:image/svg" && (D.onload = null, x.util.loadImageInDom(D, O)), D.src = m;
			},
			loadImageInDom: function(m, S) {
				var C = x.document.createElement("div");
				C.style.width = C.style.height = "1px", C.style.left = C.style.top = "-100%", C.style.position = "absolute", C.appendChild(m), x.document.querySelector("body").appendChild(C), m.onload = function() {
					S(), C.parentNode.removeChild(C), C = null;
				};
			},
			enlivenObjects: function(m, S, C, T) {
				m ||= [];
				var D = [], O = 0, k = m.length;
				function A() {
					++O === k && S && S(D.filter(function(m) {
						return m;
					}));
				}
				if (!k) {
					S && S(D);
					return;
				}
				m.forEach(function(m, S) {
					if (!m || !m.type) {
						A();
						return;
					}
					x.util.getKlass(m.type, C).fromObject(m, function(x, C) {
						C || (D[S] = x), T && T(m, x, C), A();
					});
				});
			},
			enlivenObjectEnlivables: function(m, S, C) {
				var T = x.Object.ENLIVEN_PROPS.filter(function(x) {
					return !!m[x];
				});
				x.util.enlivenObjects(T.map(function(x) {
					return m[x];
				}), function(m) {
					var x = {};
					T.forEach(function(C, T) {
						x[C] = m[T], S && (S[C] = m[T]);
					}), C && C(x);
				});
			},
			enlivenPatterns: function(m, S) {
				m ||= [];
				function C() {
					++D === O && S && S(T);
				}
				var T = [], D = 0, O = m.length;
				if (!O) {
					S && S(T);
					return;
				}
				m.forEach(function(m, S) {
					m && m.source ? new x.Pattern(m, function(m) {
						T[S] = m, C();
					}) : (T[S] = m, C());
				});
			},
			groupSVGElements: function(m, S, C) {
				var T;
				return m && m.length === 1 ? (C !== void 0 && (m[0].sourcePath = C), m[0]) : (S && (S.width && S.height ? S.centerPoint = {
					x: S.width / 2,
					y: S.height / 2
				} : (delete S.width, delete S.height)), T = new x.Group(m, S), C !== void 0 && (T.sourcePath = C), T);
			},
			populateWithProperties: function(m, x, S) {
				if (S && Array.isArray(S)) for (var C = 0, T = S.length; C < T; C++) S[C] in m && (x[S[C]] = m[S[C]]);
			},
			createCanvasElement: function() {
				return x.document.createElement("canvas");
			},
			copyCanvasElement: function(m) {
				var S = x.util.createCanvasElement();
				return S.width = m.width, S.height = m.height, S.getContext("2d").drawImage(m, 0, 0), S;
			},
			toDataURL: function(m, x, S) {
				return m.toDataURL("image/" + x, S);
			},
			createImage: function() {
				return x.document.createElement("img");
			},
			multiplyTransformMatrices: function(m, x, S) {
				return [
					m[0] * x[0] + m[2] * x[1],
					m[1] * x[0] + m[3] * x[1],
					m[0] * x[2] + m[2] * x[3],
					m[1] * x[2] + m[3] * x[3],
					S ? 0 : m[0] * x[4] + m[2] * x[5] + m[4],
					S ? 0 : m[1] * x[4] + m[3] * x[5] + m[5]
				];
			},
			qrDecompose: function(m) {
				var x = C(m[1], m[0]), O = T(m[0], 2) + T(m[1], 2), k = S(O), A = (m[0] * m[3] - m[2] * m[1]) / k, j = C(m[0] * m[2] + m[1] * m[3], O);
				return {
					angle: x / D,
					scaleX: k,
					scaleY: A,
					skewX: j / D,
					skewY: 0,
					translateX: m[4],
					translateY: m[5]
				};
			},
			calcRotateMatrix: function(m) {
				if (!m.angle) return x.iMatrix.concat();
				var S = x.util.degreesToRadians(m.angle), C = x.util.cos(S), T = x.util.sin(S);
				return [
					C,
					T,
					-T,
					C,
					0,
					0
				];
			},
			calcDimensionsMatrix: function(m) {
				var S = m.scaleX === void 0 ? 1 : m.scaleX, C = m.scaleY === void 0 ? 1 : m.scaleY, T = [
					m.flipX ? -S : S,
					0,
					0,
					m.flipY ? -C : C,
					0,
					0
				], D = x.util.multiplyTransformMatrices, O = x.util.degreesToRadians;
				return m.skewX && (T = D(T, [
					1,
					0,
					Math.tan(O(m.skewX)),
					1
				], !0)), m.skewY && (T = D(T, [
					1,
					Math.tan(O(m.skewY)),
					0,
					1
				], !0)), T;
			},
			composeMatrix: function(m) {
				var S = [
					1,
					0,
					0,
					1,
					m.translateX || 0,
					m.translateY || 0
				], C = x.util.multiplyTransformMatrices;
				return m.angle && (S = C(S, x.util.calcRotateMatrix(m))), (m.scaleX !== 1 || m.scaleY !== 1 || m.skewX || m.skewY || m.flipX || m.flipY) && (S = C(S, x.util.calcDimensionsMatrix(m))), S;
			},
			resetObjectTransform: function(m) {
				m.scaleX = 1, m.scaleY = 1, m.skewX = 0, m.skewY = 0, m.flipX = !1, m.flipY = !1, m.rotate(0);
			},
			saveObjectTransform: function(m) {
				return {
					scaleX: m.scaleX,
					scaleY: m.scaleY,
					skewX: m.skewX,
					skewY: m.skewY,
					angle: m.angle,
					left: m.left,
					flipX: m.flipX,
					flipY: m.flipY,
					top: m.top
				};
			},
			isTransparent: function(m, x, S, C) {
				C > 0 && (x > C ? x -= C : x = 0, S > C ? S -= C : S = 0);
				var T = !0, D, O, k = m.getImageData(x, S, C * 2 || 1, C * 2 || 1), A = k.data.length;
				for (D = 3; D < A && (O = k.data[D], T = O <= 0, T !== !1); D += 4);
				return k = null, T;
			},
			parsePreserveAspectRatioAttribute: function(m) {
				var x = "meet", S = "Mid", C = "Mid", T = m.split(" "), D;
				return T && T.length && (x = T.pop(), x !== "meet" && x !== "slice" ? (D = x, x = "meet") : T.length && (D = T.pop())), S = D === "none" ? "none" : D.slice(1, 4), C = D === "none" ? "none" : D.slice(5, 8), {
					meetOrSlice: x,
					alignX: S,
					alignY: C
				};
			},
			clearFabricFontCache: function(m) {
				m = (m || "").toLowerCase(), m ? x.charWidthsCache[m] && delete x.charWidthsCache[m] : x.charWidthsCache = {};
			},
			limitDimsByArea: function(m, x) {
				var S = Math.sqrt(x * m), C = Math.floor(x / S);
				return {
					x: Math.floor(S),
					y: C
				};
			},
			capValue: function(m, x, S) {
				return Math.max(m, Math.min(x, S));
			},
			findScaleToFit: function(m, x) {
				return Math.min(x.width / m.width, x.height / m.height);
			},
			findScaleToCover: function(m, x) {
				return Math.max(x.width / m.width, x.height / m.height);
			},
			matrixToSVG: function(m) {
				return "matrix(" + m.map(function(m) {
					return x.util.toFixed(m, x.Object.NUM_FRACTION_DIGITS);
				}).join(" ") + ")";
			},
			removeTransformFromObject: function(m, S) {
				var C = x.util.invertTransform(S), T = x.util.multiplyTransformMatrices(C, m.calcOwnMatrix());
				x.util.applyTransformToObject(m, T);
			},
			addTransformToObject: function(m, S) {
				x.util.applyTransformToObject(m, x.util.multiplyTransformMatrices(S, m.calcOwnMatrix()));
			},
			applyTransformToObject: function(m, S) {
				var C = x.util.qrDecompose(S), T = new x.Point(C.translateX, C.translateY);
				m.flipX = !1, m.flipY = !1, m.set("scaleX", C.scaleX), m.set("scaleY", C.scaleY), m.skewX = C.skewX, m.skewY = C.skewY, m.angle = C.angle, m.setPositionByOrigin(T, "center", "center");
			},
			sizeAfterTransform: function(m, S, C) {
				var T = m / 2, D = S / 2, O = [
					{
						x: -T,
						y: -D
					},
					{
						x: T,
						y: -D
					},
					{
						x: -T,
						y: D
					},
					{
						x: T,
						y: D
					}
				], k = x.util.calcDimensionsMatrix(C), A = x.util.makeBoundingBoxFromPoints(O, k);
				return {
					x: A.width,
					y: A.height
				};
			},
			mergeClipPaths: function(m, S) {
				var C = m, T = S;
				C.inverted && !T.inverted && (C = S, T = m), x.util.applyTransformToObject(T, x.util.multiplyTransformMatrices(x.util.invertTransform(C.calcTransformMatrix()), T.calcTransformMatrix()));
				var D = C.inverted && T.inverted;
				return D && (C.inverted = T.inverted = !1), new x.Group([C], {
					clipPath: T,
					inverted: D
				});
			},
			hasStyleChanged: function(m, x, S) {
				return S ||= !1, m.fill !== x.fill || m.stroke !== x.stroke || m.strokeWidth !== x.strokeWidth || m.fontSize !== x.fontSize || m.fontFamily !== x.fontFamily || m.fontWeight !== x.fontWeight || m.fontStyle !== x.fontStyle || m.textBackgroundColor !== x.textBackgroundColor || m.deltaY !== x.deltaY || S && (m.overline !== x.overline || m.underline !== x.underline || m.linethrough !== x.linethrough);
			},
			stylesToArray: function(m, S) {
				for (var m = x.util.object.clone(m, !0), C = S.split("\n"), T = -1, D = {}, O = [], k = 0; k < C.length; k++) {
					if (!m[k]) {
						T += C[k].length;
						continue;
					}
					for (var A = 0; A < C[k].length; A++) {
						T++;
						var j = m[k][A];
						j && Object.keys(j).length > 0 && (x.util.hasStyleChanged(D, j, !0) ? O.push({
							start: T,
							end: T + 1,
							style: j
						}) : O[O.length - 1].end++), D = j || {};
					}
				}
				return O;
			},
			stylesFromArray: function(m, x) {
				if (!Array.isArray(m)) return m;
				for (var S = x.split("\n"), C = -1, T = 0, D = {}, O = 0; O < S.length; O++) for (var k = 0; k < S[O].length; k++) C++, m[T] && m[T].start <= C && C < m[T].end && (D[O] = D[O] || {}, D[O][k] = Object.assign({}, m[T].style), C === m[T].end - 1 && T++);
				return D;
			}
		};
	})(m), (function() {
		var m = Array.prototype.join, S = {
			m: 2,
			l: 2,
			h: 1,
			v: 1,
			c: 6,
			s: 4,
			q: 4,
			t: 2,
			a: 7
		}, C = {
			m: "l",
			M: "L"
		};
		function T(m, S, C, T, D, O, k, A, j, M, N) {
			var P = x.util.cos(m), F = x.util.sin(m), I = x.util.cos(S), L = x.util.sin(S), R = C * D * I - T * O * L + k, z = T * D * I + C * O * L + A;
			return [
				"C",
				M + j * (-C * D * F - T * O * P),
				N + j * (-T * D * F + C * O * P),
				R + j * (C * D * L + T * O * I),
				z + j * (T * D * L - C * O * I),
				R,
				z
			];
		}
		function D(m, S, C, D, k, A, j) {
			var M = Math.PI, N = j * M / 180, P = x.util.sin(N), F = x.util.cos(N), I = 0, L = 0;
			C = Math.abs(C), D = Math.abs(D);
			var R = -F * m * .5 - P * S * .5, z = -F * S * .5 + P * m * .5, B = C * C, H = D * D, U = z * z, W = R * R, G = B * H - B * U - H * W, K = 0;
			if (G < 0) {
				var q = Math.sqrt(1 - G / (B * H));
				C *= q, D *= q;
			} else K = (k === A ? -1 : 1) * Math.sqrt(G / (B * U + H * W));
			var J = K * C * z / D, Y = -K * D * R / C, X = F * J - P * Y + m * .5, Z = P * J + F * Y + S * .5, sH = O(1, 0, (R - J) / C, (z - Y) / D), Q = O((R - J) / C, (z - Y) / D, (-R - J) / C, (-z - Y) / D);
			A === 0 && Q > 0 ? Q -= 2 * M : A === 1 && Q < 0 && (Q += 2 * M);
			for (var cH = Math.ceil(Math.abs(Q / M * 2)), lH = [], uH = Q / cH, dH = 8 / 3 * Math.sin(uH / 4) * Math.sin(uH / 4) / Math.sin(uH / 2), fH = sH + uH, pH = 0; pH < cH; pH++) lH[pH] = T(sH, fH, F, P, C, D, X, Z, dH, I, L), I = lH[pH][5], L = lH[pH][6], sH = fH, fH += uH;
			return lH;
		}
		function O(m, x, S, C) {
			var T = Math.atan2(x, m), D = Math.atan2(C, S);
			return D >= T ? D - T : 2 * Math.PI - (T - D);
		}
		function k(S, C, T, D, O, k, A, j) {
			var M;
			if (x.cachesBoundsOfCurve && (M = m.call(arguments), x.boundsOfCurveCache[M])) return x.boundsOfCurveCache[M];
			var N = Math.sqrt, P = Math.min, F = Math.max, I = Math.abs, L = [], R = [[], []], z, B = 6 * S - 12 * T + 6 * O, H, U, W, G, K, q;
			z = -3 * S + 9 * T - 9 * O + 3 * A, H = 3 * T - 3 * S;
			for (var J = 0; J < 2; ++J) {
				if (J > 0 && (B = 6 * C - 12 * D + 6 * k, z = -3 * C + 9 * D - 9 * k + 3 * j, H = 3 * D - 3 * C), I(z) < 1e-12) {
					if (I(B) < 1e-12) continue;
					U = -H / B, 0 < U && U < 1 && L.push(U);
					continue;
				}
				K = B * B - 4 * H * z, !(K < 0) && (q = N(K), W = (-B + q) / (2 * z), 0 < W && W < 1 && L.push(W), G = (-B - q) / (2 * z), 0 < G && G < 1 && L.push(G));
			}
			for (var Y, X, Z = L.length, sH = Z, Q; Z--;) U = L[Z], Q = 1 - U, Y = Q * Q * Q * S + 3 * Q * Q * U * T + 3 * Q * U * U * O + U * U * U * A, R[0][Z] = Y, X = Q * Q * Q * C + 3 * Q * Q * U * D + 3 * Q * U * U * k + U * U * U * j, R[1][Z] = X;
			R[0][sH] = S, R[1][sH] = C, R[0][sH + 1] = A, R[1][sH + 1] = j;
			var cH = [{
				x: P.apply(null, R[0]),
				y: P.apply(null, R[1])
			}, {
				x: F.apply(null, R[0]),
				y: F.apply(null, R[1])
			}];
			return x.cachesBoundsOfCurve && (x.boundsOfCurveCache[M] = cH), cH;
		}
		function A(m, x, S) {
			for (var C = S[1], T = S[2], O = S[3], k = S[4], A = S[5], j = S[6], M = S[7], N = D(j - m, M - x, C, T, k, A, O), P = 0, F = N.length; P < F; P++) N[P][1] += m, N[P][2] += x, N[P][3] += m, N[P][4] += x, N[P][5] += m, N[P][6] += x;
			return N;
		}
		function j(m) {
			var x = 0, S = 0, C = m.length, T = 0, D = 0, O, k, j, M = [], N, P, F;
			for (k = 0; k < C; ++k) {
				switch (j = !1, O = m[k].slice(0), O[0]) {
					case "l": O[0] = "L", O[1] += x, O[2] += S;
					case "L":
						x = O[1], S = O[2];
						break;
					case "h": O[1] += x;
					case "H":
						O[0] = "L", O[2] = S, x = O[1];
						break;
					case "v": O[1] += S;
					case "V":
						O[0] = "L", S = O[1], O[1] = x, O[2] = S;
						break;
					case "m": O[0] = "M", O[1] += x, O[2] += S;
					case "M":
						x = O[1], S = O[2], T = O[1], D = O[2];
						break;
					case "c": O[0] = "C", O[1] += x, O[2] += S, O[3] += x, O[4] += S, O[5] += x, O[6] += S;
					case "C":
						P = O[3], F = O[4], x = O[5], S = O[6];
						break;
					case "s": O[0] = "S", O[1] += x, O[2] += S, O[3] += x, O[4] += S;
					case "S":
						N === "C" ? (P = 2 * x - P, F = 2 * S - F) : (P = x, F = S), x = O[3], S = O[4], O[0] = "C", O[5] = O[3], O[6] = O[4], O[3] = O[1], O[4] = O[2], O[1] = P, O[2] = F, P = O[3], F = O[4];
						break;
					case "q": O[0] = "Q", O[1] += x, O[2] += S, O[3] += x, O[4] += S;
					case "Q":
						P = O[1], F = O[2], x = O[3], S = O[4];
						break;
					case "t": O[0] = "T", O[1] += x, O[2] += S;
					case "T":
						N === "Q" ? (P = 2 * x - P, F = 2 * S - F) : (P = x, F = S), O[0] = "Q", x = O[1], S = O[2], O[1] = P, O[2] = F, O[3] = x, O[4] = S;
						break;
					case "a": O[0] = "A", O[6] += x, O[7] += S;
					case "A":
						j = !0, M = M.concat(A(x, S, O)), x = O[6], S = O[7];
						break;
					case "z":
					case "Z":
						x = T, S = D;
						break;
					default:
				}
				j || M.push(O), N = O[0];
			}
			return M;
		}
		function M(m, x, S, C) {
			return Math.sqrt((S - m) * (S - m) + (C - x) * (C - x));
		}
		function N(m) {
			return m * m * m;
		}
		function P(m) {
			return 3 * m * m * (1 - m);
		}
		function F(m) {
			return 3 * m * (1 - m) * (1 - m);
		}
		function I(m) {
			return (1 - m) * (1 - m) * (1 - m);
		}
		function L(m, x, S, C, T, D, O, k) {
			return function(A) {
				var j = N(A), M = P(A), L = F(A), R = I(A);
				return {
					x: O * j + T * M + S * L + m * R,
					y: k * j + D * M + C * L + x * R
				};
			};
		}
		function R(m, x, S, C, T, D, O, k) {
			return function(A) {
				var j = 1 - A, M = 3 * j * j * (S - m) + 6 * j * A * (T - S) + 3 * A * A * (O - T), N = 3 * j * j * (C - x) + 6 * j * A * (D - C) + 3 * A * A * (k - D);
				return Math.atan2(N, M);
			};
		}
		function z(m) {
			return m * m;
		}
		function B(m) {
			return 2 * m * (1 - m);
		}
		function H(m) {
			return (1 - m) * (1 - m);
		}
		function U(m, x, S, C, T, D) {
			return function(O) {
				var k = z(O), A = B(O), j = H(O);
				return {
					x: T * k + S * A + m * j,
					y: D * k + C * A + x * j
				};
			};
		}
		function W(m, x, S, C, T, D) {
			return function(O) {
				var k = 1 - O, A = 2 * k * (S - m) + 2 * O * (T - S), j = 2 * k * (C - x) + 2 * O * (D - C);
				return Math.atan2(j, A);
			};
		}
		function G(m, x, S) {
			var C = {
				x,
				y: S
			}, T, D = 0, O;
			for (O = 1; O <= 100; O += 1) T = m(O / 100), D += M(C.x, C.y, T.x, T.y), C = T;
			return D;
		}
		function K(m, x) {
			for (var S = 0, C = 0, T = m.iterator, D = {
				x: m.x,
				y: m.y
			}, O, k, A = .01, j = m.angleFinder, N; C < x && A > 1e-4;) O = T(S), N = S, k = M(D.x, D.y, O.x, O.y), k + C > x ? (S -= A, A /= 2) : (D = O, S += A, C += k);
			return O.angle = j(N), O;
		}
		function q(m) {
			for (var x = 0, S = m.length, C, T = 0, D = 0, O = 0, k = 0, A = [], j, N, P, F = 0; F < S; F++) {
				switch (C = m[F], N = {
					x: T,
					y: D,
					command: C[0]
				}, C[0]) {
					case "M":
						N.length = 0, O = T = C[1], k = D = C[2];
						break;
					case "L":
						N.length = M(T, D, C[1], C[2]), T = C[1], D = C[2];
						break;
					case "C":
						j = L(T, D, C[1], C[2], C[3], C[4], C[5], C[6]), P = R(T, D, C[1], C[2], C[3], C[4], C[5], C[6]), N.iterator = j, N.angleFinder = P, N.length = G(j, T, D), T = C[5], D = C[6];
						break;
					case "Q":
						j = U(T, D, C[1], C[2], C[3], C[4]), P = W(T, D, C[1], C[2], C[3], C[4]), N.iterator = j, N.angleFinder = P, N.length = G(j, T, D), T = C[3], D = C[4];
						break;
					case "Z":
					case "z":
						N.destX = O, N.destY = k, N.length = M(T, D, O, k), T = O, D = k;
						break;
				}
				x += N.length, A.push(N);
			}
			return A.push({
				length: x,
				x: T,
				y: D
			}), A;
		}
		function J(m, S, C) {
			C ||= q(m);
			for (var T = 0; S - C[T].length > 0 && T < C.length - 2;) S -= C[T].length, T++;
			var D = C[T], O = S / D.length, k = D.command, A = m[T], j;
			switch (k) {
				case "M": return {
					x: D.x,
					y: D.y,
					angle: 0
				};
				case "Z":
				case "z": return j = new x.Point(D.x, D.y).lerp(new x.Point(D.destX, D.destY), O), j.angle = Math.atan2(D.destY - D.y, D.destX - D.x), j;
				case "L": return j = new x.Point(D.x, D.y).lerp(new x.Point(A[1], A[2]), O), j.angle = Math.atan2(A[2] - D.y, A[1] - D.x), j;
				case "C": return K(D, S);
				case "Q": return K(D, S);
			}
		}
		function Y(m) {
			var T = [], D = [], O, k, A = x.rePathCommand, j = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", M = "(" + j + ")" + x.commaWsp, N = "([01])" + x.commaWsp + "?", P = M + "?" + M + "?" + M + N + N + M + "?(" + j + ")", F = new RegExp(P, "g"), I, L, R;
			if (!m || !m.match) return T;
			R = m.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
			for (var z = 0, B, H = R.length; z < H; z++) {
				O = R[z], L = O.slice(1).trim(), D.length = 0;
				var U = O.charAt(0);
				if (B = [U], U.toLowerCase() === "a") for (var W; W = F.exec(L);) for (var G = 1; G < W.length; G++) D.push(W[G]);
				else for (; I = A.exec(L);) D.push(I[0]);
				for (var G = 0, K = D.length; G < K; G++) k = parseFloat(D[G]), isNaN(k) || B.push(k);
				var q = S[U.toLowerCase()], J = C[U] || U;
				if (B.length - 1 > q) for (var Y = 1, X = B.length; Y < X; Y += q) T.push([U].concat(B.slice(Y, Y + q))), U = J;
				else T.push(B);
			}
			return T;
		}
		function X(m, S) {
			var C = [], T, D = new x.Point(m[0].x, m[0].y), O = new x.Point(m[1].x, m[1].y), k = m.length, A = 1, j = 0, M = k > 2;
			for (S ||= 0, M && (A = m[2].x < O.x ? -1 : m[2].x === O.x ? 0 : 1, j = m[2].y < O.y ? -1 : m[2].y === O.y ? 0 : 1), C.push([
				"M",
				D.x - A * S,
				D.y - j * S
			]), T = 1; T < k; T++) {
				if (!D.eq(O)) {
					var N = D.midPointFrom(O);
					C.push([
						"Q",
						D.x,
						D.y,
						N.x,
						N.y
					]);
				}
				D = m[T], T + 1 < m.length && (O = m[T + 1]);
			}
			return M && (A = D.x > m[T - 2].x ? 1 : D.x === m[T - 2].x ? 0 : -1, j = D.y > m[T - 2].y ? 1 : D.y === m[T - 2].y ? 0 : -1), C.push([
				"L",
				D.x + A * S,
				D.y + j * S
			]), C;
		}
		function Z(m, S, C) {
			return C && (S = x.util.multiplyTransformMatrices(S, [
				1,
				0,
				0,
				1,
				-C.x,
				-C.y
			])), m.map(function(m) {
				for (var C = m.slice(0), T = {}, D = 1; D < m.length - 1; D += 2) T.x = m[D], T.y = m[D + 1], T = x.util.transformPoint(T, S), C[D] = T.x, C[D + 1] = T.y;
				return C;
			});
		}
		x.util.joinPath = function(m) {
			return m.map(function(m) {
				return m.join(" ");
			}).join(" ");
		}, x.util.parsePath = Y, x.util.makePathSimpler = j, x.util.getSmoothPathFromPoints = X, x.util.getPathSegmentsInfo = q, x.util.getBoundsOfCurve = k, x.util.getPointOnPath = J, x.util.transformPath = Z;
	})(), (function() {
		var m = Array.prototype.slice;
		function S(x, S) {
			for (var C = m.call(arguments, 2), T = [], D = 0, O = x.length; D < O; D++) T[D] = C.length ? x[D][S].apply(x[D], C) : x[D][S].call(x[D]);
			return T;
		}
		function C(m, x) {
			return O(m, x, function(m, x) {
				return m >= x;
			});
		}
		function T(m, x) {
			return O(m, x, function(m, x) {
				return m < x;
			});
		}
		function D(m, x) {
			for (var S = m.length; S--;) m[S] = x;
			return m;
		}
		function O(m, x, S) {
			if (!(!m || m.length === 0)) {
				var C = m.length - 1, T = x ? m[C][x] : m[C];
				if (x) for (; C--;) S(m[C][x], T) && (T = m[C][x]);
				else for (; C--;) S(m[C], T) && (T = m[C]);
				return T;
			}
		}
		x.util.array = {
			fill: D,
			invoke: S,
			min: T,
			max: C
		};
	})(), (function() {
		function m(S, C, T) {
			if (T) if (!x.isLikelyNode && C instanceof Element) S = C;
			else if (C instanceof Array) {
				S = [];
				for (var D = 0, O = C.length; D < O; D++) S[D] = m({}, C[D], T);
			} else if (C && typeof C == "object") for (var k in C) k === "canvas" || k === "group" ? S[k] = null : C.hasOwnProperty(k) && (S[k] = m({}, C[k], T));
			else S = C;
			else for (var k in C) S[k] = C[k];
			return S;
		}
		function S(x, S) {
			return m({}, x, S);
		}
		x.util.object = {
			extend: m,
			clone: S
		}, x.util.object.extend(x.util, x.Observable);
	})(), (function() {
		function m(m) {
			return m.replace(/-+(.)?/g, function(m, x) {
				return x ? x.toUpperCase() : "";
			});
		}
		function S(m, x) {
			return m.charAt(0).toUpperCase() + (x ? m.slice(1) : m.slice(1).toLowerCase());
		}
		function C(m) {
			return m.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
		}
		function T(m) {
			var x = 0, S, C = [];
			for (x = 0; x < m.length; x++) (S = D(m, x)) !== !1 && C.push(S);
			return C;
		}
		function D(m, x) {
			var S = m.charCodeAt(x);
			if (isNaN(S)) return "";
			if (S < 55296 || S > 57343) return m.charAt(x);
			if (55296 <= S && S <= 56319) {
				if (m.length <= x + 1) throw "High surrogate without following low surrogate";
				var C = m.charCodeAt(x + 1);
				if (56320 > C || C > 57343) throw "High surrogate without following low surrogate";
				return m.charAt(x) + m.charAt(x + 1);
			}
			if (x === 0) throw "Low surrogate without preceding high surrogate";
			var T = m.charCodeAt(x - 1);
			if (55296 > T || T > 56319) throw "Low surrogate without preceding high surrogate";
			return !1;
		}
		x.util.string = {
			camelize: m,
			capitalize: S,
			escapeXml: C,
			graphemeSplit: T
		};
	})(), (function() {
		var m = Array.prototype.slice, S = function() {}, C = (function() {
			for (var m in { toString: 1 }) if (m === "toString") return !1;
			return !0;
		})(), T = function(m, x, S) {
			for (var T in x) T in m.prototype && typeof m.prototype[T] == "function" && (x[T] + "").indexOf("callSuper") > -1 ? m.prototype[T] = (function(m) {
				return function() {
					var C = this.constructor.superclass;
					this.constructor.superclass = S;
					var T = x[m].apply(this, arguments);
					if (this.constructor.superclass = C, m !== "initialize") return T;
				};
			})(T) : m.prototype[T] = x[T], C && (x.toString !== Object.prototype.toString && (m.prototype.toString = x.toString), x.valueOf !== Object.prototype.valueOf && (m.prototype.valueOf = x.valueOf));
		};
		function D() {}
		function O(x) {
			for (var S = null, C = this; C.constructor.superclass;) {
				var T = C.constructor.superclass.prototype[x];
				if (C[x] !== T) {
					S = T;
					break;
				}
				C = C.constructor.superclass.prototype;
			}
			return S ? arguments.length > 1 ? S.apply(this, m.call(arguments, 1)) : S.call(this) : console.log("tried to callSuper " + x + ", method not found in prototype chain", this);
		}
		function k() {
			var x = null, C = m.call(arguments, 0);
			typeof C[0] == "function" && (x = C.shift());
			function k() {
				this.initialize.apply(this, arguments);
			}
			k.superclass = x, k.subclasses = [], x && (D.prototype = x.prototype, k.prototype = new D(), x.subclasses.push(k));
			for (var A = 0, j = C.length; A < j; A++) T(k, C[A], x);
			return k.prototype.initialize || (k.prototype.initialize = S), k.prototype.constructor = k, k.prototype.callSuper = O, k;
		}
		x.util.createClass = k;
	})(), (function() {
		var m = !!x.document.createElement("div").attachEvent, S = [
			"touchstart",
			"touchmove",
			"touchend"
		];
		x.util.addListener = function(x, S, C, T) {
			x && x.addEventListener(S, C, m ? !1 : T);
		}, x.util.removeListener = function(x, S, C, T) {
			x && x.removeEventListener(S, C, m ? !1 : T);
		};
		function C(m) {
			var x = m.changedTouches;
			return x && x[0] ? x[0] : m;
		}
		x.util.getPointer = function(m) {
			var S = m.target, T = x.util.getScrollLeftTop(S), D = C(m);
			return {
				x: D.clientX + T.left,
				y: D.clientY + T.top
			};
		}, x.util.isTouchEvent = function(m) {
			return S.indexOf(m.type) > -1 || m.pointerType === "touch";
		};
	})(), (function() {
		function m(m, x) {
			var S = m.style;
			if (!S) return m;
			if (typeof x == "string") return m.style.cssText += ";" + x, x.indexOf("opacity") > -1 ? O(m, x.match(/opacity:\s*(\d?\.?\d*)/)[1]) : m;
			for (var C in x) if (C === "opacity") O(m, x[C]);
			else {
				var T = C === "float" || C === "cssFloat" ? S.styleFloat === void 0 ? "cssFloat" : "styleFloat" : C;
				S.setProperty(T, x[C]);
			}
			return m;
		}
		var S = x.document.createElement("div"), C = typeof S.style.opacity == "string", T = typeof S.style.filter == "string", D = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, O = function(m) {
			return m;
		};
		C ? O = function(m, x) {
			return m.style.opacity = x, m;
		} : T && (O = function(m, x) {
			var S = m.style;
			return m.currentStyle && !m.currentStyle.hasLayout && (S.zoom = 1), D.test(S.filter) ? (x = x >= .9999 ? "" : "alpha(opacity=" + x * 100 + ")", S.filter = S.filter.replace(D, x)) : S.filter += " alpha(opacity=" + x * 100 + ")", m;
		}), x.util.setStyle = m;
	})(), (function() {
		var m = Array.prototype.slice;
		function S(m) {
			return typeof m == "string" ? x.document.getElementById(m) : m;
		}
		var C, T = function(x) {
			return m.call(x, 0);
		};
		try {
			C = T(x.document.childNodes) instanceof Array;
		} catch {}
		C || (T = function(m) {
			for (var x = Array(m.length), S = m.length; S--;) x[S] = m[S];
			return x;
		});
		function D(m, S) {
			var C = x.document.createElement(m);
			for (var T in S) T === "class" ? C.className = S[T] : T === "for" ? C.htmlFor = S[T] : C.setAttribute(T, S[T]);
			return C;
		}
		function O(m, x) {
			m && (" " + m.className + " ").indexOf(" " + x + " ") === -1 && (m.className += (m.className ? " " : "") + x);
		}
		function k(m, x, S) {
			return typeof x == "string" && (x = D(x, S)), m.parentNode && m.parentNode.replaceChild(x, m), x.appendChild(m), x;
		}
		function A(m) {
			for (var S = 0, C = 0, T = x.document.documentElement, D = x.document.body || {
				scrollLeft: 0,
				scrollTop: 0
			}; m && (m.parentNode || m.host) && (m = m.parentNode || m.host, m === x.document ? (S = D.scrollLeft || T.scrollLeft || 0, C = D.scrollTop || T.scrollTop || 0) : (S += m.scrollLeft || 0, C += m.scrollTop || 0), !(m.nodeType === 1 && m.style.position === "fixed")););
			return {
				left: S,
				top: C
			};
		}
		function j(m) {
			var x, S = m && m.ownerDocument, C = {
				left: 0,
				top: 0
			}, T = {
				left: 0,
				top: 0
			}, D, O = {
				borderLeftWidth: "left",
				borderTopWidth: "top",
				paddingLeft: "left",
				paddingTop: "top"
			};
			if (!S) return T;
			for (var k in O) T[O[k]] += parseInt(M(m, k), 10) || 0;
			return x = S.documentElement, m.getBoundingClientRect !== void 0 && (C = m.getBoundingClientRect()), D = A(m), {
				left: C.left + D.left - (x.clientLeft || 0) + T.left,
				top: C.top + D.top - (x.clientTop || 0) + T.top
			};
		}
		var M = x.document.defaultView && x.document.defaultView.getComputedStyle ? function(m, S) {
			var C = x.document.defaultView.getComputedStyle(m, null);
			return C ? C[S] : void 0;
		} : function(m, x) {
			var S = m.style[x];
			return !S && m.currentStyle && (S = m.currentStyle[x]), S;
		};
		(function() {
			var m = x.document.documentElement.style, S = "userSelect" in m ? "userSelect" : "MozUserSelect" in m ? "MozUserSelect" : "WebkitUserSelect" in m ? "WebkitUserSelect" : "KhtmlUserSelect" in m ? "KhtmlUserSelect" : "";
			function C(m) {
				return m.onselectstart !== void 0 && (m.onselectstart = x.util.falseFunction), S ? m.style[S] = "none" : typeof m.unselectable == "string" && (m.unselectable = "on"), m;
			}
			function T(m) {
				return m.onselectstart !== void 0 && (m.onselectstart = null), S ? m.style[S] = "" : typeof m.unselectable == "string" && (m.unselectable = ""), m;
			}
			x.util.makeElementUnselectable = C, x.util.makeElementSelectable = T;
		})();
		function N(m) {
			var S = x.jsdomImplForWrapper(m);
			return S._canvas || S._image;
		}
		function P(m) {
			if (x.isLikelyNode) {
				var S = x.jsdomImplForWrapper(m);
				S && (S._image = null, S._canvas = null, S._currentSrc = null, S._attributes = null, S._classList = null);
			}
		}
		function F(m, x) {
			m.imageSmoothingEnabled = m.imageSmoothingEnabled || m.webkitImageSmoothingEnabled || m.mozImageSmoothingEnabled || m.msImageSmoothingEnabled || m.oImageSmoothingEnabled, m.imageSmoothingEnabled = x;
		}
		x.util.setImageSmoothing = F, x.util.getById = S, x.util.toArray = T, x.util.addClass = O, x.util.makeElement = D, x.util.wrapElement = k, x.util.getScrollLeftTop = A, x.util.getElementOffset = j, x.util.getNodeCanvas = N, x.util.cleanUpJsdomNode = P;
	})(), (function() {
		function m(m, x) {
			return m + (/\?/.test(m) ? "&" : "?") + x;
		}
		function S() {}
		function C(C, T) {
			T ||= {};
			var D = T.method ? T.method.toUpperCase() : "GET", O = T.onComplete || function() {}, k = new x.window.XMLHttpRequest(), A = T.body || T.parameters;
			return k.onreadystatechange = function() {
				k.readyState === 4 && (O(k), k.onreadystatechange = S);
			}, D === "GET" && (A = null, typeof T.parameters == "string" && (C = m(C, T.parameters))), k.open(D, C, !0), (D === "POST" || D === "PUT") && k.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), k.send(A), k;
		}
		x.util.request = C;
	})(), x.log = console.log, x.warn = console.warn, (function() {
		var m = x.util.object.extend, S = x.util.object.clone, C = [];
		x.util.object.extend(C, {
			cancelAll: function() {
				var m = this.splice(0);
				return m.forEach(function(m) {
					m.cancel();
				}), m;
			},
			cancelByCanvas: function(m) {
				if (!m) return [];
				var x = this.filter(function(x) {
					return typeof x.target == "object" && x.target.canvas === m;
				});
				return x.forEach(function(m) {
					m.cancel();
				}), x;
			},
			cancelByTarget: function(m) {
				var x = this.findAnimationsByTarget(m);
				return x.forEach(function(m) {
					m.cancel();
				}), x;
			},
			findAnimationIndex: function(m) {
				return this.indexOf(this.findAnimation(m));
			},
			findAnimation: function(m) {
				return this.find(function(x) {
					return x.cancel === m;
				});
			},
			findAnimationsByTarget: function(m) {
				return m ? this.filter(function(x) {
					return x.target === m;
				}) : [];
			}
		});
		function T() {
			return !1;
		}
		function D(m, x, S, C) {
			return -S * Math.cos(m / C * (Math.PI / 2)) + S + x;
		}
		function O(C) {
			C ||= {};
			var O = !1, k, A = function() {
				var m = x.runningAnimations.indexOf(k);
				return m > -1 && x.runningAnimations.splice(m, 1)[0];
			};
			return k = m(S(C), {
				cancel: function() {
					return O = !0, A();
				},
				currentValue: "startValue" in C ? C.startValue : 0,
				completionRate: 0,
				durationRate: 0
			}), x.runningAnimations.push(k), j(function(m) {
				var x = m || +/* @__PURE__ */ new Date(), S = C.duration || 500, M = x + S, N, P = C.onChange || T, F = C.abort || T, I = C.onComplete || T, L = C.easing || D, R = "startValue" in C ? C.startValue.length > 0 : !1, z = "startValue" in C ? C.startValue : 0, B = "endValue" in C ? C.endValue : 100, H = C.byValue || (R ? z.map(function(m, x) {
					return B[x] - z[x];
				}) : B - z);
				C.onStart && C.onStart(), (function m(C) {
					N = C || +/* @__PURE__ */ new Date();
					var T = N > M ? S : N - x, D = T / S, U = R ? z.map(function(m, x) {
						return L(T, z[x], H[x], S);
					}) : L(T, z, H, S), W = R ? Math.abs((U[0] - z[0]) / H[0]) : Math.abs((U - z) / H);
					if (k.currentValue = R ? U.slice() : U, k.completionRate = W, k.durationRate = D, !O) {
						if (F(U, W, D)) {
							A();
							return;
						}
						if (N > M) {
							k.currentValue = R ? B.slice() : B, k.completionRate = 1, k.durationRate = 1, P(R ? B.slice() : B, 1, 1), I(B, 1, 1), A();
							return;
						} else P(U, W, D), j(m);
					}
				})(x);
			}), k.cancel;
		}
		var k = x.window.requestAnimationFrame || x.window.webkitRequestAnimationFrame || x.window.mozRequestAnimationFrame || x.window.oRequestAnimationFrame || x.window.msRequestAnimationFrame || function(m) {
			return x.window.setTimeout(m, 1e3 / 60);
		}, A = x.window.cancelAnimationFrame || x.window.clearTimeout;
		function j() {
			return k.apply(x.window, arguments);
		}
		function M() {
			return A.apply(x.window, arguments);
		}
		x.util.animate = O, x.util.requestAnimFrame = j, x.util.cancelAnimFrame = M, x.runningAnimations = C;
	})(), (function() {
		function m(m, x, S) {
			var C = "rgba(" + parseInt(m[0] + S * (x[0] - m[0]), 10) + "," + parseInt(m[1] + S * (x[1] - m[1]), 10) + "," + parseInt(m[2] + S * (x[2] - m[2]), 10);
			return C += "," + (m && x ? parseFloat(m[3] + S * (x[3] - m[3])) : 1), C += ")", C;
		}
		function S(S, C, T, D) {
			var O = new x.Color(S).getSource(), k = new x.Color(C).getSource(), A = D.onComplete, j = D.onChange;
			return D ||= {}, x.util.animate(x.util.object.extend(D, {
				duration: T || 500,
				startValue: O,
				endValue: k,
				byValue: k,
				easing: function(x, S, C, T) {
					return m(S, C, D.colorEasing ? D.colorEasing(x, T) : 1 - Math.cos(x / T * (Math.PI / 2)));
				},
				onComplete: function(x, S, C) {
					if (A) return A(m(k, k, 0), S, C);
				},
				onChange: function(x, S, C) {
					if (j) {
						if (Array.isArray(x)) return j(m(x, x, 0), S, C);
						j(x, S, C);
					}
				}
			}));
		}
		x.util.animateColor = S;
	})(), (function() {
		function m(m, x, S, C) {
			return m < Math.abs(x) ? (m = x, C = S / 4) : C = x === 0 && m === 0 ? S / (2 * Math.PI) * Math.asin(1) : S / (2 * Math.PI) * Math.asin(x / m), {
				a: m,
				c: x,
				p: S,
				s: C
			};
		}
		function S(m, x, S) {
			return m.a * 2 ** (10 * --x) * Math.sin((x * S - m.s) * (2 * Math.PI) / m.p);
		}
		function C(m, x, S, C) {
			return S * ((m = m / C - 1) * m * m + 1) + x;
		}
		function T(m, x, S, C) {
			return m /= C / 2, m < 1 ? S / 2 * m * m * m + x : S / 2 * ((m -= 2) * m * m + 2) + x;
		}
		function D(m, x, S, C) {
			return S * (m /= C) * m * m * m + x;
		}
		function O(m, x, S, C) {
			return -S * ((m = m / C - 1) * m * m * m - 1) + x;
		}
		function k(m, x, S, C) {
			return m /= C / 2, m < 1 ? S / 2 * m * m * m * m + x : -S / 2 * ((m -= 2) * m * m * m - 2) + x;
		}
		function A(m, x, S, C) {
			return S * (m /= C) * m * m * m * m + x;
		}
		function j(m, x, S, C) {
			return S * ((m = m / C - 1) * m * m * m * m + 1) + x;
		}
		function M(m, x, S, C) {
			return m /= C / 2, m < 1 ? S / 2 * m * m * m * m * m + x : S / 2 * ((m -= 2) * m * m * m * m + 2) + x;
		}
		function N(m, x, S, C) {
			return -S * Math.cos(m / C * (Math.PI / 2)) + S + x;
		}
		function P(m, x, S, C) {
			return S * Math.sin(m / C * (Math.PI / 2)) + x;
		}
		function F(m, x, S, C) {
			return -S / 2 * (Math.cos(Math.PI * m / C) - 1) + x;
		}
		function I(m, x, S, C) {
			return m === 0 ? x : S * 2 ** (10 * (m / C - 1)) + x;
		}
		function L(m, x, S, C) {
			return m === C ? x + S : S * (-(2 ** (-10 * m / C)) + 1) + x;
		}
		function R(m, x, S, C) {
			return m === 0 ? x : m === C ? x + S : (m /= C / 2, m < 1 ? S / 2 * 2 ** (10 * (m - 1)) + x : S / 2 * (-(2 ** (-10 * --m)) + 2) + x);
		}
		function z(m, x, S, C) {
			return -S * (Math.sqrt(1 - (m /= C) * m) - 1) + x;
		}
		function B(m, x, S, C) {
			return S * Math.sqrt(1 - (m = m / C - 1) * m) + x;
		}
		function H(m, x, S, C) {
			return m /= C / 2, m < 1 ? -S / 2 * (Math.sqrt(1 - m * m) - 1) + x : S / 2 * (Math.sqrt(1 - (m -= 2) * m) + 1) + x;
		}
		function U(x, C, T, D) {
			var O = 1.70158, k = 0, A = T;
			return x === 0 ? C : (x /= D, x === 1 ? C + T : (k ||= D * .3, -S(m(A, T, k, O), x, D) + C));
		}
		function W(x, S, C, T) {
			var D = 1.70158, O = 0, k = C;
			if (x === 0) return S;
			if (x /= T, x === 1) return S + C;
			O ||= T * .3;
			var A = m(k, C, O, D);
			return A.a * 2 ** (-10 * x) * Math.sin((x * T - A.s) * (2 * Math.PI) / A.p) + A.c + S;
		}
		function G(x, C, T, D) {
			var O = 1.70158, k = 0, A = T;
			if (x === 0) return C;
			if (x /= D / 2, x === 2) return C + T;
			k ||= D * (.3 * 1.5);
			var j = m(A, T, k, O);
			return x < 1 ? -.5 * S(j, x, D) + C : j.a * 2 ** (-10 * --x) * Math.sin((x * D - j.s) * (2 * Math.PI) / j.p) * .5 + j.c + C;
		}
		function K(m, x, S, C, T) {
			return T === void 0 && (T = 1.70158), S * (m /= C) * m * ((T + 1) * m - T) + x;
		}
		function q(m, x, S, C, T) {
			return T === void 0 && (T = 1.70158), S * ((m = m / C - 1) * m * ((T + 1) * m + T) + 1) + x;
		}
		function J(m, x, S, C, T) {
			return T === void 0 && (T = 1.70158), m /= C / 2, m < 1 ? S / 2 * (m * m * (((T *= 1.525) + 1) * m - T)) + x : S / 2 * ((m -= 2) * m * (((T *= 1.525) + 1) * m + T) + 2) + x;
		}
		function Y(m, x, S, C) {
			return S - X(C - m, 0, S, C) + x;
		}
		function X(m, x, S, C) {
			return (m /= C) < 1 / 2.75 ? S * (7.5625 * m * m) + x : m < 2 / 2.75 ? S * (7.5625 * (m -= 1.5 / 2.75) * m + .75) + x : m < 2.5 / 2.75 ? S * (7.5625 * (m -= 2.25 / 2.75) * m + .9375) + x : S * (7.5625 * (m -= 2.625 / 2.75) * m + .984375) + x;
		}
		function Z(m, x, S, C) {
			return m < C / 2 ? Y(m * 2, 0, S, C) * .5 + x : X(m * 2 - C, 0, S, C) * .5 + S * .5 + x;
		}
		x.util.ease = {
			easeInQuad: function(m, x, S, C) {
				return S * (m /= C) * m + x;
			},
			easeOutQuad: function(m, x, S, C) {
				return -S * (m /= C) * (m - 2) + x;
			},
			easeInOutQuad: function(m, x, S, C) {
				return m /= C / 2, m < 1 ? S / 2 * m * m + x : -S / 2 * (--m * (m - 2) - 1) + x;
			},
			easeInCubic: function(m, x, S, C) {
				return S * (m /= C) * m * m + x;
			},
			easeOutCubic: C,
			easeInOutCubic: T,
			easeInQuart: D,
			easeOutQuart: O,
			easeInOutQuart: k,
			easeInQuint: A,
			easeOutQuint: j,
			easeInOutQuint: M,
			easeInSine: N,
			easeOutSine: P,
			easeInOutSine: F,
			easeInExpo: I,
			easeOutExpo: L,
			easeInOutExpo: R,
			easeInCirc: z,
			easeOutCirc: B,
			easeInOutCirc: H,
			easeInElastic: U,
			easeOutElastic: W,
			easeInOutElastic: G,
			easeInBack: K,
			easeOutBack: q,
			easeInOutBack: J,
			easeInBounce: Y,
			easeOutBounce: X,
			easeInOutBounce: Z
		};
	})(), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.util.object.clone, T = x.util.toFixed, D = x.util.parseUnit, O = x.util.multiplyTransformMatrices, k = [
			"path",
			"circle",
			"polygon",
			"polyline",
			"ellipse",
			"rect",
			"line",
			"image",
			"text"
		], A = [
			"symbol",
			"image",
			"marker",
			"pattern",
			"view",
			"svg"
		], j = [
			"pattern",
			"defs",
			"symbol",
			"metadata",
			"clipPath",
			"mask",
			"desc"
		], M = [
			"symbol",
			"g",
			"a",
			"svg",
			"clipPath",
			"defs"
		], N = {
			cx: "left",
			x: "left",
			r: "radius",
			cy: "top",
			y: "top",
			display: "visible",
			visibility: "visible",
			transform: "transformMatrix",
			"fill-opacity": "fillOpacity",
			"fill-rule": "fillRule",
			"font-family": "fontFamily",
			"font-size": "fontSize",
			"font-style": "fontStyle",
			"font-weight": "fontWeight",
			"letter-spacing": "charSpacing",
			"paint-order": "paintFirst",
			"stroke-dasharray": "strokeDashArray",
			"stroke-dashoffset": "strokeDashOffset",
			"stroke-linecap": "strokeLineCap",
			"stroke-linejoin": "strokeLineJoin",
			"stroke-miterlimit": "strokeMiterLimit",
			"stroke-opacity": "strokeOpacity",
			"stroke-width": "strokeWidth",
			"text-decoration": "textDecoration",
			"text-anchor": "textAnchor",
			opacity: "opacity",
			"clip-path": "clipPath",
			"clip-rule": "clipRule",
			"vector-effect": "strokeUniform",
			"image-rendering": "imageSmoothing"
		}, P = {
			stroke: "strokeOpacity",
			fill: "fillOpacity"
		}, F = "font-size", I = "clip-path";
		x.svgValidTagNamesRegEx = z(k), x.svgViewBoxElementsRegEx = z(A), x.svgInvalidAncestorsRegEx = z(j), x.svgValidParentsRegEx = z(M), x.cssRules = {}, x.gradientDefs = {}, x.clipPaths = {};
		function L(m) {
			return m in N ? N[m] : m;
		}
		function R(m, S, C, T) {
			var k = Array.isArray(S), A;
			if ((m === "fill" || m === "stroke") && S === "none") S = "";
			else if (m === "strokeUniform") return S === "non-scaling-stroke";
			else if (m === "strokeDashArray") S = S === "none" ? null : S.replace(/,/g, " ").split(/\s+/).map(parseFloat);
			else if (m === "transformMatrix") S = C && C.transformMatrix ? O(C.transformMatrix, x.parseTransformAttribute(S)) : x.parseTransformAttribute(S);
			else if (m === "visible") S = S !== "none" && S !== "hidden", C && C.visible === !1 && (S = !1);
			else if (m === "opacity") S = parseFloat(S), C && C.opacity !== void 0 && (S *= C.opacity);
			else if (m === "textAnchor") S = S === "start" ? "left" : S === "end" ? "right" : "center";
			else if (m === "charSpacing") A = D(S, T) / T * 1e3;
			else if (m === "paintFirst") {
				var j = S.indexOf("fill"), M = S.indexOf("stroke"), S = "fill";
				(j > -1 && M > -1 && M < j || j === -1 && M > -1) && (S = "stroke");
			} else if (m === "href" || m === "xlink:href" || m === "font") return S;
			else if (m === "imageSmoothing") return S === "optimizeQuality";
			else A = k ? S.map(D) : D(S, T);
			return !k && isNaN(A) ? S : A;
		}
		function z(m) {
			return RegExp("^(" + m.join("|") + ")\\b", "i");
		}
		function B(m) {
			for (var S in P) if (!(m[P[S]] === void 0 || m[S] === "")) {
				if (m[S] === void 0) {
					if (!x.Object.prototype[S]) continue;
					m[S] = x.Object.prototype[S];
				}
				if (m[S].indexOf("url(") !== 0) {
					var C = new x.Color(m[S]);
					m[S] = C.setAlpha(T(C.getAlpha() * m[P[S]], 2)).toRgba();
				}
			}
			return m;
		}
		function H(m, x) {
			var S, C = [], T, D, O;
			for (D = 0, O = x.length; D < O; D++) S = x[D], T = m.getElementsByTagName(S), C = C.concat(Array.prototype.slice.call(T));
			return C;
		}
		x.parseTransformAttribute = (function() {
			function m(m, S) {
				var C = x.util.cos(S[0]), T = x.util.sin(S[0]), D = 0, O = 0;
				S.length === 3 && (D = S[1], O = S[2]), m[0] = C, m[1] = T, m[2] = -T, m[3] = C, m[4] = D - (C * D - T * O), m[5] = O - (T * D + C * O);
			}
			function S(m, x) {
				var S = x[0], C = x.length === 2 ? x[1] : x[0];
				m[0] = S, m[3] = C;
			}
			function C(m, S, C) {
				m[C] = Math.tan(x.util.degreesToRadians(S[0]));
			}
			function T(m, x) {
				m[4] = x[0], x.length === 2 && (m[5] = x[1]);
			}
			var D = x.iMatrix, O = x.reNum, k = x.commaWsp, A = "(?:(skewX)\\s*\\(\\s*(" + O + ")\\s*\\))", j = "(?:(skewY)\\s*\\(\\s*(" + O + ")\\s*\\))", M = "(?:(rotate)\\s*\\(\\s*(" + O + ")(?:" + k + "(" + O + ")" + k + "(" + O + "))?\\s*\\))", N = "(?:(scale)\\s*\\(\\s*(" + O + ")(?:" + k + "(" + O + "))?\\s*\\))", P = "(?:(translate)\\s*\\(\\s*(" + O + ")(?:" + k + "(" + O + "))?\\s*\\))", F = "(?:" + ("(?:(matrix)\\s*\\(\\s*(" + O + ")" + k + "(" + O + ")" + k + "(" + O + ")" + k + "(" + O + ")" + k + "(" + O + ")" + k + "(" + O + ")\\s*\\))") + "|" + P + "|" + N + "|" + M + "|" + A + "|" + j + ")", I = "^\\s*(?:" + ("(?:" + F + "(?:" + k + "*" + F + ")*)") + "?)\\s*$", L = new RegExp(I), R = new RegExp(F, "g");
			return function(O) {
				var k = D.concat(), A = [];
				if (!O || O && !L.test(O)) return k;
				O.replace(R, function(O) {
					var j = new RegExp(F).exec(O).filter(function(m) {
						return !!m;
					}), M = j[1], N = j.slice(2).map(parseFloat);
					switch (M) {
						case "translate":
							T(k, N);
							break;
						case "rotate":
							N[0] = x.util.degreesToRadians(N[0]), m(k, N);
							break;
						case "scale":
							S(k, N);
							break;
						case "skewX":
							C(k, N, 2);
							break;
						case "skewY":
							C(k, N, 1);
							break;
						case "matrix":
							k = N;
							break;
					}
					A.push(k.concat()), k = D.concat();
				});
				for (var j = A[0]; A.length > 1;) A.shift(), j = x.util.multiplyTransformMatrices(j, A[0]);
				return j;
			};
		})();
		function U(m, x) {
			var S, C;
			m.replace(/;\s*$/, "").split(";").forEach(function(m) {
				var T = m.split(":");
				S = T[0].trim().toLowerCase(), C = T[1].trim(), x[S] = C;
			});
		}
		function W(m, x) {
			var S, C;
			for (var T in m) m[T] !== void 0 && (S = T.toLowerCase(), C = m[T], x[S] = C);
		}
		function G(m, S) {
			var C = {};
			for (var T in x.cssRules[S]) if (K(m, T.split(" "))) for (var D in x.cssRules[S][T]) C[D] = x.cssRules[S][T][D];
			return C;
		}
		function K(m, x) {
			var S, C = !0;
			return S = J(m, x.pop()), S && x.length && (C = q(m, x)), S && C && x.length === 0;
		}
		function q(m, x) {
			for (var S, C = !0; m.parentNode && m.parentNode.nodeType === 1 && x.length;) C && (S = x.pop()), m = m.parentNode, C = J(m, S);
			return x.length === 0;
		}
		function J(m, x) {
			var S = m.nodeName, C = m.getAttribute("class"), T = m.getAttribute("id"), D = RegExp("^" + S, "i"), O;
			if (x = x.replace(D, ""), T && x.length && (D = RegExp("#" + T + "(?![a-zA-Z\\-]+)", "i"), x = x.replace(D, "")), C && x.length) for (C = C.split(" "), O = C.length; O--;) D = RegExp("\\." + C[O] + "(?![a-zA-Z\\-]+)", "i"), x = x.replace(D, "");
			return x.length === 0;
		}
		function Y(m, x) {
			var S;
			if (m.getElementById && (S = m.getElementById(x)), S) return S;
			var C, T, D, O = m.getElementsByTagName("*");
			for (T = 0, D = O.length; T < D; T++) if (C = O[T], x === C.getAttribute("id")) return C;
		}
		function X(m) {
			for (var S = H(m, ["use", "svg:use"]), C = 0; S.length && C < S.length;) {
				var T = S[C], D = T.getAttribute("xlink:href") || T.getAttribute("href");
				if (D === null) return;
				var O = D.slice(1), k = T.getAttribute("x") || 0, A = T.getAttribute("y") || 0, j = Y(m, O).cloneNode(!0), M = (j.getAttribute("transform") || "") + " translate(" + k + ", " + A + ")", N, P = S.length, F, I, L, R, z = x.svgNS;
				if (sH(j), /^svg$/i.test(j.nodeName)) {
					var B = j.ownerDocument.createElementNS(z, "g");
					for (I = 0, L = j.attributes, R = L.length; I < R; I++) F = L.item(I), B.setAttributeNS(z, F.nodeName, F.nodeValue);
					for (; j.firstChild;) B.appendChild(j.firstChild);
					j = B;
				}
				for (I = 0, L = T.attributes, R = L.length; I < R; I++) F = L.item(I), !(F.nodeName === "x" || F.nodeName === "y" || F.nodeName === "xlink:href" || F.nodeName === "href") && (F.nodeName === "transform" ? M = F.nodeValue + " " + M : j.setAttribute(F.nodeName, F.nodeValue));
				j.setAttribute("transform", M), j.setAttribute("instantiated_by_use", "1"), j.removeAttribute("id"), N = T.parentNode, N.replaceChild(j, T), S.length === P && C++;
			}
		}
		var Z = /* @__PURE__ */ RegExp("^\\s*(" + x.reNum + "+)\\s*,?\\s*(" + x.reNum + "+)\\s*,?\\s*(" + x.reNum + "+)\\s*,?\\s*(" + x.reNum + "+)\\s*$");
		function sH(m) {
			if (!x.svgViewBoxElementsRegEx.test(m.nodeName)) return {};
			var S = m.getAttribute("viewBox"), C = 1, T = 1, O = 0, k = 0, A, j, M, N, P = m.getAttribute("width"), F = m.getAttribute("height"), I = m.getAttribute("x") || 0, L = m.getAttribute("y") || 0, R = m.getAttribute("preserveAspectRatio") || "", z = !S || !(S = S.match(Z)), B = !P || !F || P === "100%" || F === "100%", H = z && B, U = {}, W = "", G = 0, K = 0;
			if (U.width = 0, U.height = 0, U.toBeParsed = H, z && (I || L) && m.parentNode && m.parentNode.nodeName !== "#document" && (W = " translate(" + D(I) + " " + D(L) + ") ", M = (m.getAttribute("transform") || "") + W, m.setAttribute("transform", M), m.removeAttribute("x"), m.removeAttribute("y")), H) return U;
			if (z) return U.width = D(P), U.height = D(F), U;
			if (O = -parseFloat(S[1]), k = -parseFloat(S[2]), A = parseFloat(S[3]), j = parseFloat(S[4]), U.minX = O, U.minY = k, U.viewBoxWidth = A, U.viewBoxHeight = j, B ? (U.width = A, U.height = j) : (U.width = D(P), U.height = D(F), C = U.width / A, T = U.height / j), R = x.util.parsePreserveAspectRatioAttribute(R), R.alignX !== "none" && (R.meetOrSlice === "meet" && (T = C = C > T ? T : C), R.meetOrSlice === "slice" && (T = C = C > T ? C : T), G = U.width - A * C, K = U.height - j * C, R.alignX === "Mid" && (G /= 2), R.alignY === "Mid" && (K /= 2), R.alignX === "Min" && (G = 0), R.alignY === "Min" && (K = 0)), C === 1 && T === 1 && O === 0 && k === 0 && I === 0 && L === 0) return U;
			if ((I || L) && m.parentNode.nodeName !== "#document" && (W = " translate(" + D(I) + " " + D(L) + ") "), M = W + " matrix(" + C + " 0 0 " + T + " " + (O * C + G) + " " + (k * T + K) + ") ", m.nodeName === "svg") {
				for (N = m.ownerDocument.createElementNS(x.svgNS, "g"); m.firstChild;) N.appendChild(m.firstChild);
				m.appendChild(N);
			} else N = m, N.removeAttribute("x"), N.removeAttribute("y"), M = N.getAttribute("transform") + M;
			return N.setAttribute("transform", M), U;
		}
		function Q(m, x) {
			for (; m &&= m.parentNode;) if (m.nodeName && x.test(m.nodeName.replace("svg:", "")) && !m.getAttribute("instantiated_by_use")) return !0;
			return !1;
		}
		x.parseSVGDocument = function(m, S, T, D) {
			if (m) {
				X(m);
				var O = x.Object.__uid++, k, A, j = sH(m), M = x.util.toArray(m.getElementsByTagName("*"));
				if (j.crossOrigin = D && D.crossOrigin, j.svgUid = O, M.length === 0 && x.isLikelyNode) {
					M = m.selectNodes("//*[name(.)!=\"svg\"]");
					var N = [];
					for (k = 0, A = M.length; k < A; k++) N[k] = M[k];
					M = N;
				}
				var P = M.filter(function(m) {
					return sH(m), x.svgValidTagNamesRegEx.test(m.nodeName.replace("svg:", "")) && !Q(m, x.svgInvalidAncestorsRegEx);
				});
				if (!P || P && !P.length) {
					S && S([], {});
					return;
				}
				var F = {};
				M.filter(function(m) {
					return m.nodeName.replace("svg:", "") === "clipPath";
				}).forEach(function(m) {
					var S = m.getAttribute("id");
					F[S] = x.util.toArray(m.getElementsByTagName("*")).filter(function(m) {
						return x.svgValidTagNamesRegEx.test(m.nodeName.replace("svg:", ""));
					});
				}), x.gradientDefs[O] = x.getGradientDefs(m), x.cssRules[O] = x.getCSSRules(m), x.clipPaths[O] = F, x.parseElements(P, function(m, C) {
					S && (S(m, j, C, M), delete x.gradientDefs[O], delete x.cssRules[O], delete x.clipPaths[O]);
				}, C(j), T, D);
			}
		};
		function cH(m, x) {
			var S = [
				"gradientTransform",
				"x1",
				"x2",
				"y1",
				"y2",
				"gradientUnits",
				"cx",
				"cy",
				"r",
				"fx",
				"fy"
			], C = "xlink:href", T = Y(m, x.getAttribute(C).slice(1));
			if (T && T.getAttribute(C) && cH(m, T), S.forEach(function(m) {
				T && !x.hasAttribute(m) && T.hasAttribute(m) && x.setAttribute(m, T.getAttribute(m));
			}), !x.children.length) for (var D = T.cloneNode(!0); D.firstChild;) x.appendChild(D.firstChild);
			x.removeAttribute(C);
		}
		var lH = /* @__PURE__ */ RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + x.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + x.reNum + "))?\\s+(.*)");
		S(x, {
			parseFontDeclaration: function(m, x) {
				var S = m.match(lH);
				if (S) {
					var C = S[1], T = S[3], O = S[4], k = S[5], A = S[6];
					C && (x.fontStyle = C), T && (x.fontWeight = isNaN(parseFloat(T)) ? T : parseFloat(T)), O && (x.fontSize = D(O)), A && (x.fontFamily = A), k && (x.lineHeight = k === "normal" ? 1 : k);
				}
			},
			getGradientDefs: function(m) {
				var x = H(m, [
					"linearGradient",
					"radialGradient",
					"svg:linearGradient",
					"svg:radialGradient"
				]), S, C = 0, T = {};
				for (C = x.length; C--;) S = x[C], S.getAttribute("xlink:href") && cH(m, S), T[S.getAttribute("id")] = S;
				return T;
			},
			parseAttributes: function(m, C, T) {
				if (m) {
					var O, k = {}, A, j;
					T === void 0 && (T = m.getAttribute("svgUid")), m.parentNode && x.svgValidParentsRegEx.test(m.parentNode.nodeName) && (k = x.parseAttributes(m.parentNode, C, T));
					var M = C.reduce(function(x, S) {
						return O = m.getAttribute(S), O && (x[S] = O), x;
					}, {}), N = S(G(m, T), x.parseStyleAttribute(m));
					M = S(M, N), N[I] && m.setAttribute(I, N[I]), A = j = k.fontSize || x.Text.DEFAULT_SVG_FONT_SIZE, M[F] && (M[F] = A = D(M[F], j));
					var P, z, H = {};
					for (var U in M) P = L(U), z = R(P, M[U], k, A), H[P] = z;
					H && H.font && x.parseFontDeclaration(H.font, H);
					var W = S(k, H);
					return x.svgValidParentsRegEx.test(m.nodeName) ? W : B(W);
				}
			},
			parseElements: function(m, S, C, T, D) {
				new x.ElementsParser(m, S, C, T, D).parse();
			},
			parseStyleAttribute: function(m) {
				var x = {}, S = m.getAttribute("style");
				return S && (typeof S == "string" ? U(S, x) : W(S, x)), x;
			},
			parsePointsAttribute: function(m) {
				if (!m) return null;
				m = m.replace(/,/g, " ").trim(), m = m.split(/\s+/);
				var x = [], S, C;
				for (S = 0, C = m.length; S < C; S += 2) x.push({
					x: parseFloat(m[S]),
					y: parseFloat(m[S + 1])
				});
				return x;
			},
			getCSSRules: function(m) {
				var S = m.getElementsByTagName("style"), C, T, D = {}, O;
				for (C = 0, T = S.length; C < T; C++) {
					var k = S[C].textContent;
					k = k.replace(/\/\*[\s\S]*?\*\//g, ""), k.trim() !== "" && (O = k.split("}"), O = O.filter(function(m) {
						return m.trim();
					}), O.forEach(function(m) {
						var S = m.split("{"), O = {}, k = S[1].trim().split(";").filter(function(m) {
							return m.trim();
						});
						for (C = 0, T = k.length; C < T; C++) {
							var A = k[C].split(":"), j = A[0].trim();
							O[j] = A[1].trim();
						}
						m = S[0].trim(), m.split(",").forEach(function(m) {
							m = m.replace(/^svg/i, "").trim(), m !== "" && (D[m] ? x.util.object.extend(D[m], O) : D[m] = x.util.object.clone(O));
						});
					}));
				}
				return D;
			},
			loadSVGFromURL: function(m, S, C, T) {
				m = m.replace(/^\n\s*/, "").trim(), new x.util.request(m, {
					method: "get",
					onComplete: D
				});
				function D(m) {
					var D = m.responseXML;
					if (!D || !D.documentElement) return S && S(null), !1;
					x.parseSVGDocument(D.documentElement, function(m, x, C, T) {
						S && S(m, x, C, T);
					}, C, T);
				}
			},
			loadSVGFromString: function(m, S, C, T) {
				var D = new x.window.DOMParser().parseFromString(m.trim(), "text/xml");
				x.parseSVGDocument(D.documentElement, function(m, x, C, T) {
					S(m, x, C, T);
				}, C, T);
			}
		});
	})(m), x.ElementsParser = function(m, x, S, C, T, D) {
		this.elements = m, this.callback = x, this.options = S, this.reviver = C, this.svgUid = S && S.svgUid || 0, this.parsingOptions = T, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = D;
	}, (function(m) {
		m.parse = function() {
			this.instances = Array(this.elements.length), this.numElements = this.elements.length, this.createObjects();
		}, m.createObjects = function() {
			var m = this;
			this.elements.forEach(function(x, S) {
				x.setAttribute("svgUid", m.svgUid), m.createObject(x, S);
			});
		}, m.findTag = function(m) {
			return x[x.util.string.capitalize(m.tagName.replace("svg:", ""))];
		}, m.createObject = function(m, S) {
			var C = this.findTag(m);
			if (C && C.fromElement) try {
				C.fromElement(m, this.createCallback(S, m), this.options);
			} catch (m) {
				x.log(m);
			}
			else this.checkIfDone();
		}, m.createCallback = function(m, S) {
			var C = this;
			return function(T) {
				var D;
				C.resolveGradient(T, S, "fill"), C.resolveGradient(T, S, "stroke"), T instanceof x.Image && T._originalElement && (D = T.parsePreserveAspectRatioAttribute(S)), T._removeTransformMatrix(D), C.resolveClipPath(T, S), C.reviver && C.reviver(S, T), C.instances[m] = T, C.checkIfDone();
			};
		}, m.extractPropertyDefinition = function(m, S, C) {
			var T = m[S], D = this.regexUrl;
			if (D.test(T)) {
				D.lastIndex = 0;
				var O = D.exec(T)[1];
				return D.lastIndex = 0, x[C][this.svgUid][O];
			}
		}, m.resolveGradient = function(m, S, C) {
			var T = this.extractPropertyDefinition(m, C, "gradientDefs");
			if (T) {
				var D = S.getAttribute(C + "-opacity"), O = x.Gradient.fromElement(T, m, D, this.options);
				m.set(C, O);
			}
		}, m.createClipPathCallback = function(m, x) {
			return function(m) {
				m._removeTransformMatrix(), m.fillRule = m.clipRule, x.push(m);
			};
		}, m.resolveClipPath = function(m, S) {
			var C = this.extractPropertyDefinition(m, "clipPath", "clipPaths"), T, D, O, k, A, j;
			if (C) {
				k = [], O = x.util.invertTransform(m.calcTransformMatrix());
				for (var M = C[0].parentNode, N = S; N.parentNode && N.getAttribute("clip-path") !== m.clipPath;) N = N.parentNode;
				N.parentNode.appendChild(M);
				for (var P = 0; P < C.length; P++) T = C[P], D = this.findTag(T), D.fromElement(T, this.createClipPathCallback(m, k), this.options);
				C = k.length === 1 ? k[0] : new x.Group(k), A = x.util.multiplyTransformMatrices(O, C.calcTransformMatrix()), C.clipPath && this.resolveClipPath(C, N);
				var j = x.util.qrDecompose(A);
				C.flipX = !1, C.flipY = !1, C.set("scaleX", j.scaleX), C.set("scaleY", j.scaleY), C.angle = j.angle, C.skewX = j.skewX, C.skewY = 0, C.setPositionByOrigin({
					x: j.translateX,
					y: j.translateY
				}, "center", "center"), m.clipPath = C;
			} else delete m.clipPath;
		}, m.checkIfDone = function() {
			--this.numElements === 0 && (this.instances = this.instances.filter(function(m) {
				return m != null;
			}), this.callback(this.instances, this.elements));
		};
	})(x.ElementsParser.prototype), (function(m) {
		var x = m.fabric ||= {};
		if (x.Point) {
			x.warn("fabric.Point is already defined");
			return;
		}
		x.Point = S;
		function S(m, x) {
			this.x = m, this.y = x;
		}
		S.prototype = {
			type: "point",
			constructor: S,
			add: function(m) {
				return new S(this.x + m.x, this.y + m.y);
			},
			addEquals: function(m) {
				return this.x += m.x, this.y += m.y, this;
			},
			scalarAdd: function(m) {
				return new S(this.x + m, this.y + m);
			},
			scalarAddEquals: function(m) {
				return this.x += m, this.y += m, this;
			},
			subtract: function(m) {
				return new S(this.x - m.x, this.y - m.y);
			},
			subtractEquals: function(m) {
				return this.x -= m.x, this.y -= m.y, this;
			},
			scalarSubtract: function(m) {
				return new S(this.x - m, this.y - m);
			},
			scalarSubtractEquals: function(m) {
				return this.x -= m, this.y -= m, this;
			},
			multiply: function(m) {
				return new S(this.x * m, this.y * m);
			},
			multiplyEquals: function(m) {
				return this.x *= m, this.y *= m, this;
			},
			divide: function(m) {
				return new S(this.x / m, this.y / m);
			},
			divideEquals: function(m) {
				return this.x /= m, this.y /= m, this;
			},
			eq: function(m) {
				return this.x === m.x && this.y === m.y;
			},
			lt: function(m) {
				return this.x < m.x && this.y < m.y;
			},
			lte: function(m) {
				return this.x <= m.x && this.y <= m.y;
			},
			gt: function(m) {
				return this.x > m.x && this.y > m.y;
			},
			gte: function(m) {
				return this.x >= m.x && this.y >= m.y;
			},
			lerp: function(m, x) {
				return x === void 0 && (x = .5), x = Math.max(Math.min(1, x), 0), new S(this.x + (m.x - this.x) * x, this.y + (m.y - this.y) * x);
			},
			distanceFrom: function(m) {
				var x = this.x - m.x, S = this.y - m.y;
				return Math.sqrt(x * x + S * S);
			},
			midPointFrom: function(m) {
				return this.lerp(m);
			},
			min: function(m) {
				return new S(Math.min(this.x, m.x), Math.min(this.y, m.y));
			},
			max: function(m) {
				return new S(Math.max(this.x, m.x), Math.max(this.y, m.y));
			},
			toString: function() {
				return this.x + "," + this.y;
			},
			setXY: function(m, x) {
				return this.x = m, this.y = x, this;
			},
			setX: function(m) {
				return this.x = m, this;
			},
			setY: function(m) {
				return this.y = m, this;
			},
			setFromPoint: function(m) {
				return this.x = m.x, this.y = m.y, this;
			},
			swap: function(m) {
				var x = this.x, S = this.y;
				this.x = m.x, this.y = m.y, m.x = x, m.y = S;
			},
			clone: function() {
				return new S(this.x, this.y);
			}
		};
	})(m), (function(m) {
		var x = m.fabric ||= {};
		if (x.Intersection) {
			x.warn("fabric.Intersection is already defined");
			return;
		}
		function S(m) {
			this.status = m, this.points = [];
		}
		x.Intersection = S, x.Intersection.prototype = {
			constructor: S,
			appendPoint: function(m) {
				return this.points.push(m), this;
			},
			appendPoints: function(m) {
				return this.points = this.points.concat(m), this;
			}
		}, x.Intersection.intersectLineLine = function(m, C, T, D) {
			var O, k = (D.x - T.x) * (m.y - T.y) - (D.y - T.y) * (m.x - T.x), A = (C.x - m.x) * (m.y - T.y) - (C.y - m.y) * (m.x - T.x), j = (D.y - T.y) * (C.x - m.x) - (D.x - T.x) * (C.y - m.y);
			if (j !== 0) {
				var M = k / j, N = A / j;
				0 <= M && M <= 1 && 0 <= N && N <= 1 ? (O = new S("Intersection"), O.appendPoint(new x.Point(m.x + M * (C.x - m.x), m.y + M * (C.y - m.y)))) : O = new S();
			} else O = k === 0 || A === 0 ? new S("Coincident") : new S("Parallel");
			return O;
		}, x.Intersection.intersectLinePolygon = function(m, x, C) {
			var T = new S(), D = C.length, O, k, A, j;
			for (j = 0; j < D; j++) O = C[j], k = C[(j + 1) % D], A = S.intersectLineLine(m, x, O, k), T.appendPoints(A.points);
			return T.points.length > 0 && (T.status = "Intersection"), T;
		}, x.Intersection.intersectPolygonPolygon = function(m, x) {
			var C = new S(), T = m.length, D;
			for (D = 0; D < T; D++) {
				var O = m[D], k = m[(D + 1) % T], A = S.intersectLinePolygon(O, k, x);
				C.appendPoints(A.points);
			}
			return C.points.length > 0 && (C.status = "Intersection"), C;
		}, x.Intersection.intersectPolygonRectangle = function(m, C, T) {
			var D = C.min(T), O = C.max(T), k = new x.Point(O.x, D.y), A = new x.Point(D.x, O.y), j = S.intersectLinePolygon(D, k, m), M = S.intersectLinePolygon(k, O, m), N = S.intersectLinePolygon(O, A, m), P = S.intersectLinePolygon(A, D, m), F = new S();
			return F.appendPoints(j.points), F.appendPoints(M.points), F.appendPoints(N.points), F.appendPoints(P.points), F.points.length > 0 && (F.status = "Intersection"), F;
		};
	})(m), (function(m) {
		var x = m.fabric ||= {};
		if (x.Color) {
			x.warn("fabric.Color is already defined.");
			return;
		}
		function S(m) {
			m ? this._tryParsingColor(m) : this.setSource([
				0,
				0,
				0,
				1
			]);
		}
		x.Color = S, x.Color.prototype = {
			_tryParsingColor: function(m) {
				var x;
				m in S.colorNameMap && (m = S.colorNameMap[m]), m === "transparent" && (x = [
					255,
					255,
					255,
					0
				]), x ||= S.sourceFromHex(m), x ||= S.sourceFromRgb(m), x ||= S.sourceFromHsl(m), x ||= [
					0,
					0,
					0,
					1
				], x && this.setSource(x);
			},
			_rgbToHsl: function(m, S, C) {
				m /= 255, S /= 255, C /= 255;
				var T, D, O, k = x.util.array.max([
					m,
					S,
					C
				]), A = x.util.array.min([
					m,
					S,
					C
				]);
				if (O = (k + A) / 2, k === A) T = D = 0;
				else {
					var j = k - A;
					switch (D = O > .5 ? j / (2 - k - A) : j / (k + A), k) {
						case m:
							T = (S - C) / j + (S < C ? 6 : 0);
							break;
						case S:
							T = (C - m) / j + 2;
							break;
						case C:
							T = (m - S) / j + 4;
							break;
					}
					T /= 6;
				}
				return [
					Math.round(T * 360),
					Math.round(D * 100),
					Math.round(O * 100)
				];
			},
			getSource: function() {
				return this._source;
			},
			setSource: function(m) {
				this._source = m;
			},
			toRgb: function() {
				var m = this.getSource();
				return "rgb(" + m[0] + "," + m[1] + "," + m[2] + ")";
			},
			toRgba: function() {
				var m = this.getSource();
				return "rgba(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + ")";
			},
			toHsl: function() {
				var m = this.getSource(), x = this._rgbToHsl(m[0], m[1], m[2]);
				return "hsl(" + x[0] + "," + x[1] + "%," + x[2] + "%)";
			},
			toHsla: function() {
				var m = this.getSource(), x = this._rgbToHsl(m[0], m[1], m[2]);
				return "hsla(" + x[0] + "," + x[1] + "%," + x[2] + "%," + m[3] + ")";
			},
			toHex: function() {
				var m = this.getSource(), x = m[0].toString(16), S, C;
				return x = x.length === 1 ? "0" + x : x, S = m[1].toString(16), S = S.length === 1 ? "0" + S : S, C = m[2].toString(16), C = C.length === 1 ? "0" + C : C, x.toUpperCase() + S.toUpperCase() + C.toUpperCase();
			},
			toHexa: function() {
				var m = this.getSource(), x = Math.round(m[3] * 255);
				return x = x.toString(16), x = x.length === 1 ? "0" + x : x, this.toHex() + x.toUpperCase();
			},
			getAlpha: function() {
				return this.getSource()[3];
			},
			setAlpha: function(m) {
				var x = this.getSource();
				return x[3] = m, this.setSource(x), this;
			},
			toGrayscale: function() {
				var m = this.getSource(), x = parseInt((m[0] * .3 + m[1] * .59 + m[2] * .11).toFixed(0), 10), S = m[3];
				return this.setSource([
					x,
					x,
					x,
					S
				]), this;
			},
			toBlackWhite: function(m) {
				var x = this.getSource(), S = (x[0] * .3 + x[1] * .59 + x[2] * .11).toFixed(0), C = x[3];
				return m ||= 127, S = Number(S) < Number(m) ? 0 : 255, this.setSource([
					S,
					S,
					S,
					C
				]), this;
			},
			overlayWith: function(m) {
				m instanceof S || (m = new S(m));
				var x = [], C = this.getAlpha(), T = .5, D = this.getSource(), O = m.getSource(), k;
				for (k = 0; k < 3; k++) x.push(Math.round(D[k] * (1 - T) + O[k] * T));
				return x[3] = C, this.setSource(x), this;
			}
		}, x.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, x.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, x.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, x.Color.colorNameMap = {
			aliceblue: "#F0F8FF",
			antiquewhite: "#FAEBD7",
			aqua: "#00FFFF",
			aquamarine: "#7FFFD4",
			azure: "#F0FFFF",
			beige: "#F5F5DC",
			bisque: "#FFE4C4",
			black: "#000000",
			blanchedalmond: "#FFEBCD",
			blue: "#0000FF",
			blueviolet: "#8A2BE2",
			brown: "#A52A2A",
			burlywood: "#DEB887",
			cadetblue: "#5F9EA0",
			chartreuse: "#7FFF00",
			chocolate: "#D2691E",
			coral: "#FF7F50",
			cornflowerblue: "#6495ED",
			cornsilk: "#FFF8DC",
			crimson: "#DC143C",
			cyan: "#00FFFF",
			darkblue: "#00008B",
			darkcyan: "#008B8B",
			darkgoldenrod: "#B8860B",
			darkgray: "#A9A9A9",
			darkgrey: "#A9A9A9",
			darkgreen: "#006400",
			darkkhaki: "#BDB76B",
			darkmagenta: "#8B008B",
			darkolivegreen: "#556B2F",
			darkorange: "#FF8C00",
			darkorchid: "#9932CC",
			darkred: "#8B0000",
			darksalmon: "#E9967A",
			darkseagreen: "#8FBC8F",
			darkslateblue: "#483D8B",
			darkslategray: "#2F4F4F",
			darkslategrey: "#2F4F4F",
			darkturquoise: "#00CED1",
			darkviolet: "#9400D3",
			deeppink: "#FF1493",
			deepskyblue: "#00BFFF",
			dimgray: "#696969",
			dimgrey: "#696969",
			dodgerblue: "#1E90FF",
			firebrick: "#B22222",
			floralwhite: "#FFFAF0",
			forestgreen: "#228B22",
			fuchsia: "#FF00FF",
			gainsboro: "#DCDCDC",
			ghostwhite: "#F8F8FF",
			gold: "#FFD700",
			goldenrod: "#DAA520",
			gray: "#808080",
			grey: "#808080",
			green: "#008000",
			greenyellow: "#ADFF2F",
			honeydew: "#F0FFF0",
			hotpink: "#FF69B4",
			indianred: "#CD5C5C",
			indigo: "#4B0082",
			ivory: "#FFFFF0",
			khaki: "#F0E68C",
			lavender: "#E6E6FA",
			lavenderblush: "#FFF0F5",
			lawngreen: "#7CFC00",
			lemonchiffon: "#FFFACD",
			lightblue: "#ADD8E6",
			lightcoral: "#F08080",
			lightcyan: "#E0FFFF",
			lightgoldenrodyellow: "#FAFAD2",
			lightgray: "#D3D3D3",
			lightgrey: "#D3D3D3",
			lightgreen: "#90EE90",
			lightpink: "#FFB6C1",
			lightsalmon: "#FFA07A",
			lightseagreen: "#20B2AA",
			lightskyblue: "#87CEFA",
			lightslategray: "#778899",
			lightslategrey: "#778899",
			lightsteelblue: "#B0C4DE",
			lightyellow: "#FFFFE0",
			lime: "#00FF00",
			limegreen: "#32CD32",
			linen: "#FAF0E6",
			magenta: "#FF00FF",
			maroon: "#800000",
			mediumaquamarine: "#66CDAA",
			mediumblue: "#0000CD",
			mediumorchid: "#BA55D3",
			mediumpurple: "#9370DB",
			mediumseagreen: "#3CB371",
			mediumslateblue: "#7B68EE",
			mediumspringgreen: "#00FA9A",
			mediumturquoise: "#48D1CC",
			mediumvioletred: "#C71585",
			midnightblue: "#191970",
			mintcream: "#F5FFFA",
			mistyrose: "#FFE4E1",
			moccasin: "#FFE4B5",
			navajowhite: "#FFDEAD",
			navy: "#000080",
			oldlace: "#FDF5E6",
			olive: "#808000",
			olivedrab: "#6B8E23",
			orange: "#FFA500",
			orangered: "#FF4500",
			orchid: "#DA70D6",
			palegoldenrod: "#EEE8AA",
			palegreen: "#98FB98",
			paleturquoise: "#AFEEEE",
			palevioletred: "#DB7093",
			papayawhip: "#FFEFD5",
			peachpuff: "#FFDAB9",
			peru: "#CD853F",
			pink: "#FFC0CB",
			plum: "#DDA0DD",
			powderblue: "#B0E0E6",
			purple: "#800080",
			rebeccapurple: "#663399",
			red: "#FF0000",
			rosybrown: "#BC8F8F",
			royalblue: "#4169E1",
			saddlebrown: "#8B4513",
			salmon: "#FA8072",
			sandybrown: "#F4A460",
			seagreen: "#2E8B57",
			seashell: "#FFF5EE",
			sienna: "#A0522D",
			silver: "#C0C0C0",
			skyblue: "#87CEEB",
			slateblue: "#6A5ACD",
			slategray: "#708090",
			slategrey: "#708090",
			snow: "#FFFAFA",
			springgreen: "#00FF7F",
			steelblue: "#4682B4",
			tan: "#D2B48C",
			teal: "#008080",
			thistle: "#D8BFD8",
			tomato: "#FF6347",
			turquoise: "#40E0D0",
			violet: "#EE82EE",
			wheat: "#F5DEB3",
			white: "#FFFFFF",
			whitesmoke: "#F5F5F5",
			yellow: "#FFFF00",
			yellowgreen: "#9ACD32"
		};
		function C(m, x, S) {
			return S < 0 && (S += 1), S > 1 && --S, S < 1 / 6 ? m + (x - m) * 6 * S : S < 1 / 2 ? x : S < 2 / 3 ? m + (x - m) * (2 / 3 - S) * 6 : m;
		}
		x.Color.fromRgb = function(m) {
			return S.fromSource(S.sourceFromRgb(m));
		}, x.Color.sourceFromRgb = function(m) {
			var x = m.match(S.reRGBa);
			if (x) {
				var C = parseInt(x[1], 10) / (/%$/.test(x[1]) ? 100 : 1) * (/%$/.test(x[1]) ? 255 : 1), T = parseInt(x[2], 10) / (/%$/.test(x[2]) ? 100 : 1) * (/%$/.test(x[2]) ? 255 : 1), D = parseInt(x[3], 10) / (/%$/.test(x[3]) ? 100 : 1) * (/%$/.test(x[3]) ? 255 : 1);
				return [
					parseInt(C, 10),
					parseInt(T, 10),
					parseInt(D, 10),
					x[4] ? parseFloat(x[4]) : 1
				];
			}
		}, x.Color.fromRgba = S.fromRgb, x.Color.fromHsl = function(m) {
			return S.fromSource(S.sourceFromHsl(m));
		}, x.Color.sourceFromHsl = function(m) {
			var x = m.match(S.reHSLa);
			if (x) {
				var T = (parseFloat(x[1]) % 360 + 360) % 360 / 360, D = parseFloat(x[2]) / (/%$/.test(x[2]) ? 100 : 1), O = parseFloat(x[3]) / (/%$/.test(x[3]) ? 100 : 1), k, A, j;
				if (D === 0) k = A = j = O;
				else {
					var M = O <= .5 ? O * (D + 1) : O + D - O * D, N = O * 2 - M;
					k = C(N, M, T + 1 / 3), A = C(N, M, T), j = C(N, M, T - 1 / 3);
				}
				return [
					Math.round(k * 255),
					Math.round(A * 255),
					Math.round(j * 255),
					x[4] ? parseFloat(x[4]) : 1
				];
			}
		}, x.Color.fromHsla = S.fromHsl, x.Color.fromHex = function(m) {
			return S.fromSource(S.sourceFromHex(m));
		}, x.Color.sourceFromHex = function(m) {
			if (m.match(S.reHex)) {
				var x = m.slice(m.indexOf("#") + 1), C = x.length === 3 || x.length === 4, T = x.length === 8 || x.length === 4, D = C ? x.charAt(0) + x.charAt(0) : x.substring(0, 2), O = C ? x.charAt(1) + x.charAt(1) : x.substring(2, 4), k = C ? x.charAt(2) + x.charAt(2) : x.substring(4, 6), A = T ? C ? x.charAt(3) + x.charAt(3) : x.substring(6, 8) : "FF";
				return [
					parseInt(D, 16),
					parseInt(O, 16),
					parseInt(k, 16),
					parseFloat((parseInt(A, 16) / 255).toFixed(2))
				];
			}
		}, x.Color.fromSource = function(m) {
			var x = new S();
			return x.setSource(m), x;
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = [
			"e",
			"se",
			"s",
			"sw",
			"w",
			"nw",
			"n",
			"ne",
			"e"
		], C = [
			"ns",
			"nesw",
			"ew",
			"nwse"
		], T = {}, D = "left", O = "top", k = "right", A = "bottom", j = "center", M = {
			top: A,
			bottom: O,
			left: k,
			right: D,
			center: j
		}, N = x.util.radiansToDegrees, P = Math.sign || function(m) {
			return (m > 0) - (m < 0) || +m;
		};
		function F(m, x) {
			var S = m.angle + N(Math.atan2(x.y, x.x)) + 360;
			return Math.round(S % 360 / 45);
		}
		function I(m, S) {
			var C = S.transform.target, T = C.canvas, D = x.util.object.clone(S);
			D.target = C, T && T.fire("object:" + m, D), C.fire(m, S);
		}
		function L(m, x) {
			var S = x.canvas, C = m[S.uniScaleKey];
			return S.uniformScaling && !C || !S.uniformScaling && C;
		}
		function R(m) {
			return m.originX === j && m.originY === j;
		}
		function z(m, x, S) {
			var C = m.lockScalingX, T = m.lockScalingY;
			return !!(C && T || !x && (C || T) && S || C && x === "x" || T && x === "y");
		}
		function B(m, x, C) {
			var T = "not-allowed", D = L(m, C), O = "";
			return x.x !== 0 && x.y === 0 ? O = "x" : x.x === 0 && x.y !== 0 && (O = "y"), z(C, O, D) ? T : S[F(C, x)] + "-resize";
		}
		function H(m, x, S) {
			return x.x !== 0 && S.lockSkewingY || x.y !== 0 && S.lockSkewingX ? "not-allowed" : C[F(S, x) % 4] + "-resize";
		}
		function U(m, x, S) {
			return m[S.canvas.altActionKey] ? T.skewCursorStyleHandler(m, x, S) : T.scaleCursorStyleHandler(m, x, S);
		}
		function W(m, x, S) {
			var C = m[S.canvas.altActionKey];
			if (x.x === 0) return C ? "skewX" : "scaleY";
			if (x.y === 0) return C ? "skewY" : "scaleX";
		}
		function G(m, x, S) {
			return S.lockRotation ? "not-allowed" : x.cursorStyle;
		}
		function K(m, x, S, C) {
			return {
				e: m,
				transform: x,
				pointer: {
					x: S,
					y: C
				}
			};
		}
		function q(m) {
			return function(x, S, C, T) {
				var D = S.target, O = D.getCenterPoint(), k = D.translateToOriginPoint(O, S.originX, S.originY), A = m(x, S, C, T);
				return D.setPositionByOrigin(k, S.originX, S.originY), A;
			};
		}
		function J(m, x) {
			return function(S, C, T, D) {
				var O = x(S, C, T, D);
				return O && I(m, K(S, C, T, D)), O;
			};
		}
		function Y(m, S, C, T, D) {
			var O = m.target, k = O.controls[m.corner], A = O.canvas.getZoom(), j = O.padding / A, M = O.toLocalPoint(new x.Point(T, D), S, C);
			return M.x >= j && (M.x -= j), M.x <= -j && (M.x += j), M.y >= j && (M.y -= j), M.y <= j && (M.y += j), M.x -= k.offsetX, M.y -= k.offsetY, M;
		}
		function X(m) {
			return m.flipX !== m.flipY;
		}
		function Z(m, x, S, C, T) {
			if (m[x] !== 0) {
				var D = T / m._getTransformedDimensions()[C] * m[S];
				m.set(S, D);
			}
		}
		function sH(m, x, S, C) {
			var T = x.target, j = T._getTransformedDimensions(0, T.skewY), M = Y(x, x.originX, x.originY, S, C), P = Math.abs(M.x * 2) - j.x, F = T.skewX, I;
			P < 2 ? I = 0 : (I = N(Math.atan2(P / T.scaleX, j.y / T.scaleY)), x.originX === D && x.originY === A && (I = -I), x.originX === k && x.originY === O && (I = -I), X(T) && (I = -I));
			var L = F !== I;
			if (L) {
				var R = T._getTransformedDimensions().y;
				T.set("skewX", I), Z(T, "skewY", "scaleY", "y", R);
			}
			return L;
		}
		function Q(m, x, S, C) {
			var T = x.target, j = T._getTransformedDimensions(T.skewX, 0), M = Y(x, x.originX, x.originY, S, C), P = Math.abs(M.y * 2) - j.y, F = T.skewY, I;
			P < 2 ? I = 0 : (I = N(Math.atan2(P / T.scaleY, j.x / T.scaleX)), x.originX === D && x.originY === A && (I = -I), x.originX === k && x.originY === O && (I = -I), X(T) && (I = -I));
			var L = F !== I;
			if (L) {
				var R = T._getTransformedDimensions().x;
				T.set("skewY", I), Z(T, "skewX", "scaleX", "x", R);
			}
			return L;
		}
		function cH(m, x, S, C) {
			var T = x.target, A = T.skewX, M, N = x.originY;
			return T.lockSkewingX ? !1 : (A === 0 ? M = Y(x, j, j, S, C).x > 0 ? D : k : (A > 0 && (M = N === O ? D : k), A < 0 && (M = N === O ? k : D), X(T) && (M = M === D ? k : D)), x.originX = M, J("skewing", q(sH))(m, x, S, C));
		}
		function lH(m, x, S, C) {
			var T = x.target, k = T.skewY, M, N = x.originX;
			return T.lockSkewingY ? !1 : (k === 0 ? M = Y(x, j, j, S, C).y > 0 ? O : A : (k > 0 && (M = N === D ? O : A), k < 0 && (M = N === D ? A : O), X(T) && (M = M === O ? A : O)), x.originY = M, J("skewing", q(Q))(m, x, S, C));
		}
		function uH(m, x, S, C) {
			var T = x, D = T.target, O = D.translateToOriginPoint(D.getCenterPoint(), T.originX, T.originY);
			if (D.lockRotation) return !1;
			var k = Math.atan2(T.ey - O.y, T.ex - O.x), A = N(Math.atan2(C - O.y, S - O.x) - k + T.theta), j = !0;
			if (D.snapAngle > 0) {
				var M = D.snapAngle, P = D.snapThreshold || M, F = Math.ceil(A / M) * M, I = Math.floor(A / M) * M;
				Math.abs(A - I) < P ? A = I : Math.abs(A - F) < P && (A = F);
			}
			return A < 0 && (A = 360 + A), A %= 360, j = D.angle !== A, D.angle = A, j;
		}
		function dH(m, x, S, C, T) {
			T ||= {};
			var D = x.target, O = D.lockScalingX, k = D.lockScalingY, A = T.by, j, N, F, I, B = L(m, D), H = z(D, A, B), U, W, G = x.gestureScale;
			if (H) return !1;
			if (G) N = x.scaleX * G, F = x.scaleY * G;
			else {
				if (j = Y(x, x.originX, x.originY, S, C), U = A === "y" ? 1 : P(j.x), W = A === "x" ? 1 : P(j.y), x.signX ||= U, x.signY ||= W, D.lockScalingFlip && (x.signX !== U || x.signY !== W)) return !1;
				if (I = D._getTransformedDimensions(), B && !A) {
					var K = Math.abs(j.x) + Math.abs(j.y), q = x.original, J = K / (Math.abs(I.x * q.scaleX / D.scaleX) + Math.abs(I.y * q.scaleY / D.scaleY));
					N = q.scaleX * J, F = q.scaleY * J;
				} else N = Math.abs(j.x * D.scaleX / I.x), F = Math.abs(j.y * D.scaleY / I.y);
				R(x) && (N *= 2, F *= 2), x.signX !== U && A !== "y" && (x.originX = M[x.originX], N *= -1, x.signX = U), x.signY !== W && A !== "x" && (x.originY = M[x.originY], F *= -1, x.signY = W);
			}
			var X = D.scaleX, Z = D.scaleY;
			return A ? (A === "x" && D.set("scaleX", N), A === "y" && D.set("scaleY", F)) : (!O && D.set("scaleX", N), !k && D.set("scaleY", F)), X !== D.scaleX || Z !== D.scaleY;
		}
		function fH(m, x, S, C) {
			return dH(m, x, S, C);
		}
		function pH(m, x, S, C) {
			return dH(m, x, S, C, { by: "x" });
		}
		function mH(m, x, S, C) {
			return dH(m, x, S, C, { by: "y" });
		}
		function hH(m, x, S, C) {
			return m[x.target.canvas.altActionKey] ? T.skewHandlerX(m, x, S, C) : T.scalingY(m, x, S, C);
		}
		function gH(m, x, S, C) {
			return m[x.target.canvas.altActionKey] ? T.skewHandlerY(m, x, S, C) : T.scalingX(m, x, S, C);
		}
		function $(m, x, S, C) {
			var T = x.target, D = Y(x, x.originX, x.originY, S, C), O = T.strokeWidth / (T.strokeUniform ? T.scaleX : 1), k = R(x) ? 2 : 1, A = T.width, j = Math.abs(D.x * k / T.scaleX) - O;
			return T.set("width", Math.max(j, 0)), A !== j;
		}
		function _H(m, x, S, C) {
			var T = x.target, D = S - x.offsetX, O = C - x.offsetY, k = !T.get("lockMovementX") && T.left !== D, A = !T.get("lockMovementY") && T.top !== O;
			return k && T.set("left", D), A && T.set("top", O), (k || A) && I("moving", K(m, x, S, C)), k || A;
		}
		T.scaleCursorStyleHandler = B, T.skewCursorStyleHandler = H, T.scaleSkewCursorStyleHandler = U, T.rotationWithSnapping = J("rotating", q(uH)), T.scalingEqually = J("scaling", q(fH)), T.scalingX = J("scaling", q(pH)), T.scalingY = J("scaling", q(mH)), T.scalingYOrSkewingX = hH, T.scalingXOrSkewingY = gH, T.changeWidth = J("resizing", q($)), T.skewHandlerX = cH, T.skewHandlerY = lH, T.dragHandler = _H, T.scaleOrSkewActionName = W, T.rotationStyleHandler = G, T.fireEvent = I, T.wrapWithFixedAnchor = q, T.wrapWithFireEvent = J, T.getLocalPoint = Y, x.controlsUtils = T;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.degreesToRadians, C = x.controlsUtils;
		function T(m, x, S, C, T) {
			C ||= {};
			var D = this.sizeX || C.cornerSize || T.cornerSize, O = this.sizeY || C.cornerSize || T.cornerSize, k = C.transparentCorners === void 0 ? T.transparentCorners : C.transparentCorners, A = k ? "stroke" : "fill", j = !k && (C.cornerStrokeColor || T.cornerStrokeColor), M = x, N = S, P;
			m.save(), m.fillStyle = C.cornerColor || T.cornerColor, m.strokeStyle = C.cornerStrokeColor || T.cornerStrokeColor, D > O ? (P = D, m.scale(1, O / D), N = S * D / O) : O > D ? (P = O, m.scale(D / O, 1), M = x * O / D) : P = D, m.lineWidth = 1, m.beginPath(), m.arc(M, N, P / 2, 0, 2 * Math.PI, !1), m[A](), j && m.stroke(), m.restore();
		}
		function D(m, x, C, T, D) {
			T ||= {};
			var O = this.sizeX || T.cornerSize || D.cornerSize, k = this.sizeY || T.cornerSize || D.cornerSize, A = T.transparentCorners === void 0 ? D.transparentCorners : T.transparentCorners, j = A ? "stroke" : "fill", M = !A && (T.cornerStrokeColor || D.cornerStrokeColor), N = O / 2, P = k / 2;
			m.save(), m.fillStyle = T.cornerColor || D.cornerColor, m.strokeStyle = T.cornerStrokeColor || D.cornerStrokeColor, m.lineWidth = 1, m.translate(x, C), m.rotate(S(D.angle)), m[j + "Rect"](-N, -P, O, k), M && m.strokeRect(-N, -P, O, k), m.restore();
		}
		C.renderCircleControl = T, C.renderSquareControl = D;
	})(m), (function(m) {
		var x = m.fabric ||= {};
		function S(m) {
			for (var x in m) this[x] = m[x];
		}
		x.Control = S, x.Control.prototype = {
			visible: !0,
			actionName: "scale",
			angle: 0,
			x: 0,
			y: 0,
			offsetX: 0,
			offsetY: 0,
			sizeX: null,
			sizeY: null,
			touchSizeX: null,
			touchSizeY: null,
			cursorStyle: "crosshair",
			withConnection: !1,
			actionHandler: function() {},
			mouseDownHandler: function() {},
			mouseUpHandler: function() {},
			getActionHandler: function() {
				return this.actionHandler;
			},
			getMouseDownHandler: function() {
				return this.mouseDownHandler;
			},
			getMouseUpHandler: function() {
				return this.mouseUpHandler;
			},
			cursorStyleHandler: function(m, x) {
				return x.cursorStyle;
			},
			getActionName: function(m, x) {
				return x.actionName;
			},
			getVisibility: function(m, x) {
				var S = m._controlsVisibility;
				return S && S[x] !== void 0 ? S[x] : this.visible;
			},
			setVisibility: function(m) {
				this.visible = m;
			},
			positionHandler: function(m, S) {
				return x.util.transformPoint({
					x: this.x * m.x + this.offsetX,
					y: this.y * m.y + this.offsetY
				}, S);
			},
			calcCornerCoords: function(m, S, C, T, D) {
				var O, k, A, j, M = D ? this.touchSizeX : this.sizeX, N = D ? this.touchSizeY : this.sizeY;
				if (M && N && M !== N) {
					var P = Math.atan2(N, M), F = Math.sqrt(M * M + N * N) / 2, I = P - x.util.degreesToRadians(m), L = Math.PI / 2 - P - x.util.degreesToRadians(m);
					O = F * x.util.cos(I), k = F * x.util.sin(I), A = F * x.util.cos(L), j = F * x.util.sin(L);
				} else {
					F = (M && N ? M : S) * .7071067812;
					var I = x.util.degreesToRadians(45 - m);
					O = A = F * x.util.cos(I), k = j = F * x.util.sin(I);
				}
				return {
					tl: {
						x: C - j,
						y: T - A
					},
					tr: {
						x: C + O,
						y: T - k
					},
					bl: {
						x: C - O,
						y: T + k
					},
					br: {
						x: C + j,
						y: T + A
					}
				};
			},
			render: function(m, S, C, T, D) {
				switch (T ||= {}, T.cornerStyle || D.cornerStyle) {
					case "circle":
						x.controlsUtils.renderCircleControl.call(this, m, S, C, T, D);
						break;
					default: x.controlsUtils.renderSquareControl.call(this, m, S, C, T, D);
				}
			}
		};
	})(m), (function() {
		function m(m, S) {
			var C = m.getAttribute("style"), T = m.getAttribute("offset") || 0, D, O, k, A;
			if (T = parseFloat(T) / (/%$/.test(T) ? 100 : 1), T = T < 0 ? 0 : T > 1 ? 1 : T, C) {
				var j = C.split(/\s*;\s*/);
				for (j[j.length - 1] === "" && j.pop(), A = j.length; A--;) {
					var M = j[A].split(/\s*:\s*/), N = M[0].trim(), P = M[1].trim();
					N === "stop-color" ? D = P : N === "stop-opacity" && (k = P);
				}
			}
			return D ||= m.getAttribute("stop-color") || "rgb(0,0,0)", k ||= m.getAttribute("stop-opacity"), D = new x.Color(D), O = D.getAlpha(), k = isNaN(parseFloat(k)) ? 1 : parseFloat(k), k *= O * S, {
				offset: T,
				color: D.toRgb(),
				opacity: k
			};
		}
		function S(m) {
			return {
				x1: m.getAttribute("x1") || 0,
				y1: m.getAttribute("y1") || 0,
				x2: m.getAttribute("x2") || "100%",
				y2: m.getAttribute("y2") || 0
			};
		}
		function C(m) {
			return {
				x1: m.getAttribute("fx") || m.getAttribute("cx") || "50%",
				y1: m.getAttribute("fy") || m.getAttribute("cy") || "50%",
				r1: 0,
				x2: m.getAttribute("cx") || "50%",
				y2: m.getAttribute("cy") || "50%",
				r2: m.getAttribute("r") || "50%"
			};
		}
		var T = x.util.object.clone;
		x.Gradient = x.util.createClass({
			offsetX: 0,
			offsetY: 0,
			gradientTransform: null,
			gradientUnits: "pixels",
			type: "linear",
			initialize: function(m) {
				m ||= {}, m.coords ||= {};
				var S, C = this;
				Object.keys(m).forEach(function(x) {
					C[x] = m[x];
				}), this.id ? this.id += "_" + x.Object.__uid++ : this.id = x.Object.__uid++, S = {
					x1: m.coords.x1 || 0,
					y1: m.coords.y1 || 0,
					x2: m.coords.x2 || 0,
					y2: m.coords.y2 || 0
				}, this.type === "radial" && (S.r1 = m.coords.r1 || 0, S.r2 = m.coords.r2 || 0), this.coords = S, this.colorStops = m.colorStops.slice();
			},
			addColorStop: function(m) {
				for (var S in m) {
					var C = new x.Color(m[S]);
					this.colorStops.push({
						offset: parseFloat(S),
						color: C.toRgb(),
						opacity: C.getAlpha()
					});
				}
				return this;
			},
			toObject: function(m) {
				var S = {
					type: this.type,
					coords: this.coords,
					colorStops: this.colorStops,
					offsetX: this.offsetX,
					offsetY: this.offsetY,
					gradientUnits: this.gradientUnits,
					gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
				};
				return x.util.populateWithProperties(this, S, m), S;
			},
			toSVG: function(m, S) {
				var C = T(this.coords, !0), D, O, S = S || {}, k, A, j = T(this.colorStops, !0), M = C.r1 > C.r2, N = this.gradientTransform ? this.gradientTransform.concat() : x.iMatrix.concat(), P = -this.offsetX, F = -this.offsetY, I = !!S.additionalTransform, L = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox";
				if (j.sort(function(m, x) {
					return m.offset - x.offset;
				}), L === "objectBoundingBox" ? (P /= m.width, F /= m.height) : (P += m.width / 2, F += m.height / 2), m.type === "path" && this.gradientUnits !== "percentage" && (P -= m.pathOffset.x, F -= m.pathOffset.y), N[4] -= P, N[5] -= F, A = "id=\"SVGID_" + this.id + "\" gradientUnits=\"" + L + "\"", A += " gradientTransform=\"" + (I ? S.additionalTransform + " " : "") + x.util.matrixToSVG(N) + "\" ", this.type === "linear" ? k = [
					"<linearGradient ",
					A,
					" x1=\"",
					C.x1,
					"\" y1=\"",
					C.y1,
					"\" x2=\"",
					C.x2,
					"\" y2=\"",
					C.y2,
					"\">\n"
				] : this.type === "radial" && (k = [
					"<radialGradient ",
					A,
					" cx=\"",
					M ? C.x1 : C.x2,
					"\" cy=\"",
					M ? C.y1 : C.y2,
					"\" r=\"",
					M ? C.r1 : C.r2,
					"\" fx=\"",
					M ? C.x2 : C.x1,
					"\" fy=\"",
					M ? C.y2 : C.y1,
					"\">\n"
				]), this.type === "radial") {
					if (M) for (j = j.concat(), j.reverse(), D = 0, O = j.length; D < O; D++) j[D].offset = 1 - j[D].offset;
					var R = Math.min(C.r1, C.r2);
					if (R > 0) {
						var z = R / Math.max(C.r1, C.r2);
						for (D = 0, O = j.length; D < O; D++) j[D].offset += z * (1 - j[D].offset);
					}
				}
				for (D = 0, O = j.length; D < O; D++) {
					var B = j[D];
					k.push("<stop ", "offset=\"", B.offset * 100 + "%", "\" style=\"stop-color:", B.color, B.opacity === void 0 ? ";" : ";stop-opacity: " + B.opacity, "\"/>\n");
				}
				return k.push(this.type === "linear" ? "</linearGradient>\n" : "</radialGradient>\n"), k.join("");
			},
			toLive: function(m) {
				var S, C = x.util.object.clone(this.coords), T, D;
				if (this.type) {
					for (this.type === "linear" ? S = m.createLinearGradient(C.x1, C.y1, C.x2, C.y2) : this.type === "radial" && (S = m.createRadialGradient(C.x1, C.y1, C.r1, C.x2, C.y2, C.r2)), T = 0, D = this.colorStops.length; T < D; T++) {
						var O = this.colorStops[T].color, k = this.colorStops[T].opacity, A = this.colorStops[T].offset;
						k !== void 0 && (O = new x.Color(O).setAlpha(k).toRgba()), S.addColorStop(A, O);
					}
					return S;
				}
			}
		}), x.util.object.extend(x.Gradient, { fromElement: function(T, O, k, A) {
			var j = parseFloat(k) / (/%$/.test(k) ? 100 : 1);
			j = j < 0 ? 0 : j > 1 ? 1 : j, isNaN(j) && (j = 1);
			var M = T.getElementsByTagName("stop"), N, P = T.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", F = T.getAttribute("gradientTransform") || "", I = [], L, R, z = 0, B = 0, H;
			for (T.nodeName === "linearGradient" || T.nodeName === "LINEARGRADIENT" ? (N = "linear", L = S(T)) : (N = "radial", L = C(T)), R = M.length; R--;) I.push(m(M[R], j));
			return H = x.parseTransformAttribute(F), D(O, L, A, P), P === "pixels" && (z = -O.left, B = -O.top), new x.Gradient({
				id: T.getAttribute("id"),
				type: N,
				coords: L,
				colorStops: I,
				gradientUnits: P,
				gradientTransform: H,
				offsetX: z,
				offsetY: B
			});
		} });
		function D(m, x, S, C) {
			var T, D;
			Object.keys(x).forEach(function(m) {
				T = x[m], T === "Infinity" ? D = 1 : T === "-Infinity" ? D = 0 : (D = parseFloat(x[m], 10), typeof T == "string" && /^(\d+\.\d+)%|(\d+)%$/.test(T) && (D *= .01, C === "pixels" && ((m === "x1" || m === "x2" || m === "r2") && (D *= S.viewBoxWidth || S.width), (m === "y1" || m === "y2") && (D *= S.viewBoxHeight || S.height)))), x[m] = D;
			});
		}
	})(), (function() {
		var m = x.util.toFixed;
		x.Pattern = x.util.createClass({
			repeat: "repeat",
			offsetX: 0,
			offsetY: 0,
			crossOrigin: "",
			patternTransform: null,
			initialize: function(m, S) {
				if (m ||= {}, this.id = x.Object.__uid++, this.setOptions(m), !m.source || m.source && typeof m.source != "string") {
					S && S(this);
					return;
				} else {
					var C = this;
					this.source = x.util.createImage(), x.util.loadImage(m.source, function(m, x) {
						C.source = m, S && S(C, x);
					}, null, this.crossOrigin);
				}
			},
			toObject: function(S) {
				var C = x.Object.NUM_FRACTION_DIGITS, T, D;
				return typeof this.source.src == "string" ? T = this.source.src : typeof this.source == "object" && this.source.toDataURL && (T = this.source.toDataURL()), D = {
					type: "pattern",
					source: T,
					repeat: this.repeat,
					crossOrigin: this.crossOrigin,
					offsetX: m(this.offsetX, C),
					offsetY: m(this.offsetY, C),
					patternTransform: this.patternTransform ? this.patternTransform.concat() : null
				}, x.util.populateWithProperties(this, D, S), D;
			},
			toSVG: function(m) {
				var x = typeof this.source == "function" ? this.source() : this.source, S = x.width / m.width, C = x.height / m.height, T = this.offsetX / m.width, D = this.offsetY / m.height, O = "";
				return (this.repeat === "repeat-x" || this.repeat === "no-repeat") && (C = 1, D && (C += Math.abs(D))), (this.repeat === "repeat-y" || this.repeat === "no-repeat") && (S = 1, T && (S += Math.abs(T))), x.src ? O = x.src : x.toDataURL && (O = x.toDataURL()), "<pattern id=\"SVGID_" + this.id + "\" x=\"" + T + "\" y=\"" + D + "\" width=\"" + S + "\" height=\"" + C + "\">\n<image x=\"0\" y=\"0\" width=\"" + x.width + "\" height=\"" + x.height + "\" xlink:href=\"" + O + "\"></image>\n</pattern>\n";
			},
			setOptions: function(m) {
				for (var x in m) this[x] = m[x];
			},
			toLive: function(m) {
				var x = this.source;
				return !x || x.src !== void 0 && (!x.complete || x.naturalWidth === 0 || x.naturalHeight === 0) ? "" : m.createPattern(x, this.repeat);
			}
		});
	})(), (function(m) {
		var x = m.fabric ||= {}, S = x.util.toFixed;
		if (x.Shadow) {
			x.warn("fabric.Shadow is already defined.");
			return;
		}
		x.Shadow = x.util.createClass({
			color: "rgb(0,0,0)",
			blur: 0,
			offsetX: 0,
			offsetY: 0,
			affectStroke: !1,
			includeDefaultValues: !0,
			nonScaling: !1,
			initialize: function(m) {
				for (var S in typeof m == "string" && (m = this._parseShadow(m)), m) this[S] = m[S];
				this.id = x.Object.__uid++;
			},
			_parseShadow: function(m) {
				var S = m.trim(), C = x.Shadow.reOffsetsAndBlur.exec(S) || [];
				return {
					color: (S.replace(x.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)").trim(),
					offsetX: parseFloat(C[1], 10) || 0,
					offsetY: parseFloat(C[2], 10) || 0,
					blur: parseFloat(C[3], 10) || 0
				};
			},
			toString: function() {
				return [
					this.offsetX,
					this.offsetY,
					this.blur,
					this.color
				].join("px ");
			},
			toSVG: function(m) {
				var C = 40, T = 40, D = x.Object.NUM_FRACTION_DIGITS, O = x.util.rotateVector({
					x: this.offsetX,
					y: this.offsetY
				}, x.util.degreesToRadians(-m.angle)), k = 20, A = new x.Color(this.color);
				return m.width && m.height && (C = S((Math.abs(O.x) + this.blur) / m.width, D) * 100 + k, T = S((Math.abs(O.y) + this.blur) / m.height, D) * 100 + k), m.flipX && (O.x *= -1), m.flipY && (O.y *= -1), "<filter id=\"SVGID_" + this.id + "\" y=\"-" + T + "%\" height=\"" + (100 + 2 * T) + "%\" x=\"-" + C + "%\" width=\"" + (100 + 2 * C) + "%\" >\n	<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"" + S(this.blur ? this.blur / 2 : 0, D) + "\"></feGaussianBlur>\n	<feOffset dx=\"" + S(O.x, D) + "\" dy=\"" + S(O.y, D) + "\" result=\"oBlur\" ></feOffset>\n	<feFlood flood-color=\"" + A.toRgb() + "\" flood-opacity=\"" + A.getAlpha() + "\"/>\n	<feComposite in2=\"oBlur\" operator=\"in\" />\n	<feMerge>\n		<feMergeNode></feMergeNode>\n		<feMergeNode in=\"SourceGraphic\"></feMergeNode>\n	</feMerge>\n</filter>\n";
			},
			toObject: function() {
				if (this.includeDefaultValues) return {
					color: this.color,
					blur: this.blur,
					offsetX: this.offsetX,
					offsetY: this.offsetY,
					affectStroke: this.affectStroke,
					nonScaling: this.nonScaling
				};
				var m = {}, S = x.Shadow.prototype;
				return [
					"color",
					"blur",
					"offsetX",
					"offsetY",
					"affectStroke",
					"nonScaling"
				].forEach(function(x) {
					this[x] !== S[x] && (m[x] = this[x]);
				}, this), m;
			}
		}), x.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/;
	})(m), (function() {
		if (x.StaticCanvas) {
			x.warn("fabric.StaticCanvas is already defined.");
			return;
		}
		var m = x.util.object.extend, S = x.util.getElementOffset, C = x.util.removeFromArray, T = x.util.toFixed, D = x.util.transformPoint, O = x.util.invertTransform, k = x.util.getNodeCanvas, A = x.util.createCanvasElement, j = /* @__PURE__ */ Error("Could not initialize `canvas` element");
		x.StaticCanvas = x.util.createClass(x.CommonMethods, {
			initialize: function(m, x) {
				x ||= {}, this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(m, x);
			},
			backgroundColor: "",
			backgroundImage: null,
			overlayColor: "",
			overlayImage: null,
			includeDefaultValues: !0,
			stateful: !1,
			renderOnAddRemove: !0,
			controlsAboveOverlay: !1,
			allowTouchScrolling: !1,
			imageSmoothingEnabled: !0,
			viewportTransform: x.iMatrix.concat(),
			backgroundVpt: !0,
			overlayVpt: !0,
			enableRetinaScaling: !0,
			vptCoords: {},
			skipOffscreen: !0,
			clipPath: void 0,
			_initStatic: function(m, x) {
				var S = this.requestRenderAllBound;
				this._objects = [], this._createLowerCanvas(m), this._initOptions(x), this.interactive || this._initRetinaScaling(), x.overlayImage && this.setOverlayImage(x.overlayImage, S), x.backgroundImage && this.setBackgroundImage(x.backgroundImage, S), x.backgroundColor && this.setBackgroundColor(x.backgroundColor, S), x.overlayColor && this.setOverlayColor(x.overlayColor, S), this.calcOffset();
			},
			_isRetinaScaling: function() {
				return x.devicePixelRatio > 1 && this.enableRetinaScaling;
			},
			getRetinaScaling: function() {
				return this._isRetinaScaling() ? Math.max(1, x.devicePixelRatio) : 1;
			},
			_initRetinaScaling: function() {
				if (this._isRetinaScaling()) {
					var m = x.devicePixelRatio;
					this.__initRetinaScaling(m, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(m, this.upperCanvasEl, this.contextTop);
				}
			},
			__initRetinaScaling: function(m, x, S) {
				x.setAttribute("width", this.width * m), x.setAttribute("height", this.height * m), S.scale(m, m);
			},
			calcOffset: function() {
				return this._offset = S(this.lowerCanvasEl), this;
			},
			setOverlayImage: function(m, x, S) {
				return this.__setBgOverlayImage("overlayImage", m, x, S);
			},
			setBackgroundImage: function(m, x, S) {
				return this.__setBgOverlayImage("backgroundImage", m, x, S);
			},
			setOverlayColor: function(m, x) {
				return this.__setBgOverlayColor("overlayColor", m, x);
			},
			setBackgroundColor: function(m, x) {
				return this.__setBgOverlayColor("backgroundColor", m, x);
			},
			__setBgOverlayImage: function(m, S, C, T) {
				return typeof S == "string" ? x.util.loadImage(S, function(S, D) {
					if (S) {
						var O = new x.Image(S, T);
						this[m] = O, O.canvas = this;
					}
					C && C(S, D);
				}, this, T && T.crossOrigin) : (T && S.setOptions(T), this[m] = S, S && (S.canvas = this), C && C(S, !1)), this;
			},
			__setBgOverlayColor: function(m, x, S) {
				return this[m] = x, this._initGradient(x, m), this._initPattern(x, m, S), this;
			},
			_createCanvasElement: function() {
				var m = A();
				if (!m || (m.style ||= {}, m.getContext === void 0)) throw j;
				return m;
			},
			_initOptions: function(m) {
				var x = this.lowerCanvasEl;
				this._setOptions(m), this.width = this.width || parseInt(x.width, 10) || 0, this.height = this.height || parseInt(x.height, 10) || 0, this.lowerCanvasEl.style && (x.width = this.width, x.height = this.height, x.style.width = this.width + "px", x.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice());
			},
			_createLowerCanvas: function(m) {
				m && m.getContext ? this.lowerCanvasEl = m : this.lowerCanvasEl = x.util.getById(m) || this._createCanvasElement(), x.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d");
			},
			getWidth: function() {
				return this.width;
			},
			getHeight: function() {
				return this.height;
			},
			setWidth: function(m, x) {
				return this.setDimensions({ width: m }, x);
			},
			setHeight: function(m, x) {
				return this.setDimensions({ height: m }, x);
			},
			setDimensions: function(m, x) {
				var S;
				for (var C in x ||= {}, m) S = m[C], x.cssOnly || (this._setBackstoreDimension(C, m[C]), S += "px", this.hasLostContext = !0), x.backstoreOnly || this._setCssDimension(C, S);
				return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), x.cssOnly || this.requestRenderAll(), this;
			},
			_setBackstoreDimension: function(m, x) {
				return this.lowerCanvasEl[m] = x, this.upperCanvasEl && (this.upperCanvasEl[m] = x), this.cacheCanvasEl && (this.cacheCanvasEl[m] = x), this[m] = x, this;
			},
			_setCssDimension: function(m, x) {
				return this.lowerCanvasEl.style[m] = x, this.upperCanvasEl && (this.upperCanvasEl.style[m] = x), this.wrapperEl && (this.wrapperEl.style[m] = x), this;
			},
			getZoom: function() {
				return this.viewportTransform[0];
			},
			setViewportTransform: function(m) {
				var x = this._activeObject, S = this.backgroundImage, C = this.overlayImage, T, D, O;
				for (this.viewportTransform = m, D = 0, O = this._objects.length; D < O; D++) T = this._objects[D], T.group || T.setCoords(!0);
				return x && x.setCoords(), S && S.setCoords(!0), C && C.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			zoomToPoint: function(m, x) {
				var S = m, C = this.viewportTransform.slice(0);
				m = D(m, O(this.viewportTransform)), C[0] = x, C[3] = x;
				var T = D(m, C);
				return C[4] += S.x - T.x, C[5] += S.y - T.y, this.setViewportTransform(C);
			},
			setZoom: function(m) {
				return this.zoomToPoint(new x.Point(0, 0), m), this;
			},
			absolutePan: function(m) {
				var x = this.viewportTransform.slice(0);
				return x[4] = -m.x, x[5] = -m.y, this.setViewportTransform(x);
			},
			relativePan: function(m) {
				return this.absolutePan(new x.Point(-m.x - this.viewportTransform[4], -m.y - this.viewportTransform[5]));
			},
			getElement: function() {
				return this.lowerCanvasEl;
			},
			_onObjectAdded: function(m) {
				this.stateful && m.setupState(), m._set("canvas", this), m.setCoords(), this.fire("object:added", { target: m }), m.fire("added");
			},
			_onObjectRemoved: function(m) {
				this.fire("object:removed", { target: m }), m.fire("removed"), delete m.canvas;
			},
			clearContext: function(m) {
				return m.clearRect(0, 0, this.width, this.height), this;
			},
			getContext: function() {
				return this.contextContainer;
			},
			clear: function() {
				return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers &&= (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			renderAll: function() {
				var m = this.contextContainer;
				return this.renderCanvas(m, this._objects), this;
			},
			renderAndReset: function() {
				this.isRendering = 0, this.renderAll();
			},
			requestRenderAll: function() {
				return this.isRendering ||= x.util.requestAnimFrame(this.renderAndResetBound), this;
			},
			calcViewportBoundaries: function() {
				var m = {}, S = this.width, C = this.height, T = O(this.viewportTransform);
				return m.tl = D({
					x: 0,
					y: 0
				}, T), m.br = D({
					x: S,
					y: C
				}, T), m.tr = new x.Point(m.br.x, m.tl.y), m.bl = new x.Point(m.tl.x, m.br.y), this.vptCoords = m, m;
			},
			cancelRequestedRender: function() {
				this.isRendering &&= (x.util.cancelAnimFrame(this.isRendering), 0);
			},
			renderCanvas: function(m, S) {
				var C = this.viewportTransform, T = this.clipPath;
				this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(m), x.util.setImageSmoothing(m, this.imageSmoothingEnabled), this.fire("before:render", { ctx: m }), this._renderBackground(m), m.save(), m.transform(C[0], C[1], C[2], C[3], C[4], C[5]), this._renderObjects(m, S), m.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(m), T && (T.canvas = this, T.shouldCache(), T._transformDone = !0, T.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(m)), this._renderOverlay(m), this.controlsAboveOverlay && this.interactive && this.drawControls(m), this.fire("after:render", { ctx: m });
			},
			drawClipPathOnCanvas: function(m) {
				var x = this.viewportTransform, S = this.clipPath;
				m.save(), m.transform(x[0], x[1], x[2], x[3], x[4], x[5]), m.globalCompositeOperation = "destination-in", S.transform(m), m.scale(1 / S.zoomX, 1 / S.zoomY), m.drawImage(S._cacheCanvas, -S.cacheTranslationX, -S.cacheTranslationY), m.restore();
			},
			_renderObjects: function(m, x) {
				var S, C;
				for (S = 0, C = x.length; S < C; ++S) x[S] && x[S].render(m);
			},
			_renderBackgroundOrOverlay: function(m, x) {
				var S = this[x + "Color"], C = this[x + "Image"], T = this.viewportTransform, D = this[x + "Vpt"];
				if (!(!S && !C)) {
					if (S) {
						m.save(), m.beginPath(), m.moveTo(0, 0), m.lineTo(this.width, 0), m.lineTo(this.width, this.height), m.lineTo(0, this.height), m.closePath(), m.fillStyle = S.toLive ? S.toLive(m, this) : S, D && m.transform(T[0], T[1], T[2], T[3], T[4], T[5]), m.transform(1, 0, 0, 1, S.offsetX || 0, S.offsetY || 0);
						var O = S.gradientTransform || S.patternTransform;
						O && m.transform(O[0], O[1], O[2], O[3], O[4], O[5]), m.fill(), m.restore();
					}
					if (C) {
						m.save();
						var k = this.skipOffscreen;
						this.skipOffscreen = D, D && m.transform(T[0], T[1], T[2], T[3], T[4], T[5]), C.render(m), this.skipOffscreen = k, m.restore();
					}
				}
			},
			_renderBackground: function(m) {
				this._renderBackgroundOrOverlay(m, "background");
			},
			_renderOverlay: function(m) {
				this._renderBackgroundOrOverlay(m, "overlay");
			},
			getCenter: function() {
				return {
					top: this.height / 2,
					left: this.width / 2
				};
			},
			getCenterPoint: function() {
				return new x.Point(this.width / 2, this.height / 2);
			},
			centerObjectH: function(m) {
				return this._centerObject(m, new x.Point(this.getCenterPoint().x, m.getCenterPoint().y));
			},
			centerObjectV: function(m) {
				return this._centerObject(m, new x.Point(m.getCenterPoint().x, this.getCenterPoint().y));
			},
			centerObject: function(m) {
				var x = this.getCenterPoint();
				return this._centerObject(m, x);
			},
			viewportCenterObject: function(m) {
				var x = this.getVpCenter();
				return this._centerObject(m, x);
			},
			viewportCenterObjectH: function(m) {
				var S = this.getVpCenter();
				return this._centerObject(m, new x.Point(S.x, m.getCenterPoint().y)), this;
			},
			viewportCenterObjectV: function(m) {
				var S = this.getVpCenter();
				return this._centerObject(m, new x.Point(m.getCenterPoint().x, S.y));
			},
			getVpCenter: function() {
				return D(this.getCenterPoint(), O(this.viewportTransform));
			},
			_centerObject: function(m, x) {
				return m.setPositionByOrigin(x, "center", "center"), m.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			toDatalessJSON: function(m) {
				return this.toDatalessObject(m);
			},
			toObject: function(m) {
				return this._toObjectMethod("toObject", m);
			},
			toDatalessObject: function(m) {
				return this._toObjectMethod("toDatalessObject", m);
			},
			_toObjectMethod: function(S, C) {
				var T = this.clipPath, D = {
					version: x.version,
					objects: this._toObjects(S, C)
				};
				return T && !T.excludeFromExport && (D.clipPath = this._toObject(this.clipPath, S, C)), m(D, this.__serializeBgOverlay(S, C)), x.util.populateWithProperties(this, D, C), D;
			},
			_toObjects: function(m, x) {
				return this._objects.filter(function(m) {
					return !m.excludeFromExport;
				}).map(function(S) {
					return this._toObject(S, m, x);
				}, this);
			},
			_toObject: function(m, x, S) {
				var C;
				this.includeDefaultValues || (C = m.includeDefaultValues, m.includeDefaultValues = !1);
				var T = m[x](S);
				return this.includeDefaultValues || (m.includeDefaultValues = C), T;
			},
			__serializeBgOverlay: function(m, x) {
				var S = {}, C = this.backgroundImage, T = this.overlayImage, D = this.backgroundColor, O = this.overlayColor;
				return D && D.toObject ? D.excludeFromExport || (S.background = D.toObject(x)) : D && (S.background = D), O && O.toObject ? O.excludeFromExport || (S.overlay = O.toObject(x)) : O && (S.overlay = O), C && !C.excludeFromExport && (S.backgroundImage = this._toObject(C, m, x)), T && !T.excludeFromExport && (S.overlayImage = this._toObject(T, m, x)), S;
			},
			svgViewportTransformation: !0,
			toSVG: function(m, x) {
				m ||= {}, m.reviver = x;
				var S = [];
				return this._setSVGPreamble(S, m), this._setSVGHeader(S, m), this.clipPath && S.push("<g clip-path=\"url(#" + this.clipPath.clipPathId + ")\" >\n"), this._setSVGBgOverlayColor(S, "background"), this._setSVGBgOverlayImage(S, "backgroundImage", x), this._setSVGObjects(S, x), this.clipPath && S.push("</g>\n"), this._setSVGBgOverlayColor(S, "overlay"), this._setSVGBgOverlayImage(S, "overlayImage", x), S.push("</svg>"), S.join("");
			},
			_setSVGPreamble: function(m, x) {
				x.suppressPreamble || m.push("<?xml version=\"1.0\" encoding=\"", x.encoding || "UTF-8", "\" standalone=\"no\" ?>\n", "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ", "\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n");
			},
			_setSVGHeader: function(m, S) {
				var C = S.width || this.width, D = S.height || this.height, O, k = "viewBox=\"0 0 " + this.width + " " + this.height + "\" ", A = x.Object.NUM_FRACTION_DIGITS;
				S.viewBox ? k = "viewBox=\"" + S.viewBox.x + " " + S.viewBox.y + " " + S.viewBox.width + " " + S.viewBox.height + "\" " : this.svgViewportTransformation && (O = this.viewportTransform, k = "viewBox=\"" + T(-O[4] / O[0], A) + " " + T(-O[5] / O[3], A) + " " + T(this.width / O[0], A) + " " + T(this.height / O[3], A) + "\" "), m.push("<svg ", "xmlns=\"http://www.w3.org/2000/svg\" ", "xmlns:xlink=\"http://www.w3.org/1999/xlink\" ", "version=\"1.1\" ", "width=\"", C, "\" ", "height=\"", D, "\" ", k, "xml:space=\"preserve\">\n", "<desc>Created with Fabric.js ", x.version, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(S), "</defs>\n");
			},
			createSVGClipPathMarkup: function(m) {
				var S = this.clipPath;
				return S ? (S.clipPathId = "CLIPPATH_" + x.Object.__uid++, "<clipPath id=\"" + S.clipPathId + "\" >\n" + this.clipPath.toClipPathSVG(m.reviver) + "</clipPath>\n") : "";
			},
			createSVGRefElementsMarkup: function() {
				var m = this;
				return ["background", "overlay"].map(function(S) {
					var C = m[S + "Color"];
					if (C && C.toLive) {
						var T = m[S + "Vpt"], D = m.viewportTransform, O = {
							width: m.width / (T ? D[0] : 1),
							height: m.height / (T ? D[3] : 1)
						};
						return C.toSVG(O, { additionalTransform: T ? x.util.matrixToSVG(D) : "" });
					}
				}).join("");
			},
			createSVGFontFacesMarkup: function() {
				var m = "", S = {}, C, T, D, O, k, A, j, M, N, P = x.fontPaths, F = [];
				for (this._objects.forEach(function m(x) {
					F.push(x), x._objects && x._objects.forEach(m);
				}), M = 0, N = F.length; M < N; M++) if (C = F[M], T = C.fontFamily, !(C.type.indexOf("text") === -1 || S[T] || !P[T]) && (S[T] = !0, C.styles)) for (k in D = C.styles, D) for (j in O = D[k], O) A = O[j], T = A.fontFamily, !S[T] && P[T] && (S[T] = !0);
				for (var I in S) m += [
					"		@font-face {\n",
					"			font-family: '",
					I,
					"';\n",
					"			src: url('",
					P[I],
					"');\n",
					"		}\n"
				].join("");
				return m &&= [
					"	<style type=\"text/css\">",
					"<![CDATA[\n",
					m,
					"]]>",
					"</style>\n"
				].join(""), m;
			},
			_setSVGObjects: function(m, x) {
				var S, C, T, D = this._objects;
				for (C = 0, T = D.length; C < T; C++) S = D[C], !S.excludeFromExport && this._setSVGObject(m, S, x);
			},
			_setSVGObject: function(m, x, S) {
				m.push(x.toSVG(S));
			},
			_setSVGBgOverlayImage: function(m, x, S) {
				this[x] && !this[x].excludeFromExport && this[x].toSVG && m.push(this[x].toSVG(S));
			},
			_setSVGBgOverlayColor: function(m, S) {
				var C = this[S + "Color"], T = this.viewportTransform, D = this.width, O = this.height;
				if (C) if (C.toLive) {
					var k = C.repeat, A = x.util.invertTransform(T), j = this[S + "Vpt"] ? x.util.matrixToSVG(A) : "";
					m.push("<rect transform=\"" + j + " translate(", D / 2, ",", O / 2, ")\"", " x=\"", C.offsetX - D / 2, "\" y=\"", C.offsetY - O / 2, "\" ", "width=\"", k === "repeat-y" || k === "no-repeat" ? C.source.width : D, "\" height=\"", k === "repeat-x" || k === "no-repeat" ? C.source.height : O, "\" fill=\"url(#SVGID_" + C.id + ")\"", "></rect>\n");
				} else m.push("<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ", "fill=\"", C, "\"", "></rect>\n");
			},
			sendToBack: function(m) {
				if (!m) return this;
				var x = this._activeObject, S, T, D;
				if (m === x && m.type === "activeSelection") for (D = x._objects, S = D.length; S--;) T = D[S], C(this._objects, T), this._objects.unshift(T);
				else C(this._objects, m), this._objects.unshift(m);
				return this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			bringToFront: function(m) {
				if (!m) return this;
				var x = this._activeObject, S, T, D;
				if (m === x && m.type === "activeSelection") for (D = x._objects, S = 0; S < D.length; S++) T = D[S], C(this._objects, T), this._objects.push(T);
				else C(this._objects, m), this._objects.push(m);
				return this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			sendBackwards: function(m, x) {
				if (!m) return this;
				var S = this._activeObject, T, D, O, k, A, j = 0;
				if (m === S && m.type === "activeSelection") for (A = S._objects, T = 0; T < A.length; T++) D = A[T], O = this._objects.indexOf(D), O > 0 + j && (k = O - 1, C(this._objects, D), this._objects.splice(k, 0, D)), j++;
				else O = this._objects.indexOf(m), O !== 0 && (k = this._findNewLowerIndex(m, O, x), C(this._objects, m), this._objects.splice(k, 0, m));
				return this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			_findNewLowerIndex: function(m, x, S) {
				var C, T;
				if (S) {
					for (C = x, T = x - 1; T >= 0; --T) if (m.intersectsWithObject(this._objects[T]) || m.isContainedWithinObject(this._objects[T]) || this._objects[T].isContainedWithinObject(m)) {
						C = T;
						break;
					}
				} else C = x - 1;
				return C;
			},
			bringForward: function(m, x) {
				if (!m) return this;
				var S = this._activeObject, T, D, O, k, A, j = 0;
				if (m === S && m.type === "activeSelection") for (A = S._objects, T = A.length; T--;) D = A[T], O = this._objects.indexOf(D), O < this._objects.length - 1 - j && (k = O + 1, C(this._objects, D), this._objects.splice(k, 0, D)), j++;
				else O = this._objects.indexOf(m), O !== this._objects.length - 1 && (k = this._findNewUpperIndex(m, O, x), C(this._objects, m), this._objects.splice(k, 0, m));
				return this.renderOnAddRemove && this.requestRenderAll(), this;
			},
			_findNewUpperIndex: function(m, x, S) {
				var C, T, D;
				if (S) {
					for (C = x, T = x + 1, D = this._objects.length; T < D; ++T) if (m.intersectsWithObject(this._objects[T]) || m.isContainedWithinObject(this._objects[T]) || this._objects[T].isContainedWithinObject(m)) {
						C = T;
						break;
					}
				} else C = x + 1;
				return C;
			},
			moveTo: function(m, x) {
				return C(this._objects, m), this._objects.splice(x, 0, m), this.renderOnAddRemove && this.requestRenderAll();
			},
			dispose: function() {
				return this.isRendering &&= (x.util.cancelAnimFrame(this.isRendering), 0), this.forEachObject(function(m) {
					m.dispose && m.dispose();
				}), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), x.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), x.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this;
			},
			toString: function() {
				return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>";
			}
		}), m(x.StaticCanvas.prototype, x.Observable), m(x.StaticCanvas.prototype, x.Collection), m(x.StaticCanvas.prototype, x.DataURLExporter), m(x.StaticCanvas, {
			EMPTY_JSON: "{\"objects\": [], \"background\": \"white\"}",
			supports: function(m) {
				var x = A();
				if (!x || !x.getContext) return null;
				var S = x.getContext("2d");
				if (!S) return null;
				switch (m) {
					case "setLineDash": return S.setLineDash !== void 0;
					default: return null;
				}
			}
		}), x.StaticCanvas.prototype.toJSON = x.StaticCanvas.prototype.toObject, x.isLikelyNode && (x.StaticCanvas.prototype.createPNGStream = function() {
			var m = k(this.lowerCanvasEl);
			return m && m.createPNGStream();
		}, x.StaticCanvas.prototype.createJPEGStream = function(m) {
			var x = k(this.lowerCanvasEl);
			return x && x.createJPEGStream(m);
		});
	})(), x.BaseBrush = x.util.createClass({
		color: "rgb(0, 0, 0)",
		width: 1,
		shadow: null,
		strokeLineCap: "round",
		strokeLineJoin: "round",
		strokeMiterLimit: 10,
		strokeDashArray: null,
		limitedToCanvasSize: !1,
		_setBrushStyles: function(m) {
			m.strokeStyle = this.color, m.lineWidth = this.width, m.lineCap = this.strokeLineCap, m.miterLimit = this.strokeMiterLimit, m.lineJoin = this.strokeLineJoin, m.setLineDash(this.strokeDashArray || []);
		},
		_saveAndTransform: function(m) {
			var x = this.canvas.viewportTransform;
			m.save(), m.transform(x[0], x[1], x[2], x[3], x[4], x[5]);
		},
		_setShadow: function() {
			if (this.shadow) {
				var m = this.canvas, S = this.shadow, C = m.contextTop, T = m.getZoom();
				m && m._isRetinaScaling() && (T *= x.devicePixelRatio), C.shadowColor = S.color, C.shadowBlur = S.blur * T, C.shadowOffsetX = S.offsetX * T, C.shadowOffsetY = S.offsetY * T;
			}
		},
		needsFullRender: function() {
			return new x.Color(this.color).getAlpha() < 1 || !!this.shadow;
		},
		_resetShadow: function() {
			var m = this.canvas.contextTop;
			m.shadowColor = "", m.shadowBlur = m.shadowOffsetX = m.shadowOffsetY = 0;
		},
		_isOutSideCanvas: function(m) {
			return m.x < 0 || m.x > this.canvas.getWidth() || m.y < 0 || m.y > this.canvas.getHeight();
		}
	}), (function() {
		x.PencilBrush = x.util.createClass(x.BaseBrush, {
			decimate: .4,
			drawStraightLine: !1,
			straightLineKey: "shiftKey",
			initialize: function(m) {
				this.canvas = m, this._points = [];
			},
			needsFullRender: function() {
				return this.callSuper("needsFullRender") || this._hasStraightLine;
			},
			_drawSegment: function(m, x, S) {
				var C = x.midPointFrom(S);
				return m.quadraticCurveTo(x.x, x.y, C.x, C.y), C;
			},
			onMouseDown: function(m, x) {
				this.canvas._isMainEvent(x.e) && (this.drawStraightLine = x.e[this.straightLineKey], this._prepareForDrawing(m), this._captureDrawingPath(m), this._render());
			},
			onMouseMove: function(m, x) {
				if (this.canvas._isMainEvent(x.e) && (this.drawStraightLine = x.e[this.straightLineKey], !(this.limitedToCanvasSize === !0 && this._isOutSideCanvas(m)) && this._captureDrawingPath(m) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render();
				else {
					var S = this._points, C = S.length, T = this.canvas.contextTop;
					this._saveAndTransform(T), this.oldEnd && (T.beginPath(), T.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(T, S[C - 2], S[C - 1], !0), T.stroke(), T.restore();
				}
			},
			onMouseUp: function(m) {
				return this.canvas._isMainEvent(m.e) ? (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1) : !0;
			},
			_prepareForDrawing: function(m) {
				var S = new x.Point(m.x, m.y);
				this._reset(), this._addPoint(S), this.canvas.contextTop.moveTo(S.x, S.y);
			},
			_addPoint: function(m) {
				return this._points.length > 1 && m.eq(this._points[this._points.length - 1]) ? !1 : (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(m), !0);
			},
			_reset: function() {
				this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1;
			},
			_captureDrawingPath: function(m) {
				var S = new x.Point(m.x, m.y);
				return this._addPoint(S);
			},
			_render: function(m) {
				var S, C, T = this._points[0], D = this._points[1];
				if (m ||= this.canvas.contextTop, this._saveAndTransform(m), m.beginPath(), this._points.length === 2 && T.x === D.x && T.y === D.y) {
					var O = this.width / 1e3;
					T = new x.Point(T.x, T.y), D = new x.Point(D.x, D.y), T.x -= O, D.x += O;
				}
				for (m.moveTo(T.x, T.y), S = 1, C = this._points.length; S < C; S++) this._drawSegment(m, T, D), T = this._points[S], D = this._points[S + 1];
				m.lineTo(T.x, T.y), m.stroke(), m.restore();
			},
			convertPointsToSVGPath: function(m) {
				var S = this.width / 1e3;
				return x.util.getSmoothPathFromPoints(m, S);
			},
			_isEmptySVGPath: function(m) {
				return x.util.joinPath(m) === "M 0 0 Q 0 0 0 0 L 0 0";
			},
			createPath: function(m) {
				var S = new x.Path(m, {
					fill: null,
					stroke: this.color,
					strokeWidth: this.width,
					strokeLineCap: this.strokeLineCap,
					strokeMiterLimit: this.strokeMiterLimit,
					strokeLineJoin: this.strokeLineJoin,
					strokeDashArray: this.strokeDashArray
				});
				return this.shadow && (this.shadow.affectStroke = !0, S.shadow = new x.Shadow(this.shadow)), S;
			},
			decimatePoints: function(m, x) {
				if (m.length <= 2) return m;
				var S = (x / this.canvas.getZoom()) ** 2, C, T = m.length - 1, D = m[0], O = [D], k;
				for (C = 1; C < T - 1; C++) k = (D.x - m[C].x) ** 2 + (D.y - m[C].y) ** 2, k >= S && (D = m[C], O.push(D));
				return O.push(m[T]), O;
			},
			_finalizeAndAddPath: function() {
				this.canvas.contextTop.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate));
				var m = this.convertPointsToSVGPath(this._points);
				if (this._isEmptySVGPath(m)) {
					this.canvas.requestRenderAll();
					return;
				}
				var x = this.createPath(m);
				this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: x }), this.canvas.add(x), this.canvas.requestRenderAll(), x.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: x });
			}
		});
	})(), x.CircleBrush = x.util.createClass(x.BaseBrush, {
		width: 10,
		initialize: function(m) {
			this.canvas = m, this.points = [];
		},
		drawDot: function(m) {
			var x = this.addPoint(m), S = this.canvas.contextTop;
			this._saveAndTransform(S), this.dot(S, x), S.restore();
		},
		dot: function(m, x) {
			m.fillStyle = x.fill, m.beginPath(), m.arc(x.x, x.y, x.radius, 0, Math.PI * 2, !1), m.closePath(), m.fill();
		},
		onMouseDown: function(m) {
			this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(m);
		},
		_render: function() {
			var m = this.canvas.contextTop, x, S, C = this.points;
			for (this._saveAndTransform(m), x = 0, S = C.length; x < S; x++) this.dot(m, C[x]);
			m.restore();
		},
		onMouseMove: function(m) {
			this.limitedToCanvasSize === !0 && this._isOutSideCanvas(m) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(m), this._render()) : this.drawDot(m));
		},
		onMouseUp: function() {
			var m = this.canvas.renderOnAddRemove, S, C;
			this.canvas.renderOnAddRemove = !1;
			var T = [];
			for (S = 0, C = this.points.length; S < C; S++) {
				var D = this.points[S], O = new x.Circle({
					radius: D.radius,
					left: D.x,
					top: D.y,
					originX: "center",
					originY: "center",
					fill: D.fill
				});
				this.shadow && (O.shadow = new x.Shadow(this.shadow)), T.push(O);
			}
			var k = new x.Group(T);
			k.canvas = this.canvas, this.canvas.fire("before:path:created", { path: k }), this.canvas.add(k), this.canvas.fire("path:created", { path: k }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = m, this.canvas.requestRenderAll();
		},
		addPoint: function(m) {
			var S = new x.Point(m.x, m.y), C = x.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, T = new x.Color(this.color).setAlpha(x.util.getRandomInt(0, 100) / 100).toRgba();
			return S.radius = C, S.fill = T, this.points.push(S), S;
		}
	}), x.SprayBrush = x.util.createClass(x.BaseBrush, {
		width: 10,
		density: 20,
		dotWidth: 1,
		dotWidthVariance: 1,
		randomOpacity: !1,
		optimizeOverlapping: !0,
		initialize: function(m) {
			this.canvas = m, this.sprayChunks = [];
		},
		onMouseDown: function(m) {
			this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(m), this.render(this.sprayChunkPoints);
		},
		onMouseMove: function(m) {
			this.limitedToCanvasSize === !0 && this._isOutSideCanvas(m) || (this.addSprayChunk(m), this.render(this.sprayChunkPoints));
		},
		onMouseUp: function() {
			var m = this.canvas.renderOnAddRemove;
			this.canvas.renderOnAddRemove = !1;
			for (var S = [], C = 0, T = this.sprayChunks.length; C < T; C++) for (var D = this.sprayChunks[C], O = 0, k = D.length; O < k; O++) {
				var A = new x.Rect({
					width: D[O].width,
					height: D[O].width,
					left: D[O].x + 1,
					top: D[O].y + 1,
					originX: "center",
					originY: "center",
					fill: this.color
				});
				S.push(A);
			}
			this.optimizeOverlapping && (S = this._getOptimizedRects(S));
			var j = new x.Group(S);
			this.shadow && j.set("shadow", new x.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: j }), this.canvas.add(j), this.canvas.fire("path:created", { path: j }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = m, this.canvas.requestRenderAll();
		},
		_getOptimizedRects: function(m) {
			var x = {}, S, C, T;
			for (C = 0, T = m.length; C < T; C++) S = m[C].left + "" + m[C].top, x[S] || (x[S] = m[C]);
			var D = [];
			for (S in x) D.push(x[S]);
			return D;
		},
		render: function(m) {
			var x = this.canvas.contextTop, S, C;
			for (x.fillStyle = this.color, this._saveAndTransform(x), S = 0, C = m.length; S < C; S++) {
				var T = m[S];
				T.opacity !== void 0 && (x.globalAlpha = T.opacity), x.fillRect(T.x, T.y, T.width, T.width);
			}
			x.restore();
		},
		_render: function() {
			var m = this.canvas.contextTop, x, S;
			for (m.fillStyle = this.color, this._saveAndTransform(m), x = 0, S = this.sprayChunks.length; x < S; x++) this.render(this.sprayChunks[x]);
			m.restore();
		},
		addSprayChunk: function(m) {
			this.sprayChunkPoints = [];
			var S, C, T, D = this.width / 2, O;
			for (O = 0; O < this.density; O++) {
				S = x.util.getRandomInt(m.x - D, m.x + D), C = x.util.getRandomInt(m.y - D, m.y + D), T = this.dotWidthVariance ? x.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth;
				var k = new x.Point(S, C);
				k.width = T, this.randomOpacity && (k.opacity = x.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(k);
			}
			this.sprayChunks.push(this.sprayChunkPoints);
		}
	}), x.PatternBrush = x.util.createClass(x.PencilBrush, {
		getPatternSrc: function() {
			var m = 20, S = 5, C = x.util.createCanvasElement(), T = C.getContext("2d");
			return C.width = C.height = m + S, T.fillStyle = this.color, T.beginPath(), T.arc(m / 2, m / 2, m / 2, 0, Math.PI * 2, !1), T.closePath(), T.fill(), C;
		},
		getPatternSrcFunction: function() {
			return String(this.getPatternSrc).replace("this.color", "\"" + this.color + "\"");
		},
		getPattern: function(m) {
			return m.createPattern(this.source || this.getPatternSrc(), "repeat");
		},
		_setBrushStyles: function(m) {
			this.callSuper("_setBrushStyles", m), m.strokeStyle = this.getPattern(m);
		},
		createPath: function(m) {
			var S = this.callSuper("createPath", m), C = S._getLeftTopCoords().scalarAdd(S.strokeWidth / 2);
			return S.stroke = new x.Pattern({
				source: this.source || this.getPatternSrcFunction(),
				offsetX: -C.x,
				offsetY: -C.y
			}), S;
		}
	}), (function() {
		var m = x.util.getPointer, S = x.util.degreesToRadians, C = x.util.isTouchEvent;
		for (var T in x.Canvas = x.util.createClass(x.StaticCanvas, {
			initialize: function(m, x) {
				x ||= {}, this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(m, x), this._initInteractive(), this._createCacheCanvas();
			},
			uniformScaling: !0,
			uniScaleKey: "shiftKey",
			centeredScaling: !1,
			centeredRotation: !1,
			centeredKey: "altKey",
			altActionKey: "shiftKey",
			interactive: !0,
			selection: !0,
			selectionKey: "shiftKey",
			altSelectionKey: null,
			selectionColor: "rgba(100, 100, 255, 0.3)",
			selectionDashArray: [],
			selectionBorderColor: "rgba(255, 255, 255, 0.3)",
			selectionLineWidth: 1,
			selectionFullyContained: !1,
			hoverCursor: "move",
			moveCursor: "move",
			defaultCursor: "default",
			freeDrawingCursor: "crosshair",
			notAllowedCursor: "not-allowed",
			containerClass: "canvas-container",
			perPixelTargetFind: !1,
			targetFindTolerance: 0,
			skipTargetFind: !1,
			isDrawingMode: !1,
			preserveObjectStacking: !1,
			snapAngle: 0,
			snapThreshold: null,
			stopContextMenu: !1,
			fireRightClick: !1,
			fireMiddleClick: !1,
			targets: [],
			enablePointerEvents: !1,
			_hoveredTarget: null,
			_hoveredTargets: [],
			_initInteractive: function() {
				this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = x.PencilBrush && new x.PencilBrush(this), this.calcOffset();
			},
			_chooseObjectsToRender: function() {
				var m = this.getActiveObjects(), x, S, C;
				if (m.length > 0 && !this.preserveObjectStacking) {
					S = [], C = [];
					for (var T = 0, D = this._objects.length; T < D; T++) x = this._objects[T], m.indexOf(x) === -1 ? S.push(x) : C.push(x);
					m.length > 1 && (this._activeObject._objects = C), S.push.apply(S, C);
				} else S = this._objects;
				return S;
			},
			renderAll: function() {
				this.contextTopDirty && !this._groupSelector && !this.isDrawingMode && (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext &&= (this.renderTopLayer(this.contextTop), !1);
				var m = this.contextContainer;
				return this.renderCanvas(m, this._chooseObjectsToRender()), this;
			},
			renderTopLayer: function(m) {
				m.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(m), this.contextTopDirty = !0), m.restore();
			},
			renderTop: function() {
				var m = this.contextTop;
				return this.clearContext(m), this.renderTopLayer(m), this.fire("after:render"), this;
			},
			_normalizePointer: function(m, S) {
				var C = m.calcTransformMatrix(), T = x.util.invertTransform(C), D = this.restorePointerVpt(S);
				return x.util.transformPoint(D, T);
			},
			isTargetTransparent: function(m, S, C) {
				if (m.shouldCache() && m._cacheCanvas && m !== this._activeObject) {
					var T = this._normalizePointer(m, {
						x: S,
						y: C
					}), D = Math.max(m.cacheTranslationX + T.x * m.zoomX, 0), O = Math.max(m.cacheTranslationY + T.y * m.zoomY, 0), k = x.util.isTransparent(m._cacheContext, Math.round(D), Math.round(O), this.targetFindTolerance);
					return k;
				}
				var A = this.contextCache, j = m.selectionBackgroundColor, M = this.viewportTransform;
				m.selectionBackgroundColor = "", this.clearContext(A), A.save(), A.transform(M[0], M[1], M[2], M[3], M[4], M[5]), m.render(A), A.restore(), m.selectionBackgroundColor = j;
				var k = x.util.isTransparent(A, S, C, this.targetFindTolerance);
				return k;
			},
			_isSelectionKeyPressed: function(m) {
				var x = !1;
				return x = Array.isArray(this.selectionKey) ? !!this.selectionKey.find(function(x) {
					return m[x] === !0;
				}) : m[this.selectionKey], x;
			},
			_shouldClearSelection: function(m, x) {
				var S = this.getActiveObjects(), C = this._activeObject;
				return !x || x && C && S.length > 1 && S.indexOf(x) === -1 && C !== x && !this._isSelectionKeyPressed(m) || x && !x.evented || x && !x.selectable && C && C !== x;
			},
			_shouldCenterTransform: function(m, x, S) {
				if (m) {
					var C;
					return x === "scale" || x === "scaleX" || x === "scaleY" || x === "resizing" ? C = this.centeredScaling || m.centeredScaling : x === "rotate" && (C = this.centeredRotation || m.centeredRotation), C ? !S : S;
				}
			},
			_getOriginFromCorner: function(m, x) {
				var S = {
					x: m.originX,
					y: m.originY
				};
				return x === "ml" || x === "tl" || x === "bl" ? S.x = "right" : (x === "mr" || x === "tr" || x === "br") && (S.x = "left"), x === "tl" || x === "mt" || x === "tr" ? S.y = "bottom" : (x === "bl" || x === "mb" || x === "br") && (S.y = "top"), S;
			},
			_getActionFromCorner: function(m, x, S, C) {
				if (!x || !m) return "drag";
				var T = C.controls[x];
				return T.getActionName(S, T, C);
			},
			_setupCurrentTransform: function(m, C, T) {
				if (C) {
					var D = this.getPointer(m), O = C.__corner, k = C.controls[O], A = T && O ? k.getActionHandler(m, C, k) : x.controlsUtils.dragHandler, j = this._getActionFromCorner(T, O, m, C), M = this._getOriginFromCorner(C, O), N = m[this.centeredKey], P = {
						target: C,
						action: j,
						actionHandler: A,
						corner: O,
						scaleX: C.scaleX,
						scaleY: C.scaleY,
						skewX: C.skewX,
						skewY: C.skewY,
						offsetX: D.x - C.left,
						offsetY: D.y - C.top,
						originX: M.x,
						originY: M.y,
						ex: D.x,
						ey: D.y,
						lastX: D.x,
						lastY: D.y,
						theta: S(C.angle),
						width: C.width * C.scaleX,
						shiftKey: m.shiftKey,
						altKey: N,
						original: x.util.saveObjectTransform(C)
					};
					this._shouldCenterTransform(C, j, N) && (P.originX = "center", P.originY = "center"), P.original.originX = M.x, P.original.originY = M.y, this._currentTransform = P, this._beforeTransform(m);
				}
			},
			setCursor: function(m) {
				this.upperCanvasEl.style.cursor = m;
			},
			_drawSelection: function(m) {
				var S = this._groupSelector, C = new x.Point(S.ex, S.ey), T = x.util.transformPoint(C, this.viewportTransform), D = new x.Point(S.ex + S.left, S.ey + S.top), O = x.util.transformPoint(D, this.viewportTransform), k = Math.min(T.x, O.x), A = Math.min(T.y, O.y), j = Math.max(T.x, O.x), M = Math.max(T.y, O.y), N = this.selectionLineWidth / 2;
				this.selectionColor && (m.fillStyle = this.selectionColor, m.fillRect(k, A, j - k, M - A)), !(!this.selectionLineWidth || !this.selectionBorderColor) && (m.lineWidth = this.selectionLineWidth, m.strokeStyle = this.selectionBorderColor, k += N, A += N, j -= N, M -= N, x.Object.prototype._setLineDash.call(this, m, this.selectionDashArray), m.strokeRect(k, A, j - k, M - A));
			},
			findTarget: function(m, x) {
				if (!this.skipTargetFind) {
					var S = this.getPointer(m, !0), T = this._activeObject, D = this.getActiveObjects(), O, k, A = C(m), j = D.length > 1 && !x || D.length === 1;
					if (this.targets = [], j && T._findTargetCorner(S, A) || D.length > 1 && !x && T === this._searchPossibleTargets([T], S)) return T;
					if (D.length === 1 && T === this._searchPossibleTargets([T], S)) if (this.preserveObjectStacking) O = T, k = this.targets, this.targets = [];
					else return T;
					var M = this._searchPossibleTargets(this._objects, S);
					return m[this.altSelectionKey] && M && O && M !== O && (M = O, this.targets = k), M;
				}
			},
			_checkTarget: function(m, x, S) {
				if (x && x.visible && x.evented && x.containsPoint(m)) if ((this.perPixelTargetFind || x.perPixelTargetFind) && !x.isEditing) {
					if (!this.isTargetTransparent(x, S.x, S.y)) return !0;
				} else return !0;
			},
			_searchPossibleTargets: function(m, S) {
				for (var C, T = m.length, D; T--;) {
					var O = m[T], k = O.group ? this._normalizePointer(O.group, S) : S;
					if (this._checkTarget(k, O, S)) {
						C = m[T], C.subTargetCheck && C instanceof x.Group && (D = this._searchPossibleTargets(C._objects, S), D && this.targets.push(D));
						break;
					}
				}
				return C;
			},
			restorePointerVpt: function(m) {
				return x.util.transformPoint(m, x.util.invertTransform(this.viewportTransform));
			},
			getPointer: function(x, S) {
				if (this._absolutePointer && !S) return this._absolutePointer;
				if (this._pointer && S) return this._pointer;
				var C = m(x), T = this.upperCanvasEl, D = T.getBoundingClientRect(), O = D.width || 0, k = D.height || 0, A;
				(!O || !k) && ("top" in D && "bottom" in D && (k = Math.abs(D.top - D.bottom)), "right" in D && "left" in D && (O = Math.abs(D.right - D.left))), this.calcOffset(), C.x -= this._offset.left, C.y -= this._offset.top, S || (C = this.restorePointerVpt(C));
				var j = this.getRetinaScaling();
				return j !== 1 && (C.x /= j, C.y /= j), A = O === 0 || k === 0 ? {
					width: 1,
					height: 1
				} : {
					width: T.width / O,
					height: T.height / k
				}, {
					x: C.x * A.width,
					y: C.y * A.height
				};
			},
			_createUpperCanvas: function() {
				var m = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), S = this.lowerCanvasEl, C = this.upperCanvasEl;
				C ? C.className = "" : (C = this._createCanvasElement(), this.upperCanvasEl = C), x.util.addClass(C, "upper-canvas " + m), this.wrapperEl.appendChild(C), this._copyCanvasStyle(S, C), this._applyCanvasStyle(C), this.contextTop = C.getContext("2d");
			},
			getTopContext: function() {
				return this.contextTop;
			},
			_createCacheCanvas: function() {
				this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d");
			},
			_initWrapperElement: function() {
				this.wrapperEl = x.util.wrapElement(this.lowerCanvasEl, "div", { class: this.containerClass }), x.util.setStyle(this.wrapperEl, {
					width: this.width + "px",
					height: this.height + "px",
					position: "relative"
				}), x.util.makeElementUnselectable(this.wrapperEl);
			},
			_applyCanvasStyle: function(m) {
				var S = this.width || m.width, C = this.height || m.height;
				x.util.setStyle(m, {
					position: "absolute",
					width: S + "px",
					height: C + "px",
					left: 0,
					top: 0,
					"touch-action": this.allowTouchScrolling ? "manipulation" : "none",
					"-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none"
				}), m.width = S, m.height = C, x.util.makeElementUnselectable(m);
			},
			_copyCanvasStyle: function(m, x) {
				x.style.cssText = m.style.cssText;
			},
			getSelectionContext: function() {
				return this.contextTop;
			},
			getSelectionElement: function() {
				return this.upperCanvasEl;
			},
			getActiveObject: function() {
				return this._activeObject;
			},
			getActiveObjects: function() {
				var m = this._activeObject;
				return m ? m.type === "activeSelection" && m._objects ? m._objects.slice(0) : [m] : [];
			},
			_onObjectRemoved: function(m) {
				m === this._activeObject && (this.fire("before:selection:cleared", { target: m }), this._discardActiveObject(), this.fire("selection:cleared", { target: m }), m.fire("deselected")), m === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", m);
			},
			_fireSelectionEvents: function(m, x) {
				var S = !1, C = this.getActiveObjects(), T = [], D = [];
				m.forEach(function(m) {
					C.indexOf(m) === -1 && (S = !0, m.fire("deselected", {
						e: x,
						target: m
					}), D.push(m));
				}), C.forEach(function(C) {
					m.indexOf(C) === -1 && (S = !0, C.fire("selected", {
						e: x,
						target: C
					}), T.push(C));
				}), m.length > 0 && C.length > 0 ? S && this.fire("selection:updated", {
					e: x,
					selected: T,
					deselected: D
				}) : C.length > 0 ? this.fire("selection:created", {
					e: x,
					selected: T
				}) : m.length > 0 && this.fire("selection:cleared", {
					e: x,
					deselected: D
				});
			},
			setActiveObject: function(m, x) {
				var S = this.getActiveObjects();
				return this._setActiveObject(m, x), this._fireSelectionEvents(S, x), this;
			},
			_setActiveObject: function(m, x) {
				return this._activeObject === m || !this._discardActiveObject(x, m) || m.onSelect({ e: x }) ? !1 : (this._activeObject = m, !0);
			},
			_discardActiveObject: function(m, x) {
				var S = this._activeObject;
				if (S) {
					if (S.onDeselect({
						e: m,
						object: x
					})) return !1;
					this._activeObject = null;
				}
				return !0;
			},
			discardActiveObject: function(m) {
				var x = this.getActiveObjects(), S = this.getActiveObject();
				return x.length && this.fire("before:selection:cleared", {
					target: S,
					e: m
				}), this._discardActiveObject(m), this._fireSelectionEvents(x, m), this;
			},
			dispose: function() {
				var m = this.wrapperEl;
				return this.removeListeners(), m.removeChild(this.upperCanvasEl), m.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach((function(m) {
					x.util.cleanUpJsdomNode(this[m]), this[m] = void 0;
				}).bind(this)), m.parentNode && m.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, x.StaticCanvas.prototype.dispose.call(this), this;
			},
			clear: function() {
				return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear");
			},
			drawControls: function(m) {
				var x = this._activeObject;
				x && x._renderControls(m);
			},
			_toObject: function(m, x, S) {
				var C = this._realizeGroupTransformOnObject(m), T = this.callSuper("_toObject", m, x, S);
				return this._unwindGroupTransformOnObject(m, C), T;
			},
			_realizeGroupTransformOnObject: function(m) {
				if (m.group && m.group.type === "activeSelection" && this._activeObject === m.group) {
					var S = [
						"angle",
						"flipX",
						"flipY",
						"left",
						"scaleX",
						"scaleY",
						"skewX",
						"skewY",
						"top"
					], C = {};
					return S.forEach(function(x) {
						C[x] = m[x];
					}), x.util.addTransformToObject(m, this._activeObject.calcOwnMatrix()), C;
				} else return null;
			},
			_unwindGroupTransformOnObject: function(m, x) {
				x && m.set(x);
			},
			_setSVGObject: function(m, x, S) {
				var C = this._realizeGroupTransformOnObject(x);
				this.callSuper("_setSVGObject", m, x, S), this._unwindGroupTransformOnObject(x, C);
			},
			setViewportTransform: function(m) {
				this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), x.StaticCanvas.prototype.setViewportTransform.call(this, m);
			}
		}), x.StaticCanvas) T !== "prototype" && (x.Canvas[T] = x.StaticCanvas[T]);
	})(), (function() {
		var m = x.util.addListener, S = x.util.removeListener, C = 3, T = 2, D = 1, O = { passive: !1 };
		function k(m, x) {
			return m.button && m.button === x - 1;
		}
		x.util.object.extend(x.Canvas.prototype, {
			mainTouchId: null,
			_initEventListeners: function() {
				this.removeListeners(), this._bindEvents(), this.addOrRemove(m, "add");
			},
			_getEventPrefix: function() {
				return this.enablePointerEvents ? "pointer" : "mouse";
			},
			addOrRemove: function(m, S) {
				var C = this.upperCanvasEl, T = this._getEventPrefix();
				m(x.window, "resize", this._onResize), m(C, T + "down", this._onMouseDown), m(C, T + "move", this._onMouseMove, O), m(C, T + "out", this._onMouseOut), m(C, T + "enter", this._onMouseEnter), m(C, "wheel", this._onMouseWheel), m(C, "contextmenu", this._onContextMenu), m(C, "dblclick", this._onDoubleClick), m(C, "dragover", this._onDragOver), m(C, "dragenter", this._onDragEnter), m(C, "dragleave", this._onDragLeave), m(C, "drop", this._onDrop), this.enablePointerEvents || m(C, "touchstart", this._onTouchStart, O), typeof eventjs < "u" && S in eventjs && (eventjs[S](C, "gesture", this._onGesture), eventjs[S](C, "drag", this._onDrag), eventjs[S](C, "orientation", this._onOrientationChange), eventjs[S](C, "shake", this._onShake), eventjs[S](C, "longpress", this._onLongPress));
			},
			removeListeners: function() {
				this.addOrRemove(S, "remove");
				var m = this._getEventPrefix();
				S(x.document, m + "up", this._onMouseUp), S(x.document, "touchend", this._onTouchEnd, O), S(x.document, m + "move", this._onMouseMove, O), S(x.document, "touchmove", this._onMouseMove, O);
			},
			_bindEvents: function() {
				this.eventsBound ||= (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), !0);
			},
			_onGesture: function(m, x) {
				this.__onTransformGesture && this.__onTransformGesture(m, x);
			},
			_onDrag: function(m, x) {
				this.__onDrag && this.__onDrag(m, x);
			},
			_onMouseWheel: function(m) {
				this.__onMouseWheel(m);
			},
			_onMouseOut: function(m) {
				var x = this._hoveredTarget;
				this.fire("mouse:out", {
					target: x,
					e: m
				}), this._hoveredTarget = null, x && x.fire("mouseout", { e: m });
				var S = this;
				this._hoveredTargets.forEach(function(x) {
					S.fire("mouse:out", {
						target: x,
						e: m
					}), x && x.fire("mouseout", { e: m });
				}), this._hoveredTargets = [];
			},
			_onMouseEnter: function(m) {
				!this._currentTransform && !this.findTarget(m) && (this.fire("mouse:over", {
					target: null,
					e: m
				}), this._hoveredTarget = null, this._hoveredTargets = []);
			},
			_onOrientationChange: function(m, x) {
				this.__onOrientationChange && this.__onOrientationChange(m, x);
			},
			_onShake: function(m, x) {
				this.__onShake && this.__onShake(m, x);
			},
			_onLongPress: function(m, x) {
				this.__onLongPress && this.__onLongPress(m, x);
			},
			_onDragOver: function(m) {
				m.preventDefault();
				var x = this._simpleEventHandler("dragover", m);
				this._fireEnterLeaveEvents(x, m);
			},
			_onDrop: function(m) {
				return this._simpleEventHandler("drop:before", m), this._simpleEventHandler("drop", m);
			},
			_onContextMenu: function(m) {
				return this.stopContextMenu && (m.stopPropagation(), m.preventDefault()), !1;
			},
			_onDoubleClick: function(m) {
				this._cacheTransformEventData(m), this._handleEvent(m, "dblclick"), this._resetTransformEventData(m);
			},
			getPointerId: function(m) {
				var x = m.changedTouches;
				return x ? x[0] && x[0].identifier : this.enablePointerEvents ? m.pointerId : -1;
			},
			_isMainEvent: function(m) {
				return m.isPrimary === !0 ? !0 : m.isPrimary === !1 ? !1 : m.type === "touchend" && m.touches.length === 0 ? !0 : m.changedTouches ? m.changedTouches[0].identifier === this.mainTouchId : !0;
			},
			_onTouchStart: function(C) {
				C.preventDefault(), this.mainTouchId === null && (this.mainTouchId = this.getPointerId(C)), this.__onMouseDown(C), this._resetTransformEventData();
				var T = this.upperCanvasEl, D = this._getEventPrefix();
				m(x.document, "touchend", this._onTouchEnd, O), m(x.document, "touchmove", this._onMouseMove, O), S(T, D + "down", this._onMouseDown);
			},
			_onMouseDown: function(C) {
				this.__onMouseDown(C), this._resetTransformEventData();
				var T = this.upperCanvasEl, D = this._getEventPrefix();
				S(T, D + "move", this._onMouseMove, O), m(x.document, D + "up", this._onMouseUp), m(x.document, D + "move", this._onMouseMove, O);
			},
			_onTouchEnd: function(C) {
				if (!(C.touches.length > 0)) {
					this.__onMouseUp(C), this._resetTransformEventData(), this.mainTouchId = null;
					var T = this._getEventPrefix();
					S(x.document, "touchend", this._onTouchEnd, O), S(x.document, "touchmove", this._onMouseMove, O);
					var D = this;
					this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function() {
						m(D.upperCanvasEl, T + "down", D._onMouseDown), D._willAddMouseDown = 0;
					}, 400);
				}
			},
			_onMouseUp: function(C) {
				this.__onMouseUp(C), this._resetTransformEventData();
				var T = this.upperCanvasEl, D = this._getEventPrefix();
				this._isMainEvent(C) && (S(x.document, D + "up", this._onMouseUp), S(x.document, D + "move", this._onMouseMove, O), m(T, D + "move", this._onMouseMove, O));
			},
			_onMouseMove: function(m) {
				!this.allowTouchScrolling && m.preventDefault && m.preventDefault(), this.__onMouseMove(m);
			},
			_onResize: function() {
				this.calcOffset();
			},
			_shouldRender: function(m) {
				var x = this._activeObject;
				return !!x != !!m || x && m && x !== m ? !0 : (x && x.isEditing, !1);
			},
			__onMouseUp: function(m) {
				var S, O = this._currentTransform, A = this._groupSelector, j = !1, M = !A || A.left === 0 && A.top === 0;
				if (this._cacheTransformEventData(m), S = this._target, this._handleEvent(m, "up:before"), k(m, C)) {
					this.fireRightClick && this._handleEvent(m, "up", C, M);
					return;
				}
				if (k(m, T)) {
					this.fireMiddleClick && this._handleEvent(m, "up", T, M), this._resetTransformEventData();
					return;
				}
				if (this.isDrawingMode && this._isCurrentlyDrawing) {
					this._onMouseUpInDrawingMode(m);
					return;
				}
				if (this._isMainEvent(m)) {
					if (O && (this._finalizeCurrentTransform(m), j = O.actionPerformed), !M) {
						var N = S === this._activeObject;
						this._maybeGroupObjects(m), j ||= this._shouldRender(S) || !N && S === this._activeObject;
					}
					var P, F;
					if (S) {
						if (P = S._findTargetCorner(this.getPointer(m, !0), x.util.isTouchEvent(m)), S.selectable && S !== this._activeObject && S.activeOn === "up") this.setActiveObject(S, m), j = !0;
						else {
							var I = S.controls[P], L = I && I.getMouseUpHandler(m, S, I);
							L && (F = this.getPointer(m), L(m, O, F.x, F.y));
						}
						S.isMoving = !1;
					}
					if (O && (O.target !== S || O.corner !== P)) {
						var R = O.target && O.target.controls[O.corner], z = R && R.getMouseUpHandler(m, S, I);
						F ||= this.getPointer(m), z && z(m, O, F.x, F.y);
					}
					this._setCursorFromEvent(m, S), this._handleEvent(m, "up", D, M), this._groupSelector = null, this._currentTransform = null, S && (S.__corner = 0), j ? this.requestRenderAll() : M || this.renderTop();
				}
			},
			_simpleEventHandler: function(m, x) {
				var S = this.findTarget(x), C = this.targets, T = {
					e: x,
					target: S,
					subTargets: C
				};
				if (this.fire(m, T), S && S.fire(m, T), !C) return S;
				for (var D = 0; D < C.length; D++) C[D].fire(m, T);
				return S;
			},
			_handleEvent: function(m, x, S, C) {
				var T = this._target, O = this.targets || [], k = {
					e: m,
					target: T,
					subTargets: O,
					button: S || D,
					isClick: C || !1,
					pointer: this._pointer,
					absolutePointer: this._absolutePointer,
					transform: this._currentTransform
				};
				x === "up" && (k.currentTarget = this.findTarget(m), k.currentSubTargets = this.targets), this.fire("mouse:" + x, k), T && T.fire("mouse" + x, k);
				for (var A = 0; A < O.length; A++) O[A].fire("mouse" + x, k);
			},
			_finalizeCurrentTransform: function(m) {
				var x = this._currentTransform, S = x.target, C = {
					e: m,
					target: S,
					transform: x,
					action: x.action
				};
				S._scaling &&= !1, S.setCoords(), (x.actionPerformed || this.stateful && S.hasStateChanged()) && this._fire("modified", C);
			},
			_onMouseDownInDrawingMode: function(m) {
				this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(m).requestRenderAll();
				var x = this.getPointer(m);
				this.freeDrawingBrush.onMouseDown(x, {
					e: m,
					pointer: x
				}), this._handleEvent(m, "down");
			},
			_onMouseMoveInDrawingMode: function(m) {
				if (this._isCurrentlyDrawing) {
					var x = this.getPointer(m);
					this.freeDrawingBrush.onMouseMove(x, {
						e: m,
						pointer: x
					});
				}
				this.setCursor(this.freeDrawingCursor), this._handleEvent(m, "move");
			},
			_onMouseUpInDrawingMode: function(m) {
				var x = this.getPointer(m);
				this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({
					e: m,
					pointer: x
				}), this._handleEvent(m, "up");
			},
			__onMouseDown: function(m) {
				this._cacheTransformEventData(m), this._handleEvent(m, "down:before");
				var S = this._target;
				if (k(m, C)) {
					this.fireRightClick && this._handleEvent(m, "down", C);
					return;
				}
				if (k(m, T)) {
					this.fireMiddleClick && this._handleEvent(m, "down", T);
					return;
				}
				if (this.isDrawingMode) {
					this._onMouseDownInDrawingMode(m);
					return;
				}
				if (this._isMainEvent(m) && !this._currentTransform) {
					var D = this._pointer;
					this._previousPointer = D;
					var O = this._shouldRender(S), A = this._shouldGroup(m, S);
					if (this._shouldClearSelection(m, S) ? this.discardActiveObject(m) : A && (this._handleGrouping(m, S), S = this._activeObject), this.selection && (!S || !S.selectable && !S.isEditing && S !== this._activeObject) && (this._groupSelector = {
						ex: this._absolutePointer.x,
						ey: this._absolutePointer.y,
						top: 0,
						left: 0
					}), S) {
						var j = S === this._activeObject;
						S.selectable && S.activeOn === "down" && this.setActiveObject(S, m);
						var M = S._findTargetCorner(this.getPointer(m, !0), x.util.isTouchEvent(m));
						if (S.__corner = M, S === this._activeObject && (M || !A)) {
							this._setupCurrentTransform(m, S, j);
							var N = S.controls[M], D = this.getPointer(m), P = N && N.getMouseDownHandler(m, S, N);
							P && P(m, this._currentTransform, D.x, D.y);
						}
					}
					this._handleEvent(m, "down"), (O || A) && this.requestRenderAll();
				}
			},
			_resetTransformEventData: function() {
				this._target = null, this._pointer = null, this._absolutePointer = null;
			},
			_cacheTransformEventData: function(m) {
				this._resetTransformEventData(), this._pointer = this.getPointer(m, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(m) || null;
			},
			_beforeTransform: function(m) {
				var x = this._currentTransform;
				this.stateful && x.target.saveState(), this.fire("before:transform", {
					e: m,
					transform: x
				});
			},
			__onMouseMove: function(m) {
				this._handleEvent(m, "move:before"), this._cacheTransformEventData(m);
				var x, S;
				if (this.isDrawingMode) {
					this._onMouseMoveInDrawingMode(m);
					return;
				}
				if (this._isMainEvent(m)) {
					var C = this._groupSelector;
					C ? (S = this._absolutePointer, C.left = S.x - C.ex, C.top = S.y - C.ey, this.renderTop()) : this._currentTransform ? this._transformObject(m) : (x = this.findTarget(m) || null, this._setCursorFromEvent(m, x), this._fireOverOutEvents(x, m)), this._handleEvent(m, "move"), this._resetTransformEventData();
				}
			},
			_fireOverOutEvents: function(m, x) {
				var S = this._hoveredTarget, C = this._hoveredTargets, T = this.targets, D = Math.max(C.length, T.length);
				this.fireSyntheticInOutEvents(m, x, {
					oldTarget: S,
					evtOut: "mouseout",
					canvasEvtOut: "mouse:out",
					evtIn: "mouseover",
					canvasEvtIn: "mouse:over"
				});
				for (var O = 0; O < D; O++) this.fireSyntheticInOutEvents(T[O], x, {
					oldTarget: C[O],
					evtOut: "mouseout",
					evtIn: "mouseover"
				});
				this._hoveredTarget = m, this._hoveredTargets = this.targets.concat();
			},
			_fireEnterLeaveEvents: function(m, x) {
				var S = this._draggedoverTarget, C = this._hoveredTargets, T = this.targets, D = Math.max(C.length, T.length);
				this.fireSyntheticInOutEvents(m, x, {
					oldTarget: S,
					evtOut: "dragleave",
					evtIn: "dragenter"
				});
				for (var O = 0; O < D; O++) this.fireSyntheticInOutEvents(T[O], x, {
					oldTarget: C[O],
					evtOut: "dragleave",
					evtIn: "dragenter"
				});
				this._draggedoverTarget = m;
			},
			fireSyntheticInOutEvents: function(m, x, S) {
				var C, T, D = S.oldTarget, O, k, A = D !== m, j = S.canvasEvtIn, M = S.canvasEvtOut;
				A && (C = {
					e: x,
					target: m,
					previousTarget: D
				}, T = {
					e: x,
					target: D,
					nextTarget: m
				}), k = m && A, O = D && A, O && (M && this.fire(M, T), D.fire(S.evtOut, T)), k && (j && this.fire(j, C), m.fire(S.evtIn, C));
			},
			__onMouseWheel: function(m) {
				this._cacheTransformEventData(m), this._handleEvent(m, "wheel"), this._resetTransformEventData();
			},
			_transformObject: function(m) {
				var x = this.getPointer(m), S = this._currentTransform;
				S.reset = !1, S.shiftKey = m.shiftKey, S.altKey = m[this.centeredKey], this._performTransformAction(m, S, x), S.actionPerformed && this.requestRenderAll();
			},
			_performTransformAction: function(m, x, S) {
				var C = S.x, T = S.y, D = x.action, O = !1, k = x.actionHandler;
				k && (O = k(m, x, C, T)), D === "drag" && O && (x.target.isMoving = !0, this.setCursor(x.target.moveCursor || this.moveCursor)), x.actionPerformed = x.actionPerformed || O;
			},
			_fire: x.controlsUtils.fireEvent,
			_setCursorFromEvent: function(m, x) {
				if (!x) return this.setCursor(this.defaultCursor), !1;
				var S = x.hoverCursor || this.hoverCursor, C = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, T = (!C || !C.contains(x)) && x._findTargetCorner(this.getPointer(m, !0));
				T ? this.setCursor(this.getCornerCursor(T, x, m)) : (x.subTargetCheck && this.targets.concat().reverse().map(function(m) {
					S = m.hoverCursor || S;
				}), this.setCursor(S));
			},
			getCornerCursor: function(m, x, S) {
				var C = x.controls[m];
				return C.cursorStyleHandler(S, C, x);
			}
		});
	})(), (function() {
		var m = Math.min, S = Math.max;
		x.util.object.extend(x.Canvas.prototype, {
			_shouldGroup: function(m, x) {
				var S = this._activeObject;
				return S && this._isSelectionKeyPressed(m) && x && x.selectable && this.selection && (S !== x || S.type === "activeSelection") && !x.onSelect({ e: m });
			},
			_handleGrouping: function(m, x) {
				var S = this._activeObject;
				S.__corner || x === S && (x = this.findTarget(m, !0), !x || !x.selectable) || (S && S.type === "activeSelection" ? this._updateActiveSelection(x, m) : this._createActiveSelection(x, m));
			},
			_updateActiveSelection: function(m, x) {
				var S = this._activeObject, C = S._objects.slice(0);
				S.contains(m) ? (S.removeWithUpdate(m), this._hoveredTarget = m, this._hoveredTargets = this.targets.concat(), S.size() === 1 && this._setActiveObject(S.item(0), x)) : (S.addWithUpdate(m), this._hoveredTarget = S, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(C, x);
			},
			_createActiveSelection: function(m, x) {
				var S = this.getActiveObjects(), C = this._createGroup(m);
				this._hoveredTarget = C, this._setActiveObject(C, x), this._fireSelectionEvents(S, x);
			},
			_createGroup: function(m) {
				var S = this._objects, C = S.indexOf(this._activeObject) < S.indexOf(m) ? [this._activeObject, m] : [m, this._activeObject];
				return this._activeObject.isEditing && this._activeObject.exitEditing(), new x.ActiveSelection(C, { canvas: this });
			},
			_groupSelectedObjects: function(m) {
				var S = this._collectObjects(m), C;
				S.length === 1 ? this.setActiveObject(S[0], m) : S.length > 1 && (C = new x.ActiveSelection(S.reverse(), { canvas: this }), this.setActiveObject(C, m));
			},
			_collectObjects: function(C) {
				for (var T = [], D, O = this._groupSelector.ex, k = this._groupSelector.ey, A = O + this._groupSelector.left, j = k + this._groupSelector.top, M = new x.Point(m(O, A), m(k, j)), N = new x.Point(S(O, A), S(k, j)), P = !this.selectionFullyContained, F = O === A && k === j, I = this._objects.length; I-- && (D = this._objects[I], !(!(!D || !D.selectable || !D.visible) && (P && D.intersectsWithRect(M, N, !0) || D.isContainedWithinRect(M, N, !0) || P && D.containsPoint(M, null, !0) || P && D.containsPoint(N, null, !0)) && (T.push(D), F))););
				return T.length > 1 && (T = T.filter(function(m) {
					return !m.onSelect({ e: C });
				})), T;
			},
			_maybeGroupObjects: function(m) {
				this.selection && this._groupSelector && this._groupSelectedObjects(m), this.setCursor(this.defaultCursor), this._groupSelector = null;
			}
		});
	})(), (function() {
		x.util.object.extend(x.StaticCanvas.prototype, {
			toDataURL: function(m) {
				m ||= {};
				var S = m.format || "png", C = m.quality || 1, T = (m.multiplier || 1) * (m.enableRetinaScaling ? this.getRetinaScaling() : 1), D = this.toCanvasElement(T, m);
				return x.util.toDataURL(D, S, C);
			},
			toCanvasElement: function(m, S) {
				m ||= 1, S ||= {};
				var C = (S.width || this.width) * m, T = (S.height || this.height) * m, D = this.getZoom(), O = this.width, k = this.height, A = D * m, j = this.viewportTransform, M = (j[4] - (S.left || 0)) * m, N = (j[5] - (S.top || 0)) * m, P = this.interactive, F = [
					A,
					0,
					0,
					A,
					M,
					N
				], I = this.enableRetinaScaling, L = x.util.createCanvasElement(), R = this.contextTop;
				return L.width = C, L.height = T, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = F, this.width = C, this.height = T, this.calcViewportBoundaries(), this.renderCanvas(L.getContext("2d"), this._objects), this.viewportTransform = j, this.width = O, this.height = k, this.calcViewportBoundaries(), this.interactive = P, this.enableRetinaScaling = I, this.contextTop = R, L;
			}
		});
	})(), x.util.object.extend(x.StaticCanvas.prototype, {
		loadFromJSON: function(m, S, C) {
			if (m) {
				var T = typeof m == "string" ? JSON.parse(m) : x.util.object.clone(m), D = this, O = T.clipPath, k = this.renderOnAddRemove;
				return this.renderOnAddRemove = !1, delete T.clipPath, this._enlivenObjects(T.objects, function(m) {
					D.clear(), D._setBgOverlay(T, function() {
						O ? D._enlivenObjects([O], function(x) {
							D.clipPath = x[0], D.__setupCanvas.call(D, T, m, k, S);
						}) : D.__setupCanvas.call(D, T, m, k, S);
					});
				}, C), this;
			}
		},
		__setupCanvas: function(m, x, S, C) {
			var T = this;
			x.forEach(function(m, x) {
				T.insertAt(m, x);
			}), this.renderOnAddRemove = S, delete m.objects, delete m.backgroundImage, delete m.overlayImage, delete m.background, delete m.overlay, this._setOptions(m), this.renderAll(), C && C();
		},
		_setBgOverlay: function(m, x) {
			var S = {
				backgroundColor: !1,
				overlayColor: !1,
				backgroundImage: !1,
				overlayImage: !1
			};
			if (!m.backgroundImage && !m.overlayImage && !m.background && !m.overlay) {
				x && x();
				return;
			}
			var C = function() {
				S.backgroundImage && S.overlayImage && S.backgroundColor && S.overlayColor && x && x();
			};
			this.__setBgOverlay("backgroundImage", m.backgroundImage, S, C), this.__setBgOverlay("overlayImage", m.overlayImage, S, C), this.__setBgOverlay("backgroundColor", m.background, S, C), this.__setBgOverlay("overlayColor", m.overlay, S, C);
		},
		__setBgOverlay: function(m, S, C, T) {
			var D = this;
			if (!S) {
				C[m] = !0, T && T();
				return;
			}
			m === "backgroundImage" || m === "overlayImage" ? x.util.enlivenObjects([S], function(x) {
				D[m] = x[0], C[m] = !0, T && T();
			}) : this["set" + x.util.string.capitalize(m, !0)](S, function() {
				C[m] = !0, T && T();
			});
		},
		_enlivenObjects: function(m, S, C) {
			if (!m || m.length === 0) {
				S && S([]);
				return;
			}
			x.util.enlivenObjects(m, function(m) {
				S && S(m);
			}, null, C);
		},
		_toDataURL: function(m, x) {
			this.clone(function(S) {
				x(S.toDataURL(m));
			});
		},
		_toDataURLWithMultiplier: function(m, x, S) {
			this.clone(function(C) {
				S(C.toDataURLWithMultiplier(m, x));
			});
		},
		clone: function(m, x) {
			var S = JSON.stringify(this.toJSON(x));
			this.cloneWithoutData(function(x) {
				x.loadFromJSON(S, function() {
					m && m(x);
				});
			});
		},
		cloneWithoutData: function(m) {
			var S = x.util.createCanvasElement();
			S.width = this.width, S.height = this.height;
			var C = new x.Canvas(S);
			this.backgroundImage ? (C.setBackgroundImage(this.backgroundImage.src, function() {
				C.renderAll(), m && m(C);
			}), C.backgroundImageOpacity = this.backgroundImageOpacity, C.backgroundImageStretch = this.backgroundImageStretch) : m && m(C);
		}
	}), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.util.object.clone, T = x.util.toFixed, D = x.util.string.capitalize, O = x.util.degreesToRadians, k = !x.isLikelyNode, A = 2;
		x.Object || (x.Object = x.util.createClass(x.CommonMethods, {
			type: "object",
			originX: "left",
			originY: "top",
			top: 0,
			left: 0,
			width: 0,
			height: 0,
			scaleX: 1,
			scaleY: 1,
			flipX: !1,
			flipY: !1,
			opacity: 1,
			angle: 0,
			skewX: 0,
			skewY: 0,
			cornerSize: 13,
			touchCornerSize: 24,
			transparentCorners: !0,
			hoverCursor: null,
			moveCursor: null,
			padding: 0,
			borderColor: "rgb(178,204,255)",
			borderDashArray: null,
			cornerColor: "rgb(178,204,255)",
			cornerStrokeColor: null,
			cornerStyle: "rect",
			cornerDashArray: null,
			centeredScaling: !1,
			centeredRotation: !0,
			fill: "rgb(0,0,0)",
			fillRule: "nonzero",
			globalCompositeOperation: "source-over",
			backgroundColor: "",
			selectionBackgroundColor: "",
			stroke: null,
			strokeWidth: 1,
			strokeDashArray: null,
			strokeDashOffset: 0,
			strokeLineCap: "butt",
			strokeLineJoin: "miter",
			strokeMiterLimit: 4,
			shadow: null,
			borderOpacityWhenMoving: .4,
			borderScaleFactor: 1,
			minScaleLimit: 0,
			selectable: !0,
			evented: !0,
			visible: !0,
			hasControls: !0,
			hasBorders: !0,
			perPixelTargetFind: !1,
			includeDefaultValues: !0,
			lockMovementX: !1,
			lockMovementY: !1,
			lockRotation: !1,
			lockScalingX: !1,
			lockScalingY: !1,
			lockSkewingX: !1,
			lockSkewingY: !1,
			lockScalingFlip: !1,
			excludeFromExport: !1,
			objectCaching: k,
			statefullCache: !1,
			noScaleCache: !0,
			strokeUniform: !1,
			dirty: !0,
			__corner: 0,
			paintFirst: "fill",
			activeOn: "down",
			stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "),
			cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "),
			colorProperties: "fill stroke backgroundColor".split(" "),
			clipPath: void 0,
			inverted: !1,
			absolutePositioned: !1,
			initialize: function(m) {
				m && this.setOptions(m);
			},
			_createCacheCanvas: function() {
				this._cacheProperties = {}, this._cacheCanvas = x.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
			},
			_limitCacheSize: function(m) {
				var S = x.perfLimitSizeTotal, C = m.width, T = m.height, D = x.maxCacheSideLimit, O = x.minCacheSideLimit;
				if (C <= D && T <= D && C * T <= S) return C < O && (m.width = O), T < O && (m.height = O), m;
				var k = C / T, A = x.util.limitDimsByArea(k, S), j = x.util.capValue, M = j(O, A.x, D), N = j(O, A.y, D);
				return C > M && (m.zoomX /= C / M, m.width = M, m.capped = !0), T > N && (m.zoomY /= T / N, m.height = N, m.capped = !0), m;
			},
			_getCacheCanvasDimensions: function() {
				var m = this.getTotalObjectScaling(), x = this._getTransformedDimensions(0, 0), S = x.x * m.scaleX / this.scaleX, C = x.y * m.scaleY / this.scaleY;
				return {
					width: Math.ceil(S + A),
					height: Math.ceil(C + A),
					zoomX: m.scaleX,
					zoomY: m.scaleY,
					x: S,
					y: C
				};
			},
			_updateCacheCanvas: function() {
				var m = this.canvas;
				if (this.noScaleCache && m && m._currentTransform) {
					var x = m._currentTransform.target, S = m._currentTransform.action;
					if (this === x && S.slice && S.slice(0, 5) === "scale") return !1;
				}
				var C = this._cacheCanvas, T = this._limitCacheSize(this._getCacheCanvasDimensions()), D = T.width, O = T.height, k, A, j = T.zoomX, M = T.zoomY, N = D !== this.cacheWidth || O !== this.cacheHeight, P = this.zoomX !== j || this.zoomY !== M;
				return N || P ? (N ? (C.width = D, C.height = O) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, C.width, C.height)), k = T.x / 2, A = T.y / 2, this.cacheTranslationX = Math.round(C.width / 2 - k) + k, this.cacheTranslationY = Math.round(C.height / 2 - A) + A, this.cacheWidth = D, this.cacheHeight = O, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(j, M), this.zoomX = j, this.zoomY = M, !0) : !1;
			},
			setOptions: function(m) {
				this._setOptions(m), this._initGradient(m.fill, "fill"), this._initGradient(m.stroke, "stroke"), this._initPattern(m.fill, "fill"), this._initPattern(m.stroke, "stroke");
			},
			transform: function(m) {
				var x = this.group && !this.group._transformDone || this.group && this.canvas && m === this.canvas.contextTop, S = this.calcTransformMatrix(!x);
				m.transform(S[0], S[1], S[2], S[3], S[4], S[5]);
			},
			toObject: function(m) {
				var S = x.Object.NUM_FRACTION_DIGITS, C = {
					type: this.type,
					version: x.version,
					originX: this.originX,
					originY: this.originY,
					left: T(this.left, S),
					top: T(this.top, S),
					width: T(this.width, S),
					height: T(this.height, S),
					fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,
					stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,
					strokeWidth: T(this.strokeWidth, S),
					strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
					strokeLineCap: this.strokeLineCap,
					strokeDashOffset: this.strokeDashOffset,
					strokeLineJoin: this.strokeLineJoin,
					strokeUniform: this.strokeUniform,
					strokeMiterLimit: T(this.strokeMiterLimit, S),
					scaleX: T(this.scaleX, S),
					scaleY: T(this.scaleY, S),
					angle: T(this.angle, S),
					flipX: this.flipX,
					flipY: this.flipY,
					opacity: T(this.opacity, S),
					shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,
					visible: this.visible,
					backgroundColor: this.backgroundColor,
					fillRule: this.fillRule,
					paintFirst: this.paintFirst,
					globalCompositeOperation: this.globalCompositeOperation,
					skewX: T(this.skewX, S),
					skewY: T(this.skewY, S)
				};
				return this.clipPath && !this.clipPath.excludeFromExport && (C.clipPath = this.clipPath.toObject(m), C.clipPath.inverted = this.clipPath.inverted, C.clipPath.absolutePositioned = this.clipPath.absolutePositioned), x.util.populateWithProperties(this, C, m), this.includeDefaultValues || (C = this._removeDefaultValues(C)), C;
			},
			toDatalessObject: function(m) {
				return this.toObject(m);
			},
			_removeDefaultValues: function(m) {
				var S = x.util.getKlass(m.type).prototype;
				return S.stateProperties.forEach(function(x) {
					x === "left" || x === "top" || (m[x] === S[x] && delete m[x], Array.isArray(m[x]) && Array.isArray(S[x]) && m[x].length === 0 && S[x].length === 0 && delete m[x]);
				}), m;
			},
			toString: function() {
				return "#<fabric." + D(this.type) + ">";
			},
			getObjectScaling: function() {
				if (!this.group) return {
					scaleX: this.scaleX,
					scaleY: this.scaleY
				};
				var m = x.util.qrDecompose(this.calcTransformMatrix());
				return {
					scaleX: Math.abs(m.scaleX),
					scaleY: Math.abs(m.scaleY)
				};
			},
			getTotalObjectScaling: function() {
				var m = this.getObjectScaling(), x = m.scaleX, S = m.scaleY;
				if (this.canvas) {
					var C = this.canvas.getZoom(), T = this.canvas.getRetinaScaling();
					x *= C * T, S *= C * T;
				}
				return {
					scaleX: x,
					scaleY: S
				};
			},
			getObjectOpacity: function() {
				var m = this.opacity;
				return this.group && (m *= this.group.getObjectOpacity()), m;
			},
			_set: function(m, S) {
				var C = m === "scaleX" || m === "scaleY", T = this[m] !== S, D = !1;
				return C && (S = this._constrainScale(S)), m === "scaleX" && S < 0 ? (this.flipX = !this.flipX, S *= -1) : m === "scaleY" && S < 0 ? (this.flipY = !this.flipY, S *= -1) : m === "shadow" && S && !(S instanceof x.Shadow) ? S = new x.Shadow(S) : m === "dirty" && this.group && this.group.set("dirty", S), this[m] = S, T && (D = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(m) > -1 ? (this.dirty = !0, D && this.group.set("dirty", !0)) : D && this.stateProperties.indexOf(m) > -1 && this.group.set("dirty", !0)), this;
			},
			setOnGroup: function() {},
			getViewportTransform: function() {
				return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : x.iMatrix.concat();
			},
			isNotVisible: function() {
				return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
			},
			render: function(m) {
				this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (m.save(), this._setupCompositeOperation(m), this.drawSelectionBackground(m), this.transform(m), this._setOpacity(m), this._setShadow(m, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(m)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(m), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), m.restore());
			},
			renderCache: function(m) {
				m ||= {}, (!this._cacheCanvas || !this._cacheContext) && this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, m.forClipping), this.dirty = !1);
			},
			_removeCacheCanvas: function() {
				this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0;
			},
			hasStroke: function() {
				return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
			},
			hasFill: function() {
				return this.fill && this.fill !== "transparent";
			},
			needsItsOwnCache: function() {
				return !!(this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow == "object" || this.clipPath);
			},
			shouldCache: function() {
				return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching;
			},
			willDrawShadow: function() {
				return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
			},
			drawClipPathOnCache: function(m, S) {
				if (m.save(), S.inverted ? m.globalCompositeOperation = "destination-out" : m.globalCompositeOperation = "destination-in", S.absolutePositioned) {
					var C = x.util.invertTransform(this.calcTransformMatrix());
					m.transform(C[0], C[1], C[2], C[3], C[4], C[5]);
				}
				S.transform(m), m.scale(1 / S.zoomX, 1 / S.zoomY), m.drawImage(S._cacheCanvas, -S.cacheTranslationX, -S.cacheTranslationY), m.restore();
			},
			drawObject: function(m, x) {
				var S = this.fill, C = this.stroke;
				x ? (this.fill = "black", this.stroke = "", this._setClippingProperties(m)) : this._renderBackground(m), this._render(m), this._drawClipPath(m, this.clipPath), this.fill = S, this.stroke = C;
			},
			_drawClipPath: function(m, x) {
				x && (x.canvas = this.canvas, x.shouldCache(), x._transformDone = !0, x.renderCache({ forClipping: !0 }), this.drawClipPathOnCache(m, x));
			},
			drawCacheOnCanvas: function(m) {
				m.scale(1 / this.zoomX, 1 / this.zoomY), m.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
			},
			isCacheDirty: function(m) {
				if (this.isNotVisible()) return !1;
				if (this._cacheCanvas && this._cacheContext && !m && this._updateCacheCanvas()) return !0;
				if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) {
					if (this._cacheCanvas && this._cacheContext && !m) {
						var x = this.cacheWidth / this.zoomX, S = this.cacheHeight / this.zoomY;
						this._cacheContext.clearRect(-x / 2, -S / 2, x, S);
					}
					return !0;
				}
				return !1;
			},
			_renderBackground: function(m) {
				if (this.backgroundColor) {
					var x = this._getNonTransformedDimensions();
					m.fillStyle = this.backgroundColor, m.fillRect(-x.x / 2, -x.y / 2, x.x, x.y), this._removeShadow(m);
				}
			},
			_setOpacity: function(m) {
				this.group && !this.group._transformDone ? m.globalAlpha = this.getObjectOpacity() : m.globalAlpha *= this.opacity;
			},
			_setStrokeStyles: function(m, x) {
				var S = x.stroke;
				S && (m.lineWidth = x.strokeWidth, m.lineCap = x.strokeLineCap, m.lineDashOffset = x.strokeDashOffset, m.lineJoin = x.strokeLineJoin, m.miterLimit = x.strokeMiterLimit, S.toLive ? S.gradientUnits === "percentage" || S.gradientTransform || S.patternTransform ? this._applyPatternForTransformedGradient(m, S) : (m.strokeStyle = S.toLive(m, this), this._applyPatternGradientTransform(m, S)) : m.strokeStyle = x.stroke);
			},
			_setFillStyles: function(m, x) {
				var S = x.fill;
				S && (S.toLive ? (m.fillStyle = S.toLive(m, this), this._applyPatternGradientTransform(m, x.fill)) : m.fillStyle = S);
			},
			_setClippingProperties: function(m) {
				m.globalAlpha = 1, m.strokeStyle = "transparent", m.fillStyle = "#000000";
			},
			_setLineDash: function(m, x) {
				!x || x.length === 0 || (1 & x.length && x.push.apply(x, x), m.setLineDash(x));
			},
			_renderControls: function(m, S) {
				var C = this.getViewportTransform(), T = this.calcTransformMatrix(), D, k, A;
				S ||= {}, k = S.hasBorders === void 0 ? this.hasBorders : S.hasBorders, A = S.hasControls === void 0 ? this.hasControls : S.hasControls, T = x.util.multiplyTransformMatrices(C, T), D = x.util.qrDecompose(T), m.save(), m.translate(D.translateX, D.translateY), m.lineWidth = 1 * this.borderScaleFactor, this.group || (m.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (D.angle -= 180), m.rotate(O(this.group ? D.angle : this.angle)), S.forActiveSelection || this.group ? k && this.drawBordersInGroup(m, D, S) : k && this.drawBorders(m, S), A && this.drawControls(m, S), m.restore();
			},
			_setShadow: function(m) {
				if (this.shadow) {
					var S = this.shadow, C = this.canvas, T, D = C && C.viewportTransform[0] || 1, O = C && C.viewportTransform[3] || 1;
					T = S.nonScaling ? {
						scaleX: 1,
						scaleY: 1
					} : this.getObjectScaling(), C && C._isRetinaScaling() && (D *= x.devicePixelRatio, O *= x.devicePixelRatio), m.shadowColor = S.color, m.shadowBlur = S.blur * x.browserShadowBlurConstant * (D + O) * (T.scaleX + T.scaleY) / 4, m.shadowOffsetX = S.offsetX * D * T.scaleX, m.shadowOffsetY = S.offsetY * O * T.scaleY;
				}
			},
			_removeShadow: function(m) {
				this.shadow && (m.shadowColor = "", m.shadowBlur = m.shadowOffsetX = m.shadowOffsetY = 0);
			},
			_applyPatternGradientTransform: function(m, x) {
				if (!x || !x.toLive) return {
					offsetX: 0,
					offsetY: 0
				};
				var S = x.gradientTransform || x.patternTransform, C = -this.width / 2 + x.offsetX || 0, T = -this.height / 2 + x.offsetY || 0;
				return x.gradientUnits === "percentage" ? m.transform(this.width, 0, 0, this.height, C, T) : m.transform(1, 0, 0, 1, C, T), S && m.transform(S[0], S[1], S[2], S[3], S[4], S[5]), {
					offsetX: C,
					offsetY: T
				};
			},
			_renderPaintInOrder: function(m) {
				this.paintFirst === "stroke" ? (this._renderStroke(m), this._renderFill(m)) : (this._renderFill(m), this._renderStroke(m));
			},
			_render: function() {},
			_renderFill: function(m) {
				this.fill && (m.save(), this._setFillStyles(m, this), this.fillRule === "evenodd" ? m.fill("evenodd") : m.fill(), m.restore());
			},
			_renderStroke: function(m) {
				if (!(!this.stroke || this.strokeWidth === 0)) {
					if (this.shadow && !this.shadow.affectStroke && this._removeShadow(m), m.save(), this.strokeUniform && this.group) {
						var x = this.getObjectScaling();
						m.scale(1 / x.scaleX, 1 / x.scaleY);
					} else this.strokeUniform && m.scale(1 / this.scaleX, 1 / this.scaleY);
					this._setLineDash(m, this.strokeDashArray), this._setStrokeStyles(m, this), m.stroke(), m.restore();
				}
			},
			_applyPatternForTransformedGradient: function(m, S) {
				var C = this._limitCacheSize(this._getCacheCanvasDimensions()), T = x.util.createCanvasElement(), D, O = this.canvas.getRetinaScaling(), k = C.x / this.scaleX / O, A = C.y / this.scaleY / O;
				T.width = Math.ceil(k), T.height = Math.ceil(A), D = T.getContext("2d"), D.beginPath(), D.moveTo(0, 0), D.lineTo(k, 0), D.lineTo(k, A), D.lineTo(0, A), D.closePath(), D.translate(k / 2, A / 2), D.scale(C.zoomX / this.scaleX / O, C.zoomY / this.scaleY / O), this._applyPatternGradientTransform(D, S), D.fillStyle = S.toLive(m), D.fill(), m.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), m.scale(O * this.scaleX / C.zoomX, O * this.scaleY / C.zoomY), m.strokeStyle = D.createPattern(T, "no-repeat");
			},
			_findCenterFromElement: function() {
				return {
					x: this.left + this.width / 2,
					y: this.top + this.height / 2
				};
			},
			_assignTransformMatrixProps: function() {
				if (this.transformMatrix) {
					var m = x.util.qrDecompose(this.transformMatrix);
					this.flipX = !1, this.flipY = !1, this.set("scaleX", m.scaleX), this.set("scaleY", m.scaleY), this.angle = m.angle, this.skewX = m.skewX, this.skewY = 0;
				}
			},
			_removeTransformMatrix: function(m) {
				var S = this._findCenterFromElement();
				this.transformMatrix && (this._assignTransformMatrixProps(), S = x.util.transformPoint(S, this.transformMatrix)), this.transformMatrix = null, m && (this.scaleX *= m.scaleX, this.scaleY *= m.scaleY, this.cropX = m.cropX, this.cropY = m.cropY, S.x += m.offsetLeft, S.y += m.offsetTop, this.width = m.width, this.height = m.height), this.setPositionByOrigin(S, "center", "center");
			},
			clone: function(m, S) {
				var C = this.toObject(S);
				this.constructor.fromObject ? this.constructor.fromObject(C, m) : x.Object._fromObject("Object", C, m);
			},
			cloneAsImage: function(m, S) {
				var C = this.toCanvasElement(S);
				return m && m(new x.Image(C)), this;
			},
			toCanvasElement: function(m) {
				m ||= {};
				var S = x.util, C = S.saveObjectTransform(this), T = this.group, D = this.shadow, O = Math.abs, k = (m.multiplier || 1) * (m.enableRetinaScaling ? x.devicePixelRatio : 1);
				delete this.group, m.withoutTransform && S.resetObjectTransform(this), m.withoutShadow && (this.shadow = null);
				var A = x.util.createCanvasElement(), j = this.getBoundingRect(!0, !0), M = this.shadow, N, P = {
					x: 0,
					y: 0
				}, F, I, L;
				M && (F = M.blur, N = M.nonScaling ? {
					scaleX: 1,
					scaleY: 1
				} : this.getObjectScaling(), P.x = 2 * Math.round(O(M.offsetX) + F) * O(N.scaleX), P.y = 2 * Math.round(O(M.offsetY) + F) * O(N.scaleY)), I = j.width + P.x, L = j.height + P.y, A.width = Math.ceil(I), A.height = Math.ceil(L);
				var R = new x.StaticCanvas(A, {
					enableRetinaScaling: !1,
					renderOnAddRemove: !1,
					skipOffscreen: !1
				});
				m.format === "jpeg" && (R.backgroundColor = "#fff"), this.setPositionByOrigin(new x.Point(R.width / 2, R.height / 2), "center", "center");
				var z = this.canvas;
				R.add(this);
				var B = R.toCanvasElement(k || 1, m);
				return this.shadow = D, this.set("canvas", z), T && (this.group = T), this.set(C).setCoords(), R._objects = [], R.dispose(), R = null, B;
			},
			toDataURL: function(m) {
				return m ||= {}, x.util.toDataURL(this.toCanvasElement(m), m.format || "png", m.quality || 1);
			},
			isType: function(m) {
				return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === m;
			},
			complexity: function() {
				return 1;
			},
			toJSON: function(m) {
				return this.toObject(m);
			},
			rotate: function(m) {
				var x = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation;
				return x && this._setOriginToCenter(), this.set("angle", m), x && this._resetOrigin(), this;
			},
			centerH: function() {
				return this.canvas && this.canvas.centerObjectH(this), this;
			},
			viewportCenterH: function() {
				return this.canvas && this.canvas.viewportCenterObjectH(this), this;
			},
			centerV: function() {
				return this.canvas && this.canvas.centerObjectV(this), this;
			},
			viewportCenterV: function() {
				return this.canvas && this.canvas.viewportCenterObjectV(this), this;
			},
			center: function() {
				return this.canvas && this.canvas.centerObject(this), this;
			},
			viewportCenter: function() {
				return this.canvas && this.canvas.viewportCenterObject(this), this;
			},
			getLocalPointer: function(m, S) {
				S ||= this.canvas.getPointer(m);
				var C = new x.Point(S.x, S.y), T = this._getLeftTopCoords();
				return this.angle && (C = x.util.rotatePoint(C, T, O(-this.angle))), {
					x: C.x - T.x,
					y: C.y - T.y
				};
			},
			_setupCompositeOperation: function(m) {
				this.globalCompositeOperation && (m.globalCompositeOperation = this.globalCompositeOperation);
			},
			dispose: function() {
				x.runningAnimations && x.runningAnimations.cancelByTarget(this);
			}
		}), x.util.createAccessors && x.util.createAccessors(x.Object), S(x.Object.prototype, x.Observable), x.Object.NUM_FRACTION_DIGITS = 2, x.Object.ENLIVEN_PROPS = ["clipPath"], x.Object._fromObject = function(m, S, T, D) {
			var O = x[m];
			S = C(S, !0), x.util.enlivenPatterns([S.fill, S.stroke], function(m) {
				m[0] !== void 0 && (S.fill = m[0]), m[1] !== void 0 && (S.stroke = m[1]), x.util.enlivenObjectEnlivables(S, S, function() {
					var m = D ? new O(S[D], S) : new O(S);
					T && T(m);
				});
			});
		}, x.Object.__uid = 0);
	})(m), (function() {
		var m = x.util.degreesToRadians, S = {
			left: -.5,
			center: 0,
			right: .5
		}, C = {
			top: -.5,
			center: 0,
			bottom: .5
		};
		x.util.object.extend(x.Object.prototype, {
			translateToGivenOrigin: function(m, T, D, O, k) {
				var A = m.x, j = m.y, M, N, P;
				return typeof T == "string" ? T = S[T] : T -= .5, typeof O == "string" ? O = S[O] : O -= .5, M = O - T, typeof D == "string" ? D = C[D] : D -= .5, typeof k == "string" ? k = C[k] : k -= .5, N = k - D, (M || N) && (P = this._getTransformedDimensions(), A = m.x + M * P.x, j = m.y + N * P.y), new x.Point(A, j);
			},
			translateToCenterPoint: function(S, C, T) {
				var D = this.translateToGivenOrigin(S, C, T, "center", "center");
				return this.angle ? x.util.rotatePoint(D, S, m(this.angle)) : D;
			},
			translateToOriginPoint: function(S, C, T) {
				var D = this.translateToGivenOrigin(S, "center", "center", C, T);
				return this.angle ? x.util.rotatePoint(D, S, m(this.angle)) : D;
			},
			getCenterPoint: function() {
				var m = new x.Point(this.left, this.top);
				return this.translateToCenterPoint(m, this.originX, this.originY);
			},
			getPointByOrigin: function(m, x) {
				var S = this.getCenterPoint();
				return this.translateToOriginPoint(S, m, x);
			},
			toLocalPoint: function(S, C, T) {
				var D = this.getCenterPoint(), O = C !== void 0 && T !== void 0 ? this.translateToGivenOrigin(D, "center", "center", C, T) : new x.Point(this.left, this.top), k = new x.Point(S.x, S.y);
				return this.angle && (k = x.util.rotatePoint(k, D, -m(this.angle))), k.subtractEquals(O);
			},
			setPositionByOrigin: function(m, x, S) {
				var C = this.translateToCenterPoint(m, x, S), T = this.translateToOriginPoint(C, this.originX, this.originY);
				this.set("left", T.x), this.set("top", T.y);
			},
			adjustPosition: function(C) {
				var T = m(this.angle), D = this.getScaledWidth(), O = x.util.cos(T) * D, k = x.util.sin(T) * D, A = typeof this.originX == "string" ? S[this.originX] : this.originX - .5, j = typeof C == "string" ? S[C] : C - .5;
				this.left += O * (j - A), this.top += k * (j - A), this.setCoords(), this.originX = C;
			},
			_setOriginToCenter: function() {
				this._originalOriginX = this.originX, this._originalOriginY = this.originY;
				var m = this.getCenterPoint();
				this.originX = "center", this.originY = "center", this.left = m.x, this.top = m.y;
			},
			_resetOrigin: function() {
				var m = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);
				this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = m.x, this.top = m.y, this._originalOriginX = null, this._originalOriginY = null;
			},
			_getLeftTopCoords: function() {
				return this.translateToOriginPoint(this.getCenterPoint(), "left", "top");
			}
		});
	})(), (function() {
		function m(m) {
			return [
				new x.Point(m.tl.x, m.tl.y),
				new x.Point(m.tr.x, m.tr.y),
				new x.Point(m.br.x, m.br.y),
				new x.Point(m.bl.x, m.bl.y)
			];
		}
		var S = x.util, C = S.degreesToRadians, T = S.multiplyTransformMatrices, D = S.transformPoint;
		S.object.extend(x.Object.prototype, {
			oCoords: null,
			aCoords: null,
			lineCoords: null,
			ownMatrixCache: null,
			matrixCache: null,
			controls: {},
			_getCoords: function(m, x) {
				return x ? m ? this.calcACoords() : this.calcLineCoords() : ((!this.aCoords || !this.lineCoords) && this.setCoords(!0), m ? this.aCoords : this.lineCoords);
			},
			getCoords: function(x, S) {
				return m(this._getCoords(x, S));
			},
			intersectsWithRect: function(m, S, C, T) {
				var D = this.getCoords(C, T);
				return x.Intersection.intersectPolygonRectangle(D, m, S).status === "Intersection";
			},
			intersectsWithObject: function(m, S, C) {
				return x.Intersection.intersectPolygonPolygon(this.getCoords(S, C), m.getCoords(S, C)).status === "Intersection" || m.isContainedWithinObject(this, S, C) || this.isContainedWithinObject(m, S, C);
			},
			isContainedWithinObject: function(m, x, S) {
				for (var C = this.getCoords(x, S), T = x ? m.aCoords : m.lineCoords, D = 0, O = m._getImageLines(T); D < 4; D++) if (!m.containsPoint(C[D], O)) return !1;
				return !0;
			},
			isContainedWithinRect: function(m, x, S, C) {
				var T = this.getBoundingRect(S, C);
				return T.left >= m.x && T.left + T.width <= x.x && T.top >= m.y && T.top + T.height <= x.y;
			},
			containsPoint: function(m, x, S, C) {
				var T = this._getCoords(S, C), x = x || this._getImageLines(T), D = this._findCrossPoints(m, x);
				return D !== 0 && D % 2 == 1;
			},
			isOnScreen: function(m) {
				if (!this.canvas) return !1;
				var x = this.canvas.vptCoords.tl, S = this.canvas.vptCoords.br;
				return this.getCoords(!0, m).some(function(m) {
					return m.x <= S.x && m.x >= x.x && m.y <= S.y && m.y >= x.y;
				}) || this.intersectsWithRect(x, S, !0, m) ? !0 : this._containsCenterOfCanvas(x, S, m);
			},
			_containsCenterOfCanvas: function(m, x, S) {
				var C = {
					x: (m.x + x.x) / 2,
					y: (m.y + x.y) / 2
				};
				return !!this.containsPoint(C, null, !0, S);
			},
			isPartiallyOnScreen: function(m) {
				if (!this.canvas) return !1;
				var x = this.canvas.vptCoords.tl, S = this.canvas.vptCoords.br;
				return this.intersectsWithRect(x, S, !0, m) ? !0 : this.getCoords(!0, m).every(function(m) {
					return (m.x >= S.x || m.x <= x.x) && (m.y >= S.y || m.y <= x.y);
				}) && this._containsCenterOfCanvas(x, S, m);
			},
			_getImageLines: function(m) {
				return {
					topline: {
						o: m.tl,
						d: m.tr
					},
					rightline: {
						o: m.tr,
						d: m.br
					},
					bottomline: {
						o: m.br,
						d: m.bl
					},
					leftline: {
						o: m.bl,
						d: m.tl
					}
				};
			},
			_findCrossPoints: function(m, x) {
				var S, C, T, D, O, k = 0, A;
				for (var j in x) if (A = x[j], !(A.o.y < m.y && A.d.y < m.y) && !(A.o.y >= m.y && A.d.y >= m.y) && (A.o.x === A.d.x && A.o.x >= m.x ? O = A.o.x : (S = 0, C = (A.d.y - A.o.y) / (A.d.x - A.o.x), T = m.y - S * m.x, D = A.o.y - C * A.o.x, O = -(T - D) / (S - C)), O >= m.x && (k += 1), k === 2)) break;
				return k;
			},
			getBoundingRect: function(m, x) {
				var C = this.getCoords(m, x);
				return S.makeBoundingBoxFromPoints(C);
			},
			getScaledWidth: function() {
				return this._getTransformedDimensions().x;
			},
			getScaledHeight: function() {
				return this._getTransformedDimensions().y;
			},
			_constrainScale: function(m) {
				return Math.abs(m) < this.minScaleLimit ? m < 0 ? -this.minScaleLimit : this.minScaleLimit : m === 0 ? 1e-4 : m;
			},
			scale: function(m) {
				return this._set("scaleX", m), this._set("scaleY", m), this.setCoords();
			},
			scaleToWidth: function(m, x) {
				var S = this.getBoundingRect(x).width / this.getScaledWidth();
				return this.scale(m / this.width / S);
			},
			scaleToHeight: function(m, x) {
				var S = this.getBoundingRect(x).height / this.getScaledHeight();
				return this.scale(m / this.height / S);
			},
			calcLineCoords: function() {
				var m = this.getViewportTransform(), x = this.padding, T = C(this.angle), O = S.cos(T), k = S.sin(T), A = O * x, j = k * x, M = A + j, N = A - j, P = this.calcACoords(), F = {
					tl: D(P.tl, m),
					tr: D(P.tr, m),
					bl: D(P.bl, m),
					br: D(P.br, m)
				};
				return x && (F.tl.x -= N, F.tl.y -= M, F.tr.x += M, F.tr.y -= N, F.bl.x -= M, F.bl.y += N, F.br.x += N, F.br.y += M), F;
			},
			calcOCoords: function() {
				var m = this._calcRotateMatrix(), x = this._calcTranslateMatrix(), S = this.getViewportTransform(), C = T(T(S, x), m), C = T(C, [
					1 / S[0],
					0,
					0,
					1 / S[3],
					0,
					0
				]), D = this._calculateCurrentDimensions(), O = {};
				return this.forEachControl(function(m, x, S) {
					O[x] = m.positionHandler(D, C, S);
				}), O;
			},
			calcACoords: function() {
				var m = this._calcRotateMatrix(), x = T(this._calcTranslateMatrix(), m), S = this._getTransformedDimensions(), C = S.x / 2, O = S.y / 2;
				return {
					tl: D({
						x: -C,
						y: -O
					}, x),
					tr: D({
						x: C,
						y: -O
					}, x),
					bl: D({
						x: -C,
						y: O
					}, x),
					br: D({
						x: C,
						y: O
					}, x)
				};
			},
			setCoords: function(m) {
				return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), m ? this : (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords(), this);
			},
			_calcRotateMatrix: function() {
				return S.calcRotateMatrix(this);
			},
			_calcTranslateMatrix: function() {
				var m = this.getCenterPoint();
				return [
					1,
					0,
					0,
					1,
					m.x,
					m.y
				];
			},
			transformMatrixKey: function(m) {
				var x = "_", S = "";
				return !m && this.group && (S = this.group.transformMatrixKey(m) + x), S + this.top + x + this.left + x + this.scaleX + x + this.scaleY + x + this.skewX + x + this.skewY + x + this.angle + x + this.originX + x + this.originY + x + this.width + x + this.height + x + this.strokeWidth + this.flipX + this.flipY;
			},
			calcTransformMatrix: function(m) {
				var x = this.calcOwnMatrix();
				if (m || !this.group) return x;
				var S = this.transformMatrixKey(m), C = this.matrixCache ||= {};
				return C.key === S ? C.value : (this.group && (x = T(this.group.calcTransformMatrix(!1), x)), C.key = S, C.value = x, x);
			},
			calcOwnMatrix: function() {
				var m = this.transformMatrixKey(!0), x = this.ownMatrixCache ||= {};
				if (x.key === m) return x.value;
				var C = this._calcTranslateMatrix(), T = {
					angle: this.angle,
					translateX: C[4],
					translateY: C[5],
					scaleX: this.scaleX,
					scaleY: this.scaleY,
					skewX: this.skewX,
					skewY: this.skewY,
					flipX: this.flipX,
					flipY: this.flipY
				};
				return x.key = m, x.value = S.composeMatrix(T), x.value;
			},
			_getNonTransformedDimensions: function() {
				var m = this.strokeWidth;
				return {
					x: this.width + m,
					y: this.height + m
				};
			},
			_getTransformedDimensions: function(m, x) {
				m === void 0 && (m = this.skewX), x === void 0 && (x = this.skewY);
				var C, T, D, O = m === 0 && x === 0;
				if (this.strokeUniform ? (T = this.width, D = this.height) : (C = this._getNonTransformedDimensions(), T = C.x, D = C.y), O) return this._finalizeDimensions(T * this.scaleX, D * this.scaleY);
				var k = S.sizeAfterTransform(T, D, {
					scaleX: this.scaleX,
					scaleY: this.scaleY,
					skewX: m,
					skewY: x
				});
				return this._finalizeDimensions(k.x, k.y);
			},
			_finalizeDimensions: function(m, x) {
				return this.strokeUniform ? {
					x: m + this.strokeWidth,
					y: x + this.strokeWidth
				} : {
					x: m,
					y: x
				};
			},
			_calculateCurrentDimensions: function() {
				var m = this.getViewportTransform();
				return D(this._getTransformedDimensions(), m, !0).scalarAdd(2 * this.padding);
			}
		});
	})(), x.util.object.extend(x.Object.prototype, {
		sendToBack: function() {
			return this.group ? x.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this;
		},
		bringToFront: function() {
			return this.group ? x.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this;
		},
		sendBackwards: function(m) {
			return this.group ? x.StaticCanvas.prototype.sendBackwards.call(this.group, this, m) : this.canvas && this.canvas.sendBackwards(this, m), this;
		},
		bringForward: function(m) {
			return this.group ? x.StaticCanvas.prototype.bringForward.call(this.group, this, m) : this.canvas && this.canvas.bringForward(this, m), this;
		},
		moveTo: function(m) {
			return this.group && this.group.type !== "activeSelection" ? x.StaticCanvas.prototype.moveTo.call(this.group, this, m) : this.canvas && this.canvas.moveTo(this, m), this;
		}
	}), (function() {
		function m(m, S) {
			if (S) {
				if (S.toLive) return m + ": url(#SVGID_" + S.id + "); ";
				var C = new x.Color(S), T = m + ": " + C.toRgb() + "; ", D = C.getAlpha();
				return D !== 1 && (T += m + "-opacity: " + D.toString() + "; "), T;
			} else return m + ": none; ";
		}
		var S = x.util.toFixed;
		x.util.object.extend(x.Object.prototype, {
			getSvgStyles: function(x) {
				var S = this.fillRule ? this.fillRule : "nonzero", C = this.strokeWidth ? this.strokeWidth : "0", T = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", D = this.strokeDashOffset ? this.strokeDashOffset : "0", O = this.strokeLineCap ? this.strokeLineCap : "butt", k = this.strokeLineJoin ? this.strokeLineJoin : "miter", A = this.strokeMiterLimit ? this.strokeMiterLimit : "4", j = this.opacity === void 0 ? "1" : this.opacity, M = this.visible ? "" : " visibility: hidden;", N = x ? "" : this.getSvgFilter(), P = m("fill", this.fill);
				return [
					m("stroke", this.stroke),
					"stroke-width: ",
					C,
					"; ",
					"stroke-dasharray: ",
					T,
					"; ",
					"stroke-linecap: ",
					O,
					"; ",
					"stroke-dashoffset: ",
					D,
					"; ",
					"stroke-linejoin: ",
					k,
					"; ",
					"stroke-miterlimit: ",
					A,
					"; ",
					P,
					"fill-rule: ",
					S,
					"; ",
					"opacity: ",
					j,
					";",
					N,
					M
				].join("");
			},
			getSvgSpanStyles: function(x, S) {
				var C = "; ", T = x.fontFamily ? "font-family: " + (x.fontFamily.indexOf("'") === -1 && x.fontFamily.indexOf("\"") === -1 ? "'" + x.fontFamily + "'" : x.fontFamily) + C : "", D = x.strokeWidth ? "stroke-width: " + x.strokeWidth + C : "", T = T, O = x.fontSize ? "font-size: " + x.fontSize + "px" + C : "", k = x.fontStyle ? "font-style: " + x.fontStyle + C : "", A = x.fontWeight ? "font-weight: " + x.fontWeight + C : "", j = x.fill ? m("fill", x.fill) : "", M = x.stroke ? m("stroke", x.stroke) : "", N = this.getSvgTextDecoration(x), P = x.deltaY ? "baseline-shift: " + -x.deltaY + "; " : "";
				return N &&= "text-decoration: " + N + C, [
					M,
					D,
					T,
					O,
					k,
					A,
					N,
					j,
					P,
					S ? "white-space: pre; " : ""
				].join("");
			},
			getSvgTextDecoration: function(m) {
				return [
					"overline",
					"underline",
					"line-through"
				].filter(function(x) {
					return m[x.replace("-", "")];
				}).join(" ");
			},
			getSvgFilter: function() {
				return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "";
			},
			getSvgCommons: function() {
				return [this.id ? "id=\"" + this.id + "\" " : "", this.clipPath ? "clip-path=\"url(#" + this.clipPath.clipPathId + ")\" " : ""].join("");
			},
			getSvgTransform: function(m, S) {
				var C = m ? this.calcTransformMatrix() : this.calcOwnMatrix();
				return "transform=\"" + x.util.matrixToSVG(C) + (S || "") + "\" ";
			},
			_setSVGBg: function(m) {
				if (this.backgroundColor) {
					var C = x.Object.NUM_FRACTION_DIGITS;
					m.push("		<rect ", this._getFillAttributes(this.backgroundColor), " x=\"", S(-this.width / 2, C), "\" y=\"", S(-this.height / 2, C), "\" width=\"", S(this.width, C), "\" height=\"", S(this.height, C), "\"></rect>\n");
				}
			},
			toSVG: function(m) {
				return this._createBaseSVGMarkup(this._toSVG(m), { reviver: m });
			},
			toClipPathSVG: function(m) {
				return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(m), { reviver: m });
			},
			_createBaseClipPathSVGMarkup: function(m, x) {
				x ||= {};
				var S = x.reviver, C = x.additionalTransform || "", T = [this.getSvgTransform(!0, C), this.getSvgCommons()].join(""), D = m.indexOf("COMMON_PARTS");
				return m[D] = T, S ? S(m.join("")) : m.join("");
			},
			_createBaseSVGMarkup: function(m, S) {
				S ||= {};
				var C = S.noStyle, T = S.reviver, D = C ? "" : "style=\"" + this.getSvgStyles() + "\" ", O = S.withShadow ? "style=\"" + this.getSvgFilter() + "\" " : "", k = this.clipPath, A = this.strokeUniform ? "vector-effect=\"non-scaling-stroke\" " : "", j = k && k.absolutePositioned, M = this.stroke, N = this.fill, P = this.shadow, F, I = [], L, R = m.indexOf("COMMON_PARTS"), z = S.additionalTransform;
				return k && (k.clipPathId = "CLIPPATH_" + x.Object.__uid++, L = "<clipPath id=\"" + k.clipPathId + "\" >\n" + k.toClipPathSVG(T) + "</clipPath>\n"), j && I.push("<g ", O, this.getSvgCommons(), " >\n"), I.push("<g ", this.getSvgTransform(!1), j ? "" : O + this.getSvgCommons(), " >\n"), F = [
					D,
					A,
					C ? "" : this.addPaintOrder(),
					" ",
					z ? "transform=\"" + z + "\" " : ""
				].join(""), m[R] = F, N && N.toLive && I.push(N.toSVG(this)), M && M.toLive && I.push(M.toSVG(this)), P && I.push(P.toSVG(this)), k && I.push(L), I.push(m.join("")), I.push("</g>\n"), j && I.push("</g>\n"), T ? T(I.join("")) : I.join("");
			},
			addPaintOrder: function() {
				return this.paintFirst === "fill" ? "" : " paint-order=\"" + this.paintFirst + "\" ";
			}
		});
	})(), (function() {
		var m = x.util.object.extend, S = "stateProperties";
		function C(x, S, C) {
			var T = {};
			C.forEach(function(m) {
				T[m] = x[m];
			}), m(x[S], T, !0);
		}
		function T(m, x, S) {
			if (m === x) return !0;
			if (Array.isArray(m)) {
				if (!Array.isArray(x) || m.length !== x.length) return !1;
				for (var C = 0, D = m.length; C < D; C++) if (!T(m[C], x[C])) return !1;
				return !0;
			} else if (m && typeof m == "object") {
				var O = Object.keys(m), k;
				if (!x || typeof x != "object" || !S && O.length !== Object.keys(x).length) return !1;
				for (var C = 0, D = O.length; C < D; C++) if (k = O[C], !(k === "canvas" || k === "group") && !T(m[k], x[k])) return !1;
				return !0;
			}
		}
		x.util.object.extend(x.Object.prototype, {
			hasStateChanged: function(m) {
				m ||= S;
				var x = "_" + m;
				return Object.keys(this[x]).length < this[m].length ? !0 : !T(this[x], this, !0);
			},
			saveState: function(m) {
				var x = m && m.propertySet || S, T = "_" + x;
				return this[T] ? (C(this, T, this[x]), m && m.stateProperties && C(this, T, m.stateProperties), this) : this.setupState(m);
			},
			setupState: function(m) {
				m ||= {};
				var x = m.propertySet || S;
				return m.propertySet = x, this["_" + x] = {}, this.saveState(m), this;
			}
		});
	})(), (function() {
		var m = x.util.degreesToRadians;
		x.util.object.extend(x.Object.prototype, {
			_findTargetCorner: function(m, x) {
				if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1;
				var S = m.x, C = m.y, T, D, O = Object.keys(this.oCoords), k = O.length - 1, A;
				for (this.__corner = 0; k >= 0; k--) if (A = O[k], this.isControlVisible(A) && (D = this._getImageLines(x ? this.oCoords[A].touchCorner : this.oCoords[A].corner), T = this._findCrossPoints({
					x: S,
					y: C
				}, D), T !== 0 && T % 2 == 1)) return this.__corner = A, A;
				return !1;
			},
			forEachControl: function(m) {
				for (var x in this.controls) m(this.controls[x], x, this);
			},
			_setCornerCoords: function() {
				var m = this.oCoords;
				for (var x in m) {
					var S = this.controls[x];
					m[x].corner = S.calcCornerCoords(this.angle, this.cornerSize, m[x].x, m[x].y, !1), m[x].touchCorner = S.calcCornerCoords(this.angle, this.touchCornerSize, m[x].x, m[x].y, !0);
				}
			},
			drawSelectionBackground: function(x) {
				if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this;
				x.save();
				var S = this.getCenterPoint(), C = this._calculateCurrentDimensions(), T = this.canvas.viewportTransform;
				return x.translate(S.x, S.y), x.scale(1 / T[0], 1 / T[3]), x.rotate(m(this.angle)), x.fillStyle = this.selectionBackgroundColor, x.fillRect(-C.x / 2, -C.y / 2, C.x, C.y), x.restore(), this;
			},
			drawBorders: function(m, x) {
				x ||= {};
				var S = this._calculateCurrentDimensions(), C = this.borderScaleFactor, T = S.x + C, D = S.y + C, O = x.hasControls === void 0 ? this.hasControls : x.hasControls, k = !1;
				return m.save(), m.strokeStyle = x.borderColor || this.borderColor, this._setLineDash(m, x.borderDashArray || this.borderDashArray), m.strokeRect(-T / 2, -D / 2, T, D), O && (m.beginPath(), this.forEachControl(function(x, S, C) {
					x.withConnection && x.getVisibility(C, S) && (k = !0, m.moveTo(x.x * T, x.y * D), m.lineTo(x.x * T + x.offsetX, x.y * D + x.offsetY));
				}), k && m.stroke()), m.restore(), this;
			},
			drawBordersInGroup: function(m, S, C) {
				C ||= {};
				var T = x.util.sizeAfterTransform(this.width, this.height, S), D = this.strokeWidth, O = this.strokeUniform, k = this.borderScaleFactor, A = T.x + D * (O ? this.canvas.getZoom() : S.scaleX) + k, j = T.y + D * (O ? this.canvas.getZoom() : S.scaleY) + k;
				return m.save(), this._setLineDash(m, C.borderDashArray || this.borderDashArray), m.strokeStyle = C.borderColor || this.borderColor, m.strokeRect(-A / 2, -j / 2, A, j), m.restore(), this;
			},
			drawControls: function(m, S) {
				S ||= {}, m.save();
				var C = 1, T, D;
				return this.canvas && (C = this.canvas.getRetinaScaling()), m.setTransform(C, 0, 0, C, 0, 0), m.strokeStyle = m.fillStyle = S.cornerColor || this.cornerColor, this.transparentCorners || (m.strokeStyle = S.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(m, S.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (T = this.group.calcTransformMatrix()), this.forEachControl(function(C, O, k) {
					D = k.oCoords[O], C.getVisibility(k, O) && (T && (D = x.util.transformPoint(D, T)), C.render(m, D.x, D.y, S, k));
				}), m.restore(), this;
			},
			isControlVisible: function(m) {
				return this.controls[m] && this.controls[m].getVisibility(this, m);
			},
			setControlVisible: function(m, x) {
				return this._controlsVisibility ||= {}, this._controlsVisibility[m] = x, this;
			},
			setControlsVisibility: function(m) {
				for (var x in m ||= {}, m) this.setControlVisible(x, m[x]);
				return this;
			},
			onDeselect: function() {},
			onSelect: function() {}
		});
	})(), x.util.object.extend(x.StaticCanvas.prototype, {
		FX_DURATION: 500,
		fxCenterObjectH: function(m, S) {
			S ||= {};
			var C = function() {}, T = S.onComplete || C, D = S.onChange || C, O = this;
			return x.util.animate({
				target: this,
				startValue: m.left,
				endValue: this.getCenterPoint().x,
				duration: this.FX_DURATION,
				onChange: function(x) {
					m.set("left", x), O.requestRenderAll(), D();
				},
				onComplete: function() {
					m.setCoords(), T();
				}
			});
		},
		fxCenterObjectV: function(m, S) {
			S ||= {};
			var C = function() {}, T = S.onComplete || C, D = S.onChange || C, O = this;
			return x.util.animate({
				target: this,
				startValue: m.top,
				endValue: this.getCenterPoint().y,
				duration: this.FX_DURATION,
				onChange: function(x) {
					m.set("top", x), O.requestRenderAll(), D();
				},
				onComplete: function() {
					m.setCoords(), T();
				}
			});
		},
		fxRemove: function(m, S) {
			S ||= {};
			var C = function() {}, T = S.onComplete || C, D = S.onChange || C, O = this;
			return x.util.animate({
				target: this,
				startValue: m.opacity,
				endValue: 0,
				duration: this.FX_DURATION,
				onChange: function(x) {
					m.set("opacity", x), O.requestRenderAll(), D();
				},
				onComplete: function() {
					O.remove(m), T();
				}
			});
		}
	}), x.util.object.extend(x.Object.prototype, {
		animate: function() {
			if (arguments[0] && typeof arguments[0] == "object") {
				var m = [], x, S, C = [];
				for (x in arguments[0]) m.push(x);
				for (var T = 0, D = m.length; T < D; T++) x = m[T], S = T !== D - 1, C.push(this._animate(x, arguments[0][x], arguments[1], S));
				return C;
			} else return this._animate.apply(this, arguments);
		},
		_animate: function(m, S, C, T) {
			var D = this, O;
			S = S.toString(), C = C ? x.util.object.clone(C) : {}, ~m.indexOf(".") && (O = m.split("."));
			var k = D.colorProperties.indexOf(m) > -1 || O && D.colorProperties.indexOf(O[1]) > -1, A = O ? this.get(O[0])[O[1]] : this.get(m);
			"from" in C || (C.from = A), k || (S = ~S.indexOf("=") ? A + parseFloat(S.replace("=", "")) : parseFloat(S));
			var j = {
				target: this,
				startValue: C.from,
				endValue: S,
				byValue: C.by,
				easing: C.easing,
				duration: C.duration,
				abort: C.abort && function(m, x, S) {
					return C.abort.call(D, m, x, S);
				},
				onChange: function(x, S, k) {
					O ? D[O[0]][O[1]] = x : D.set(m, x), !T && C.onChange && C.onChange(x, S, k);
				},
				onComplete: function(m, x, S) {
					T || (D.setCoords(), C.onComplete && C.onComplete(m, x, S));
				}
			};
			return k ? x.util.animateColor(j.startValue, j.endValue, j.duration, j) : x.util.animate(j);
		}
	}), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.util.object.clone, T = {
			x1: 1,
			x2: 1,
			y1: 1,
			y2: 1
		};
		if (x.Line) {
			x.warn("fabric.Line is already defined");
			return;
		}
		x.Line = x.util.createClass(x.Object, {
			type: "line",
			x1: 0,
			y1: 0,
			x2: 0,
			y2: 0,
			cacheProperties: x.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"),
			initialize: function(m, x) {
				m ||= [
					0,
					0,
					0,
					0
				], this.callSuper("initialize", x), this.set("x1", m[0]), this.set("y1", m[1]), this.set("x2", m[2]), this.set("y2", m[3]), this._setWidthHeight(x);
			},
			_setWidthHeight: function(m) {
				m ||= {}, this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in m ? m.left : this._getLeftToOriginX(), this.top = "top" in m ? m.top : this._getTopToOriginY();
			},
			_set: function(m, x) {
				return this.callSuper("_set", m, x), T[m] !== void 0 && this._setWidthHeight(), this;
			},
			_getLeftToOriginX: D({
				origin: "originX",
				axis1: "x1",
				axis2: "x2",
				dimension: "width"
			}, {
				nearest: "left",
				center: "center",
				farthest: "right"
			}),
			_getTopToOriginY: D({
				origin: "originY",
				axis1: "y1",
				axis2: "y2",
				dimension: "height"
			}, {
				nearest: "top",
				center: "center",
				farthest: "bottom"
			}),
			_render: function(m) {
				m.beginPath();
				var x = this.calcLinePoints();
				m.moveTo(x.x1, x.y1), m.lineTo(x.x2, x.y2), m.lineWidth = this.strokeWidth;
				var S = m.strokeStyle;
				m.strokeStyle = this.stroke || m.fillStyle, this.stroke && this._renderStroke(m), m.strokeStyle = S;
			},
			_findCenterFromElement: function() {
				return {
					x: (this.x1 + this.x2) / 2,
					y: (this.y1 + this.y2) / 2
				};
			},
			toObject: function(m) {
				return S(this.callSuper("toObject", m), this.calcLinePoints());
			},
			_getNonTransformedDimensions: function() {
				var m = this.callSuper("_getNonTransformedDimensions");
				return this.strokeLineCap === "butt" && (this.width === 0 && (m.y -= this.strokeWidth), this.height === 0 && (m.x -= this.strokeWidth)), m;
			},
			calcLinePoints: function() {
				var m = this.x1 <= this.x2 ? -1 : 1, x = this.y1 <= this.y2 ? -1 : 1, S = m * this.width * .5, C = x * this.height * .5;
				return {
					x1: S,
					x2: m * this.width * -.5,
					y1: C,
					y2: x * this.height * -.5
				};
			},
			_toSVG: function() {
				var m = this.calcLinePoints();
				return [
					"<line ",
					"COMMON_PARTS",
					"x1=\"",
					m.x1,
					"\" y1=\"",
					m.y1,
					"\" x2=\"",
					m.x2,
					"\" y2=\"",
					m.y2,
					"\" />\n"
				];
			}
		}), x.Line.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), x.Line.fromElement = function(m, C, T) {
			T ||= {};
			var D = x.parseAttributes(m, x.Line.ATTRIBUTE_NAMES), O = [
				D.x1 || 0,
				D.y1 || 0,
				D.x2 || 0,
				D.y2 || 0
			];
			C(new x.Line(O, S(D, T)));
		}, x.Line.fromObject = function(m, S) {
			function T(m) {
				delete m.points, S && S(m);
			}
			var D = C(m, !0);
			D.points = [
				m.x1,
				m.y1,
				m.x2,
				m.y2
			], x.Object._fromObject("Line", D, T, "points");
		};
		function D(m, x) {
			var S = m.origin, C = m.axis1, T = m.axis2, D = m.dimension, O = x.nearest, k = x.center, A = x.farthest;
			return function() {
				switch (this.get(S)) {
					case O: return Math.min(this.get(C), this.get(T));
					case k: return Math.min(this.get(C), this.get(T)) + .5 * this.get(D);
					case A: return Math.max(this.get(C), this.get(T));
				}
			};
		}
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.degreesToRadians;
		if (x.Circle) {
			x.warn("fabric.Circle is already defined.");
			return;
		}
		x.Circle = x.util.createClass(x.Object, {
			type: "circle",
			radius: 0,
			startAngle: 0,
			endAngle: 360,
			cacheProperties: x.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"),
			_set: function(m, x) {
				return this.callSuper("_set", m, x), m === "radius" && this.setRadius(x), this;
			},
			toObject: function(m) {
				return this.callSuper("toObject", [
					"radius",
					"startAngle",
					"endAngle"
				].concat(m));
			},
			_toSVG: function() {
				var m, C = 0, T = 0, D = (this.endAngle - this.startAngle) % 360;
				if (D === 0) m = [
					"<circle ",
					"COMMON_PARTS",
					"cx=\"" + C + "\" cy=\"" + T + "\" ",
					"r=\"",
					this.radius,
					"\" />\n"
				];
				else {
					var O = S(this.startAngle), k = S(this.endAngle), A = this.radius, j = x.util.cos(O) * A, M = x.util.sin(O) * A, N = x.util.cos(k) * A, P = x.util.sin(k) * A, F = D > 180 ? "1" : "0";
					m = [
						"<path d=\"M " + j + " " + M,
						" A " + A + " " + A,
						" 0 ",
						+F + " 1",
						" " + N + " " + P,
						"\" ",
						"COMMON_PARTS",
						" />\n"
					];
				}
				return m;
			},
			_render: function(m) {
				m.beginPath(), m.arc(0, 0, this.radius, S(this.startAngle), S(this.endAngle), !1), this._renderPaintInOrder(m);
			},
			getRadiusX: function() {
				return this.get("radius") * this.get("scaleX");
			},
			getRadiusY: function() {
				return this.get("radius") * this.get("scaleY");
			},
			setRadius: function(m) {
				return this.radius = m, this.set("width", m * 2).set("height", m * 2);
			}
		}), x.Circle.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), x.Circle.fromElement = function(m, S) {
			var T = x.parseAttributes(m, x.Circle.ATTRIBUTE_NAMES);
			if (!C(T)) throw Error("value of `r` attribute is required and can not be negative");
			T.left = (T.left || 0) - T.radius, T.top = (T.top || 0) - T.radius, S(new x.Circle(T));
		};
		function C(m) {
			return "radius" in m && m.radius >= 0;
		}
		x.Circle.fromObject = function(m, S) {
			x.Object._fromObject("Circle", m, S);
		};
	})(m), (function(m) {
		var x = m.fabric ||= {};
		if (x.Triangle) {
			x.warn("fabric.Triangle is already defined");
			return;
		}
		x.Triangle = x.util.createClass(x.Object, {
			type: "triangle",
			width: 100,
			height: 100,
			_render: function(m) {
				var x = this.width / 2, S = this.height / 2;
				m.beginPath(), m.moveTo(-x, S), m.lineTo(0, -S), m.lineTo(x, S), m.closePath(), this._renderPaintInOrder(m);
			},
			_toSVG: function() {
				var m = this.width / 2, x = this.height / 2;
				return [
					"<polygon ",
					"COMMON_PARTS",
					"points=\"",
					[
						-m + " " + x,
						"0 " + -x,
						m + " " + x
					].join(","),
					"\" />"
				];
			}
		}), x.Triangle.fromObject = function(m, S) {
			return x.Object._fromObject("Triangle", m, S);
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = Math.PI * 2;
		if (x.Ellipse) {
			x.warn("fabric.Ellipse is already defined.");
			return;
		}
		x.Ellipse = x.util.createClass(x.Object, {
			type: "ellipse",
			rx: 0,
			ry: 0,
			cacheProperties: x.Object.prototype.cacheProperties.concat("rx", "ry"),
			initialize: function(m) {
				this.callSuper("initialize", m), this.set("rx", m && m.rx || 0), this.set("ry", m && m.ry || 0);
			},
			_set: function(m, x) {
				switch (this.callSuper("_set", m, x), m) {
					case "rx":
						this.rx = x, this.set("width", x * 2);
						break;
					case "ry":
						this.ry = x, this.set("height", x * 2);
						break;
				}
				return this;
			},
			getRx: function() {
				return this.get("rx") * this.get("scaleX");
			},
			getRy: function() {
				return this.get("ry") * this.get("scaleY");
			},
			toObject: function(m) {
				return this.callSuper("toObject", ["rx", "ry"].concat(m));
			},
			_toSVG: function() {
				return [
					"<ellipse ",
					"COMMON_PARTS",
					"cx=\"0\" cy=\"0\" ",
					"rx=\"",
					this.rx,
					"\" ry=\"",
					this.ry,
					"\" />\n"
				];
			},
			_render: function(m) {
				m.beginPath(), m.save(), m.transform(1, 0, 0, this.ry / this.rx, 0, 0), m.arc(0, 0, this.rx, 0, S, !1), m.restore(), this._renderPaintInOrder(m);
			}
		}), x.Ellipse.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), x.Ellipse.fromElement = function(m, S) {
			var C = x.parseAttributes(m, x.Ellipse.ATTRIBUTE_NAMES);
			C.left = (C.left || 0) - C.rx, C.top = (C.top || 0) - C.ry, S(new x.Ellipse(C));
		}, x.Ellipse.fromObject = function(m, S) {
			x.Object._fromObject("Ellipse", m, S);
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend;
		if (x.Rect) {
			x.warn("fabric.Rect is already defined");
			return;
		}
		x.Rect = x.util.createClass(x.Object, {
			stateProperties: x.Object.prototype.stateProperties.concat("rx", "ry"),
			type: "rect",
			rx: 0,
			ry: 0,
			cacheProperties: x.Object.prototype.cacheProperties.concat("rx", "ry"),
			initialize: function(m) {
				this.callSuper("initialize", m), this._initRxRy();
			},
			_initRxRy: function() {
				this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry);
			},
			_render: function(m) {
				var x = this.rx ? Math.min(this.rx, this.width / 2) : 0, S = this.ry ? Math.min(this.ry, this.height / 2) : 0, C = this.width, T = this.height, D = -this.width / 2, O = -this.height / 2, k = x !== 0 || S !== 0, A = .4477152502;
				m.beginPath(), m.moveTo(D + x, O), m.lineTo(D + C - x, O), k && m.bezierCurveTo(D + C - A * x, O, D + C, O + A * S, D + C, O + S), m.lineTo(D + C, O + T - S), k && m.bezierCurveTo(D + C, O + T - A * S, D + C - A * x, O + T, D + C - x, O + T), m.lineTo(D + x, O + T), k && m.bezierCurveTo(D + A * x, O + T, D, O + T - A * S, D, O + T - S), m.lineTo(D, O + S), k && m.bezierCurveTo(D, O + A * S, D + A * x, O, D + x, O), m.closePath(), this._renderPaintInOrder(m);
			},
			toObject: function(m) {
				return this.callSuper("toObject", ["rx", "ry"].concat(m));
			},
			_toSVG: function() {
				return [
					"<rect ",
					"COMMON_PARTS",
					"x=\"",
					-this.width / 2,
					"\" y=\"",
					-this.height / 2,
					"\" rx=\"",
					this.rx,
					"\" ry=\"",
					this.ry,
					"\" width=\"",
					this.width,
					"\" height=\"",
					this.height,
					"\" />\n"
				];
			}
		}), x.Rect.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), x.Rect.fromElement = function(m, C, T) {
			if (!m) return C(null);
			T ||= {};
			var D = x.parseAttributes(m, x.Rect.ATTRIBUTE_NAMES);
			D.left = D.left || 0, D.top = D.top || 0, D.height = D.height || 0, D.width = D.width || 0;
			var O = new x.Rect(S(T ? x.util.object.clone(T) : {}, D));
			O.visible = O.visible && O.width > 0 && O.height > 0, C(O);
		}, x.Rect.fromObject = function(m, S) {
			return x.Object._fromObject("Rect", m, S);
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.util.array.min, T = x.util.array.max, D = x.util.toFixed, O = x.util.projectStrokeOnPoints;
		if (x.Polyline) {
			x.warn("fabric.Polyline is already defined");
			return;
		}
		x.Polyline = x.util.createClass(x.Object, {
			type: "polyline",
			points: null,
			exactBoundingBox: !1,
			cacheProperties: x.Object.prototype.cacheProperties.concat("points"),
			initialize: function(m, x) {
				x ||= {}, this.points = m || [], this.callSuper("initialize", x), this._setPositionDimensions(x);
			},
			_projectStrokeOnPoints: function() {
				return O(this.points, this, !0);
			},
			_setPositionDimensions: function(m) {
				var x = this._calcDimensions(m), S, C = this.exactBoundingBox ? this.strokeWidth : 0;
				this.width = x.width - C, this.height = x.height - C, m.fromSVG || (S = this.translateToGivenOrigin({
					x: x.left - this.strokeWidth / 2 + C / 2,
					y: x.top - this.strokeWidth / 2 + C / 2
				}, "left", "top", this.originX, this.originY)), m.left === void 0 && (this.left = m.fromSVG ? x.left : S.x), m.top === void 0 && (this.top = m.fromSVG ? x.top : S.y), this.pathOffset = {
					x: x.left + this.width / 2 + C / 2,
					y: x.top + this.height / 2 + C / 2
				};
			},
			_calcDimensions: function() {
				var m = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, x = C(m, "x") || 0, S = C(m, "y") || 0, D = T(m, "x") || 0, O = T(m, "y") || 0;
				return {
					left: x,
					top: S,
					width: D - x,
					height: O - S
				};
			},
			toObject: function(m) {
				return S(this.callSuper("toObject", m), { points: this.points.concat() });
			},
			_toSVG: function() {
				for (var m = [], S = this.pathOffset.x, C = this.pathOffset.y, T = x.Object.NUM_FRACTION_DIGITS, O = 0, k = this.points.length; O < k; O++) m.push(D(this.points[O].x - S, T), ",", D(this.points[O].y - C, T), " ");
				return [
					"<" + this.type + " ",
					"COMMON_PARTS",
					"points=\"",
					m.join(""),
					"\" />\n"
				];
			},
			commonRender: function(m) {
				var x, S = this.points.length, C = this.pathOffset.x, T = this.pathOffset.y;
				if (!S || isNaN(this.points[S - 1].y)) return !1;
				m.beginPath(), m.moveTo(this.points[0].x - C, this.points[0].y - T);
				for (var D = 0; D < S; D++) x = this.points[D], m.lineTo(x.x - C, x.y - T);
				return !0;
			},
			_render: function(m) {
				this.commonRender(m) && this._renderPaintInOrder(m);
			},
			complexity: function() {
				return this.get("points").length;
			}
		}), x.Polyline.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat(), x.Polyline.fromElementGenerator = function(m) {
			return function(C, T, D) {
				if (!C) return T(null);
				D ||= {};
				var O = x.parsePointsAttribute(C.getAttribute("points")), k = x.parseAttributes(C, x[m].ATTRIBUTE_NAMES);
				k.fromSVG = !0, T(new x[m](O, S(k, D)));
			};
		}, x.Polyline.fromElement = x.Polyline.fromElementGenerator("Polyline"), x.Polyline.fromObject = function(m, S) {
			return x.Object._fromObject("Polyline", m, S, "points");
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.projectStrokeOnPoints;
		if (x.Polygon) {
			x.warn("fabric.Polygon is already defined");
			return;
		}
		x.Polygon = x.util.createClass(x.Polyline, {
			type: "polygon",
			_projectStrokeOnPoints: function() {
				return S(this.points, this);
			},
			_render: function(m) {
				this.commonRender(m) && (m.closePath(), this._renderPaintInOrder(m));
			}
		}), x.Polygon.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat(), x.Polygon.fromElement = x.Polyline.fromElementGenerator("Polygon"), x.Polygon.fromObject = function(m, S) {
			x.Object._fromObject("Polygon", m, S, "points");
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.array.min, C = x.util.array.max, T = x.util.object.extend, D = x.util.object.clone, O = x.util.toFixed;
		if (x.Path) {
			x.warn("fabric.Path is already defined");
			return;
		}
		x.Path = x.util.createClass(x.Object, {
			type: "path",
			path: null,
			cacheProperties: x.Object.prototype.cacheProperties.concat("path", "fillRule"),
			stateProperties: x.Object.prototype.stateProperties.concat("path"),
			initialize: function(m, x) {
				x = D(x || {}), delete x.path, this.callSuper("initialize", x), this._setPath(m || [], x);
			},
			_setPath: function(m, S) {
				this.path = x.util.makePathSimpler(Array.isArray(m) ? m : x.util.parsePath(m)), x.Polyline.prototype._setPositionDimensions.call(this, S || {});
			},
			_renderPathCommands: function(m) {
				var x, S = 0, C = 0, T = 0, D = 0, O = 0, k = 0, A = -this.pathOffset.x, j = -this.pathOffset.y;
				m.beginPath();
				for (var M = 0, N = this.path.length; M < N; ++M) switch (x = this.path[M], x[0]) {
					case "L":
						T = x[1], D = x[2], m.lineTo(T + A, D + j);
						break;
					case "M":
						T = x[1], D = x[2], S = T, C = D, m.moveTo(T + A, D + j);
						break;
					case "C":
						T = x[5], D = x[6], O = x[3], k = x[4], m.bezierCurveTo(x[1] + A, x[2] + j, O + A, k + j, T + A, D + j);
						break;
					case "Q":
						m.quadraticCurveTo(x[1] + A, x[2] + j, x[3] + A, x[4] + j), T = x[3], D = x[4], O = x[1], k = x[2];
						break;
					case "z":
					case "Z":
						T = S, D = C, m.closePath();
						break;
				}
			},
			_render: function(m) {
				this._renderPathCommands(m), this._renderPaintInOrder(m);
			},
			toString: function() {
				return "#<fabric.Path (" + this.complexity() + "): { \"top\": " + this.top + ", \"left\": " + this.left + " }>";
			},
			toObject: function(m) {
				return T(this.callSuper("toObject", m), { path: this.path.map(function(m) {
					return m.slice();
				}) });
			},
			toDatalessObject: function(m) {
				var x = this.toObject(["sourcePath"].concat(m));
				return x.sourcePath && delete x.path, x;
			},
			_toSVG: function() {
				return [
					"<path ",
					"COMMON_PARTS",
					"d=\"",
					x.util.joinPath(this.path),
					"\" stroke-linecap=\"round\" ",
					"/>\n"
				];
			},
			_getOffsetTransform: function() {
				var m = x.Object.NUM_FRACTION_DIGITS;
				return " translate(" + O(-this.pathOffset.x, m) + ", " + O(-this.pathOffset.y, m) + ")";
			},
			toClipPathSVG: function(m) {
				var x = this._getOffsetTransform();
				return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), {
					reviver: m,
					additionalTransform: x
				});
			},
			toSVG: function(m) {
				var x = this._getOffsetTransform();
				return this._createBaseSVGMarkup(this._toSVG(), {
					reviver: m,
					additionalTransform: x
				});
			},
			complexity: function() {
				return this.path.length;
			},
			_calcDimensions: function() {
				for (var m = [], T = [], D, O = 0, k = 0, A = 0, j = 0, M, N = 0, P = this.path.length; N < P; ++N) {
					switch (D = this.path[N], D[0]) {
						case "L":
							A = D[1], j = D[2], M = [];
							break;
						case "M":
							A = D[1], j = D[2], O = A, k = j, M = [];
							break;
						case "C":
							M = x.util.getBoundsOfCurve(A, j, D[1], D[2], D[3], D[4], D[5], D[6]), A = D[5], j = D[6];
							break;
						case "Q":
							M = x.util.getBoundsOfCurve(A, j, D[1], D[2], D[1], D[2], D[3], D[4]), A = D[3], j = D[4];
							break;
						case "z":
						case "Z":
							A = O, j = k;
							break;
					}
					M.forEach(function(x) {
						m.push(x.x), T.push(x.y);
					}), m.push(A), T.push(j);
				}
				var F = S(m) || 0, I = S(T) || 0, L = C(m) || 0, R = C(T) || 0;
				return {
					left: F,
					top: I,
					width: L - F,
					height: R - I
				};
			}
		}), x.Path.fromObject = function(m, S) {
			if (typeof m.sourcePath == "string") {
				var C = m.sourcePath;
				x.loadSVGFromURL(C, function(C) {
					var T = C[0];
					T.setOptions(m), m.clipPath ? x.util.enlivenObjects([m.clipPath], function(m) {
						T.clipPath = m[0], S && S(T);
					}) : S && S(T);
				});
			} else x.Object._fromObject("Path", m, S, "path");
		}, x.Path.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat(["d"]), x.Path.fromElement = function(m, S, C) {
			var D = x.parseAttributes(m, x.Path.ATTRIBUTE_NAMES);
			D.fromSVG = !0, S(new x.Path(D.d, T(D, C)));
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.array.min, C = x.util.array.max;
		x.Group || (x.Group = x.util.createClass(x.Object, x.Collection, {
			type: "group",
			strokeWidth: 0,
			subTargetCheck: !1,
			cacheProperties: [],
			useSetOnGroup: !1,
			initialize: function(m, x, S) {
				x ||= {}, this._objects = [], S && this.callSuper("initialize", x), this._objects = m || [];
				for (var C = this._objects.length; C--;) this._objects[C].group = this;
				if (S) this._updateObjectsACoords();
				else {
					var T = x && x.centerPoint;
					x.originX !== void 0 && (this.originX = x.originX), x.originY !== void 0 && (this.originY = x.originY), T || this._calcBounds(), this._updateObjectsCoords(T), delete x.centerPoint, this.callSuper("initialize", x);
				}
				this.setCoords();
			},
			_updateObjectsACoords: function() {
				for (var m = !0, x = this._objects.length; x--;) this._objects[x].setCoords(m);
			},
			_updateObjectsCoords: function(m) {
				for (var m = m || this.getCenterPoint(), x = this._objects.length; x--;) this._updateObjectCoords(this._objects[x], m);
			},
			_updateObjectCoords: function(m, x) {
				var S = m.left, C = m.top;
				m.set({
					left: S - x.x,
					top: C - x.y
				}), m.group = this, m.setCoords(!0);
			},
			toString: function() {
				return "#<fabric.Group: (" + this.complexity() + ")>";
			},
			addWithUpdate: function(m) {
				var S = !!this.group;
				return this._restoreObjectsState(), x.util.resetObjectTransform(this), m && (S && x.util.removeTransformFromObject(m, this.group.calcTransformMatrix()), this._objects.push(m), m.group = this, m._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, S ? this.group.addWithUpdate() : this.setCoords(), this;
			},
			removeWithUpdate: function(m) {
				return this._restoreObjectsState(), x.util.resetObjectTransform(this), this.remove(m), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this;
			},
			_onObjectAdded: function(m) {
				this.dirty = !0, m.group = this, m._set("canvas", this.canvas);
			},
			_onObjectRemoved: function(m) {
				this.dirty = !0, delete m.group;
			},
			_set: function(m, S) {
				var C = this._objects.length;
				if (this.useSetOnGroup) for (; C--;) this._objects[C].setOnGroup(m, S);
				if (m === "canvas") for (; C--;) this._objects[C]._set(m, S);
				x.Object.prototype._set.call(this, m, S);
			},
			toObject: function(m) {
				var S = this.includeDefaultValues, C = this._objects.filter(function(m) {
					return !m.excludeFromExport;
				}).map(function(x) {
					var C = x.includeDefaultValues;
					x.includeDefaultValues = S;
					var T = x.toObject(m);
					return x.includeDefaultValues = C, T;
				}), T = x.Object.prototype.toObject.call(this, m);
				return T.objects = C, T;
			},
			toDatalessObject: function(m) {
				var S, C = this.sourcePath;
				if (C) S = C;
				else {
					var T = this.includeDefaultValues;
					S = this._objects.map(function(x) {
						var S = x.includeDefaultValues;
						x.includeDefaultValues = T;
						var C = x.toDatalessObject(m);
						return x.includeDefaultValues = S, C;
					});
				}
				var D = x.Object.prototype.toDatalessObject.call(this, m);
				return D.objects = S, D;
			},
			render: function(m) {
				this._transformDone = !0, this.callSuper("render", m), this._transformDone = !1;
			},
			shouldCache: function() {
				var m = x.Object.prototype.shouldCache.call(this);
				if (m) {
					for (var S = 0, C = this._objects.length; S < C; S++) if (this._objects[S].willDrawShadow()) return this.ownCaching = !1, !1;
				}
				return m;
			},
			willDrawShadow: function() {
				if (x.Object.prototype.willDrawShadow.call(this)) return !0;
				for (var m = 0, S = this._objects.length; m < S; m++) if (this._objects[m].willDrawShadow()) return !0;
				return !1;
			},
			isOnACache: function() {
				return this.ownCaching || this.group && this.group.isOnACache();
			},
			drawObject: function(m) {
				for (var x = 0, S = this._objects.length; x < S; x++) this._objects[x].render(m);
				this._drawClipPath(m, this.clipPath);
			},
			isCacheDirty: function(m) {
				if (this.callSuper("isCacheDirty", m)) return !0;
				if (!this.statefullCache) return !1;
				for (var x = 0, S = this._objects.length; x < S; x++) if (this._objects[x].isCacheDirty(!0)) {
					if (this._cacheCanvas) {
						var C = this.cacheWidth / this.zoomX, T = this.cacheHeight / this.zoomY;
						this._cacheContext.clearRect(-C / 2, -T / 2, C, T);
					}
					return !0;
				}
				return !1;
			},
			_restoreObjectsState: function() {
				var m = this.calcOwnMatrix();
				return this._objects.forEach(function(S) {
					x.util.addTransformToObject(S, m), delete S.group, S.setCoords();
				}), this;
			},
			destroy: function() {
				return this._objects.forEach(function(m) {
					m.set("dirty", !0);
				}), this._restoreObjectsState();
			},
			dispose: function() {
				this.callSuper("dispose"), this.forEachObject(function(m) {
					m.dispose && m.dispose();
				}), this._objects = [];
			},
			toActiveSelection: function() {
				if (this.canvas) {
					var m = this._objects, S = this.canvas;
					this._objects = [];
					var C = this.toObject();
					delete C.objects;
					var T = new x.ActiveSelection([]);
					return T.set(C), T.type = "activeSelection", S.remove(this), m.forEach(function(m) {
						m.group = T, m.dirty = !0, S.add(m);
					}), T.canvas = S, T._objects = m, S._activeObject = T, T.setCoords(), T;
				}
			},
			ungroupOnCanvas: function() {
				return this._restoreObjectsState();
			},
			setObjectsCoords: function() {
				var m = !0;
				return this.forEachObject(function(x) {
					x.setCoords(m);
				}), this;
			},
			_calcBounds: function(m) {
				for (var x = [], S = [], C, T, D, O = [
					"tr",
					"br",
					"bl",
					"tl"
				], k = 0, A = this._objects.length, j, M = O.length; k < A; ++k) {
					for (C = this._objects[k], D = C.calcACoords(), j = 0; j < M; j++) T = O[j], x.push(D[T].x), S.push(D[T].y);
					C.aCoords = D;
				}
				this._getBounds(x, S, m);
			},
			_getBounds: function(m, T, D) {
				var O = new x.Point(S(m), S(T)), k = new x.Point(C(m), C(T)), A = O.y || 0, j = O.x || 0, M = k.x - O.x || 0, N = k.y - O.y || 0;
				this.width = M, this.height = N, D || this.setPositionByOrigin({
					x: j,
					y: A
				}, "left", "top");
			},
			_toSVG: function(m) {
				for (var x = [
					"<g ",
					"COMMON_PARTS",
					" >\n"
				], S = 0, C = this._objects.length; S < C; S++) x.push("		", this._objects[S].toSVG(m));
				return x.push("</g>\n"), x;
			},
			getSvgStyles: function() {
				var m = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", x = this.visible ? "" : " visibility: hidden;";
				return [
					m,
					this.getSvgFilter(),
					x
				].join("");
			},
			toClipPathSVG: function(m) {
				for (var x = [], S = 0, C = this._objects.length; S < C; S++) x.push("	", this._objects[S].toClipPathSVG(m));
				return this._createBaseClipPathSVGMarkup(x, { reviver: m });
			}
		}), x.Group.fromObject = function(m, S) {
			var C = m.objects, T = x.util.object.clone(m, !0);
			if (delete T.objects, typeof C == "string") {
				x.loadSVGFromURL(C, function(D) {
					var O = x.util.groupSVGElements(D, m, C), k = T.clipPath;
					delete T.clipPath, O.set(T), k ? x.util.enlivenObjects([k], function(m) {
						O.clipPath = m[0], S && S(O);
					}) : S && S(O);
				});
				return;
			}
			x.util.enlivenObjects(C, function(C) {
				x.util.enlivenObjectEnlivables(m, T, function() {
					S && S(new x.Group(C, T, !0));
				});
			});
		});
	})(m), (function(m) {
		var x = m.fabric ||= {};
		x.ActiveSelection || (x.ActiveSelection = x.util.createClass(x.Group, {
			type: "activeSelection",
			initialize: function(m, S) {
				S ||= {}, this._objects = m || [];
				for (var C = this._objects.length; C--;) this._objects[C].group = this;
				S.originX && (this.originX = S.originX), S.originY && (this.originY = S.originY), this._calcBounds(), this._updateObjectsCoords(), x.Object.prototype.initialize.call(this, S), this.setCoords();
			},
			toGroup: function() {
				var m = this._objects.concat();
				this._objects = [];
				var S = x.Object.prototype.toObject.call(this), C = new x.Group([]);
				if (delete S.type, C.set(S), m.forEach(function(m) {
					m.canvas.remove(m), m.group = C;
				}), C._objects = m, !this.canvas) return C;
				var T = this.canvas;
				return T.add(C), T._activeObject = C, C.setCoords(), C;
			},
			onDeselect: function() {
				return this.destroy(), !1;
			},
			toString: function() {
				return "#<fabric.ActiveSelection: (" + this.complexity() + ")>";
			},
			shouldCache: function() {
				return !1;
			},
			isOnACache: function() {
				return !1;
			},
			_renderControls: function(m, x, S) {
				m.save(), m.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, S ||= {}, S.hasControls === void 0 && (S.hasControls = !1), S.forActiveSelection = !0;
				for (var C = 0, T = this._objects.length; C < T; C++) this._objects[C]._renderControls(m, S);
				this.callSuper("_renderControls", m, x), m.restore();
			}
		}), x.ActiveSelection.fromObject = function(m, S) {
			x.util.enlivenObjects(m.objects, function(C) {
				delete m.objects, S && S(new x.ActiveSelection(C, m, !0));
			});
		});
	})(m), (function(m) {
		var S = x.util.object.extend;
		if (m.fabric ||= {}, m.fabric.Image) {
			x.warn("fabric.Image is already defined.");
			return;
		}
		x.Image = x.util.createClass(x.Object, {
			type: "image",
			strokeWidth: 0,
			srcFromAttribute: !1,
			_lastScaleX: 1,
			_lastScaleY: 1,
			_filterScalingX: 1,
			_filterScalingY: 1,
			minimumScaleTrigger: .5,
			stateProperties: x.Object.prototype.stateProperties.concat("cropX", "cropY"),
			cacheProperties: x.Object.prototype.cacheProperties.concat("cropX", "cropY"),
			cacheKey: "",
			cropX: 0,
			cropY: 0,
			imageSmoothing: !0,
			initialize: function(m, S) {
				S ||= {}, this.filters = [], this.cacheKey = "texture" + x.Object.__uid++, this.callSuper("initialize", S), this._initElement(m, S);
			},
			getElement: function() {
				return this._element || {};
			},
			setElement: function(m, x) {
				return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = m, this._originalElement = m, this._initConfig(x), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this;
			},
			removeTexture: function(m) {
				var S = x.filterBackend;
				S && S.evictCachesForKey && S.evictCachesForKey(m);
			},
			dispose: function() {
				this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, [
					"_originalElement",
					"_element",
					"_filteredEl",
					"_cacheCanvas"
				].forEach((function(m) {
					x.util.cleanUpJsdomNode(this[m]), this[m] = void 0;
				}).bind(this));
			},
			getCrossOrigin: function() {
				return this._originalElement && (this._originalElement.crossOrigin || null);
			},
			getOriginalSize: function() {
				var m = this.getElement();
				return {
					width: m.naturalWidth || m.width,
					height: m.naturalHeight || m.height
				};
			},
			_stroke: function(m) {
				if (!(!this.stroke || this.strokeWidth === 0)) {
					var x = this.width / 2, S = this.height / 2;
					m.beginPath(), m.moveTo(-x, -S), m.lineTo(x, -S), m.lineTo(x, S), m.lineTo(-x, S), m.lineTo(-x, -S), m.closePath();
				}
			},
			toObject: function(m) {
				var x = [];
				this.filters.forEach(function(m) {
					m && x.push(m.toObject());
				});
				var C = S(this.callSuper("toObject", ["cropX", "cropY"].concat(m)), {
					src: this.getSrc(),
					crossOrigin: this.getCrossOrigin(),
					filters: x
				});
				return this.resizeFilter && (C.resizeFilter = this.resizeFilter.toObject()), C;
			},
			hasCrop: function() {
				return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
			},
			_toSVG: function() {
				var m = [], S = [], C, T = this._element, D = -this.width / 2, O = -this.height / 2, k = "", A = "";
				if (!T) return [];
				if (this.hasCrop()) {
					var j = x.Object.__uid++;
					m.push("<clipPath id=\"imageCrop_" + j + "\">\n", "	<rect x=\"" + D + "\" y=\"" + O + "\" width=\"" + this.width + "\" height=\"" + this.height + "\" />\n", "</clipPath>\n"), k = " clip-path=\"url(#imageCrop_" + j + ")\" ";
				}
				if (this.imageSmoothing || (A = "\" image-rendering=\"optimizeSpeed"), S.push("	<image ", "COMMON_PARTS", "xlink:href=\"", this.getSvgSrc(!0), "\" x=\"", D - this.cropX, "\" y=\"", O - this.cropY, "\" width=\"", T.width || T.naturalWidth, "\" height=\"", T.height || T.height, A, "\"", k, "></image>\n"), this.stroke || this.strokeDashArray) {
					var M = this.fill;
					this.fill = null, C = [
						"	<rect ",
						"x=\"",
						D,
						"\" y=\"",
						O,
						"\" width=\"",
						this.width,
						"\" height=\"",
						this.height,
						"\" style=\"",
						this.getSvgStyles(),
						"\"/>\n"
					], this.fill = M;
				}
				return m = this.paintFirst === "fill" ? m.concat(S, C) : m.concat(C, S), m;
			},
			getSrc: function(m) {
				var x = m ? this._element : this._originalElement;
				return x ? x.toDataURL ? x.toDataURL() : this.srcFromAttribute ? x.getAttribute("src") : x.src : this.src || "";
			},
			setSrc: function(m, S, C) {
				return x.util.loadImage(m, function(m, x) {
					this.setElement(m, C), this._setWidthHeight(), S && S(this, x);
				}, this, C && C.crossOrigin), this;
			},
			toString: function() {
				return "#<fabric.Image: { src: \"" + this.getSrc() + "\" }>";
			},
			applyResizeFilters: function() {
				var m = this.resizeFilter, S = this.minimumScaleTrigger, C = this.getTotalObjectScaling(), T = C.scaleX, D = C.scaleY, O = this._filteredEl || this._originalElement;
				if (this.group && this.set("dirty", !0), !m || T > S && D > S) {
					this._element = O, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = T, this._lastScaleY = D;
					return;
				}
				x.filterBackend ||= x.initFilterBackend();
				var k = x.util.createCanvasElement(), A = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, j = O.width, M = O.height;
				k.width = j, k.height = M, this._element = k, this._lastScaleX = m.scaleX = T, this._lastScaleY = m.scaleY = D, x.filterBackend.applyFilters([m], O, j, M, this._element, A), this._filterScalingX = k.width / this._originalElement.width, this._filterScalingY = k.height / this._originalElement.height;
			},
			applyFilters: function(m) {
				if (m = m || this.filters || [], m = m.filter(function(m) {
					return m && !m.isNeutralState();
				}), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), m.length === 0) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this;
				var S = this._originalElement, C = S.naturalWidth || S.width, T = S.naturalHeight || S.height;
				if (this._element === this._originalElement) {
					var D = x.util.createCanvasElement();
					D.width = C, D.height = T, this._element = D, this._filteredEl = D;
				} else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, C, T), this._lastScaleX = 1, this._lastScaleY = 1;
				return x.filterBackend ||= x.initFilterBackend(), x.filterBackend.applyFilters(m, this._originalElement, C, T, this._element, this.cacheKey), (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) && (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this;
			},
			_render: function(m) {
				x.util.setImageSmoothing(m, this.imageSmoothing), this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(m), this._renderPaintInOrder(m);
			},
			drawCacheOnCanvas: function(m) {
				x.util.setImageSmoothing(m, this.imageSmoothing), x.Object.prototype.drawCacheOnCanvas.call(this, m);
			},
			shouldCache: function() {
				return this.needsItsOwnCache();
			},
			_renderFill: function(m) {
				var x = this._element;
				if (x) {
					var S = this._filterScalingX, C = this._filterScalingY, T = this.width, D = this.height, O = Math.min, k = Math.max, A = k(this.cropX, 0), j = k(this.cropY, 0), M = x.naturalWidth || x.width, N = x.naturalHeight || x.height, P = A * S, F = j * C, I = O(T * S, M - P), L = O(D * C, N - F), R = -T / 2, z = -D / 2, B = O(T, M / S - A), H = O(D, N / C - j);
					x && m.drawImage(x, P, F, I, L, R, z, B, H);
				}
			},
			_needsResize: function() {
				var m = this.getTotalObjectScaling();
				return m.scaleX !== this._lastScaleX || m.scaleY !== this._lastScaleY;
			},
			_resetWidthHeight: function() {
				this.set(this.getOriginalSize());
			},
			_initElement: function(m, S) {
				this.setElement(x.util.getById(m), S), x.util.addClass(this.getElement(), x.Image.CSS_CANVAS);
			},
			_initConfig: function(m) {
				m ||= {}, this.setOptions(m), this._setWidthHeight(m);
			},
			_initFilters: function(m, S) {
				m && m.length ? x.util.enlivenObjects(m, function(m) {
					S && S(m);
				}, "fabric.Image.filters") : S && S();
			},
			_setWidthHeight: function(m) {
				m ||= {};
				var x = this.getElement();
				this.width = m.width || x.naturalWidth || x.width || 0, this.height = m.height || x.naturalHeight || x.height || 0;
			},
			parsePreserveAspectRatioAttribute: function() {
				var m = x.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), S = this._element.width, C = this._element.height, T = 1, D = 1, O = 0, k = 0, A = 0, j = 0, M, N = this.width, P = this.height, F = {
					width: N,
					height: P
				};
				return m && (m.alignX !== "none" || m.alignY !== "none") ? (m.meetOrSlice === "meet" && (T = D = x.util.findScaleToFit(this._element, F), M = (N - S * T) / 2, m.alignX === "Min" && (O = -M), m.alignX === "Max" && (O = M), M = (P - C * D) / 2, m.alignY === "Min" && (k = -M), m.alignY === "Max" && (k = M)), m.meetOrSlice === "slice" && (T = D = x.util.findScaleToCover(this._element, F), M = S - N / T, m.alignX === "Mid" && (A = M / 2), m.alignX === "Max" && (A = M), M = C - P / D, m.alignY === "Mid" && (j = M / 2), m.alignY === "Max" && (j = M), S = N / T, C = P / D)) : (T = N / S, D = P / C), {
					width: S,
					height: C,
					scaleX: T,
					scaleY: D,
					offsetLeft: O,
					offsetTop: k,
					cropX: A,
					cropY: j
				};
			}
		}), x.Image.CSS_CANVAS = "canvas-img", x.Image.prototype.getSvgSrc = x.Image.prototype.getSrc, x.Image.fromObject = function(m, S) {
			var C = x.util.object.clone(m);
			x.util.loadImage(C.src, function(m, T) {
				if (T) {
					S && S(null, !0);
					return;
				}
				x.Image.prototype._initFilters.call(C, C.filters, function(T) {
					C.filters = T || [], x.Image.prototype._initFilters.call(C, [C.resizeFilter], function(T) {
						C.resizeFilter = T[0], x.util.enlivenObjectEnlivables(C, C, function() {
							S(new x.Image(m, C), !1);
						});
					});
				});
			}, null, C.crossOrigin);
		}, x.Image.fromURL = function(m, S, C) {
			x.util.loadImage(m, function(m, T) {
				S && S(new x.Image(m, C), T);
			}, null, C && C.crossOrigin);
		}, x.Image.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), x.Image.fromElement = function(m, C, T) {
			var D = x.parseAttributes(m, x.Image.ATTRIBUTE_NAMES);
			x.Image.fromURL(D["xlink:href"], C, S(T ? x.util.object.clone(T) : {}, D));
		};
	})(m), x.util.object.extend(x.Object.prototype, {
		_getAngleValueForStraighten: function() {
			var m = this.angle % 360;
			return m > 0 ? Math.round((m - 1) / 90) * 90 : Math.round(m / 90) * 90;
		},
		straighten: function() {
			return this.rotate(this._getAngleValueForStraighten());
		},
		fxStraighten: function(m) {
			m ||= {};
			var S = function() {}, C = m.onComplete || S, T = m.onChange || S, D = this;
			return x.util.animate({
				target: this,
				startValue: this.get("angle"),
				endValue: this._getAngleValueForStraighten(),
				duration: this.FX_DURATION,
				onChange: function(m) {
					D.rotate(m), T();
				},
				onComplete: function() {
					D.setCoords(), C();
				}
			});
		}
	}), x.util.object.extend(x.StaticCanvas.prototype, {
		straightenObject: function(m) {
			return m.straighten(), this.requestRenderAll(), this;
		},
		fxStraightenObject: function(m) {
			return m.fxStraighten({ onChange: this.requestRenderAllBound });
		}
	}), (function() {
		function m(m, x) {
			var S = "precision " + x + " float;\nvoid main(){}", C = m.createShader(m.FRAGMENT_SHADER);
			return m.shaderSource(C, S), m.compileShader(C), !!m.getShaderParameter(C, m.COMPILE_STATUS);
		}
		x.isWebglSupported = function(S) {
			if (x.isLikelyNode) return !1;
			S ||= x.WebglFilterBackend.prototype.tileSize;
			var C = document.createElement("canvas"), T = C.getContext("webgl") || C.getContext("experimental-webgl"), D = !1;
			if (T) {
				x.maxTextureSize = T.getParameter(T.MAX_TEXTURE_SIZE), D = x.maxTextureSize >= S;
				for (var O = [
					"highp",
					"mediump",
					"lowp"
				], k = 0; k < 3; k++) if (m(T, O[k])) {
					x.webGlPrecision = O[k];
					break;
				}
			}
			return this.isSupported = D, D;
		}, x.WebglFilterBackend = S;
		function S(m) {
			m && m.tileSize && (this.tileSize = m.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo();
		}
		S.prototype = {
			tileSize: 2048,
			resources: {},
			setupGLContext: function(m, x) {
				this.dispose(), this.createWebGLCanvas(m, x), this.aPosition = new Float32Array([
					0,
					0,
					0,
					1,
					1,
					0,
					1,
					1
				]), this.chooseFastestCopyGLTo2DMethod(m, x);
			},
			chooseFastestCopyGLTo2DMethod: function(m, S) {
				var C = window.performance !== void 0, O;
				try {
					new ImageData(1, 1), O = !0;
				} catch {
					O = !1;
				}
				if (C && O && typeof ArrayBuffer < "u" && typeof Uint8ClampedArray < "u") {
					var k = x.util.createCanvasElement(), A = /* @__PURE__ */ new ArrayBuffer(m * S * 4);
					if (x.forceGLPutImageData) {
						this.imageBuffer = A, this.copyGLTo2D = D;
						return;
					}
					var j = {
						imageBuffer: A,
						destinationWidth: m,
						destinationHeight: S,
						targetCanvas: k
					}, M, N, P;
					k.width = m, k.height = S, M = window.performance.now(), T.call(j, this.gl, j), N = window.performance.now() - M, M = window.performance.now(), D.call(j, this.gl, j), P = window.performance.now() - M, N > P ? (this.imageBuffer = A, this.copyGLTo2D = D) : this.copyGLTo2D = T;
				}
			},
			createWebGLCanvas: function(m, S) {
				var C = x.util.createCanvasElement();
				C.width = m, C.height = S;
				var T = {
					alpha: !0,
					premultipliedAlpha: !1,
					depth: !1,
					stencil: !1,
					antialias: !1
				}, D = C.getContext("webgl", T);
				D ||= C.getContext("experimental-webgl", T), D && (D.clearColor(0, 0, 0, 0), this.canvas = C, this.gl = D);
			},
			applyFilters: function(m, x, S, T, D, O) {
				var k = this.gl, A;
				O && (A = this.getCachedTexture(O, x));
				var j = {
					originalWidth: x.width || x.originalWidth,
					originalHeight: x.height || x.originalHeight,
					sourceWidth: S,
					sourceHeight: T,
					destinationWidth: S,
					destinationHeight: T,
					context: k,
					sourceTexture: this.createTexture(k, S, T, !A && x),
					targetTexture: this.createTexture(k, S, T),
					originalTexture: A || this.createTexture(k, S, T, !A && x),
					passes: m.length,
					webgl: !0,
					aPosition: this.aPosition,
					programCache: this.programCache,
					pass: 0,
					filterBackend: this,
					targetCanvas: D
				}, M = k.createFramebuffer();
				return k.bindFramebuffer(k.FRAMEBUFFER, M), m.forEach(function(m) {
					m && m.applyTo(j);
				}), C(j), this.copyGLTo2D(k, j), k.bindTexture(k.TEXTURE_2D, null), k.deleteTexture(j.sourceTexture), k.deleteTexture(j.targetTexture), k.deleteFramebuffer(M), D.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), j;
			},
			dispose: function() {
				this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
			},
			clearWebGLCaches: function() {
				this.programCache = {}, this.textureCache = {};
			},
			createTexture: function(m, x, S, C, T) {
				var D = m.createTexture();
				return m.bindTexture(m.TEXTURE_2D, D), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, T || m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, T || m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), C ? m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, m.RGBA, m.UNSIGNED_BYTE, C) : m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, x, S, 0, m.RGBA, m.UNSIGNED_BYTE, null), D;
			},
			getCachedTexture: function(m, x) {
				if (this.textureCache[m]) return this.textureCache[m];
				var S = this.createTexture(this.gl, x.width, x.height, x);
				return this.textureCache[m] = S, S;
			},
			evictCachesForKey: function(m) {
				this.textureCache[m] && (this.gl.deleteTexture(this.textureCache[m]), delete this.textureCache[m]);
			},
			copyGLTo2D: T,
			captureGPUInfo: function() {
				if (this.gpuInfo) return this.gpuInfo;
				var m = this.gl, x = {
					renderer: "",
					vendor: ""
				};
				if (!m) return x;
				var S = m.getExtension("WEBGL_debug_renderer_info");
				if (S) {
					var C = m.getParameter(S.UNMASKED_RENDERER_WEBGL), T = m.getParameter(S.UNMASKED_VENDOR_WEBGL);
					C && (x.renderer = C.toLowerCase()), T && (x.vendor = T.toLowerCase());
				}
				return this.gpuInfo = x, x;
			}
		};
	})();
	function C(m) {
		var x = m.targetCanvas, S = x.width, C = x.height, T = m.destinationWidth, D = m.destinationHeight;
		(S !== T || C !== D) && (x.width = T, x.height = D);
	}
	function T(m, x) {
		var S = m.canvas, C = x.targetCanvas, T = C.getContext("2d");
		T.translate(0, C.height), T.scale(1, -1);
		var D = S.height - C.height;
		T.drawImage(S, 0, D, C.width, C.height, 0, 0, C.width, C.height);
	}
	function D(m, x) {
		var S = x.targetCanvas.getContext("2d"), C = x.destinationWidth, T = x.destinationHeight, D = C * T * 4, O = new Uint8Array(this.imageBuffer, 0, D), k = new Uint8ClampedArray(this.imageBuffer, 0, D);
		m.readPixels(0, 0, C, T, m.RGBA, m.UNSIGNED_BYTE, O);
		var A = new ImageData(k, C, T);
		S.putImageData(A, 0, 0);
	}
	(function() {
		var m = function() {};
		x.Canvas2dFilterBackend = S;
		function S() {}
		S.prototype = {
			evictCachesForKey: m,
			dispose: m,
			clearWebGLCaches: m,
			resources: {},
			applyFilters: function(m, x, S, C, T) {
				var D = T.getContext("2d");
				D.drawImage(x, 0, 0, S, C);
				var O = {
					sourceWidth: S,
					sourceHeight: C,
					imageData: D.getImageData(0, 0, S, C),
					originalEl: x,
					originalImageData: D.getImageData(0, 0, S, C),
					canvasEl: T,
					ctx: D,
					filterBackend: this
				};
				return m.forEach(function(m) {
					m.applyTo(O);
				}), (O.imageData.width !== S || O.imageData.height !== C) && (T.width = O.imageData.width, T.height = O.imageData.height), D.putImageData(O.imageData, 0, 0), O;
			}
		};
	})(), x.Image = x.Image || {}, x.Image.filters = x.Image.filters || {}, x.Image.filters.BaseFilter = x.util.createClass({
		type: "BaseFilter",
		vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
		fragmentSource: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}",
		initialize: function(m) {
			m && this.setOptions(m);
		},
		setOptions: function(m) {
			for (var x in m) this[x] = m[x];
		},
		createProgram: function(m, S, C) {
			S ||= this.fragmentSource, C ||= this.vertexSource, x.webGlPrecision !== "highp" && (S = S.replace(/precision highp float/g, "precision " + x.webGlPrecision + " float"));
			var T = m.createShader(m.VERTEX_SHADER);
			if (m.shaderSource(T, C), m.compileShader(T), !m.getShaderParameter(T, m.COMPILE_STATUS)) throw Error("Vertex shader compile error for " + this.type + ": " + m.getShaderInfoLog(T));
			var D = m.createShader(m.FRAGMENT_SHADER);
			if (m.shaderSource(D, S), m.compileShader(D), !m.getShaderParameter(D, m.COMPILE_STATUS)) throw Error("Fragment shader compile error for " + this.type + ": " + m.getShaderInfoLog(D));
			var O = m.createProgram();
			if (m.attachShader(O, T), m.attachShader(O, D), m.linkProgram(O), !m.getProgramParameter(O, m.LINK_STATUS)) throw Error("Shader link error for \"${this.type}\" " + m.getProgramInfoLog(O));
			var k = this.getAttributeLocations(m, O), A = this.getUniformLocations(m, O) || {};
			return A.uStepW = m.getUniformLocation(O, "uStepW"), A.uStepH = m.getUniformLocation(O, "uStepH"), {
				program: O,
				attributeLocations: k,
				uniformLocations: A
			};
		},
		getAttributeLocations: function(m, x) {
			return { aPosition: m.getAttribLocation(x, "aPosition") };
		},
		getUniformLocations: function() {
			return {};
		},
		sendAttributeData: function(m, x, S) {
			var C = x.aPosition, T = m.createBuffer();
			m.bindBuffer(m.ARRAY_BUFFER, T), m.enableVertexAttribArray(C), m.vertexAttribPointer(C, 2, m.FLOAT, !1, 0, 0), m.bufferData(m.ARRAY_BUFFER, S, m.STATIC_DRAW);
		},
		_setupFrameBuffer: function(m) {
			var x = m.context, S, C;
			m.passes > 1 ? (S = m.destinationWidth, C = m.destinationHeight, (m.sourceWidth !== S || m.sourceHeight !== C) && (x.deleteTexture(m.targetTexture), m.targetTexture = m.filterBackend.createTexture(x, S, C)), x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, m.targetTexture, 0)) : (x.bindFramebuffer(x.FRAMEBUFFER, null), x.finish());
		},
		_swapTextures: function(m) {
			m.passes--, m.pass++;
			var x = m.targetTexture;
			m.targetTexture = m.sourceTexture, m.sourceTexture = x;
		},
		isNeutralState: function() {
			var m = this.mainParameter, S = x.Image.filters[this.type].prototype;
			if (m) if (Array.isArray(S[m])) {
				for (var C = S[m].length; C--;) if (this[m][C] !== S[m][C]) return !1;
				return !0;
			} else return S[m] === this[m];
			else return !1;
		},
		applyTo: function(m) {
			m.webgl ? (this._setupFrameBuffer(m), this.applyToWebGL(m), this._swapTextures(m)) : this.applyTo2d(m);
		},
		retrieveShader: function(m) {
			return m.programCache.hasOwnProperty(this.type) || (m.programCache[this.type] = this.createProgram(m.context)), m.programCache[this.type];
		},
		applyToWebGL: function(m) {
			var x = m.context, S = this.retrieveShader(m);
			m.pass === 0 && m.originalTexture ? x.bindTexture(x.TEXTURE_2D, m.originalTexture) : x.bindTexture(x.TEXTURE_2D, m.sourceTexture), x.useProgram(S.program), this.sendAttributeData(x, S.attributeLocations, m.aPosition), x.uniform1f(S.uniformLocations.uStepW, 1 / m.sourceWidth), x.uniform1f(S.uniformLocations.uStepH, 1 / m.sourceHeight), this.sendUniformData(x, S.uniformLocations), x.viewport(0, 0, m.destinationWidth, m.destinationHeight), x.drawArrays(x.TRIANGLE_STRIP, 0, 4);
		},
		bindAdditionalTexture: function(m, x, S) {
			m.activeTexture(S), m.bindTexture(m.TEXTURE_2D, x), m.activeTexture(m.TEXTURE0);
		},
		unbindAdditionalTexture: function(m, x) {
			m.activeTexture(x), m.bindTexture(m.TEXTURE_2D, null), m.activeTexture(m.TEXTURE0);
		},
		getMainParameter: function() {
			return this[this.mainParameter];
		},
		setMainParameter: function(m) {
			this[this.mainParameter] = m;
		},
		sendUniformData: function() {},
		createHelpLayer: function(m) {
			if (!m.helpLayer) {
				var x = document.createElement("canvas");
				x.width = m.sourceWidth, x.height = m.sourceHeight, m.helpLayer = x;
			}
		},
		toObject: function() {
			var m = { type: this.type }, x = this.mainParameter;
			return x && (m[x] = this[x]), m;
		},
		toJSON: function() {
			return this.toObject();
		}
	}), x.Image.filters.BaseFilter.fromObject = function(m, S) {
		var C = new x.Image.filters[m.type](m);
		return S && S(C), C;
	}, (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.ColorMatrix = C(S.BaseFilter, {
			type: "ColorMatrix",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}",
			matrix: [
				1,
				0,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
				0,
				1,
				0
			],
			mainParameter: "matrix",
			colorsOnly: !0,
			initialize: function(m) {
				this.callSuper("initialize", m), this.matrix = this.matrix.slice(0);
			},
			applyTo2d: function(m) {
				var x = m.imageData.data, S = x.length, C = this.matrix, T, D, O, k, A, j = this.colorsOnly;
				for (A = 0; A < S; A += 4) T = x[A], D = x[A + 1], O = x[A + 2], j ? (x[A] = T * C[0] + D * C[1] + O * C[2] + C[4] * 255, x[A + 1] = T * C[5] + D * C[6] + O * C[7] + C[9] * 255, x[A + 2] = T * C[10] + D * C[11] + O * C[12] + C[14] * 255) : (k = x[A + 3], x[A] = T * C[0] + D * C[1] + O * C[2] + k * C[3] + C[4] * 255, x[A + 1] = T * C[5] + D * C[6] + O * C[7] + k * C[8] + C[9] * 255, x[A + 2] = T * C[10] + D * C[11] + O * C[12] + k * C[13] + C[14] * 255, x[A + 3] = T * C[15] + D * C[16] + O * C[17] + k * C[18] + C[19] * 255);
			},
			getUniformLocations: function(m, x) {
				return {
					uColorMatrix: m.getUniformLocation(x, "uColorMatrix"),
					uConstants: m.getUniformLocation(x, "uConstants")
				};
			},
			sendUniformData: function(m, x) {
				var S = this.matrix, C = [
					S[0],
					S[1],
					S[2],
					S[3],
					S[5],
					S[6],
					S[7],
					S[8],
					S[10],
					S[11],
					S[12],
					S[13],
					S[15],
					S[16],
					S[17],
					S[18]
				], T = [
					S[4],
					S[9],
					S[14],
					S[19]
				];
				m.uniformMatrix4fv(x.uColorMatrix, !1, C), m.uniform4fv(x.uConstants, T);
			}
		}), x.Image.filters.ColorMatrix.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Brightness = C(S.BaseFilter, {
			type: "Brightness",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}",
			brightness: 0,
			mainParameter: "brightness",
			applyTo2d: function(m) {
				if (this.brightness !== 0) {
					var x = m.imageData.data, S, C = x.length, T = Math.round(this.brightness * 255);
					for (S = 0; S < C; S += 4) x[S] = x[S] + T, x[S + 1] = x[S + 1] + T, x[S + 2] = x[S + 2] + T;
				}
			},
			getUniformLocations: function(m, x) {
				return { uBrightness: m.getUniformLocation(x, "uBrightness") };
			},
			sendUniformData: function(m, x) {
				m.uniform1f(x.uBrightness, this.brightness);
			}
		}), x.Image.filters.Brightness.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.Image.filters, T = x.util.createClass;
		C.Convolute = T(C.BaseFilter, {
			type: "Convolute",
			opaque: !1,
			matrix: [
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0
			],
			fragmentSource: {
				Convolute_3_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
				Convolute_3_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
				Convolute_5_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
				Convolute_5_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
				Convolute_7_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
				Convolute_7_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
				Convolute_9_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
				Convolute_9_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}"
			},
			retrieveShader: function(m) {
				var x = Math.sqrt(this.matrix.length), S = this.type + "_" + x + "_" + (this.opaque ? 1 : 0), C = this.fragmentSource[S];
				return m.programCache.hasOwnProperty(S) || (m.programCache[S] = this.createProgram(m.context, C)), m.programCache[S];
			},
			applyTo2d: function(m) {
				var x = m.imageData, S = x.data, C = this.matrix, T = Math.round(Math.sqrt(C.length)), D = Math.floor(T / 2), O = x.width, k = x.height, A = m.ctx.createImageData(O, k), j = A.data, M = this.opaque ? 1 : 0, N, P, F, I, L, R, z, B, H, U, W, G, K;
				for (W = 0; W < k; W++) for (U = 0; U < O; U++) {
					for (L = (W * O + U) * 4, N = 0, P = 0, F = 0, I = 0, K = 0; K < T; K++) for (G = 0; G < T; G++) z = W + K - D, R = U + G - D, !(z < 0 || z >= k || R < 0 || R >= O) && (B = (z * O + R) * 4, H = C[K * T + G], N += S[B] * H, P += S[B + 1] * H, F += S[B + 2] * H, M || (I += S[B + 3] * H));
					j[L] = N, j[L + 1] = P, j[L + 2] = F, M ? j[L + 3] = S[L + 3] : j[L + 3] = I;
				}
				m.imageData = A;
			},
			getUniformLocations: function(m, x) {
				return {
					uMatrix: m.getUniformLocation(x, "uMatrix"),
					uOpaque: m.getUniformLocation(x, "uOpaque"),
					uHalfSize: m.getUniformLocation(x, "uHalfSize"),
					uSize: m.getUniformLocation(x, "uSize")
				};
			},
			sendUniformData: function(m, x) {
				m.uniform1fv(x.uMatrix, this.matrix);
			},
			toObject: function() {
				return S(this.callSuper("toObject"), {
					opaque: this.opaque,
					matrix: this.matrix
				});
			}
		}), x.Image.filters.Convolute.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Grayscale = C(S.BaseFilter, {
			type: "Grayscale",
			fragmentSource: {
				average: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}",
				lightness: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}",
				luminosity: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}"
			},
			mode: "average",
			mainParameter: "mode",
			applyTo2d: function(m) {
				var x = m.imageData.data, S, C = x.length, T, D = this.mode;
				for (S = 0; S < C; S += 4) D === "average" ? T = (x[S] + x[S + 1] + x[S + 2]) / 3 : D === "lightness" ? T = (Math.min(x[S], x[S + 1], x[S + 2]) + Math.max(x[S], x[S + 1], x[S + 2])) / 2 : D === "luminosity" && (T = .21 * x[S] + .72 * x[S + 1] + .07 * x[S + 2]), x[S] = T, x[S + 1] = T, x[S + 2] = T;
			},
			retrieveShader: function(m) {
				var x = this.type + "_" + this.mode;
				if (!m.programCache.hasOwnProperty(x)) {
					var S = this.fragmentSource[this.mode];
					m.programCache[x] = this.createProgram(m.context, S);
				}
				return m.programCache[x];
			},
			getUniformLocations: function(m, x) {
				return { uMode: m.getUniformLocation(x, "uMode") };
			},
			sendUniformData: function(m, x) {
				m.uniform1i(x.uMode, 1);
			},
			isNeutralState: function() {
				return !1;
			}
		}), x.Image.filters.Grayscale.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Invert = C(S.BaseFilter, {
			type: "Invert",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}",
			invert: !0,
			mainParameter: "invert",
			applyTo2d: function(m) {
				var x = m.imageData.data, S, C = x.length;
				for (S = 0; S < C; S += 4) x[S] = 255 - x[S], x[S + 1] = 255 - x[S + 1], x[S + 2] = 255 - x[S + 2];
			},
			isNeutralState: function() {
				return !this.invert;
			},
			getUniformLocations: function(m, x) {
				return { uInvert: m.getUniformLocation(x, "uInvert") };
			},
			sendUniformData: function(m, x) {
				m.uniform1i(x.uInvert, this.invert);
			}
		}), x.Image.filters.Invert.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.Image.filters, T = x.util.createClass;
		C.Noise = T(C.BaseFilter, {
			type: "Noise",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}",
			mainParameter: "noise",
			noise: 0,
			applyTo2d: function(m) {
				if (this.noise !== 0) {
					var x = m.imageData.data, S, C = x.length, T = this.noise, D;
					for (S = 0, C = x.length; S < C; S += 4) D = (.5 - Math.random()) * T, x[S] += D, x[S + 1] += D, x[S + 2] += D;
				}
			},
			getUniformLocations: function(m, x) {
				return {
					uNoise: m.getUniformLocation(x, "uNoise"),
					uSeed: m.getUniformLocation(x, "uSeed")
				};
			},
			sendUniformData: function(m, x) {
				m.uniform1f(x.uNoise, this.noise / 255), m.uniform1f(x.uSeed, Math.random());
			},
			toObject: function() {
				return S(this.callSuper("toObject"), { noise: this.noise });
			}
		}), x.Image.filters.Noise.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Pixelate = C(S.BaseFilter, {
			type: "Pixelate",
			blocksize: 4,
			mainParameter: "blocksize",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}",
			applyTo2d: function(m) {
				var x = m.imageData, S = x.data, C = x.height, T = x.width, D, O, k, A, j, M, N, P, F, I, L;
				for (O = 0; O < C; O += this.blocksize) for (k = 0; k < T; k += this.blocksize) for (D = O * 4 * T + k * 4, A = S[D], j = S[D + 1], M = S[D + 2], N = S[D + 3], I = Math.min(O + this.blocksize, C), L = Math.min(k + this.blocksize, T), P = O; P < I; P++) for (F = k; F < L; F++) D = P * 4 * T + F * 4, S[D] = A, S[D + 1] = j, S[D + 2] = M, S[D + 3] = N;
			},
			isNeutralState: function() {
				return this.blocksize === 1;
			},
			getUniformLocations: function(m, x) {
				return {
					uBlocksize: m.getUniformLocation(x, "uBlocksize"),
					uStepW: m.getUniformLocation(x, "uStepW"),
					uStepH: m.getUniformLocation(x, "uStepH")
				};
			},
			sendUniformData: function(m, x) {
				m.uniform1f(x.uBlocksize, this.blocksize);
			}
		}), x.Image.filters.Pixelate.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.extend, C = x.Image.filters, T = x.util.createClass;
		C.RemoveColor = T(C.BaseFilter, {
			type: "RemoveColor",
			color: "#FFFFFF",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}",
			distance: .02,
			useAlpha: !1,
			applyTo2d: function(m) {
				var S = m.imageData.data, C, T = this.distance * 255, D, O, k, A = new x.Color(this.color).getSource(), j = [
					A[0] - T,
					A[1] - T,
					A[2] - T
				], M = [
					A[0] + T,
					A[1] + T,
					A[2] + T
				];
				for (C = 0; C < S.length; C += 4) D = S[C], O = S[C + 1], k = S[C + 2], D > j[0] && O > j[1] && k > j[2] && D < M[0] && O < M[1] && k < M[2] && (S[C + 3] = 0);
			},
			getUniformLocations: function(m, x) {
				return {
					uLow: m.getUniformLocation(x, "uLow"),
					uHigh: m.getUniformLocation(x, "uHigh")
				};
			},
			sendUniformData: function(m, S) {
				var C = new x.Color(this.color).getSource(), T = parseFloat(this.distance), D = [
					0 + C[0] / 255 - T,
					0 + C[1] / 255 - T,
					0 + C[2] / 255 - T,
					1
				], O = [
					C[0] / 255 + T,
					C[1] / 255 + T,
					C[2] / 255 + T,
					1
				];
				m.uniform4fv(S.uLow, D), m.uniform4fv(S.uHigh, O);
			},
			toObject: function() {
				return S(this.callSuper("toObject"), {
					color: this.color,
					distance: this.distance
				});
			}
		}), x.Image.filters.RemoveColor.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass, T = {
			Brownie: [
				.5997,
				.34553,
				-.27082,
				0,
				.186,
				-.0377,
				.86095,
				.15059,
				0,
				-.1449,
				.24113,
				-.07441,
				.44972,
				0,
				-.02965,
				0,
				0,
				0,
				1,
				0
			],
			Vintage: [
				.62793,
				.32021,
				-.03965,
				0,
				.03784,
				.02578,
				.64411,
				.03259,
				0,
				.02926,
				.0466,
				-.08512,
				.52416,
				0,
				.02023,
				0,
				0,
				0,
				1,
				0
			],
			Kodachrome: [
				1.12855,
				-.39673,
				-.03992,
				0,
				.24991,
				-.16404,
				1.08352,
				-.05498,
				0,
				.09698,
				-.16786,
				-.56034,
				1.60148,
				0,
				.13972,
				0,
				0,
				0,
				1,
				0
			],
			Technicolor: [
				1.91252,
				-.85453,
				-.09155,
				0,
				.04624,
				-.30878,
				1.76589,
				-.10601,
				0,
				-.27589,
				-.2311,
				-.75018,
				1.84759,
				0,
				.12137,
				0,
				0,
				0,
				1,
				0
			],
			Polaroid: [
				1.438,
				-.062,
				-.062,
				0,
				0,
				-.122,
				1.378,
				-.122,
				0,
				0,
				-.016,
				-.016,
				1.483,
				0,
				0,
				0,
				0,
				0,
				1,
				0
			],
			Sepia: [
				.393,
				.769,
				.189,
				0,
				0,
				.349,
				.686,
				.168,
				0,
				0,
				.272,
				.534,
				.131,
				0,
				0,
				0,
				0,
				0,
				1,
				0
			],
			BlackWhite: [
				1.5,
				1.5,
				1.5,
				0,
				-1,
				1.5,
				1.5,
				1.5,
				0,
				-1,
				1.5,
				1.5,
				1.5,
				0,
				-1,
				0,
				0,
				0,
				1,
				0
			]
		};
		for (var D in T) S[D] = C(S.ColorMatrix, {
			type: D,
			matrix: T[D],
			mainParameter: !1,
			colorsOnly: !0
		}), x.Image.filters[D].fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric, S = x.Image.filters, C = x.util.createClass;
		S.BlendColor = C(S.BaseFilter, {
			type: "BlendColor",
			color: "#F95C63",
			mode: "multiply",
			alpha: 1,
			fragmentSource: {
				multiply: "gl_FragColor.rgb *= uColor.rgb;\n",
				screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",
				add: "gl_FragColor.rgb += uColor.rgb;\n",
				diff: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",
				subtract: "gl_FragColor.rgb -= uColor.rgb;\n",
				lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",
				darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",
				exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",
				overlay: "if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n",
				tint: "gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n"
			},
			buildSource: function(m) {
				return "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n" + this.fragmentSource[m] + "}\n}";
			},
			retrieveShader: function(m) {
				var x = this.type + "_" + this.mode, S;
				return m.programCache.hasOwnProperty(x) || (S = this.buildSource(this.mode), m.programCache[x] = this.createProgram(m.context, S)), m.programCache[x];
			},
			applyTo2d: function(m) {
				var S = m.imageData.data, C = S.length, T, D, O, k, A, j, M, N = 1 - this.alpha;
				M = new x.Color(this.color).getSource(), T = M[0] * this.alpha, D = M[1] * this.alpha, O = M[2] * this.alpha;
				for (var P = 0; P < C; P += 4) switch (k = S[P], A = S[P + 1], j = S[P + 2], this.mode) {
					case "multiply":
						S[P] = k * T / 255, S[P + 1] = A * D / 255, S[P + 2] = j * O / 255;
						break;
					case "screen":
						S[P] = 255 - (255 - k) * (255 - T) / 255, S[P + 1] = 255 - (255 - A) * (255 - D) / 255, S[P + 2] = 255 - (255 - j) * (255 - O) / 255;
						break;
					case "add":
						S[P] = k + T, S[P + 1] = A + D, S[P + 2] = j + O;
						break;
					case "diff":
					case "difference":
						S[P] = Math.abs(k - T), S[P + 1] = Math.abs(A - D), S[P + 2] = Math.abs(j - O);
						break;
					case "subtract":
						S[P] = k - T, S[P + 1] = A - D, S[P + 2] = j - O;
						break;
					case "darken":
						S[P] = Math.min(k, T), S[P + 1] = Math.min(A, D), S[P + 2] = Math.min(j, O);
						break;
					case "lighten":
						S[P] = Math.max(k, T), S[P + 1] = Math.max(A, D), S[P + 2] = Math.max(j, O);
						break;
					case "overlay":
						S[P] = T < 128 ? 2 * k * T / 255 : 255 - 2 * (255 - k) * (255 - T) / 255, S[P + 1] = D < 128 ? 2 * A * D / 255 : 255 - 2 * (255 - A) * (255 - D) / 255, S[P + 2] = O < 128 ? 2 * j * O / 255 : 255 - 2 * (255 - j) * (255 - O) / 255;
						break;
					case "exclusion":
						S[P] = T + k - 2 * T * k / 255, S[P + 1] = D + A - 2 * D * A / 255, S[P + 2] = O + j - 2 * O * j / 255;
						break;
					case "tint": S[P] = T + k * N, S[P + 1] = D + A * N, S[P + 2] = O + j * N;
				}
			},
			getUniformLocations: function(m, x) {
				return { uColor: m.getUniformLocation(x, "uColor") };
			},
			sendUniformData: function(m, S) {
				var C = new x.Color(this.color).getSource();
				C[0] = this.alpha * C[0] / 255, C[1] = this.alpha * C[1] / 255, C[2] = this.alpha * C[2] / 255, C[3] = this.alpha, m.uniform4fv(S.uColor, C);
			},
			toObject: function() {
				return {
					type: this.type,
					color: this.color,
					mode: this.mode,
					alpha: this.alpha
				};
			}
		}), x.Image.filters.BlendColor.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric, S = x.Image.filters, C = x.util.createClass;
		S.BlendImage = C(S.BaseFilter, {
			type: "BlendImage",
			image: null,
			mode: "multiply",
			alpha: 1,
			vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
			fragmentSource: {
				multiply: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}",
				mask: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}"
			},
			retrieveShader: function(m) {
				var x = this.type + "_" + this.mode, S = this.fragmentSource[this.mode];
				return m.programCache.hasOwnProperty(x) || (m.programCache[x] = this.createProgram(m.context, S)), m.programCache[x];
			},
			applyToWebGL: function(m) {
				var x = m.context, S = this.createTexture(m.filterBackend, this.image);
				this.bindAdditionalTexture(x, S, x.TEXTURE1), this.callSuper("applyToWebGL", m), this.unbindAdditionalTexture(x, x.TEXTURE1);
			},
			createTexture: function(m, x) {
				return m.getCachedTexture(x.cacheKey, x._element);
			},
			calculateMatrix: function() {
				var m = this.image, x = m._element.width, S = m._element.height;
				return [
					1 / m.scaleX,
					0,
					0,
					0,
					1 / m.scaleY,
					0,
					-m.left / x,
					-m.top / S,
					1
				];
			},
			applyTo2d: function(m) {
				var S = m.imageData, C = m.filterBackend.resources, T = S.data, D = T.length, O = S.width, k = S.height, A, j, M, N, P, F, I, L, R, z, B = this.image, H;
				C.blendImage ||= x.util.createCanvasElement(), R = C.blendImage, z = R.getContext("2d"), R.width !== O || R.height !== k ? (R.width = O, R.height = k) : z.clearRect(0, 0, O, k), z.setTransform(B.scaleX, 0, 0, B.scaleY, B.left, B.top), z.drawImage(B._element, 0, 0, O, k), H = z.getImageData(0, 0, O, k).data;
				for (var U = 0; U < D; U += 4) switch (P = T[U], F = T[U + 1], I = T[U + 2], L = T[U + 3], A = H[U], j = H[U + 1], M = H[U + 2], N = H[U + 3], this.mode) {
					case "multiply":
						T[U] = P * A / 255, T[U + 1] = F * j / 255, T[U + 2] = I * M / 255, T[U + 3] = L * N / 255;
						break;
					case "mask":
						T[U + 3] = N;
						break;
				}
			},
			getUniformLocations: function(m, x) {
				return {
					uTransformMatrix: m.getUniformLocation(x, "uTransformMatrix"),
					uImage: m.getUniformLocation(x, "uImage")
				};
			},
			sendUniformData: function(m, x) {
				var S = this.calculateMatrix();
				m.uniform1i(x.uImage, 1), m.uniformMatrix3fv(x.uTransformMatrix, !1, S);
			},
			toObject: function() {
				return {
					type: this.type,
					image: this.image && this.image.toObject(),
					mode: this.mode,
					alpha: this.alpha
				};
			}
		}), x.Image.filters.BlendImage.fromObject = function(m, S) {
			x.Image.fromObject(m.image, function(C) {
				var T = x.util.object.clone(m);
				T.image = C, S(new x.Image.filters.BlendImage(T));
			});
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = Math.pow, C = Math.floor, T = Math.sqrt, D = Math.abs, O = Math.round, k = Math.sin, A = Math.ceil, j = x.Image.filters, M = x.util.createClass;
		j.Resize = M(j.BaseFilter, {
			type: "Resize",
			resizeType: "hermite",
			scaleX: 1,
			scaleY: 1,
			lanczosLobes: 3,
			getUniformLocations: function(m, x) {
				return {
					uDelta: m.getUniformLocation(x, "uDelta"),
					uTaps: m.getUniformLocation(x, "uTaps")
				};
			},
			sendUniformData: function(m, x) {
				m.uniform2fv(x.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), m.uniform1fv(x.uTaps, this.taps);
			},
			retrieveShader: function(m) {
				var x = this.getFilterWindow(), S = this.type + "_" + x;
				if (!m.programCache.hasOwnProperty(S)) {
					var C = this.generateShader(x);
					m.programCache[S] = this.createProgram(m.context, C);
				}
				return m.programCache[S];
			},
			getFilterWindow: function() {
				var m = this.tempScale;
				return Math.ceil(this.lanczosLobes / m);
			},
			getTaps: function() {
				for (var m = this.lanczosCreate(this.lanczosLobes), x = this.tempScale, S = this.getFilterWindow(), C = Array(S), T = 1; T <= S; T++) C[T - 1] = m(T * x);
				return C;
			},
			generateShader: function(m) {
				for (var x = Array(m), S = this.fragmentSourceTOP, m, C = 1; C <= m; C++) x[C - 1] = C + ".0 * uDelta";
				return S += "uniform float uTaps[" + m + "];\n", S += "void main() {\n", S += "  vec4 color = texture2D(uTexture, vTexCoord);\n", S += "  float sum = 1.0;\n", x.forEach(function(m, x) {
					S += "  color += texture2D(uTexture, vTexCoord + " + m + ") * uTaps[" + x + "];\n", S += "  color += texture2D(uTexture, vTexCoord - " + m + ") * uTaps[" + x + "];\n", S += "  sum += 2.0 * uTaps[" + x + "];\n";
				}), S += "  gl_FragColor = color / sum;\n", S += "}", S;
			},
			fragmentSourceTOP: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n",
			applyTo: function(m) {
				m.webgl ? (m.passes++, this.width = m.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = m.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), m.destinationWidth = this.dW, this._setupFrameBuffer(m), this.applyToWebGL(m), this._swapTextures(m), m.sourceWidth = m.destinationWidth, this.height = m.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), m.destinationHeight = this.dH, this._setupFrameBuffer(m), this.applyToWebGL(m), this._swapTextures(m), m.sourceHeight = m.destinationHeight) : this.applyTo2d(m);
			},
			isNeutralState: function() {
				return this.scaleX === 1 && this.scaleY === 1;
			},
			lanczosCreate: function(m) {
				return function(x) {
					if (x >= m || x <= -m) return 0;
					if (x < 1.1920929e-7 && x > -1.1920929e-7) return 1;
					x *= Math.PI;
					var S = x / m;
					return k(x) / x * k(S) / S;
				};
			},
			applyTo2d: function(m) {
				var x = m.imageData, S = this.scaleX, C = this.scaleY;
				this.rcpScaleX = 1 / S, this.rcpScaleY = 1 / C;
				var T = x.width, D = x.height, k = O(T * S), A = O(D * C), j;
				this.resizeType === "sliceHack" ? j = this.sliceByTwo(m, T, D, k, A) : this.resizeType === "hermite" ? j = this.hermiteFastResize(m, T, D, k, A) : this.resizeType === "bilinear" ? j = this.bilinearFiltering(m, T, D, k, A) : this.resizeType === "lanczos" && (j = this.lanczosResize(m, T, D, k, A)), m.imageData = j;
			},
			sliceByTwo: function(m, S, T, D, O) {
				var k = m.imageData, A = .5, j = !1, M = !1, N = S * A, P = T * A, F = x.filterBackend.resources, I, L, R = 0, z = 0, B = S, H = 0;
				for (F.sliceByTwo ||= document.createElement("canvas"), I = F.sliceByTwo, (I.width < S * 1.5 || I.height < T) && (I.width = S * 1.5, I.height = T), L = I.getContext("2d"), L.clearRect(0, 0, S * 1.5, T), L.putImageData(k, 0, 0), D = C(D), O = C(O); !j || !M;) S = N, T = P, D < C(N * A) ? N = C(N * A) : (N = D, j = !0), O < C(P * A) ? P = C(P * A) : (P = O, M = !0), L.drawImage(I, R, z, S, T, B, H, N, P), R = B, z = H, H += P;
				return L.getImageData(R, z, D, O);
			},
			lanczosResize: function(m, x, O, k, j) {
				function M(m) {
					var A, q, J, Y, X, Z, sH, Q, cH, lH, uH;
					for (G.x = (m + .5) * L, K.x = C(G.x), A = 0; A < j; A++) {
						for (G.y = (A + .5) * R, K.y = C(G.y), X = 0, Z = 0, sH = 0, Q = 0, cH = 0, q = K.x - H; q <= K.x + H; q++) if (!(q < 0 || q >= x)) {
							lH = C(1e3 * D(q - G.x)), W[lH] || (W[lH] = {});
							for (var dH = K.y - U; dH <= K.y + U; dH++) dH < 0 || dH >= O || (uH = C(1e3 * D(dH - G.y)), W[lH][uH] || (W[lH][uH] = I(T(S(lH * z, 2) + S(uH * B, 2)) / 1e3)), J = W[lH][uH], J > 0 && (Y = (dH * x + q) * 4, X += J, Z += J * N[Y], sH += J * N[Y + 1], Q += J * N[Y + 2], cH += J * N[Y + 3]));
						}
						Y = (A * k + m) * 4, F[Y] = Z / X, F[Y + 1] = sH / X, F[Y + 2] = Q / X, F[Y + 3] = cH / X;
					}
					return ++m < k ? M(m) : P;
				}
				var N = m.imageData.data, P = m.ctx.createImageData(k, j), F = P.data, I = this.lanczosCreate(this.lanczosLobes), L = this.rcpScaleX, R = this.rcpScaleY, z = 2 / this.rcpScaleX, B = 2 / this.rcpScaleY, H = A(L * this.lanczosLobes / 2), U = A(R * this.lanczosLobes / 2), W = {}, G = {}, K = {};
				return M(0);
			},
			bilinearFiltering: function(m, x, S, T, D) {
				var O, k, A, j, M, N, P, F, I, L, R, z, B = 0, H, U = this.rcpScaleX, W = this.rcpScaleY, G = 4 * (x - 1), K = m.imageData.data, q = m.ctx.createImageData(T, D), J = q.data;
				for (P = 0; P < D; P++) for (F = 0; F < T; F++) for (M = C(U * F), N = C(W * P), I = U * F - M, L = W * P - N, H = 4 * (N * x + M), R = 0; R < 4; R++) O = K[H + R], k = K[H + 4 + R], A = K[H + G + R], j = K[H + G + 4 + R], z = O * (1 - I) * (1 - L) + k * I * (1 - L) + A * L * (1 - I) + j * I * L, J[B++] = z;
				return q;
			},
			hermiteFastResize: function(m, x, S, O, k) {
				for (var j = this.rcpScaleX, M = this.rcpScaleY, N = A(j / 2), P = A(M / 2), F = m.imageData.data, I = m.ctx.createImageData(O, k), L = I.data, R = 0; R < k; R++) for (var z = 0; z < O; z++) {
					for (var B = (z + R * O) * 4, H = 0, U = 0, W = 0, G = 0, K = 0, q = 0, J = 0, Y = (R + .5) * M, X = C(R * M); X < (R + 1) * M; X++) for (var Z = D(Y - (X + .5)) / P, sH = (z + .5) * j, Q = Z * Z, cH = C(z * j); cH < (z + 1) * j; cH++) {
						var lH = D(sH - (cH + .5)) / N, uH = T(Q + lH * lH);
						uH > 1 && uH < -1 || (H = 2 * uH * uH * uH - 3 * uH * uH + 1, H > 0 && (lH = 4 * (cH + X * x), J += H * F[lH + 3], W += H, F[lH + 3] < 255 && (H = H * F[lH + 3] / 250), G += H * F[lH], K += H * F[lH + 1], q += H * F[lH + 2], U += H));
					}
					L[B] = G / U, L[B + 1] = K / U, L[B + 2] = q / U, L[B + 3] = J / W;
				}
				return I;
			},
			toObject: function() {
				return {
					type: this.type,
					scaleX: this.scaleX,
					scaleY: this.scaleY,
					resizeType: this.resizeType,
					lanczosLobes: this.lanczosLobes
				};
			}
		}), x.Image.filters.Resize.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Contrast = C(S.BaseFilter, {
			type: "Contrast",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}",
			contrast: 0,
			mainParameter: "contrast",
			applyTo2d: function(m) {
				if (this.contrast !== 0) {
					var x = m.imageData, S, C, T = x.data, C = T.length, D = Math.floor(this.contrast * 255), O = 259 * (D + 255) / (255 * (259 - D));
					for (S = 0; S < C; S += 4) T[S] = O * (T[S] - 128) + 128, T[S + 1] = O * (T[S + 1] - 128) + 128, T[S + 2] = O * (T[S + 2] - 128) + 128;
				}
			},
			getUniformLocations: function(m, x) {
				return { uContrast: m.getUniformLocation(x, "uContrast") };
			},
			sendUniformData: function(m, x) {
				m.uniform1f(x.uContrast, this.contrast);
			}
		}), x.Image.filters.Contrast.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Saturation = C(S.BaseFilter, {
			type: "Saturation",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}",
			saturation: 0,
			mainParameter: "saturation",
			applyTo2d: function(m) {
				if (this.saturation !== 0) {
					var x = m.imageData.data, S = x.length, C = -this.saturation, T, D;
					for (T = 0; T < S; T += 4) D = Math.max(x[T], x[T + 1], x[T + 2]), x[T] += D === x[T] ? 0 : (D - x[T]) * C, x[T + 1] += D === x[T + 1] ? 0 : (D - x[T + 1]) * C, x[T + 2] += D === x[T + 2] ? 0 : (D - x[T + 2]) * C;
				}
			},
			getUniformLocations: function(m, x) {
				return { uSaturation: m.getUniformLocation(x, "uSaturation") };
			},
			sendUniformData: function(m, x) {
				m.uniform1f(x.uSaturation, -this.saturation);
			}
		}), x.Image.filters.Saturation.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Vibrance = C(S.BaseFilter, {
			type: "Vibrance",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uVibrance;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat max = max(color.r, max(color.g, color.b));\nfloat avg = (color.r + color.g + color.b) / 3.0;\nfloat amt = (abs(max - avg) * 2.0) * uVibrance;\ncolor.r += max != color.r ? (max - color.r) * amt : 0.00;\ncolor.g += max != color.g ? (max - color.g) * amt : 0.00;\ncolor.b += max != color.b ? (max - color.b) * amt : 0.00;\ngl_FragColor = color;\n}",
			vibrance: 0,
			mainParameter: "vibrance",
			applyTo2d: function(m) {
				if (this.vibrance !== 0) {
					var x = m.imageData.data, S = x.length, C = -this.vibrance, T, D, O, k;
					for (T = 0; T < S; T += 4) D = Math.max(x[T], x[T + 1], x[T + 2]), O = (x[T] + x[T + 1] + x[T + 2]) / 3, k = Math.abs(D - O) * 2 / 255 * C, x[T] += D === x[T] ? 0 : (D - x[T]) * k, x[T + 1] += D === x[T + 1] ? 0 : (D - x[T + 1]) * k, x[T + 2] += D === x[T + 2] ? 0 : (D - x[T + 2]) * k;
				}
			},
			getUniformLocations: function(m, x) {
				return { uVibrance: m.getUniformLocation(x, "uVibrance") };
			},
			sendUniformData: function(m, x) {
				m.uniform1f(x.uVibrance, -this.vibrance);
			}
		}), x.Image.filters.Vibrance.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Blur = C(S.BaseFilter, {
			type: "Blur",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}",
			blur: 0,
			mainParameter: "blur",
			applyTo: function(m) {
				m.webgl ? (this.aspectRatio = m.sourceWidth / m.sourceHeight, m.passes++, this._setupFrameBuffer(m), this.horizontal = !0, this.applyToWebGL(m), this._swapTextures(m), this._setupFrameBuffer(m), this.horizontal = !1, this.applyToWebGL(m), this._swapTextures(m)) : this.applyTo2d(m);
			},
			applyTo2d: function(m) {
				m.imageData = this.simpleBlur(m);
			},
			simpleBlur: function(m) {
				var S = m.filterBackend.resources, C, T, D = m.imageData.width, O = m.imageData.height;
				S.blurLayer1 || (S.blurLayer1 = x.util.createCanvasElement(), S.blurLayer2 = x.util.createCanvasElement()), C = S.blurLayer1, T = S.blurLayer2, (C.width !== D || C.height !== O) && (T.width = C.width = D, T.height = C.height = O);
				var k = C.getContext("2d"), A = T.getContext("2d"), j = 15, M, N, P, F, I = this.blur * .06 * .5;
				for (k.putImageData(m.imageData, 0, 0), A.clearRect(0, 0, D, O), F = -j; F <= j; F++) M = (Math.random() - .5) / 4, N = F / j, P = I * N * D + M, A.globalAlpha = 1 - Math.abs(N), A.drawImage(C, P, M), k.drawImage(T, 0, 0), A.globalAlpha = 1, A.clearRect(0, 0, T.width, T.height);
				for (F = -j; F <= j; F++) M = (Math.random() - .5) / 4, N = F / j, P = I * N * O + M, A.globalAlpha = 1 - Math.abs(N), A.drawImage(C, M, P), k.drawImage(T, 0, 0), A.globalAlpha = 1, A.clearRect(0, 0, T.width, T.height);
				m.ctx.drawImage(C, 0, 0);
				var L = m.ctx.getImageData(0, 0, C.width, C.height);
				return k.globalAlpha = 1, k.clearRect(0, 0, C.width, C.height), L;
			},
			getUniformLocations: function(m, x) {
				return { delta: m.getUniformLocation(x, "uDelta") };
			},
			sendUniformData: function(m, x) {
				var S = this.chooseRightDelta();
				m.uniform2fv(x.delta, S);
			},
			chooseRightDelta: function() {
				var m = 1, x = [0, 0], S;
				return this.horizontal ? this.aspectRatio > 1 && (m = 1 / this.aspectRatio) : this.aspectRatio < 1 && (m = this.aspectRatio), S = m * this.blur * .12, this.horizontal ? x[0] = S : x[1] = S, x;
			}
		}), S.Blur.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Gamma = C(S.BaseFilter, {
			type: "Gamma",
			fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}",
			gamma: [
				1,
				1,
				1
			],
			mainParameter: "gamma",
			initialize: function(m) {
				this.gamma = [
					1,
					1,
					1
				], S.BaseFilter.prototype.initialize.call(this, m);
			},
			applyTo2d: function(m) {
				var x = m.imageData.data, S = this.gamma, C = x.length, T = 1 / S[0], D = 1 / S[1], O = 1 / S[2], k;
				for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), k = 0, C = 256; k < C; k++) this.rVals[k] = (k / 255) ** T * 255, this.gVals[k] = (k / 255) ** D * 255, this.bVals[k] = (k / 255) ** O * 255;
				for (k = 0, C = x.length; k < C; k += 4) x[k] = this.rVals[x[k]], x[k + 1] = this.gVals[x[k + 1]], x[k + 2] = this.bVals[x[k + 2]];
			},
			getUniformLocations: function(m, x) {
				return { uGamma: m.getUniformLocation(x, "uGamma") };
			},
			sendUniformData: function(m, x) {
				m.uniform3fv(x.uGamma, this.gamma);
			}
		}), x.Image.filters.Gamma.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.Composed = C(S.BaseFilter, {
			type: "Composed",
			subFilters: [],
			initialize: function(m) {
				this.callSuper("initialize", m), this.subFilters = this.subFilters.slice(0);
			},
			applyTo: function(m) {
				m.passes += this.subFilters.length - 1, this.subFilters.forEach(function(x) {
					x.applyTo(m);
				});
			},
			toObject: function() {
				return x.util.object.extend(this.callSuper("toObject"), { subFilters: this.subFilters.map(function(m) {
					return m.toObject();
				}) });
			},
			isNeutralState: function() {
				return !this.subFilters.some(function(m) {
					return !m.isNeutralState();
				});
			}
		}), x.Image.filters.Composed.fromObject = function(m, S) {
			var C = (m.subFilters || []).map(function(m) {
				return new x.Image.filters[m.type](m);
			}), T = new x.Image.filters.Composed({ subFilters: C });
			return S && S(T), T;
		};
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.Image.filters, C = x.util.createClass;
		S.HueRotation = C(S.ColorMatrix, {
			type: "HueRotation",
			rotation: 0,
			mainParameter: "rotation",
			calculateMatrix: function() {
				var m = this.rotation * Math.PI, S = x.util.cos(m), C = x.util.sin(m), T = 1 / 3, D = Math.sqrt(T) * C, O = 1 - S;
				this.matrix = [
					1,
					0,
					0,
					0,
					0,
					0,
					1,
					0,
					0,
					0,
					0,
					0,
					1,
					0,
					0,
					0,
					0,
					0,
					1,
					0
				], this.matrix[0] = S + O / 3, this.matrix[1] = T * O - D, this.matrix[2] = T * O + D, this.matrix[5] = T * O + D, this.matrix[6] = S + T * O, this.matrix[7] = T * O - D, this.matrix[10] = T * O - D, this.matrix[11] = T * O + D, this.matrix[12] = S + T * O;
			},
			isNeutralState: function(m) {
				return this.calculateMatrix(), S.BaseFilter.prototype.isNeutralState.call(this, m);
			},
			applyTo: function(m) {
				this.calculateMatrix(), S.BaseFilter.prototype.applyTo.call(this, m);
			}
		}), x.Image.filters.HueRotation.fromObject = x.Image.filters.BaseFilter.fromObject;
	})(m), (function(m) {
		var x = m.fabric ||= {}, S = x.util.object.clone;
		if (x.Text) {
			x.warn("fabric.Text is already defined");
			return;
		}
		var C = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" ");
		x.Text = x.util.createClass(x.Object, {
			_dimensionAffectingProps: [
				"fontSize",
				"fontWeight",
				"fontFamily",
				"fontStyle",
				"lineHeight",
				"text",
				"charSpacing",
				"textAlign",
				"styles",
				"path",
				"pathStartOffset",
				"pathSide",
				"pathAlign"
			],
			_reNewline: /\r?\n/,
			_reSpacesAndTabs: /[ \t\r]/g,
			_reSpaceAndTab: /[ \t\r]/,
			_reWords: /\S+/g,
			type: "text",
			fontSize: 40,
			fontWeight: "normal",
			fontFamily: "Times New Roman",
			underline: !1,
			overline: !1,
			linethrough: !1,
			textAlign: "left",
			fontStyle: "normal",
			lineHeight: 1.16,
			superscript: {
				size: .6,
				baseline: -.35
			},
			subscript: {
				size: .6,
				baseline: .11
			},
			textBackgroundColor: "",
			stateProperties: x.Object.prototype.stateProperties.concat(C),
			cacheProperties: x.Object.prototype.cacheProperties.concat(C),
			stroke: null,
			shadow: null,
			path: null,
			pathStartOffset: 0,
			pathSide: "left",
			pathAlign: "baseline",
			_fontSizeFraction: .222,
			offsets: {
				underline: .1,
				linethrough: -.315,
				overline: -.88
			},
			_fontSizeMult: 1.13,
			charSpacing: 0,
			styles: null,
			_measuringContext: null,
			deltaY: 0,
			direction: "ltr",
			_styleProperties: [
				"stroke",
				"strokeWidth",
				"fill",
				"fontFamily",
				"fontSize",
				"fontWeight",
				"fontStyle",
				"underline",
				"overline",
				"linethrough",
				"deltaY",
				"textBackgroundColor"
			],
			__charBounds: [],
			CACHE_FONT_SIZE: 400,
			MIN_TEXT_WIDTH: 2,
			initialize: function(m, x) {
				this.styles = x && x.styles || {}, this.text = m, this.__skipDimension = !0, this.callSuper("initialize", x), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" });
			},
			setPathInfo: function() {
				var m = this.path;
				m && (m.segmentsInfo = x.util.getPathSegmentsInfo(m.path));
			},
			getMeasuringContext: function() {
				return x._measuringContext ||= this.canvas && this.canvas.contextCache || x.util.createCanvasElement().getContext("2d"), x._measuringContext;
			},
			_splitText: function() {
				var m = this._splitTextIntoLines(this.text);
				return this.textLines = m.lines, this._textLines = m.graphemeLines, this._unwrappedTextLines = m._unwrappedLines, this._text = m.graphemeText, m;
			},
			initDimensions: function() {
				if (!this.__skipDimension) {
					if (this._splitText(), this._clearCache(), this.path) {
						var m = this.getHeightOfLine(0) * 1.1;
						this.width = this.path.width + m, this.height = this.path.height + m;
					} else this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight();
					this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" });
				}
			},
			enlargeSpaces: function() {
				for (var m, x, S, C, T, D, O, k = 0, A = this._textLines.length; k < A; k++) if (!(this.textAlign !== "justify" && (k === A - 1 || this.isEndOfWrapping(k))) && (C = 0, T = this._textLines[k], x = this.getLineWidth(k), x < this.width && (O = this.textLines[k].match(this._reSpacesAndTabs)))) {
					S = O.length, m = (this.width - x) / S;
					for (var j = 0, M = T.length; j <= M; j++) D = this.__charBounds[k][j], this._reSpaceAndTab.test(T[j]) ? (D.width += m, D.kernedWidth += m, D.left += C, C += m) : D.left += C;
				}
			},
			isEndOfWrapping: function(m) {
				return m === this._textLines.length - 1;
			},
			missingNewlineOffset: function() {
				return 1;
			},
			toString: function() {
				return "#<fabric.Text (" + this.complexity() + "): { \"text\": \"" + this.text + "\", \"fontFamily\": \"" + this.fontFamily + "\" }>";
			},
			_getCacheCanvasDimensions: function() {
				var m = this.callSuper("_getCacheCanvasDimensions"), x = this.fontSize;
				return m.width += x * m.zoomX, m.height += x * m.zoomY, m;
			},
			_render: function(m) {
				var x = this.path;
				x && !x.isNotVisible() && x._render(m), this._setTextStyles(m), this._renderTextLinesBackground(m), this._renderTextDecoration(m, "underline"), this._renderText(m), this._renderTextDecoration(m, "overline"), this._renderTextDecoration(m, "linethrough");
			},
			_renderText: function(m) {
				this.paintFirst === "stroke" ? (this._renderTextStroke(m), this._renderTextFill(m)) : (this._renderTextFill(m), this._renderTextStroke(m));
			},
			_setTextStyles: function(m, x, S) {
				if (m.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
					case "center":
						m.textBaseline = "middle";
						break;
					case "ascender":
						m.textBaseline = "top";
						break;
					case "descender":
						m.textBaseline = "bottom";
						break;
				}
				m.font = this._getFontDeclaration(x, S);
			},
			calcTextWidth: function() {
				for (var m = this.getLineWidth(0), x = 1, S = this._textLines.length; x < S; x++) {
					var C = this.getLineWidth(x);
					C > m && (m = C);
				}
				return m;
			},
			_renderTextLine: function(m, x, S, C, T, D) {
				this._renderChars(m, x, S, C, T, D);
			},
			_renderTextLinesBackground: function(m) {
				if (!(!this.textBackgroundColor && !this.styleHas("textBackgroundColor"))) {
					for (var x, S, C = m.fillStyle, T, D, O = this._getLeftOffset(), k = this._getTopOffset(), A = 0, j = 0, M, N, P = this.path, F, I = 0, L = this._textLines.length; I < L; I++) {
						if (x = this.getHeightOfLine(I), !this.textBackgroundColor && !this.styleHas("textBackgroundColor", I)) {
							k += x;
							continue;
						}
						T = this._textLines[I], S = this._getLineLeftOffset(I), j = 0, A = 0, D = this.getValueOfPropertyAt(I, 0, "textBackgroundColor");
						for (var R = 0, z = T.length; R < z; R++) M = this.__charBounds[I][R], N = this.getValueOfPropertyAt(I, R, "textBackgroundColor"), P ? (m.save(), m.translate(M.renderLeft, M.renderTop), m.rotate(M.angle), m.fillStyle = N, N && m.fillRect(-M.width / 2, -x / this.lineHeight * (1 - this._fontSizeFraction), M.width, x / this.lineHeight), m.restore()) : N === D ? j += M.kernedWidth : (F = O + S + A, this.direction === "rtl" && (F = this.width - F - j), m.fillStyle = D, D && m.fillRect(F, k, j, x / this.lineHeight), A = M.left, j = M.width, D = N);
						N && !P && (F = O + S + A, this.direction === "rtl" && (F = this.width - F - j), m.fillStyle = N, m.fillRect(F, k, j, x / this.lineHeight)), k += x;
					}
					m.fillStyle = C, this._removeShadow(m);
				}
			},
			getFontCache: function(m) {
				var S = m.fontFamily.toLowerCase();
				x.charWidthsCache[S] || (x.charWidthsCache[S] = {});
				var C = x.charWidthsCache[S], T = m.fontStyle.toLowerCase() + "_" + (m.fontWeight + "").toLowerCase();
				return C[T] || (C[T] = {}), C[T];
			},
			_measureChar: function(m, x, S, C) {
				var T = this.getFontCache(x), D = this._getFontDeclaration(x), O = this._getFontDeclaration(C), k = S + m, A = D === O, j, M, N, P = x.fontSize / this.CACHE_FONT_SIZE, F;
				if (S && T[S] !== void 0 && (N = T[S]), T[m] !== void 0 && (F = j = T[m]), A && T[k] !== void 0 && (M = T[k], F = M - N), j === void 0 || N === void 0 || M === void 0) {
					var I = this.getMeasuringContext();
					this._setTextStyles(I, x, !0);
				}
				return j === void 0 && (F = j = I.measureText(m).width, T[m] = j), N === void 0 && A && S && (N = I.measureText(S).width, T[S] = N), A && M === void 0 && (M = I.measureText(k).width, T[k] = M, F = M - N), {
					width: j * P,
					kernedWidth: F * P
				};
			},
			getHeightOfChar: function(m, x) {
				return this.getValueOfPropertyAt(m, x, "fontSize");
			},
			measureLine: function(m) {
				var x = this._measureLine(m);
				return this.charSpacing !== 0 && (x.width -= this._getWidthOfCharSpacing()), x.width < 0 && (x.width = 0), x;
			},
			_measureLine: function(m) {
				var S = 0, C, T, D = this._textLines[m], O, k, A = 0, j = Array(D.length), M = 0, N, P, F = this.path, I = this.pathSide === "right";
				for (this.__charBounds[m] = j, C = 0; C < D.length; C++) T = D[C], k = this._getGraphemeBox(T, m, C, O), j[C] = k, S += k.kernedWidth, O = T;
				if (j[C] = {
					left: k ? k.left + k.width : 0,
					width: 0,
					kernedWidth: 0,
					height: this.fontSize
				}, F) {
					switch (P = F.segmentsInfo[F.segmentsInfo.length - 1].length, N = x.util.getPointOnPath(F.path, 0, F.segmentsInfo), N.x += F.pathOffset.x, N.y += F.pathOffset.y, this.textAlign) {
						case "left":
							M = I ? P - S : 0;
							break;
						case "center":
							M = (P - S) / 2;
							break;
						case "right":
							M = I ? 0 : P - S;
							break;
					}
					for (M += this.pathStartOffset * (I ? -1 : 1), C = I ? D.length - 1 : 0; I ? C >= 0 : C < D.length; I ? C-- : C++) k = j[C], M > P ? M %= P : M < 0 && (M += P), this._setGraphemeOnPath(M, k, N), M += k.kernedWidth;
				}
				return {
					width: S,
					numOfSpaces: A
				};
			},
			_setGraphemeOnPath: function(m, S, C) {
				var T = m + S.kernedWidth / 2, D = this.path, O = x.util.getPointOnPath(D.path, T, D.segmentsInfo);
				S.renderLeft = O.x - C.x, S.renderTop = O.y - C.y, S.angle = O.angle + (this.pathSide === "right" ? Math.PI : 0);
			},
			_getGraphemeBox: function(m, x, S, C, T) {
				var D = this.getCompleteStyleDeclaration(x, S), O = C ? this.getCompleteStyleDeclaration(x, S - 1) : {}, k = this._measureChar(m, D, C, O), A = k.kernedWidth, j = k.width, M;
				this.charSpacing !== 0 && (M = this._getWidthOfCharSpacing(), j += M, A += M);
				var N = {
					width: j,
					left: 0,
					height: D.fontSize,
					kernedWidth: A,
					deltaY: D.deltaY
				};
				if (S > 0 && !T) {
					var P = this.__charBounds[x][S - 1];
					N.left = P.left + P.width + k.kernedWidth - k.width;
				}
				return N;
			},
			getHeightOfLine: function(m) {
				if (this.__lineHeights[m]) return this.__lineHeights[m];
				for (var x = this._textLines[m], S = this.getHeightOfChar(m, 0), C = 1, T = x.length; C < T; C++) S = Math.max(this.getHeightOfChar(m, C), S);
				return this.__lineHeights[m] = S * this.lineHeight * this._fontSizeMult;
			},
			calcTextHeight: function() {
				for (var m, x = 0, S = 0, C = this._textLines.length; S < C; S++) m = this.getHeightOfLine(S), x += S === C - 1 ? m / this.lineHeight : m;
				return x;
			},
			_getLeftOffset: function() {
				return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
			},
			_getTopOffset: function() {
				return -this.height / 2;
			},
			_renderTextCommon: function(m, x) {
				m.save();
				for (var S = 0, C = this._getLeftOffset(), T = this._getTopOffset(), D = 0, O = this._textLines.length; D < O; D++) {
					var k = this.getHeightOfLine(D), A = k / this.lineHeight, j = this._getLineLeftOffset(D);
					this._renderTextLine(x, m, this._textLines[D], C + j, T + S + A, D), S += k;
				}
				m.restore();
			},
			_renderTextFill: function(m) {
				!this.fill && !this.styleHas("fill") || this._renderTextCommon(m, "fillText");
			},
			_renderTextStroke: function(m) {
				(!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles() || (this.shadow && !this.shadow.affectStroke && this._removeShadow(m), m.save(), this._setLineDash(m, this.strokeDashArray), m.beginPath(), this._renderTextCommon(m, "strokeText"), m.closePath(), m.restore());
			},
			_renderChars: function(m, S, C, T, D, O) {
				var k = this.getHeightOfLine(O), A = this.textAlign.indexOf("justify") !== -1, j, M, N = "", P, F = 0, I, L = this.path, R = !A && this.charSpacing === 0 && this.isEmptyStyles(O) && !L, z = this.direction === "ltr", B = this.direction === "ltr" ? 1 : -1, H, U = S.canvas.getAttribute("dir");
				if (S.save(), U !== this.direction && (S.canvas.setAttribute("dir", z ? "ltr" : "rtl"), S.direction = z ? "ltr" : "rtl", S.textAlign = z ? "left" : "right"), D -= k * this._fontSizeFraction / this.lineHeight, R) {
					this._renderChar(m, S, O, 0, C.join(""), T, D, k), S.restore();
					return;
				}
				for (var W = 0, G = C.length - 1; W <= G; W++) I = W === G || this.charSpacing || L, N += C[W], P = this.__charBounds[O][W], F === 0 ? (T += B * (P.kernedWidth - P.width), F += P.width) : F += P.kernedWidth, A && !I && this._reSpaceAndTab.test(C[W]) && (I = !0), I ||= (j ||= this.getCompleteStyleDeclaration(O, W), M = this.getCompleteStyleDeclaration(O, W + 1), x.util.hasStyleChanged(j, M, !1)), I && (L ? (S.save(), S.translate(P.renderLeft, P.renderTop), S.rotate(P.angle), this._renderChar(m, S, O, W, N, -F / 2, 0, k), S.restore()) : (H = T, this._renderChar(m, S, O, W, N, H, D, k)), N = "", j = M, T += B * F, F = 0);
				S.restore();
			},
			_applyPatternGradientTransformText: function(m) {
				var S = x.util.createCanvasElement(), C, T = this.width + this.strokeWidth, D = this.height + this.strokeWidth;
				return S.width = T, S.height = D, C = S.getContext("2d"), C.beginPath(), C.moveTo(0, 0), C.lineTo(T, 0), C.lineTo(T, D), C.lineTo(0, D), C.closePath(), C.translate(T / 2, D / 2), C.fillStyle = m.toLive(C), this._applyPatternGradientTransform(C, m), C.fill(), C.createPattern(S, "no-repeat");
			},
			handleFiller: function(m, x, S) {
				var C, T;
				return S.toLive ? S.gradientUnits === "percentage" || S.gradientTransform || S.patternTransform ? (C = -this.width / 2, T = -this.height / 2, m.translate(C, T), m[x] = this._applyPatternGradientTransformText(S), {
					offsetX: C,
					offsetY: T
				}) : (m[x] = S.toLive(m, this), this._applyPatternGradientTransform(m, S)) : (m[x] = S, {
					offsetX: 0,
					offsetY: 0
				});
			},
			_setStrokeStyles: function(m, x) {
				return m.lineWidth = x.strokeWidth, m.lineCap = this.strokeLineCap, m.lineDashOffset = this.strokeDashOffset, m.lineJoin = this.strokeLineJoin, m.miterLimit = this.strokeMiterLimit, this.handleFiller(m, "strokeStyle", x.stroke);
			},
			_setFillStyles: function(m, x) {
				return this.handleFiller(m, "fillStyle", x.fill);
			},
			_renderChar: function(m, x, S, C, T, D, O) {
				var k = this._getStyleDeclaration(S, C), A = this.getCompleteStyleDeclaration(S, C), j = m === "fillText" && A.fill, M = m === "strokeText" && A.stroke && A.strokeWidth, N, P;
				!M && !j || (x.save(), j && (N = this._setFillStyles(x, A)), M && (P = this._setStrokeStyles(x, A)), x.font = this._getFontDeclaration(A), k && k.textBackgroundColor && this._removeShadow(x), k && k.deltaY && (O += k.deltaY), j && x.fillText(T, D - N.offsetX, O - N.offsetY), M && x.strokeText(T, D - P.offsetX, O - P.offsetY), x.restore());
			},
			setSuperscript: function(m, x) {
				return this._setScript(m, x, this.superscript);
			},
			setSubscript: function(m, x) {
				return this._setScript(m, x, this.subscript);
			},
			_setScript: function(m, x, S) {
				var C = this.get2DCursorLocation(m, !0), T = this.getValueOfPropertyAt(C.lineIndex, C.charIndex, "fontSize"), D = this.getValueOfPropertyAt(C.lineIndex, C.charIndex, "deltaY"), O = {
					fontSize: T * S.size,
					deltaY: D + T * S.baseline
				};
				return this.setSelectionStyles(O, m, x), this;
			},
			_getLineLeftOffset: function(m) {
				var x = this.getLineWidth(m), S = this.width - x, C = this.textAlign, T = this.direction, D, O = 0, D = this.isEndOfWrapping(m);
				return C === "justify" || C === "justify-center" && !D || C === "justify-right" && !D || C === "justify-left" && !D ? 0 : (C === "center" && (O = S / 2), C === "right" && (O = S), C === "justify-center" && (O = S / 2), C === "justify-right" && (O = S), T === "rtl" && (O -= S), O);
			},
			_clearCache: function() {
				this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
			},
			_shouldClearDimensionCache: function() {
				var m = this._forceClearCache;
				return m ||= this.hasStateChanged("_dimensionAffectingProps"), m && (this.dirty = !0, this._forceClearCache = !1), m;
			},
			getLineWidth: function(m) {
				if (this.__lineWidths[m] !== void 0) return this.__lineWidths[m];
				var x = this.measureLine(m).width;
				return this.__lineWidths[m] = x, x;
			},
			_getWidthOfCharSpacing: function() {
				return this.charSpacing === 0 ? 0 : this.fontSize * this.charSpacing / 1e3;
			},
			getValueOfPropertyAt: function(m, x, S) {
				var C = this._getStyleDeclaration(m, x);
				return C && C[S] !== void 0 ? C[S] : this[S];
			},
			_renderTextDecoration: function(m, x) {
				if (!(!this[x] && !this.styleHas(x))) {
					m.save(), (x === "overline" || x === "linethrough") && this._removeShadow(m);
					for (var S, C, T, D, O, k, A, j, M = this._getLeftOffset(), N = this._getTopOffset(), P, F, I, L, R, z, B, H, U = this.path, W = this._getWidthOfCharSpacing(), G = this.offsets[x], K = 0, q = this._textLines.length; K < q; K++) {
						if (S = this.getHeightOfLine(K), !this[x] && !this.styleHas(x, K)) {
							N += S;
							continue;
						}
						A = this._textLines[K], z = S / this.lineHeight, D = this._getLineLeftOffset(K), F = 0, I = 0, j = this.getValueOfPropertyAt(K, 0, x), H = this.getValueOfPropertyAt(K, 0, "fill"), P = N + z * (1 - this._fontSizeFraction), C = this.getHeightOfChar(K, 0), O = this.getValueOfPropertyAt(K, 0, "deltaY");
						for (var J = 0, Y = A.length; J < Y; J++) if (L = this.__charBounds[K][J], R = this.getValueOfPropertyAt(K, J, x), B = this.getValueOfPropertyAt(K, J, "fill"), T = this.getHeightOfChar(K, J), k = this.getValueOfPropertyAt(K, J, "deltaY"), U && R && B) m.save(), m.fillStyle = H, m.translate(L.renderLeft, L.renderTop), m.rotate(L.angle), m.fillRect(-L.kernedWidth / 2, G * T + k, L.kernedWidth, this.fontSize / 15), m.restore();
						else if ((R !== j || B !== H || T !== C || k !== O) && I > 0) {
							var X = M + D + F;
							this.direction === "rtl" && (X = this.width - X - I), j && H && (m.fillStyle = H, m.fillRect(X, P + G * C + O, I, this.fontSize / 15)), F = L.left, I = L.width, j = R, H = B, C = T, O = k;
						} else I += L.kernedWidth;
						var X = M + D + F;
						this.direction === "rtl" && (X = this.width - X - I), m.fillStyle = B, R && B && m.fillRect(X, P + G * C + O, I - W, this.fontSize / 15), N += S;
					}
					m.restore();
				}
			},
			_getFontDeclaration: function(m, S) {
				var C = m || this, T = this.fontFamily, D = x.Text.genericFonts.indexOf(T.toLowerCase()) > -1, O = T === void 0 || T.indexOf("'") > -1 || T.indexOf(",") > -1 || T.indexOf("\"") > -1 || D ? C.fontFamily : "\"" + C.fontFamily + "\"";
				return [
					x.isLikelyNode ? C.fontWeight : C.fontStyle,
					x.isLikelyNode ? C.fontStyle : C.fontWeight,
					S ? this.CACHE_FONT_SIZE + "px" : C.fontSize + "px",
					O
				].join(" ");
			},
			render: function(m) {
				this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", m)));
			},
			_splitTextIntoLines: function(m) {
				for (var S = m.split(this._reNewline), C = Array(S.length), T = ["\n"], D = [], O = 0; O < S.length; O++) C[O] = x.util.string.graphemeSplit(S[O]), D = D.concat(C[O], T);
				return D.pop(), {
					_unwrappedLines: C,
					lines: S,
					graphemeText: D,
					graphemeLines: C
				};
			},
			toObject: function(m) {
				var S = C.concat(m), T = this.callSuper("toObject", S);
				return T.styles = x.util.stylesToArray(this.styles, this.text), T.path &&= this.path.toObject(), T;
			},
			set: function(m, x) {
				this.callSuper("set", m, x);
				var S = !1, C = !1;
				if (typeof m == "object") for (var T in m) T === "path" && this.setPathInfo(), S ||= this._dimensionAffectingProps.indexOf(T) !== -1, C ||= T === "path";
				else S = this._dimensionAffectingProps.indexOf(m) !== -1, C = m === "path";
				return C && this.setPathInfo(), S && (this.initDimensions(), this.setCoords()), this;
			},
			complexity: function() {
				return 1;
			}
		}), x.Text.ATTRIBUTE_NAMES = x.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), x.Text.DEFAULT_SVG_FONT_SIZE = 16, x.Text.fromElement = function(m, C, T) {
			if (!m) return C(null);
			var D = x.parseAttributes(m, x.Text.ATTRIBUTE_NAMES), O = D.textAnchor || "left";
			if (T = x.util.object.extend(T ? S(T) : {}, D), T.top = T.top || 0, T.left = T.left || 0, D.textDecoration) {
				var k = D.textDecoration;
				k.indexOf("underline") !== -1 && (T.underline = !0), k.indexOf("overline") !== -1 && (T.overline = !0), k.indexOf("line-through") !== -1 && (T.linethrough = !0), delete T.textDecoration;
			}
			"dx" in D && (T.left += D.dx), "dy" in D && (T.top += D.dy), "fontSize" in T || (T.fontSize = x.Text.DEFAULT_SVG_FONT_SIZE);
			var A = "";
			"textContent" in m ? A = m.textContent : "firstChild" in m && m.firstChild !== null && "data" in m.firstChild && m.firstChild.data !== null && (A = m.firstChild.data), A = A.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " ");
			var j = T.strokeWidth;
			T.strokeWidth = 0;
			var M = new x.Text(A, T), N = M.getScaledHeight() / M.height, P = ((M.height + M.strokeWidth) * M.lineHeight - M.height) * N, F = M.getScaledHeight() + P, I = 0;
			O === "center" && (I = M.getScaledWidth() / 2), O === "right" && (I = M.getScaledWidth()), M.set({
				left: M.left - I,
				top: M.top - (F - M.fontSize * (.07 + M._fontSizeFraction)) / M.lineHeight,
				strokeWidth: j === void 0 ? 1 : j
			}), C(M);
		}, x.Text.fromObject = function(m, C) {
			var T = S(m), D = m.path;
			return delete T.path, x.Object._fromObject("Text", T, function(S) {
				S.styles = x.util.stylesFromArray(m.styles, m.text), D ? x.Object._fromObject("Path", D, function(m) {
					S.set("path", m), C(S);
				}, "path") : C(S);
			}, "text");
		}, x.Text.genericFonts = [
			"sans-serif",
			"serif",
			"cursive",
			"fantasy",
			"monospace"
		], x.util.createAccessors && x.util.createAccessors(x.Text);
	})(m), (function() {
		x.util.object.extend(x.Text.prototype, {
			isEmptyStyles: function(m) {
				if (!this.styles || m !== void 0 && !this.styles[m]) return !0;
				var x = m === void 0 ? this.styles : { line: this.styles[m] };
				for (var S in x) for (var C in x[S]) for (var T in x[S][C]) return !1;
				return !0;
			},
			styleHas: function(m, x) {
				if (!this.styles || !m || m === "" || x !== void 0 && !this.styles[x]) return !1;
				var S = x === void 0 ? this.styles : { 0: this.styles[x] };
				for (var C in S) for (var T in S[C]) if (S[C][T][m] !== void 0) return !0;
				return !1;
			},
			cleanStyle: function(m) {
				if (!this.styles || !m || m === "") return !1;
				var x = this.styles, S = 0, C, T, D = !0, O = 0, k;
				for (var A in x) {
					for (var j in C = 0, x[A]) {
						var k = x[A][j], M = k.hasOwnProperty(m);
						S++, M ? (T ? k[m] !== T && (D = !1) : T = k[m], k[m] === this[m] && delete k[m]) : D = !1, Object.keys(k).length === 0 ? delete x[A][j] : C++;
					}
					C === 0 && delete x[A];
				}
				for (var N = 0; N < this._textLines.length; N++) O += this._textLines[N].length;
				D && S === O && (this[m] = T, this.removeStyle(m));
			},
			removeStyle: function(m) {
				if (!(!this.styles || !m || m === "")) {
					var x = this.styles, S, C, T;
					for (C in x) {
						for (T in S = x[C], S) delete S[T][m], Object.keys(S[T]).length === 0 && delete S[T];
						Object.keys(S).length === 0 && delete x[C];
					}
				}
			},
			_extendStyles: function(m, S) {
				var C = this.get2DCursorLocation(m);
				this._getLineStyle(C.lineIndex) || this._setLineStyle(C.lineIndex), this._getStyleDeclaration(C.lineIndex, C.charIndex) || this._setStyleDeclaration(C.lineIndex, C.charIndex, {}), x.util.object.extend(this._getStyleDeclaration(C.lineIndex, C.charIndex), S);
			},
			get2DCursorLocation: function(m, x) {
				m === void 0 && (m = this.selectionStart);
				for (var S = x ? this._unwrappedTextLines : this._textLines, C = S.length, T = 0; T < C; T++) {
					if (m <= S[T].length) return {
						lineIndex: T,
						charIndex: m
					};
					m -= S[T].length + this.missingNewlineOffset(T, x);
				}
				return {
					lineIndex: T - 1,
					charIndex: S[T - 1].length < m ? S[T - 1].length : m
				};
			},
			getSelectionStyles: function(m, x, S) {
				m === void 0 && (m = this.selectionStart || 0), x === void 0 && (x = this.selectionEnd || m);
				for (var C = [], T = m; T < x; T++) C.push(this.getStyleAtPosition(T, S));
				return C;
			},
			getStyleAtPosition: function(m, x) {
				var S = this.get2DCursorLocation(m);
				return (x ? this.getCompleteStyleDeclaration(S.lineIndex, S.charIndex) : this._getStyleDeclaration(S.lineIndex, S.charIndex)) || {};
			},
			setSelectionStyles: function(m, x, S) {
				x === void 0 && (x = this.selectionStart || 0), S === void 0 && (S = this.selectionEnd || x);
				for (var C = x; C < S; C++) this._extendStyles(C, m);
				return this._forceClearCache = !0, this;
			},
			_getStyleDeclaration: function(m, x) {
				var S = this.styles && this.styles[m];
				return S ? S[x] : null;
			},
			getCompleteStyleDeclaration: function(m, x) {
				for (var S = this._getStyleDeclaration(m, x) || {}, C = {}, T, D = 0; D < this._styleProperties.length; D++) T = this._styleProperties[D], C[T] = S[T] === void 0 ? this[T] : S[T];
				return C;
			},
			_setStyleDeclaration: function(m, x, S) {
				this.styles[m][x] = S;
			},
			_deleteStyleDeclaration: function(m, x) {
				delete this.styles[m][x];
			},
			_getLineStyle: function(m) {
				return !!this.styles[m];
			},
			_setLineStyle: function(m) {
				this.styles[m] = {};
			},
			_deleteLineStyle: function(m) {
				delete this.styles[m];
			}
		});
	})(), (function() {
		function m(m) {
			m.textDecoration && (m.textDecoration.indexOf("underline") > -1 && (m.underline = !0), m.textDecoration.indexOf("line-through") > -1 && (m.linethrough = !0), m.textDecoration.indexOf("overline") > -1 && (m.overline = !0), delete m.textDecoration);
		}
		x.IText = x.util.createClass(x.Text, x.Observable, {
			type: "i-text",
			selectionStart: 0,
			selectionEnd: 0,
			selectionColor: "rgba(17,119,255,0.3)",
			isEditing: !1,
			editable: !0,
			editingBorderColor: "rgba(102,153,255,0.25)",
			cursorWidth: 2,
			cursorColor: "",
			cursorDelay: 1e3,
			cursorDuration: 600,
			caching: !0,
			hiddenTextareaContainer: null,
			_reSpace: /\s|\n/,
			_currentCursorOpacity: 0,
			_selectionDirection: null,
			_abortCursorAnimation: !1,
			__widthOfSpace: [],
			inCompositionMode: !1,
			initialize: function(m, x) {
				this.callSuper("initialize", m, x), this.initBehavior();
			},
			setSelectionStart: function(m) {
				m = Math.max(m, 0), this._updateAndFire("selectionStart", m);
			},
			setSelectionEnd: function(m) {
				m = Math.min(m, this.text.length), this._updateAndFire("selectionEnd", m);
			},
			_updateAndFire: function(m, x) {
				this[m] !== x && (this._fireSelectionChanged(), this[m] = x), this._updateTextarea();
			},
			_fireSelectionChanged: function() {
				this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
			},
			initDimensions: function() {
				this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions");
			},
			render: function(m) {
				this.clearContextTop(), this.callSuper("render", m), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
			},
			_render: function(m) {
				this.callSuper("_render", m);
			},
			clearContextTop: function(m) {
				if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) {
					var x = this.canvas.contextTop, S = this.canvas.viewportTransform;
					x.save(), x.transform(S[0], S[1], S[2], S[3], S[4], S[5]), this.transform(x), this._clearTextArea(x), m || x.restore();
				}
			},
			renderCursorOrSelection: function() {
				if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) {
					var m = this._getCursorBoundaries(), x = this.canvas.contextTop;
					this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(m, x) : this.renderSelection(m, x), x.restore();
				}
			},
			_clearTextArea: function(m) {
				var x = this.width + 4, S = this.height + 4;
				m.clearRect(-x / 2, -S / 2, x, S);
			},
			_getCursorBoundaries: function(m) {
				m === void 0 && (m = this.selectionStart);
				var x = this._getLeftOffset(), S = this._getTopOffset(), C = this._getCursorBoundariesOffsets(m);
				return {
					left: x,
					top: S,
					leftOffset: C.left,
					topOffset: C.top
				};
			},
			_getCursorBoundariesOffsets: function(m) {
				if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache;
				var x, S, C, T = 0, D = 0, O, k = this.get2DCursorLocation(m);
				C = k.charIndex, S = k.lineIndex;
				for (var A = 0; A < S; A++) T += this.getHeightOfLine(A);
				x = this._getLineLeftOffset(S);
				var j = this.__charBounds[S][C];
				return j && (D = j.left), this.charSpacing !== 0 && C === this._textLines[S].length && (D -= this._getWidthOfCharSpacing()), O = {
					top: T,
					left: x + (D > 0 ? D : 0)
				}, this.direction === "rtl" && (O.left *= -1), this.cursorOffsetCache = O, this.cursorOffsetCache;
			},
			renderCursor: function(m, x) {
				var S = this.get2DCursorLocation(), C = S.lineIndex, T = S.charIndex > 0 ? S.charIndex - 1 : 0, D = this.getValueOfPropertyAt(C, T, "fontSize"), O = this.scaleX * this.canvas.getZoom(), k = this.cursorWidth / O, A = m.topOffset, j = this.getValueOfPropertyAt(C, T, "deltaY");
				A += (1 - this._fontSizeFraction) * this.getHeightOfLine(C) / this.lineHeight - D * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(m, x), x.fillStyle = this.cursorColor || this.getValueOfPropertyAt(C, T, "fill"), x.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, x.fillRect(m.left + m.leftOffset - k / 2, A + m.top + j, k, D);
			},
			renderSelection: function(m, x) {
				for (var S = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, C = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, T = this.textAlign.indexOf("justify") !== -1, D = this.get2DCursorLocation(S), O = this.get2DCursorLocation(C), k = D.lineIndex, A = O.lineIndex, j = D.charIndex < 0 ? 0 : D.charIndex, M = O.charIndex < 0 ? 0 : O.charIndex, N = k; N <= A; N++) {
					var P = this._getLineLeftOffset(N) || 0, F = this.getHeightOfLine(N), I = 0, L = 0, R = 0;
					if (N === k && (L = this.__charBounds[k][j].left), N >= k && N < A) R = T && !this.isEndOfWrapping(N) ? this.width : this.getLineWidth(N) || 5;
					else if (N === A) if (M === 0) R = this.__charBounds[A][M].left;
					else {
						var z = this._getWidthOfCharSpacing();
						R = this.__charBounds[A][M - 1].left + this.__charBounds[A][M - 1].width - z;
					}
					I = F, (this.lineHeight < 1 || N === A && this.lineHeight > 1) && (F /= this.lineHeight);
					var B = m.left + P + L, H = R - L, U = F, W = 0;
					this.inCompositionMode ? (x.fillStyle = this.compositionColor || "black", U = 1, W = F) : x.fillStyle = this.selectionColor, this.direction === "rtl" && (B = this.width - B - H), x.fillRect(B, m.top + m.topOffset + W, H, U), m.topOffset += I;
				}
			},
			getCurrentCharFontSize: function() {
				var m = this._getCurrentCharIndex();
				return this.getValueOfPropertyAt(m.l, m.c, "fontSize");
			},
			getCurrentCharColor: function() {
				var m = this._getCurrentCharIndex();
				return this.getValueOfPropertyAt(m.l, m.c, "fill");
			},
			_getCurrentCharIndex: function() {
				var m = this.get2DCursorLocation(this.selectionStart, !0), x = m.charIndex > 0 ? m.charIndex - 1 : 0;
				return {
					l: m.lineIndex,
					c: x
				};
			}
		}), x.IText.fromObject = function(S, C) {
			var T = x.util.stylesFromArray(S.styles, S.text), D = Object.assign({}, S, { styles: T });
			if (delete D.path, m(D), D.styles) for (var O in D.styles) for (var k in D.styles[O]) m(D.styles[O][k]);
			x.Object._fromObject("IText", D, function(m) {
				S.path ? x.Object._fromObject("Path", S.path, function(x) {
					m.set("path", x), C(m);
				}, "path") : C(m);
			}, "text");
		};
	})(), (function() {
		var m = x.util.object.clone;
		x.util.object.extend(x.IText.prototype, {
			initBehavior: function() {
				this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
			},
			onDeselect: function() {
				this.isEditing && this.exitEditing(), this.selected = !1;
			},
			initAddedHandler: function() {
				var m = this;
				this.on("added", function() {
					var x = m.canvas;
					x && (x._hasITextHandlers || (x._hasITextHandlers = !0, m._initCanvasHandlers(x)), x._iTextInstances = x._iTextInstances || [], x._iTextInstances.push(m));
				});
			},
			initRemovedHandler: function() {
				var m = this;
				this.on("removed", function() {
					var S = m.canvas;
					S && (S._iTextInstances = S._iTextInstances || [], x.util.removeFromArray(S._iTextInstances, m), S._iTextInstances.length === 0 && (S._hasITextHandlers = !1, m._removeCanvasHandlers(S)));
				});
			},
			_initCanvasHandlers: function(m) {
				m._mouseUpITextHandler = function() {
					m._iTextInstances && m._iTextInstances.forEach(function(m) {
						m.__isMousedown = !1;
					});
				}, m.on("mouse:up", m._mouseUpITextHandler);
			},
			_removeCanvasHandlers: function(m) {
				m.off("mouse:up", m._mouseUpITextHandler);
			},
			_tick: function() {
				this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete");
			},
			_animateCursor: function(m, x, S, C) {
				var T = {
					isAborted: !1,
					abort: function() {
						this.isAborted = !0;
					}
				};
				return m.animate("_currentCursorOpacity", x, {
					duration: S,
					onComplete: function() {
						T.isAborted || m[C]();
					},
					onChange: function() {
						m.canvas && m.selectionStart === m.selectionEnd && m.renderCursorOrSelection();
					},
					abort: function() {
						return T.isAborted;
					}
				}), T;
			},
			_onTickComplete: function() {
				var m = this;
				this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function() {
					m._currentTickCompleteState = m._animateCursor(m, 0, this.cursorDuration / 2, "_tick");
				}, 100);
			},
			initDelayedCursor: function(m) {
				var x = this, S = m ? 0 : this.cursorDelay;
				this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function() {
					x._tick();
				}, S);
			},
			abortCursorAnimation: function() {
				var m = this._currentTickState || this._currentTickCompleteState, x = this.canvas;
				this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, m && x && x.clearContext(x.contextTop || x.contextContainer);
			},
			selectAll: function() {
				return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
			},
			getSelectedText: function() {
				return this._text.slice(this.selectionStart, this.selectionEnd).join("");
			},
			findWordBoundaryLeft: function(m) {
				var x = 0, S = m - 1;
				if (this._reSpace.test(this._text[S])) for (; this._reSpace.test(this._text[S]);) x++, S--;
				for (; /\S/.test(this._text[S]) && S > -1;) x++, S--;
				return m - x;
			},
			findWordBoundaryRight: function(m) {
				var x = 0, S = m;
				if (this._reSpace.test(this._text[S])) for (; this._reSpace.test(this._text[S]);) x++, S++;
				for (; /\S/.test(this._text[S]) && S < this._text.length;) x++, S++;
				return m + x;
			},
			findLineBoundaryLeft: function(m) {
				for (var x = 0, S = m - 1; !/\n/.test(this._text[S]) && S > -1;) x++, S--;
				return m - x;
			},
			findLineBoundaryRight: function(m) {
				for (var x = 0, S = m; !/\n/.test(this._text[S]) && S < this._text.length;) x++, S++;
				return m + x;
			},
			searchWordBoundary: function(m, S) {
				for (var C = this._text, T = this._reSpace.test(C[m]) ? m - 1 : m, D = C[T], O = x.reNonWord; !O.test(D) && T > 0 && T < C.length;) T += S, D = C[T];
				return O.test(D) && (T += S === 1 ? 0 : 1), T;
			},
			selectWord: function(m) {
				m ||= this.selectionStart;
				var x = this.searchWordBoundary(m, -1), S = this.searchWordBoundary(m, 1);
				this.selectionStart = x, this.selectionEnd = S, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
			},
			selectLine: function(m) {
				m ||= this.selectionStart;
				var x = this.findLineBoundaryLeft(m), S = this.findLineBoundaryRight(m);
				return this.selectionStart = x, this.selectionEnd = S, this._fireSelectionChanged(), this._updateTextarea(), this;
			},
			enterEditing: function(m) {
				if (!(this.isEditing || !this.editable)) return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(m), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this;
			},
			exitEditingOnOthers: function(m) {
				m._iTextInstances && m._iTextInstances.forEach(function(m) {
					m.selected = !1, m.isEditing && m.exitEditing();
				});
			},
			initMouseMoveHandler: function() {
				this.canvas.on("mouse:move", this.mouseMoveHandler);
			},
			mouseMoveHandler: function(m) {
				if (!(!this.__isMousedown || !this.isEditing)) {
					document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();
					var x = this.getSelectionStartFromPointer(m.e), S = this.selectionStart, C = this.selectionEnd;
					(x !== this.__selectionStartOnMouseDown || S === C) && (S === x || C === x) || (x > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = x) : (this.selectionStart = x, this.selectionEnd = this.__selectionStartOnMouseDown), (this.selectionStart !== S || this.selectionEnd !== C) && (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
				}
			},
			_setEditingProps: function() {
				this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
			},
			fromStringToGraphemeSelection: function(m, S, C) {
				var T = C.slice(0, m), D = x.util.string.graphemeSplit(T).length;
				if (m === S) return {
					selectionStart: D,
					selectionEnd: D
				};
				var O = C.slice(m, S);
				return {
					selectionStart: D,
					selectionEnd: D + x.util.string.graphemeSplit(O).length
				};
			},
			fromGraphemeToStringSelection: function(m, x, S) {
				var C = S.slice(0, m).join("").length;
				return m === x ? {
					selectionStart: C,
					selectionEnd: C
				} : {
					selectionStart: C,
					selectionEnd: C + S.slice(m, x).join("").length
				};
			},
			_updateTextarea: function() {
				if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
					if (!this.inCompositionMode) {
						var m = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
						this.hiddenTextarea.selectionStart = m.selectionStart, this.hiddenTextarea.selectionEnd = m.selectionEnd;
					}
					this.updateTextareaPosition();
				}
			},
			updateFromTextArea: function() {
				if (this.hiddenTextarea) {
					this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords());
					var m = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
					this.selectionEnd = this.selectionStart = m.selectionEnd, this.inCompositionMode || (this.selectionStart = m.selectionStart), this.updateTextareaPosition();
				}
			},
			updateTextareaPosition: function() {
				if (this.selectionStart === this.selectionEnd) {
					var m = this._calcTextareaPosition();
					this.hiddenTextarea.style.left = m.left, this.hiddenTextarea.style.top = m.top;
				}
			},
			_calcTextareaPosition: function() {
				if (!this.canvas) return {
					x: 1,
					y: 1
				};
				var m = this.inCompositionMode ? this.compositionStart : this.selectionStart, S = this._getCursorBoundaries(m), C = this.get2DCursorLocation(m), T = C.lineIndex, D = C.charIndex, O = this.getValueOfPropertyAt(T, D, "fontSize") * this.lineHeight, k = S.leftOffset, A = this.calcTransformMatrix(), j = {
					x: S.left + k,
					y: S.top + S.topOffset + O
				}, M = this.canvas.getRetinaScaling(), N = this.canvas.upperCanvasEl, P = N.width / M, F = N.height / M, I = P - O, L = F - O, R = N.clientWidth / P, z = N.clientHeight / F;
				return j = x.util.transformPoint(j, A), j = x.util.transformPoint(j, this.canvas.viewportTransform), j.x *= R, j.y *= z, j.x < 0 && (j.x = 0), j.x > I && (j.x = I), j.y < 0 && (j.y = 0), j.y > L && (j.y = L), j.x += this.canvas._offset.left, j.y += this.canvas._offset.top, {
					left: j.x + "px",
					top: j.y + "px",
					fontSize: O + "px",
					charHeight: O
				};
			},
			_saveEditingProps: function() {
				this._savedProps = {
					hasControls: this.hasControls,
					borderColor: this.borderColor,
					lockMovementX: this.lockMovementX,
					lockMovementY: this.lockMovementY,
					hoverCursor: this.hoverCursor,
					selectable: this.selectable,
					defaultCursor: this.canvas && this.canvas.defaultCursor,
					moveCursor: this.canvas && this.canvas.moveCursor
				};
			},
			_restoreEditingProps: function() {
				this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor));
			},
			exitEditing: function() {
				var m = this._textBeforeEdit !== this.text, x = this.hiddenTextarea;
				return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, x && (x.blur && x.blur(), x.parentNode && x.parentNode.removeChild(x)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), m && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), m && this.canvas.fire("object:modified", { target: this })), this;
			},
			_removeExtraneousStyles: function() {
				for (var m in this.styles) this._textLines[m] || delete this.styles[m];
			},
			removeStyleFromTo: function(m, x) {
				var S = this.get2DCursorLocation(m, !0), C = this.get2DCursorLocation(x, !0), T = S.lineIndex, D = S.charIndex, O = C.lineIndex, k = C.charIndex, A, j;
				if (T !== O) {
					if (this.styles[T]) for (A = D; A < this._unwrappedTextLines[T].length; A++) delete this.styles[T][A];
					if (this.styles[O]) for (A = k; A < this._unwrappedTextLines[O].length; A++) j = this.styles[O][A], j && (this.styles[T] || (this.styles[T] = {}), this.styles[T][D + A - k] = j);
					for (A = T + 1; A <= O; A++) delete this.styles[A];
					this.shiftLineStyles(O, T - O);
				} else if (this.styles[T]) {
					j = this.styles[T];
					var M = k - D, N, P;
					for (A = D; A < k; A++) delete j[A];
					for (P in this.styles[T]) N = parseInt(P, 10), N >= k && (j[N - M] = j[P], delete j[P]);
				}
			},
			shiftLineStyles: function(x, S) {
				var C = m(this.styles);
				for (var T in this.styles) {
					var D = parseInt(T, 10);
					D > x && (this.styles[D + S] = C[D], C[D - S] || delete this.styles[D]);
				}
			},
			restartCursorIfNeeded: function() {
				(!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) && this.initDelayedCursor();
			},
			insertNewlineStyleObject: function(x, S, C, T) {
				var D, O = {}, k = !1, A = this._unwrappedTextLines[x].length, j = A === S;
				for (var M in C ||= 1, this.shiftLineStyles(x, C), this.styles[x] && (D = this.styles[x][S === 0 ? S : S - 1]), this.styles[x]) {
					var N = parseInt(M, 10);
					N >= S && (k = !0, O[N - S] = this.styles[x][M], j && S === 0 || delete this.styles[x][M]);
				}
				var P = !1;
				for (k && !j && (this.styles[x + C] = O, P = !0), (P || A > S) && C--; C > 0;) T && T[C - 1] ? this.styles[x + C] = { 0: m(T[C - 1]) } : D ? this.styles[x + C] = { 0: m(D) } : delete this.styles[x + C], C--;
				this._forceClearCache = !0;
			},
			insertCharStyleObject: function(x, S, C, T) {
				this.styles ||= {};
				var D = this.styles[x], O = D ? m(D) : {};
				for (var k in C ||= 1, O) {
					var A = parseInt(k, 10);
					A >= S && (D[A + C] = O[A], O[A - C] || delete D[A]);
				}
				if (this._forceClearCache = !0, T) {
					for (; C--;) Object.keys(T[C]).length && (this.styles[x] || (this.styles[x] = {}), this.styles[x][S + C] = m(T[C]));
					return;
				}
				if (D) for (var j = D[S ? S - 1 : 1]; j && C--;) this.styles[x][S + C] = m(j);
			},
			insertNewStyleBlock: function(m, x, S) {
				for (var C = this.get2DCursorLocation(x, !0), T = [0], D = 0, O = 0; O < m.length; O++) m[O] === "\n" ? (D++, T[D] = 0) : T[D]++;
				T[0] > 0 && (this.insertCharStyleObject(C.lineIndex, C.charIndex, T[0], S), S &&= S.slice(T[0] + 1)), D && this.insertNewlineStyleObject(C.lineIndex, C.charIndex + T[0], D);
				for (var O = 1; O < D; O++) T[O] > 0 ? this.insertCharStyleObject(C.lineIndex + O, 0, T[O], S) : S && this.styles[C.lineIndex + O] && S[0] && (this.styles[C.lineIndex + O][0] = S[0]), S &&= S.slice(T[O] + 1);
				T[O] > 0 && this.insertCharStyleObject(C.lineIndex + O, 0, T[O], S);
			},
			setSelectionStartEndWithShift: function(m, x, S) {
				S <= m ? (x === m ? this._selectionDirection = "left" : this._selectionDirection === "right" && (this._selectionDirection = "left", this.selectionEnd = m), this.selectionStart = S) : S > m && S < x ? this._selectionDirection === "right" ? this.selectionEnd = S : this.selectionStart = S : (x === m ? this._selectionDirection = "right" : this._selectionDirection === "left" && (this._selectionDirection = "right", this.selectionStart = x), this.selectionEnd = S);
			},
			setSelectionInBoundaries: function() {
				var m = this.text.length;
				this.selectionStart > m ? this.selectionStart = m : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > m ? this.selectionEnd = m : this.selectionEnd < 0 && (this.selectionEnd = 0);
			}
		});
	})(), x.util.object.extend(x.IText.prototype, {
		initDoubleClickSimulation: function() {
			this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown);
		},
		onMouseDown: function(m) {
			if (this.canvas) {
				this.__newClickTime = +/* @__PURE__ */ new Date();
				var x = m.pointer;
				this.isTripleClick(x) && (this.fire("tripleclick", m), this._stopEvent(m.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = x, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected;
			}
		},
		isTripleClick: function(m) {
			return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === m.x && this.__lastPointer.y === m.y;
		},
		_stopEvent: function(m) {
			m.preventDefault && m.preventDefault(), m.stopPropagation && m.stopPropagation();
		},
		initCursorSelectionHandlers: function() {
			this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks();
		},
		doubleClickHandler: function(m) {
			this.isEditing && this.selectWord(this.getSelectionStartFromPointer(m.e));
		},
		tripleClickHandler: function(m) {
			this.isEditing && this.selectLine(this.getSelectionStartFromPointer(m.e));
		},
		initClicks: function() {
			this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler);
		},
		_mouseDownHandler: function(m) {
			!this.canvas || !this.editable || m.e.button && m.e.button !== 1 || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(m.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()));
		},
		_mouseDownHandlerBefore: function(m) {
			!this.canvas || !this.editable || m.e.button && m.e.button !== 1 || (this.selected = this === this.canvas._activeObject);
		},
		initMousedownHandler: function() {
			this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore);
		},
		initMouseupHandler: function() {
			this.on("mouseup", this.mouseUpHandler);
		},
		mouseUpHandler: function(m) {
			if (this.__isMousedown = !1, !(!this.editable || this.group || m.transform && m.transform.actionPerformed || m.e.button && m.e.button !== 1)) {
				if (this.canvas) {
					var x = this.canvas._activeObject;
					if (x && x !== this) return;
				}
				this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(m.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0;
			}
		},
		setCursorByClick: function(m) {
			var x = this.getSelectionStartFromPointer(m), S = this.selectionStart, C = this.selectionEnd;
			m.shiftKey ? this.setSelectionStartEndWithShift(S, C, x) : (this.selectionStart = x, this.selectionEnd = x), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
		},
		getSelectionStartFromPointer: function(m) {
			for (var x = this.getLocalPointer(m), S = 0, C = 0, T = 0, D = 0, O = 0, k, A, j = 0, M = this._textLines.length; j < M && T <= x.y; j++) T += this.getHeightOfLine(j) * this.scaleY, O = j, j > 0 && (D += this._textLines[j - 1].length + this.missingNewlineOffset(j - 1));
			k = this._getLineLeftOffset(O), C = k * this.scaleX, A = this._textLines[O], this.direction === "rtl" && (x.x = this.width * this.scaleX - x.x + C);
			for (var N = 0, P = A.length; N < P && (S = C, C += this.__charBounds[O][N].kernedWidth * this.scaleX, C <= x.x); N++) D++;
			return this._getNewSelectionStartFromOffset(x, S, C, D, P);
		},
		_getNewSelectionStartFromOffset: function(m, x, S, C, T) {
			var D = m.x - x, O = S - m.x, k = C + (O > D || O < 0 ? 0 : 1);
			return this.flipX && (k = T - k), k > this._text.length && (k = this._text.length), k;
		}
	}), x.util.object.extend(x.IText.prototype, {
		initHiddenTextarea: function() {
			this.hiddenTextarea = x.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off");
			var m = this._calcTextareaPosition();
			this.hiddenTextarea.style.cssText = "position: absolute; top: " + m.top + "; left: " + m.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + m.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : x.document.body.appendChild(this.hiddenTextarea), x.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), x.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), x.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), x.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), x.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), x.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), x.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), x.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), x.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (x.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0);
		},
		keysMap: {
			9: "exitEditing",
			27: "exitEditing",
			33: "moveCursorUp",
			34: "moveCursorDown",
			35: "moveCursorRight",
			36: "moveCursorLeft",
			37: "moveCursorLeft",
			38: "moveCursorUp",
			39: "moveCursorRight",
			40: "moveCursorDown"
		},
		keysMapRtl: {
			9: "exitEditing",
			27: "exitEditing",
			33: "moveCursorUp",
			34: "moveCursorDown",
			35: "moveCursorLeft",
			36: "moveCursorRight",
			37: "moveCursorRight",
			38: "moveCursorUp",
			39: "moveCursorLeft",
			40: "moveCursorDown"
		},
		ctrlKeysMapUp: {
			67: "copy",
			88: "cut"
		},
		ctrlKeysMapDown: { 65: "selectAll" },
		onClick: function() {
			this.hiddenTextarea && this.hiddenTextarea.focus();
		},
		onKeyDown: function(m) {
			if (this.isEditing) {
				var x = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
				if (m.keyCode in x) this[x[m.keyCode]](m);
				else if (m.keyCode in this.ctrlKeysMapDown && (m.ctrlKey || m.metaKey)) this[this.ctrlKeysMapDown[m.keyCode]](m);
				else return;
				m.stopImmediatePropagation(), m.preventDefault(), m.keyCode >= 33 && m.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
			}
		},
		onKeyUp: function(m) {
			if (!this.isEditing || this._copyDone || this.inCompositionMode) {
				this._copyDone = !1;
				return;
			}
			if (m.keyCode in this.ctrlKeysMapUp && (m.ctrlKey || m.metaKey)) this[this.ctrlKeysMapUp[m.keyCode]](m);
			else return;
			m.stopImmediatePropagation(), m.preventDefault(), this.canvas && this.canvas.requestRenderAll();
		},
		onInput: function(m) {
			var S = this.fromPaste;
			if (this.fromPaste = !1, m && m.stopPropagation(), this.isEditing) {
				var C = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, T = this._text.length, D = C.length, O, k, A = D - T, j = this.selectionStart, M = this.selectionEnd, N = j !== M, P, F, I;
				if (this.hiddenTextarea.value === "") {
					this.styles = {}, this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
					return;
				}
				var L = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), R = j > L.selectionStart;
				N ? (O = this._text.slice(j, M), A += M - j) : D < T && (O = R ? this._text.slice(M + A, M) : this._text.slice(j, j - A)), k = C.slice(L.selectionEnd - A, L.selectionEnd), O && O.length && (k.length && (P = this.getSelectionStyles(j, j + 1, !1), P = k.map(function() {
					return P[0];
				})), N ? (F = j, I = M) : R ? (F = M - O.length, I = M) : (F = M, I = M + O.length), this.removeStyleFromTo(F, I)), k.length && (S && k.join("") === x.copiedText && !x.disableStyleCopyPaste && (P = x.copiedTextStyle), this.insertNewStyleBlock(k, j, P)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
			}
		},
		onCompositionStart: function() {
			this.inCompositionMode = !0;
		},
		onCompositionEnd: function() {
			this.inCompositionMode = !1;
		},
		onCompositionUpdate: function(m) {
			this.compositionStart = m.target.selectionStart, this.compositionEnd = m.target.selectionEnd, this.updateTextareaPosition();
		},
		copy: function() {
			this.selectionStart !== this.selectionEnd && (x.copiedText = this.getSelectedText(), x.disableStyleCopyPaste ? x.copiedTextStyle = null : x.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0);
		},
		paste: function() {
			this.fromPaste = !0;
		},
		_getClipboardData: function(m) {
			return m && m.clipboardData || x.window.clipboardData;
		},
		_getWidthBeforeCursor: function(m, x) {
			var S = this._getLineLeftOffset(m), C;
			return x > 0 && (C = this.__charBounds[m][x - 1], S += C.left + C.width), S;
		},
		getDownCursorOffset: function(m, x) {
			var S = this._getSelectionForOffset(m, x), C = this.get2DCursorLocation(S), T = C.lineIndex;
			if (T === this._textLines.length - 1 || m.metaKey || m.keyCode === 34) return this._text.length - S;
			var D = C.charIndex, O = this._getWidthBeforeCursor(T, D), k = this._getIndexOnLine(T + 1, O);
			return this._textLines[T].slice(D).length + k + 1 + this.missingNewlineOffset(T);
		},
		_getSelectionForOffset: function(m, x) {
			return m.shiftKey && this.selectionStart !== this.selectionEnd && x ? this.selectionEnd : this.selectionStart;
		},
		getUpCursorOffset: function(m, x) {
			var S = this._getSelectionForOffset(m, x), C = this.get2DCursorLocation(S), T = C.lineIndex;
			if (T === 0 || m.metaKey || m.keyCode === 33) return -S;
			var D = C.charIndex, O = this._getWidthBeforeCursor(T, D), k = this._getIndexOnLine(T - 1, O), A = this._textLines[T].slice(0, D), j = this.missingNewlineOffset(T - 1);
			return -this._textLines[T - 1].length + k - A.length + (1 - j);
		},
		_getIndexOnLine: function(m, x) {
			for (var S = this._textLines[m], C = this._getLineLeftOffset(m), T = 0, D, O, k = 0, A = S.length; k < A; k++) if (D = this.__charBounds[m][k].width, C += D, C > x) {
				O = !0;
				var j = C - D, M = C, N = Math.abs(j - x);
				T = Math.abs(M - x) < N ? k : k - 1;
				break;
			}
			return O || (T = S.length - 1), T;
		},
		moveCursorDown: function(m) {
			this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", m);
		},
		moveCursorUp: function(m) {
			this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", m);
		},
		_moveCursorUpOrDown: function(m, x) {
			var S = "get" + m + "CursorOffset", C = this[S](x, this._selectionDirection === "right");
			x.shiftKey ? this.moveCursorWithShift(C) : this.moveCursorWithoutShift(C), C !== 0 && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
		},
		moveCursorWithShift: function(m) {
			var x = this._selectionDirection === "left" ? this.selectionStart + m : this.selectionEnd + m;
			return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, x), m !== 0;
		},
		moveCursorWithoutShift: function(m) {
			return m < 0 ? (this.selectionStart += m, this.selectionEnd = this.selectionStart) : (this.selectionEnd += m, this.selectionStart = this.selectionEnd), m !== 0;
		},
		moveCursorLeft: function(m) {
			this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", m);
		},
		_move: function(m, x, S) {
			var C;
			if (m.altKey) C = this["findWordBoundary" + S](this[x]);
			else if (m.metaKey || m.keyCode === 35 || m.keyCode === 36) C = this["findLineBoundary" + S](this[x]);
			else return this[x] += S === "Left" ? -1 : 1, !0;
			if (C !== void 0 && this[x] !== C) return this[x] = C, !0;
		},
		_moveLeft: function(m, x) {
			return this._move(m, x, "Left");
		},
		_moveRight: function(m, x) {
			return this._move(m, x, "Right");
		},
		moveCursorLeftWithoutShift: function(m) {
			var x = !0;
			return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (x = this._moveLeft(m, "selectionStart")), this.selectionEnd = this.selectionStart, x;
		},
		moveCursorLeftWithShift: function(m) {
			if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd) return this._moveLeft(m, "selectionEnd");
			if (this.selectionStart !== 0) return this._selectionDirection = "left", this._moveLeft(m, "selectionStart");
		},
		moveCursorRight: function(m) {
			this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", m);
		},
		_moveCursorLeftOrRight: function(m, x) {
			var S = "moveCursor" + m + "With";
			this._currentCursorOpacity = 1, x.shiftKey ? S += "Shift" : S += "outShift", this[S](x) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
		},
		moveCursorRightWithShift: function(m) {
			if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd) return this._moveRight(m, "selectionStart");
			if (this.selectionEnd !== this._text.length) return this._selectionDirection = "right", this._moveRight(m, "selectionEnd");
		},
		moveCursorRightWithoutShift: function(m) {
			var x = !0;
			return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (x = this._moveRight(m, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, x;
		},
		removeChars: function(m, x) {
			x === void 0 && (x = m + 1), this.removeStyleFromTo(m, x), this._text.splice(m, x - m), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();
		},
		insertChars: function(m, S, C, T) {
			T === void 0 && (T = C), T > C && this.removeStyleFromTo(C, T);
			var D = x.util.string.graphemeSplit(m);
			this.insertNewStyleBlock(D, C, S), this._text = [].concat(this._text.slice(0, C), D, this._text.slice(T)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();
		}
	}), (function() {
		var m = x.util.toFixed, S = x.util.radiansToDegrees, C = x.util.calcRotateMatrix, T = x.util.transformPoint, D = /  +/g;
		x.util.object.extend(x.Text.prototype, {
			_toSVG: function() {
				var m = this._getSVGLeftTopOffsets(), x = this._getSVGTextAndBg(m.textTop, m.textLeft);
				return this._wrapSVGTextAndBg(x);
			},
			toSVG: function(m) {
				var x = this._createBaseSVGMarkup(this._toSVG(), {
					reviver: m,
					noStyle: !0,
					withShadow: !0
				}), S = this.path;
				return S ? x + S._createBaseSVGMarkup(S._toSVG(), {
					reviver: m,
					withShadow: !0
				}) : x;
			},
			_getSVGLeftTopOffsets: function() {
				return {
					textLeft: -this.width / 2,
					textTop: -this.height / 2,
					lineTop: this.getHeightOfLine(0)
				};
			},
			_wrapSVGTextAndBg: function(m) {
				var x = !0, S = this.getSvgTextDecoration(this);
				return [
					m.textBgRects.join(""),
					"		<text xml:space=\"preserve\" ",
					this.fontFamily ? "font-family=\"" + this.fontFamily.replace(/"/g, "'") + "\" " : "",
					this.fontSize ? "font-size=\"" + this.fontSize + "\" " : "",
					this.fontStyle ? "font-style=\"" + this.fontStyle + "\" " : "",
					this.fontWeight ? "font-weight=\"" + this.fontWeight + "\" " : "",
					S ? "text-decoration=\"" + S + "\" " : "",
					"style=\"",
					this.getSvgStyles(x),
					"\"",
					this.addPaintOrder(),
					" >",
					m.textSpans.join(""),
					"</text>\n"
				];
			},
			_getSVGTextAndBg: function(m, x) {
				var S = [], C = [], T = m, D;
				this._setSVGBg(C);
				for (var O = 0, k = this._textLines.length; O < k; O++) D = this._getLineLeftOffset(O), (this.textBackgroundColor || this.styleHas("textBackgroundColor", O)) && this._setSVGTextLineBg(C, O, x + D, T), this._setSVGTextLineText(S, O, x + D, T), T += this.getHeightOfLine(O);
				return {
					textSpans: S,
					textBgRects: C
				};
			},
			_createTextCharSpan: function(O, k, A, j, M) {
				var N = O !== O.trim() || O.match(D), P = this.getSvgSpanStyles(k, N), F = P ? "style=\"" + P + "\"" : "", I = k.deltaY, L = "", R = x.Object.NUM_FRACTION_DIGITS, z = "";
				if (I && (L = " dy=\"" + m(I, R) + "\" "), M.renderLeft !== void 0) {
					var B = M.angle;
					z = " rotate=\"" + m(S(B), x.Object.NUM_FRACTION_DIGITS) + "\" ";
					var H = M.width / 2, U = C({ angle: S(B) });
					U[4] = M.renderLeft, U[5] = M.renderTop;
					var W = T({
						x: -H,
						y: 0
					}, U);
					A = W.x, j = W.y;
				}
				return [
					"<tspan x=\"",
					m(A, R),
					"\" y=\"",
					m(j, R),
					"\" ",
					L,
					F,
					z,
					">",
					x.util.string.escapeXml(O),
					"</tspan>"
				].join("");
			},
			_setSVGTextLineText: function(m, S, C, T) {
				var D = this.getHeightOfLine(S), O = this.textAlign.indexOf("justify") !== -1, k, A, j = "", M, N, P = 0, F = this._textLines[S], I;
				T += D * (1 - this._fontSizeFraction) / this.lineHeight;
				for (var L = 0, R = F.length - 1; L <= R; L++) I = L === R || this.charSpacing || this.path, j += F[L], M = this.__charBounds[S][L], P === 0 ? (C += M.kernedWidth - M.width, P += M.width) : P += M.kernedWidth, O && !I && this._reSpaceAndTab.test(F[L]) && (I = !0), I ||= (k ||= this.getCompleteStyleDeclaration(S, L), A = this.getCompleteStyleDeclaration(S, L + 1), x.util.hasStyleChanged(k, A, !0)), I && (N = this._getStyleDeclaration(S, L) || {}, m.push(this._createTextCharSpan(j, N, C, T, M)), j = "", k = A, C += P, P = 0);
			},
			_pushTextBgRect: function(S, C, T, D, O, k) {
				var A = x.Object.NUM_FRACTION_DIGITS;
				S.push("		<rect ", this._getFillAttributes(C), " x=\"", m(T, A), "\" y=\"", m(D, A), "\" width=\"", m(O, A), "\" height=\"", m(k, A), "\"></rect>\n");
			},
			_setSVGTextLineBg: function(m, x, S, C) {
				for (var T = this._textLines[x], D = this.getHeightOfLine(x) / this.lineHeight, O = 0, k = 0, A, j, M = this.getValueOfPropertyAt(x, 0, "textBackgroundColor"), N = 0, P = T.length; N < P; N++) A = this.__charBounds[x][N], j = this.getValueOfPropertyAt(x, N, "textBackgroundColor"), j === M ? O += A.kernedWidth : (M && this._pushTextBgRect(m, M, S + k, C, O, D), k = A.left, O = A.width, M = j);
				j && this._pushTextBgRect(m, j, S + k, C, O, D);
			},
			_getFillAttributes: function(m) {
				var S = m && typeof m == "string" ? new x.Color(m) : "";
				return !S || !S.getSource() || S.getAlpha() === 1 ? "fill=\"" + m + "\"" : "opacity=\"" + S.getAlpha() + "\" fill=\"" + S.setAlpha(1).toRgb() + "\"";
			},
			_getSVGLineTopOffset: function(m) {
				for (var x = 0, S = 0, C = 0; C < m; C++) x += this.getHeightOfLine(C);
				return S = this.getHeightOfLine(C), {
					lineTop: x,
					offset: (this._fontSizeMult - this._fontSizeFraction) * S / (this.lineHeight * this._fontSizeMult)
				};
			},
			getSvgStyles: function(m) {
				return x.Object.prototype.getSvgStyles.call(this, m) + " white-space: pre;";
			}
		});
	})(), (function(m) {
		var x = m.fabric ||= {};
		x.Textbox = x.util.createClass(x.IText, x.Observable, {
			type: "textbox",
			minWidth: 20,
			dynamicMinWidth: 2,
			__cachedLines: null,
			lockScalingFlip: !0,
			noScaleCache: !1,
			_dimensionAffectingProps: x.Text.prototype._dimensionAffectingProps.concat("width"),
			_wordJoiners: /[ \t\r]/,
			splitByGrapheme: !1,
			initDimensions: function() {
				this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" }));
			},
			_generateStyleMap: function(m) {
				for (var x = 0, S = 0, C = 0, T = {}, D = 0; D < m.graphemeLines.length; D++) m.graphemeText[C] === "\n" && D > 0 ? (S = 0, C++, x++) : !this.splitByGrapheme && this._reSpaceAndTab.test(m.graphemeText[C]) && D > 0 && (S++, C++), T[D] = {
					line: x,
					offset: S
				}, C += m.graphemeLines[D].length, S += m.graphemeLines[D].length;
				return T;
			},
			styleHas: function(m, S) {
				if (this._styleMap && !this.isWrapping) {
					var C = this._styleMap[S];
					C && (S = C.line);
				}
				return x.Text.prototype.styleHas.call(this, m, S);
			},
			isEmptyStyles: function(m) {
				if (!this.styles) return !0;
				var x = 0, S = m + 1, C, T, D = !1, O = this._styleMap[m], k = this._styleMap[m + 1];
				for (var A in O && (m = O.line, x = O.offset), k && (S = k.line, D = S === m, C = k.offset), T = m === void 0 ? this.styles : { line: this.styles[m] }, T) for (var j in T[A]) if (j >= x && (!D || j < C)) for (var M in T[A][j]) return !1;
				return !0;
			},
			_getStyleDeclaration: function(m, x) {
				if (this._styleMap && !this.isWrapping) {
					var S = this._styleMap[m];
					if (!S) return null;
					m = S.line, x = S.offset + x;
				}
				return this.callSuper("_getStyleDeclaration", m, x);
			},
			_setStyleDeclaration: function(m, x, S) {
				var C = this._styleMap[m];
				m = C.line, x = C.offset + x, this.styles[m][x] = S;
			},
			_deleteStyleDeclaration: function(m, x) {
				var S = this._styleMap[m];
				m = S.line, x = S.offset + x, delete this.styles[m][x];
			},
			_getLineStyle: function(m) {
				var x = this._styleMap[m];
				return !!this.styles[x.line];
			},
			_setLineStyle: function(m) {
				var x = this._styleMap[m];
				this.styles[x.line] = {};
			},
			_wrapText: function(m, x) {
				var S = [], C;
				for (this.isWrapping = !0, C = 0; C < m.length; C++) S = S.concat(this._wrapLine(m[C], C, x));
				return this.isWrapping = !1, S;
			},
			_measureWord: function(m, x, S) {
				var C = 0, T, D = !0;
				S ||= 0;
				for (var O = 0, k = m.length; O < k; O++) {
					var A = this._getGraphemeBox(m[O], x, O + S, T, D);
					C += A.kernedWidth, T = m[O];
				}
				return C;
			},
			_wrapLine: function(m, S, C, T) {
				var D = 0, O = this.splitByGrapheme, k = [], A = [], j = O ? x.util.string.graphemeSplit(m) : m.split(this._wordJoiners), M = "", N = 0, P = O ? "" : " ", F = 0, I = 0, L = 0, R = !0, z = this._getWidthOfCharSpacing(), T = T || 0;
				j.length === 0 && j.push([]), C -= T;
				for (var B = 0; B < j.length; B++) M = O ? j[B] : x.util.string.graphemeSplit(j[B]), F = this._measureWord(M, S, N), N += M.length, D += I + F - z, D > C && !R ? (k.push(A), A = [], D = F, R = !0) : D += z, !R && !O && A.push(P), A = A.concat(M), I = O ? 0 : this._measureWord([P], S, N), N++, R = !1, F > L && (L = F);
				return B && k.push(A), L + T > this.dynamicMinWidth && (this.dynamicMinWidth = L - z + T), k;
			},
			isEndOfWrapping: function(m) {
				return !this._styleMap[m + 1] || this._styleMap[m + 1].line !== this._styleMap[m].line;
			},
			missingNewlineOffset: function(m, x) {
				return this.splitByGrapheme && !x ? this.isEndOfWrapping(m) ? 1 : 0 : 1;
			},
			_splitTextIntoLines: function(m) {
				for (var S = x.Text.prototype._splitTextIntoLines.call(this, m), C = this._wrapText(S.lines, this.width), T = Array(C.length), D = 0; D < C.length; D++) T[D] = C[D].join("");
				return S.lines = T, S.graphemeLines = C, S;
			},
			getMinWidth: function() {
				return Math.max(this.minWidth, this.dynamicMinWidth);
			},
			_removeExtraneousStyles: function() {
				var m = {};
				for (var x in this._styleMap) this._textLines[x] && (m[this._styleMap[x].line] = 1);
				for (var x in this.styles) m[x] || delete this.styles[x];
			},
			toObject: function(m) {
				return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(m));
			}
		}), x.Textbox.fromObject = function(m, S) {
			var C = x.util.stylesFromArray(m.styles, m.text), T = Object.assign({}, m, { styles: C });
			return delete T.path, x.Object._fromObject("Textbox", T, function(C) {
				m.path ? x.Object._fromObject("Path", m.path, function(m) {
					C.set("path", m), S(C);
				}, "path") : S(C);
			}, "text");
		};
	})(m), (function() {
		var m = x.controlsUtils, S = m.scaleSkewCursorStyleHandler, C = m.scaleCursorStyleHandler, T = m.scalingEqually, D = m.scalingYOrSkewingX, O = m.scalingXOrSkewingY, k = m.scaleOrSkewActionName, A = x.Object.prototype.controls;
		if (A.ml = new x.Control({
			x: -.5,
			y: 0,
			cursorStyleHandler: S,
			actionHandler: O,
			getActionName: k
		}), A.mr = new x.Control({
			x: .5,
			y: 0,
			cursorStyleHandler: S,
			actionHandler: O,
			getActionName: k
		}), A.mb = new x.Control({
			x: 0,
			y: .5,
			cursorStyleHandler: S,
			actionHandler: D,
			getActionName: k
		}), A.mt = new x.Control({
			x: 0,
			y: -.5,
			cursorStyleHandler: S,
			actionHandler: D,
			getActionName: k
		}), A.tl = new x.Control({
			x: -.5,
			y: -.5,
			cursorStyleHandler: C,
			actionHandler: T
		}), A.tr = new x.Control({
			x: .5,
			y: -.5,
			cursorStyleHandler: C,
			actionHandler: T
		}), A.bl = new x.Control({
			x: -.5,
			y: .5,
			cursorStyleHandler: C,
			actionHandler: T
		}), A.br = new x.Control({
			x: .5,
			y: .5,
			cursorStyleHandler: C,
			actionHandler: T
		}), A.mtr = new x.Control({
			x: 0,
			y: -.5,
			actionHandler: m.rotationWithSnapping,
			cursorStyleHandler: m.rotationStyleHandler,
			offsetY: -40,
			withConnection: !0,
			actionName: "rotate"
		}), x.Textbox) {
			var j = x.Textbox.prototype.controls = {};
			j.mtr = A.mtr, j.tr = A.tr, j.br = A.br, j.tl = A.tl, j.bl = A.bl, j.mt = A.mt, j.mb = A.mb, j.mr = new x.Control({
				x: .5,
				y: 0,
				actionHandler: m.changeWidth,
				cursorStyleHandler: S,
				actionName: "resizing"
			}), j.ml = new x.Control({
				x: -.5,
				y: 0,
				actionHandler: m.changeWidth,
				cursorStyleHandler: S,
				actionName: "resizing"
			});
		}
	})();
})), import_fabric$6 = require_fabric();
const PlanItemTypeEnum = {
	None: 0,
	Room: 1,
	Plot: 2,
	PlotContainer: 3
}, PlanItemTypeEnumNames = {
	[PlanItemTypeEnum.None]: "None",
	[PlanItemTypeEnum.Room]: "Room",
	[PlanItemTypeEnum.Plot]: "Plot",
	[PlanItemTypeEnum.PlotContainer]: "PlotContainer"
};
function getPlanItemTypeEnum(m) {
	return PlanItemTypeEnum[m] ?? PlanItemTypeEnum.None;
}
const PlanObjectTypeEnum = {
	None: 0,
	Rectangle: 1,
	Circle: 2,
	Polygon: 3
}, PlanObjectTypeEnumNames = {
	[PlanObjectTypeEnum.None]: "None",
	[PlanObjectTypeEnum.Rectangle]: "Rectangle",
	[PlanObjectTypeEnum.Circle]: "Circle",
	[PlanObjectTypeEnum.Polygon]: "Polygon"
};
var PlanLabelObject = class extends import_fabric$6.fabric.Group {
	get label() {
		return this._text.text;
	}
	constructor(m, x, S, C, T, D, O, k = 16) {
		super([], {
			left: S,
			top: C,
			selectable: !1,
			hasControls: !1,
			evented: !1,
			lockRotation: !0
		}), this.PADDING_RIGHT_LEFT = 10, this.PADDING_TOP_BOTTOM = 4, this._text = new import_fabric$6.fabric.Text(m, {
			left: T / 2 + S,
			top: D / 2 + C,
			fontSize: k,
			lineHeight: 16,
			fontFamily: "Inter",
			originX: "center",
			originY: "center",
			textAlign: "center",
			hasControls: !1,
			selectable: !1,
			lockRotation: !0,
			fill: "white",
			fontWeight: "bolder",
			opacity: O ?? 1
		}), this._rectangle = new import_fabric$6.fabric.Rect({
			left: T / 2 + S,
			top: D / 2 + C,
			originX: "center",
			originY: "center",
			width: (this._text.width ?? 0) + 200,
			height: (this._text.height ?? 0) + this.PADDING_TOP_BOTTOM * 2,
			selectable: !1,
			hasControls: !1,
			evented: !1,
			hasBorders: !1,
			lockRotation: !0,
			fill: x,
			rx: 12,
			ry: 12,
			opacity: O ?? 1
		}), this.addWithUpdate(this._rectangle), this.addWithUpdate(this._text);
	}
	setLabel(m) {
		try {
			this._text.set("text", m), this._rectangle.set("width", (this._text.width ?? 0) + this.PADDING_RIGHT_LEFT * 2);
		} catch {}
	}
	addStroke() {
		this._text.set("stroke", "black"), this._text.set("strokeWidth", 15), this._text.set("paintFirst", "stroke");
	}
	setColor(m) {
		this._rectangle.set("fill", m);
	}
	hideBackground() {
		this._rectangle.set("opacity", 0);
	}
	setOpacity(m) {
		this._rectangle.set("opacity", m), this._text.set("opacity", m);
	}
}, import_fabric$5 = require_fabric(), PlanCircleObject = class m extends import_fabric$5.fabric.Circle {
	get objectId() {
		return this._objectId;
	}
	get objectType() {
		return PlanObjectTypeEnumNames[PlanObjectTypeEnum.Circle];
	}
	get objectName() {
		return this.itemName ? this.itemName : "New Shape";
	}
	get icon() {
		return this.itemId ? "assets/icons/link.svg" : "assets/icons/link-broken.svg";
	}
	constructor(m) {
		super({
			left: m.left,
			top: m.top,
			radius: Math.min(m.width ?? 0, m.height ?? 0) / 2,
			selectable: !1,
			hasControls: !1,
			originX: "center",
			originY: "center",
			evented: !1,
			hasBorders: !0,
			strokeWidth: .2,
			stroke: "#000000",
			fill: m.fill,
			opacity: m.opacity ?? .6
		}), this._objectId = v4_default(), this.containerId = 0, this.itemId = "", this.itemType = PlanItemTypeEnumNames[PlanItemTypeEnum.None], this.itemName = "", m.objectId && (this._objectId = m.objectId), this.containerType = m.containerType, this.containerId = m.containerId, this.itemType = m.itemType, this.itemId = m.itemId, this.label = new PlanLabelObject(this.objectType, m.fill ?? "0x000000", m.left ?? 0, m.top ?? 0, 0, 0), this.text = new import_fabric$5.fabric.Text(this.objectType, {
			fontSize: 15,
			fontFamily: "Arial",
			originX: "center",
			originY: "center",
			textAlign: "center",
			hasControls: !1,
			selectable: !1,
			evented: !1,
			left: this.left,
			top: this.top,
			width: this.width,
			height: (this.height ?? 0) / 2,
			visible: !1
		});
	}
	finishDrawing() {
		this.setControlsVisibility({
			bl: !0,
			br: !0,
			mb: !1,
			ml: !1,
			mr: !1,
			mt: !1,
			tl: !0,
			tr: !0,
			mtr: !1
		}), this.selectable = !1, this.evented = !0, this.hasControls = !0, this.centeredScaling = !0, this.hoverCursor = "pointer", this.text.visible = !0, this.label.visible = !0, this.setCoords();
	}
	redraw(m) {
		let x = this.left, S = this.top;
		this.set("radius", Math.max(Math.abs(m.x - (x ?? 0)), Math.abs(m.y - (S ?? 0)))).setCoords(), this.text.set("left", this.left).set("top", this.top).set("width", this.width);
	}
	duplicate() {
		let x = new m({
			objectId: "",
			objectType: PlanObjectTypeEnumNames[PlanObjectTypeEnum.Circle],
			containerType: this.containerType,
			containerId: this.containerId,
			itemType: PlanItemTypeEnumNames[PlanItemTypeEnum.None],
			itemId: "",
			left: (this.left ?? 0) + (this.width ?? 0),
			top: this.top,
			fill: this.fill,
			radius: this.radius,
			label: this.label
		});
		return x.finishDrawing(), x;
	}
	assign(m) {
		m ? (this.itemType = m.type, this.itemId = m.id, this.itemName = m.number ?? m.name, this.itemInformation = m.informations?.join("\r\n") ?? "", this.text.visible = !0, this.label.visible = !0, this.setControlVisible("assignControl", !1), this.setControlVisible("unassignControl", !0), this.changeColor(m.color)) : (this.itemType = PlanItemTypeEnumNames[PlanItemTypeEnum.None], this.itemId = "", this.itemName = "", this.setControlVisible("unassignControl", !1), this.setControlVisible("assignControl", !0)), this.setText(this.itemName ?? "");
	}
	move() {
		this.setCoords(), this.text.set("left", this.left).set("top", this.top).setCoords();
	}
	resize() {
		this.text.set("left", this.left).set("top", this.top).set("width", (this.radius ?? 0) * (this.scaleX ?? 1)).setCoords();
	}
	modify() {
		this.setCoords().set("radius", (this.radius ?? 0) * (this.scaleX ?? 1)).set("scaleX", 1).set("scaleY", 1);
	}
	setText(m) {
		this.label.setLabel(m);
	}
	changeColor(m) {
		m && (this.set("fill", m), this.label.setColor(m));
	}
}, import_fabric$4 = require_fabric(), PlanRectangleObject = class m extends import_fabric$4.fabric.Rect {
	get objectId() {
		return this._objectId;
	}
	get objectType() {
		return PlanObjectTypeEnumNames[PlanObjectTypeEnum.Rectangle];
	}
	get objectName() {
		return this.itemName ? this.itemName : "New Shape";
	}
	get icon() {
		return this.itemId ? "assets/icons/link.svg" : "assets/icons/link-broken.svg";
	}
	constructor(m) {
		super({
			objectCaching: !1,
			left: m.left,
			top: m.top,
			width: m.width ?? 1,
			height: m.height ?? 1,
			originX: "center",
			originY: "center",
			selectable: !1,
			hasControls: !1,
			evented: !1,
			hasBorders: !0,
			strokeWidth: .2,
			stroke: "#000000",
			fill: m.fill,
			opacity: m.opacity ?? .6
		}), this._objectId = v4_default(), this.containerId = 0, this.itemId = "", this.itemType = PlanItemTypeEnumNames[PlanItemTypeEnum.None], this.itemName = "", m.objectId && (this._objectId = m.objectId), this.containerType = m.containerType, this.containerId = m.containerId, this.itemType = m.itemType, this.itemId = m.itemId, this.label = new PlanLabelObject(this.objectType, m.fill ?? "0x000000", m.left ?? 0, m.top ?? 0, 0, 0), this.text = new import_fabric$4.fabric.Text(this.objectType, {
			fontSize: 15,
			fontFamily: "Arial",
			originX: "center",
			originY: "center",
			textAlign: "center",
			hasControls: !1,
			selectable: !1,
			evented: !1,
			left: this.left,
			top: this.top,
			width: this.width * .75,
			height: this.height / 2,
			visible: !1
		}), this._pointer = new import_fabric$4.fabric.Point(m.left, m.top);
	}
	finishDrawing() {
		this.selectable = !1, this.evented = !0, this.hasControls = !0, this.lockRotation = !0, this.hoverCursor = "pointer", this.text.visible = !0;
	}
	redraw(m) {
		let x = Math.abs(m.x - this._pointer.x), S = Math.abs(m.y - this._pointer.y);
		if (!x || !S) return !1;
		let C = (m.x + this._pointer.x) / 2, T = (m.y + this._pointer.y) / 2;
		this.set("left", C).set("top", T).set("width", x).set("height", S), this.text.set("width", x).set("left", C).set("top", T);
	}
	duplicate() {
		let x = new m({
			objectId: "",
			objectType: PlanObjectTypeEnumNames[PlanObjectTypeEnum.Rectangle],
			containerType: this.containerType,
			containerId: this.containerId,
			itemType: PlanItemTypeEnumNames[PlanItemTypeEnum.None],
			itemId: "",
			left: this.left + this.width,
			top: this.top,
			width: this.width,
			height: this.height,
			fill: this.fill,
			label: this.label
		});
		return x.finishDrawing(), x;
	}
	assign(m) {
		m ? (this.itemType = m.type, this.itemId = m.id, this.itemName = m.number ?? "", this.text.visible = !0, this.itemInformation = m.informations?.join("\r\n"), this.setControlVisible("assignControl", !1), this.setControlVisible("unassignControl", !0), this.changeColor(m.color)) : (this.itemType = PlanItemTypeEnumNames[PlanItemTypeEnum.None], this.itemId = "", this.itemName = "", this.setControlVisible("unassignControl", !1), this.setControlVisible("assignControl", !0)), this.setText(this.itemId ? this.itemName : this.objectType);
	}
	move() {
		this.setCoords(), this.text.set("left", this.left).set("top", this.top).setCoords();
	}
	resize() {
		let m = this.getScaledWidth();
		this.text.set("left", this.left).set("top", this.top).set("width", m * .75).setCoords();
	}
	modify() {
		this.set("width", this.getScaledWidth()).set("height", this.getScaledHeight()).set("scaleX", 1).set("scaleY", 1).setCoords();
	}
	setText(m) {
		this.label.setLabel(m);
	}
	changeColor(m) {
		m && this.set("fill", m);
	}
}, import_fabric$3 = require_fabric(), PlanPolygonObject = class m extends import_fabric$3.fabric.Polygon {
	get objectId() {
		return this._objectId;
	}
	get objectType() {
		return PlanObjectTypeEnumNames[PlanObjectTypeEnum.Polygon];
	}
	get objectName() {
		return this.itemName ? this.itemName : "New Shape";
	}
	get icon() {
		return this.itemId ? "assets/icons/link.svg" : "assets/icons/link-broken.svg";
	}
	constructor(m) {
		let x = m.points || [], S = m.left ?? 0, C = m.top ?? 0, T = m.width ?? 0, D = m.height ?? 0;
		if (x.length > 0) {
			let m = x.map((m) => m.x), O = x.map((m) => m.y), k = Math.min(...m), A = Math.max(...m), j = Math.min(...O), M = Math.max(...O);
			T = A - k, D = M - j, S = k, C = j;
			let N = (k + A) / 2, P = (j + M) / 2;
			x = x.map((m) => new import_fabric$3.fabric.Point(m.x - N, m.y - P)), S = N, C = P;
		}
		super(x, {
			left: S,
			top: C,
			width: T,
			height: D,
			opacity: m.opacity ?? .6,
			fill: m.fill,
			hoverCursor: "pointer",
			selectable: !1,
			hasControls: !1,
			evented: !1,
			originX: "center",
			originY: "center"
		}), this._objectId = v4_default(), this.containerId = 0, this.itemId = "", this.itemType = PlanItemTypeEnumNames[PlanItemTypeEnum.None], this.itemName = "", m.objectId && (this._objectId = m.objectId), this.containerType = m.containerType, this.containerId = m.containerId, this.itemType = m.itemType, this.itemId = m.itemId;
		let O = S - T / 2, k = C - D / 2;
		this.label = new PlanLabelObject(this.objectType, m.fill ?? "0x000000", O, k, T, D), this.text = new import_fabric$3.fabric.Text(this.objectType, {
			fontSize: 15,
			fontFamily: "Arial",
			originX: "center",
			originY: "center",
			textAlign: "center",
			hasControls: !1,
			selectable: !1,
			evented: !1,
			left: S,
			top: C,
			width: T,
			height: D / 2,
			visible: !1
		});
	}
	finishDrawing() {
		this.selectable = !1, this.evented = !0, this.hasControls = !1, this.text.visible = !0;
	}
	duplicate() {
		let x = this.points.map((m) => new import_fabric$3.fabric.Point(m.x + (this.left ?? 0), m.y + (this.top ?? 0))), S = x.map((m) => m.x), C = Math.min(...S), T = Math.max(...S) - C, D = x.map((m) => new import_fabric$3.fabric.Point(m.x + T, m.y)), O = new m({
			objectId: "",
			objectType: PlanObjectTypeEnumNames[PlanObjectTypeEnum.Polygon],
			containerType: this.containerType,
			containerId: this.containerId,
			itemType: PlanItemTypeEnumNames[PlanItemTypeEnum.None],
			itemId: "",
			points: D,
			fill: this.fill,
			opacity: this.opacity,
			label: null
		});
		return O.finishDrawing(), O;
	}
	assign(m) {
		m ? (this.itemType = m.type, this.itemId = m.id, this.itemName = m.number ? `${m.number}` : m.name, this.text.visible = !0, this.itemInformation = m.informations?.join("\r\n"), this.setControlVisible("assignControl", !1), this.setControlVisible("unassignControl", !0), this.changeColor(m.color)) : (this.itemType = PlanItemTypeEnumNames[PlanItemTypeEnum.None], this.itemId = "", this.itemName = "", this.setControlVisible("unassignControl", !1), this.setControlVisible("assignControl", !0)), this.setText(this.itemId ? this.itemName : this.objectType);
	}
	move() {
		this.setCoords(), this.text.set("left", this.left).set("top", this.top).setCoords();
		let m = this.left - this.width / 2, x = this.top - this.height / 2;
		this.label.set("left", m), this.label.set("top", x), this.label.setCoords();
	}
	setText(m) {
		this.label.setLabel(m);
	}
	changeColor(m) {
		m && this.set("fill", m);
	}
	resize() {
		let m = this.getScaledWidth(), x = this.getScaledHeight();
		this.text.set("left", this.left).set("top", this.top).set("width", m).setCoords();
		let S = this.left - m / 2, C = this.top - x / 2;
		this.label.set("left", S), this.label.set("top", C), this.label.setCoords();
	}
	modify() {
		let m = this.getScaledWidth(), x = this.getScaledHeight(), S = m - this.width, C = x - this.height;
		this.calcPoints(this.points, S, C, m / this.width, x / this.height), this.setCoords().set("width", m).set("height", x).set("scaleX", 1).set("scaleY", 1);
		let T = this.left - m / 2, D = this.top - x / 2;
		this.label.set("left", T), this.label.set("top", D), this.label.setCoords();
	}
	toPlanObject(m) {
		let x = this.points.map((m) => new import_fabric$3.fabric.Point(m.x + (this.left ?? 0), m.y + (this.top ?? 0))), S = x.map((m) => m.x), C = x.map((m) => m.y), T = Math.min(...S), D = Math.max(...S), O = Math.min(...C), k = Math.max(...C), A = D - T, j = k - O, M = T, N = O;
		return {
			objectId: this.objectId,
			objectType: this.objectType,
			containerId: this.containerId,
			containerType: this.containerType,
			itemId: this.itemId,
			itemType: this.itemType,
			left: M / m.x,
			top: N / m.y,
			width: A / m.x,
			height: j / m.y,
			radius: 0,
			points: x.map((x, S) => ({
				id: v4_default(),
				order: S,
				x: x.x / m.x,
				y: x.y / m.y
			})),
			fill: this.fill,
			opacity: this.opacity,
			svg: this.toSVG()
		};
	}
	calcPoints(m, x, S, C, T) {
		let D = Math.min(...m.map((m) => m.x)), O = m.map((m, x) => m.x == D ? x : -1).filter((m) => m != -1), k = Math.max(...O), A = [];
		for (let x = k; x < k + m.length; x++) {
			let S = x % m.length, C = m[S], T = m[(S + 1) % m.length];
			A.push(T.x - C.x);
		}
		for (let S = k; S < k + m.length; S++) {
			let T = S % m.length, D = m[T], O = m[(T + m.length - 1) % m.length];
			T == k ? D.x -= x / 2 : D.x = O.x + A[S - k - 1] * C;
		}
		let j = Math.min(...m.map((m) => m.y)), M = m.map((m, x) => m.y == j ? x : -1).filter((m) => m != -1), N = Math.min(...M), P = [];
		for (let x = N; x < N + m.length; x++) {
			let S = x % m.length, C = m[S], T = m[(S + 1) % m.length];
			P.push(T.y - C.y);
		}
		for (let x = N; x < N + m.length; x++) {
			let C = x % m.length, D = m[C], O = m[(C + m.length - 1) % m.length];
			C == N ? D.y -= S / 2 : D.y = O.y + P[x - N - 1] * T;
		}
	}
}, import_fabric$2 = require_fabric(), PlanLineObject = class extends import_fabric$2.fabric.Line {
	get id() {
		return this._id;
	}
	constructor(m, x, S) {
		super([
			x.x,
			x.y,
			S.x,
			S.y
		], {
			strokeWidth: .2,
			stroke: "#000000",
			selectable: !1,
			hasControls: !1,
			evented: !1,
			hasBorders: !1
		}), this._id = v4_default(), this.canvas = m, this.selectable = !1, this.canvas.add(this);
	}
	redraw(m) {
		this.set("x2", m.x), this.set("y2", m.y);
	}
}, import_fabric$1 = require_fabric(), PlanObjectController = class {
	get planObjects() {
		return this._planObjects;
	}
	get containerObjects() {
		return this._containerObjects;
	}
	get selectedObject() {
		return this._selectedObjects.length == 1 ? this._selectedObjects[0] : null;
	}
	get isRectangle() {
		return this.selectedObject ? this.selectedObject instanceof PlanRectangleObject : !1;
	}
	get isCircle() {
		return this.selectedObject ? this.selectedObject instanceof PlanCircleObject : !1;
	}
	get isPolygon() {
		return this.selectedObject ? this.selectedObject instanceof PlanPolygonObject : !1;
	}
	get isLine() {
		return this.selectedObject ? this.selectedObject instanceof PlanLineObject : !1;
	}
	get selectedItemType() {
		return this.isRectangle ? "Rectangle" : this.isCircle ? "Circle" : this.isPolygon ? "Polygon" : this.isLine ? "Vector" : "";
	}
	constructor(m) {
		this._planObjects = [], this._containerObjects = [], this._selectedObjects = [], this._planObjects = m;
	}
	getPlanObjectByItemId(m) {
		return this.planObjects.find((x) => x.itemId == m);
	}
	isObjectSelected(m) {
		return this.selectedObject ? this.selectedObject.objectId === m : !1;
	}
	onKeydownDelete() {
		this.deleteObjects();
	}
	deleteObjects() {
		!this._selectedObjects || !this._selectedObjects.length || this._selectedObjects.forEach((m) => {
			let x = this.containerObjects.findIndex((x) => x.objectId === m.objectId);
			this.containerObjects.splice(x, 1);
		});
	}
	initObject(m, x) {
		let S = Math.min(m.width ?? 0, m.height ?? 0) / 2, C = {
			objectId: m.objectId,
			objectType: m.objectType,
			containerId: m.containerId,
			containerType: m.containerType,
			itemId: m.itemId,
			itemType: m.itemType,
			left: x.x * m.left,
			top: x.y * m.top,
			width: m.width * x.x,
			height: m.height * x.y,
			radius: (m.radius ?? S) * x.x,
			points: m.points ? m.points.map((m) => new import_fabric$1.fabric.Point(x.x * m.x, x.y * m.y)) : [],
			fill: m.fill,
			opacity: m.opacity,
			label: null
		};
		if (m.objectType === PlanObjectTypeEnumNames[PlanObjectTypeEnum.Rectangle]) {
			let m = new PlanRectangleObject(C);
			return m.finishDrawing(), this.containerObjects.push(m), m;
		} else if (m.objectType === PlanObjectTypeEnumNames[PlanObjectTypeEnum.Polygon]) {
			let m = new PlanPolygonObject(C);
			return m.finishDrawing(), this.containerObjects.push(m), m;
		} else {
			let m = new PlanCircleObject(C);
			return m.finishDrawing(), this.containerObjects.push(m), m;
		}
	}
	initContainerObjects(m) {
		this._containerObjects = this.planObjects.map((x) => this.initObject(x, m)).filter((m) => m != null);
	}
	startDrawingRectangle(m) {
		return new PlanRectangleObject(m);
	}
	startDrawingCircle(m) {
		return new PlanCircleObject(m);
	}
	finishDrawing(m) {
		this.containerObjects.push(m);
	}
}, PlanItemController = class {
	get items() {
		return this._items;
	}
	constructor(m) {
		this._items = [], this._items = m;
	}
	getItem(m) {
		return this.items.find((x) => x.id == m);
	}
};
function clamp(m, x, S) {
	return Math.max(x, Math.min(m, S));
}
var V = {
	toVector(m, x) {
		return m === void 0 && (m = x), Array.isArray(m) ? m : [m, m];
	},
	add(m, x) {
		return [m[0] + x[0], m[1] + x[1]];
	},
	sub(m, x) {
		return [m[0] - x[0], m[1] - x[1]];
	},
	addTo(m, x) {
		m[0] += x[0], m[1] += x[1];
	},
	subTo(m, x) {
		m[0] -= x[0], m[1] -= x[1];
	}
};
function rubberband(m, x, S) {
	return x === 0 || Math.abs(x) === Infinity ? m ** (S * 5) : m * x * S / (x + S * m);
}
function rubberbandIfOutOfBounds(m, x, S, C = .15) {
	return C === 0 ? clamp(m, x, S) : m < x ? -rubberband(x - m, S - x, C) + x : m > S ? +rubberband(m - S, S - x, C) + S : m;
}
function computeRubberband(m, [x, S], [C, T]) {
	let [[D, O], [k, A]] = m;
	return [rubberbandIfOutOfBounds(x, D, O, C), rubberbandIfOutOfBounds(S, k, A, T)];
}
function _toPrimitive(m, x) {
	if (typeof m != "object" || !m) return m;
	var S = m[Symbol.toPrimitive];
	if (S !== void 0) {
		var C = S.call(m, x || "default");
		if (typeof C != "object") return C;
		throw TypeError("@@toPrimitive must return a primitive value.");
	}
	return (x === "string" ? String : Number)(m);
}
function _toPropertyKey(m) {
	var x = _toPrimitive(m, "string");
	return typeof x == "symbol" ? x : String(x);
}
function _defineProperty(m, x, S) {
	return x = _toPropertyKey(x), x in m ? Object.defineProperty(m, x, {
		value: S,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : m[x] = S, m;
}
function ownKeys(m, x) {
	var S = Object.keys(m);
	if (Object.getOwnPropertySymbols) {
		var C = Object.getOwnPropertySymbols(m);
		x && (C = C.filter(function(x) {
			return Object.getOwnPropertyDescriptor(m, x).enumerable;
		})), S.push.apply(S, C);
	}
	return S;
}
function _objectSpread2(m) {
	for (var x = 1; x < arguments.length; x++) {
		var S = arguments[x] == null ? {} : arguments[x];
		x % 2 ? ownKeys(Object(S), !0).forEach(function(x) {
			_defineProperty(m, x, S[x]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(S)) : ownKeys(Object(S)).forEach(function(x) {
			Object.defineProperty(m, x, Object.getOwnPropertyDescriptor(S, x));
		});
	}
	return m;
}
var EVENT_TYPE_MAP = {
	pointer: {
		start: "down",
		change: "move",
		end: "up"
	},
	mouse: {
		start: "down",
		change: "move",
		end: "up"
	},
	touch: {
		start: "start",
		change: "move",
		end: "end"
	},
	gesture: {
		start: "start",
		change: "change",
		end: "end"
	}
};
function capitalize(m) {
	return m ? m[0].toUpperCase() + m.slice(1) : "";
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(m = !1, x) {
	return m && !actionsWithoutCaptureSupported.includes(x);
}
function toHandlerProp(m, x = "", S = !1) {
	let C = EVENT_TYPE_MAP[m], T = C && C[x] || x;
	return "on" + capitalize(m) + capitalize(T) + (hasCapture(S, T) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(m) {
	let x = m.substring(2).toLowerCase(), S = !!~x.indexOf("passive");
	S && (x = x.replace("passive", ""));
	let C = pointerCaptureEvents.includes(x) ? "capturecapture" : "capture", T = !!~x.indexOf(C);
	return T && (x = x.replace("capture", "")), {
		device: x,
		capture: T,
		passive: S
	};
}
function toDomEventType(m, x = "") {
	let S = EVENT_TYPE_MAP[m];
	return m + (S && S[x] || x);
}
function isTouch(m) {
	return "touches" in m;
}
function getCurrentTargetTouchList(m) {
	return Array.from(m.touches).filter((x) => {
		var S, C;
		return x.target === m.currentTarget || ((S = m.currentTarget) == null || (C = S.contains) == null ? void 0 : C.call(S, x.target));
	});
}
function distanceAngle(m, x) {
	try {
		let S = x.clientX - m.clientX, C = x.clientY - m.clientY, T = (x.clientX + m.clientX) / 2, D = (x.clientY + m.clientY) / 2, O = Math.hypot(S, C);
		return {
			angle: -(Math.atan2(S, C) * 180) / Math.PI,
			distance: O,
			origin: [T, D]
		};
	} catch {}
	return null;
}
function touchIds(m) {
	return getCurrentTargetTouchList(m).map((m) => m.identifier);
}
function touchDistanceAngle(m, x) {
	let [S, C] = Array.from(m.touches).filter((m) => x.includes(m.identifier));
	return distanceAngle(S, C);
}
var LINE_HEIGHT = 40, PAGE_HEIGHT = 800;
function wheelValues(m) {
	let { deltaX: x, deltaY: S, deltaMode: C } = m;
	return C === 1 ? (x *= LINE_HEIGHT, S *= LINE_HEIGHT) : C === 2 && (x *= PAGE_HEIGHT, S *= PAGE_HEIGHT), [x, S];
}
function getEventDetails(m) {
	let x = {};
	if ("buttons" in m && (x.buttons = m.buttons), "shiftKey" in m) {
		let { shiftKey: S, altKey: C, metaKey: T, ctrlKey: D } = m;
		Object.assign(x, {
			shiftKey: S,
			altKey: C,
			metaKey: T,
			ctrlKey: D
		});
	}
	return x;
}
function call(m, ...x) {
	return typeof m == "function" ? m(...x) : m;
}
function noop() {}
function chain(...m) {
	return m.length === 0 ? noop : m.length === 1 ? m[0] : function() {
		let x;
		for (let S of m) x = S.apply(this, arguments) || x;
		return x;
	};
}
function assignDefault(m, x) {
	return Object.assign({}, x, m || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32, Engine = class {
	constructor(m, x, S) {
		this.ctrl = m, this.args = x, this.key = S, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
	}
	get state() {
		return this.ctrl.state[this.key];
	}
	set state(m) {
		this.ctrl.state[this.key] = m;
	}
	get shared() {
		return this.ctrl.state.shared;
	}
	get eventStore() {
		return this.ctrl.gestureEventStores[this.key];
	}
	get timeoutStore() {
		return this.ctrl.gestureTimeoutStores[this.key];
	}
	get config() {
		return this.ctrl.config[this.key];
	}
	get sharedConfig() {
		return this.ctrl.config.shared;
	}
	get handler() {
		return this.ctrl.handlers[this.key];
	}
	reset() {
		let { state: m, shared: x, ingKey: S, args: C } = this;
		x[S] = m._active = m.active = m._blocked = m._force = !1, m._step = [!1, !1], m.intentional = !1, m._movement = [0, 0], m._distance = [0, 0], m._direction = [0, 0], m._delta = [0, 0], m._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]], m.args = C, m.axis = void 0, m.memo = void 0, m.elapsedTime = m.timeDelta = 0, m.direction = [0, 0], m.distance = [0, 0], m.overflow = [0, 0], m._movementBound = [!1, !1], m.velocity = [0, 0], m.movement = [0, 0], m.delta = [0, 0], m.timeStamp = 0;
	}
	start(m) {
		let x = this.state, S = this.config;
		x._active || (this.reset(), this.computeInitial(), x._active = !0, x.target = m.target, x.currentTarget = m.currentTarget, x.lastOffset = S.from ? call(S.from, x) : x.offset, x.offset = x.lastOffset, x.startTime = x.timeStamp = m.timeStamp);
	}
	computeValues(m) {
		let x = this.state;
		x._values = m, x.values = this.config.transform(m);
	}
	computeInitial() {
		let m = this.state;
		m._initial = m._values, m.initial = m.values;
	}
	compute(m) {
		let { state: x, config: S, shared: C } = this;
		x.args = this.args;
		let T = 0;
		if (m && (x.event = m, S.preventDefault && m.cancelable && x.event.preventDefault(), x.type = m.type, C.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, C.locked = !!document.pointerLockElement, Object.assign(C, getEventDetails(m)), C.down = C.pressed = C.buttons % 2 == 1 || C.touches > 0, T = m.timeStamp - x.timeStamp, x.timeStamp = m.timeStamp, x.elapsedTime = x.timeStamp - x.startTime), x._active) {
			let m = x._delta.map(Math.abs);
			V.addTo(x._distance, m);
		}
		this.axisIntent && this.axisIntent(m);
		let [D, O] = x._movement, [k, A] = S.threshold, { _step: j, values: M } = x;
		if (S.hasCustomTransform ? (j[0] === !1 && (j[0] = Math.abs(D) >= k && M[0]), j[1] === !1 && (j[1] = Math.abs(O) >= A && M[1])) : (j[0] === !1 && (j[0] = Math.abs(D) >= k && Math.sign(D) * k), j[1] === !1 && (j[1] = Math.abs(O) >= A && Math.sign(O) * A)), x.intentional = j[0] !== !1 || j[1] !== !1, !x.intentional) return;
		let N = [0, 0];
		if (S.hasCustomTransform) {
			let [m, x] = M;
			N[0] = j[0] === !1 ? 0 : m - j[0], N[1] = j[1] === !1 ? 0 : x - j[1];
		} else N[0] = j[0] === !1 ? 0 : D - j[0], N[1] = j[1] === !1 ? 0 : O - j[1];
		this.restrictToAxis && !x._blocked && this.restrictToAxis(N);
		let P = x.offset, F = x._active && !x._blocked || x.active;
		F && (x.first = x._active && !x.active, x.last = !x._active && x.active, x.active = C[this.ingKey] = x._active, m && (x.first && ("bounds" in S && (x._bounds = call(S.bounds, x)), this.setup && this.setup()), x.movement = N, this.computeOffset()));
		let [I, L] = x.offset, [[R, z], [B, H]] = x._bounds;
		x.overflow = [I < R ? -1 : I > z ? 1 : 0, L < B ? -1 : L > H ? 1 : 0], x._movementBound[0] = x.overflow[0] ? x._movementBound[0] === !1 ? x._movement[0] : x._movementBound[0] : !1, x._movementBound[1] = x.overflow[1] ? x._movementBound[1] === !1 ? x._movement[1] : x._movementBound[1] : !1;
		let U = x._active && S.rubberband || [0, 0];
		if (x.offset = computeRubberband(x._bounds, x.offset, U), x.delta = V.sub(x.offset, P), this.computeMovement(), F && (!x.last || T > BEFORE_LAST_KINEMATICS_DELAY)) {
			x.delta = V.sub(x.offset, P);
			let m = x.delta.map(Math.abs);
			V.addTo(x.distance, m), x.direction = x.delta.map(Math.sign), x._direction = x._delta.map(Math.sign), !x.first && T > 0 && (x.velocity = [m[0] / T, m[1] / T], x.timeDelta = T);
		}
	}
	emit() {
		let m = this.state, x = this.shared, S = this.config;
		if (m._active || this.clean(), (m._blocked || !m.intentional) && !m._force && !S.triggerAllEvents) return;
		let C = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, x), m), {}, { [this.aliasKey]: m.values }));
		C !== void 0 && (m.memo = C);
	}
	clean() {
		this.eventStore.clean(), this.timeoutStore.clean();
	}
}, identity = (m) => m, DEFAULT_RUBBERBAND = .15, commonConfigResolver = {
	enabled(m = !0) {
		return m;
	},
	eventOptions(m, x, S) {
		return _objectSpread2(_objectSpread2({}, S.shared.eventOptions), m);
	},
	preventDefault(m = !1) {
		return m;
	},
	triggerAllEvents(m = !1) {
		return m;
	},
	rubberband(m = 0) {
		switch (m) {
			case !0: return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
			case !1: return [0, 0];
			default: return V.toVector(m);
		}
	},
	from(m) {
		if (typeof m == "function") return m;
		if (m != null) return V.toVector(m);
	},
	transform(m, x, S) {
		let C = m || S.shared.transform;
		if (this.hasCustomTransform = !!C, process.env.NODE_ENV === "development") {
			let m = C || identity;
			return (x) => {
				let S = m(x);
				return (!isFinite(S[0]) || !isFinite(S[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${S[0]},1]`), S;
			};
		}
		return C || identity;
	},
	threshold(m) {
		return V.toVector(m, 0);
	}
};
process.env.NODE_ENV === "development" && Object.assign(commonConfigResolver, {
	domTarget(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
		return NaN;
	},
	lockDirection(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
		return NaN;
	},
	initial(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
		return NaN;
	}
});
var DEFAULT_AXIS_THRESHOLD = 0, coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
	axis(m, x, { axis: S }) {
		if (this.lockDirection = S === "lock", !this.lockDirection) return S;
	},
	axisThreshold(m = DEFAULT_AXIS_THRESHOLD) {
		return m;
	},
	bounds(m = {}) {
		if (typeof m == "function") return (x) => coordinatesConfigResolver.bounds(m(x));
		if ("current" in m) return () => m.current;
		if (typeof HTMLElement == "function" && m instanceof HTMLElement) return m;
		let { left: x = -Infinity, right: S = Infinity, top: C = -Infinity, bottom: T = Infinity } = m;
		return [[x, S], [C, T]];
	}
}), isBrowser = typeof window < "u" && window.document && window.document.createElement;
function supportsTouchEvents() {
	return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
	return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
	return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
	return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
	try {
		return "constructor" in GestureEvent;
	} catch {
		return !1;
	}
}
var SUPPORT = {
	isBrowser,
	gesture: supportsGestureEvents(),
	touch: supportsTouchEvents(),
	touchscreen: isTouchScreen(),
	pointer: supportsPointerEvents(),
	pointerLock: supportsPointerLock()
}, DEFAULT_PREVENT_SCROLL_DELAY = 250, DEFAULT_DRAG_DELAY = 180, DEFAULT_SWIPE_VELOCITY = .5, DEFAULT_SWIPE_DISTANCE = 50, DEFAULT_SWIPE_DURATION = 250, DEFAULT_KEYBOARD_DISPLACEMENT = 10, DEFAULT_DRAG_AXIS_THRESHOLD = {
	mouse: 0,
	touch: 0,
	pen: 8
}, dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
	device(m, x, { pointer: { touch: S = !1, lock: C = !1, mouse: T = !1 } = {} }) {
		return this.pointerLock = C && SUPPORT.pointerLock, SUPPORT.touch && S ? "touch" : this.pointerLock ? "mouse" : SUPPORT.pointer && !T ? "pointer" : SUPPORT.touch ? "touch" : "mouse";
	},
	preventScrollAxis(m, x, { preventScroll: S }) {
		if (this.preventScrollDelay = typeof S == "number" ? S : S || S === void 0 && m ? DEFAULT_PREVENT_SCROLL_DELAY : void 0, !(!SUPPORT.touchscreen || S === !1)) return m || (S === void 0 ? void 0 : "y");
	},
	pointerCapture(m, x, { pointer: { capture: S = !0, buttons: C = 1, keys: T = !0 } = {} }) {
		return this.pointerButtons = C, this.keys = T, !this.pointerLock && this.device === "pointer" && S;
	},
	threshold(m, x, { filterTaps: S = !1, tapsThreshold: C = 3, axis: T = void 0 }) {
		let D = V.toVector(m, S ? C : T ? 1 : 0);
		return this.filterTaps = S, this.tapsThreshold = C, D;
	},
	swipe({ velocity: m = DEFAULT_SWIPE_VELOCITY, distance: x = DEFAULT_SWIPE_DISTANCE, duration: S = DEFAULT_SWIPE_DURATION } = {}) {
		return {
			velocity: this.transform(V.toVector(m)),
			distance: this.transform(V.toVector(x)),
			duration: S
		};
	},
	delay(m = 0) {
		switch (m) {
			case !0: return DEFAULT_DRAG_DELAY;
			case !1: return 0;
			default: return m;
		}
	},
	axisThreshold(m) {
		return m ? _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), m) : DEFAULT_DRAG_AXIS_THRESHOLD;
	},
	keyboardDisplacement(m = DEFAULT_KEYBOARD_DISPLACEMENT) {
		return m;
	}
});
process.env.NODE_ENV === "development" && Object.assign(dragConfigResolver, {
	useTouch(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
		return NaN;
	},
	experimental_preventWindowScrollY(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
		return NaN;
	},
	swipeVelocity(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
		return NaN;
	},
	swipeDistance(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
		return NaN;
	},
	swipeDuration(m) {
		if (m !== void 0) throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
		return NaN;
	}
});
function clampStateInternalMovementToBounds(m) {
	let [x, S] = m.overflow, [C, T] = m._delta, [D, O] = m._direction;
	(x < 0 && C > 0 && D < 0 || x > 0 && C < 0 && D > 0) && (m._movement[0] = m._movementBound[0]), (S < 0 && T > 0 && O < 0 || S > 0 && T < 0 && O > 0) && (m._movement[1] = m._movementBound[1]);
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30, PINCH_WHEEL_RATIO = 100, PinchEngine = class extends Engine {
	constructor(...m) {
		super(...m), _defineProperty(this, "ingKey", "pinching"), _defineProperty(this, "aliasKey", "da");
	}
	init() {
		this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = /* @__PURE__ */ new Map();
	}
	reset() {
		super.reset();
		let m = this.state;
		m._touchIds = [], m.canceled = !1, m.cancel = this.cancel.bind(this), m.turns = 0;
	}
	computeOffset() {
		let { type: m, movement: x, lastOffset: S } = this.state;
		m === "wheel" ? this.state.offset = V.add(x, S) : this.state.offset = [(1 + x[0]) * S[0], x[1] + S[1]];
	}
	computeMovement() {
		let { offset: m, lastOffset: x } = this.state;
		this.state.movement = [m[0] / x[0], m[1] - x[1]];
	}
	axisIntent() {
		let m = this.state, [x, S] = m._movement;
		if (!m.axis) {
			let C = Math.abs(x) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(S);
			C < 0 ? m.axis = "angle" : C > 0 && (m.axis = "scale");
		}
	}
	restrictToAxis(m) {
		this.config.lockDirection && (this.state.axis === "scale" ? m[1] = 0 : this.state.axis === "angle" && (m[0] = 0));
	}
	cancel() {
		let m = this.state;
		m.canceled || setTimeout(() => {
			m.canceled = !0, m._active = !1, this.compute(), this.emit();
		}, 0);
	}
	touchStart(m) {
		this.ctrl.setEventIds(m);
		let x = this.state, S = this.ctrl.touchIds;
		if (x._active && x._touchIds.every((m) => S.has(m)) || S.size < 2) return;
		this.start(m), x._touchIds = Array.from(S).slice(0, 2);
		let C = touchDistanceAngle(m, x._touchIds);
		C && this.pinchStart(m, C);
	}
	pointerStart(m) {
		if (m.buttons != null && m.buttons % 2 != 1) return;
		this.ctrl.setEventIds(m), m.target.setPointerCapture(m.pointerId);
		let x = this.state, S = x._pointerEvents, C = this.ctrl.pointerIds;
		if (x._active && Array.from(S.keys()).every((m) => C.has(m)) || (S.size < 2 && S.set(m.pointerId, m), x._pointerEvents.size < 2)) return;
		this.start(m);
		let T = distanceAngle(...Array.from(S.values()));
		T && this.pinchStart(m, T);
	}
	pinchStart(m, x) {
		let S = this.state;
		S.origin = x.origin, this.computeValues([x.distance, x.angle]), this.computeInitial(), this.compute(m), this.emit();
	}
	touchMove(m) {
		if (!this.state._active) return;
		let x = touchDistanceAngle(m, this.state._touchIds);
		x && this.pinchMove(m, x);
	}
	pointerMove(m) {
		let x = this.state._pointerEvents;
		if (x.has(m.pointerId) && x.set(m.pointerId, m), !this.state._active) return;
		let S = distanceAngle(...Array.from(x.values()));
		S && this.pinchMove(m, S);
	}
	pinchMove(m, x) {
		let S = this.state, C = S._values[1], T = x.angle - C, D = 0;
		Math.abs(T) > 270 && (D += Math.sign(T)), this.computeValues([x.distance, x.angle - 360 * D]), S.origin = x.origin, S.turns = D, S._movement = [S._values[0] / S._initial[0] - 1, S._values[1] - S._initial[1]], this.compute(m), this.emit();
	}
	touchEnd(m) {
		this.ctrl.setEventIds(m), this.state._active && this.state._touchIds.some((m) => !this.ctrl.touchIds.has(m)) && (this.state._active = !1, this.compute(m), this.emit());
	}
	pointerEnd(m) {
		let x = this.state;
		this.ctrl.setEventIds(m);
		try {
			m.target.releasePointerCapture(m.pointerId);
		} catch {}
		x._pointerEvents.has(m.pointerId) && x._pointerEvents.delete(m.pointerId), x._active && x._pointerEvents.size < 2 && (x._active = !1, this.compute(m), this.emit());
	}
	gestureStart(m) {
		m.cancelable && m.preventDefault();
		let x = this.state;
		x._active || (this.start(m), this.computeValues([m.scale, m.rotation]), x.origin = [m.clientX, m.clientY], this.compute(m), this.emit());
	}
	gestureMove(m) {
		if (m.cancelable && m.preventDefault(), !this.state._active) return;
		let x = this.state;
		this.computeValues([m.scale, m.rotation]), x.origin = [m.clientX, m.clientY];
		let S = x._movement;
		x._movement = [m.scale - 1, m.rotation], x._delta = V.sub(x._movement, S), this.compute(m), this.emit();
	}
	gestureEnd(m) {
		this.state._active && (this.state._active = !1, this.compute(m), this.emit());
	}
	wheel(m) {
		let x = this.config.modifierKey;
		x && (Array.isArray(x) ? !x.find((x) => m[x]) : !m[x]) || (this.state._active ? this.wheelChange(m) : this.wheelStart(m), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)));
	}
	wheelStart(m) {
		this.start(m), this.wheelChange(m);
	}
	wheelChange(m) {
		"uv" in m || (m.cancelable && m.preventDefault(), process.env.NODE_ENV === "development" && !m.defaultPrevented && console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
		let x = this.state;
		x._delta = [-wheelValues(m)[1] / PINCH_WHEEL_RATIO * x.offset[0], 0], V.addTo(x._movement, x._delta), clampStateInternalMovementToBounds(x), this.state.origin = [m.clientX, m.clientY], this.compute(m), this.emit();
	}
	wheelEnd() {
		this.state._active && (this.state._active = !1, this.compute(), this.emit());
	}
	bind(m) {
		let x = this.config.device;
		x && (m(x, "start", this[x + "Start"].bind(this)), m(x, "change", this[x + "Move"].bind(this)), m(x, "end", this[x + "End"].bind(this)), m(x, "cancel", this[x + "End"].bind(this)), m("lostPointerCapture", "", this[x + "End"].bind(this))), this.config.pinchOnWheel && m("wheel", "", this.wheel.bind(this), { passive: !1 });
	}
}, pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
	device(m, x, { shared: S, pointer: { touch: C = !1 } = {} }) {
		if (S.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
		if (SUPPORT.touch && C) return "touch";
		if (SUPPORT.touchscreen) {
			if (SUPPORT.pointer) return "pointer";
			if (SUPPORT.touch) return "touch";
		}
	},
	bounds(m, x, { scaleBounds: S = {}, angleBounds: C = {} }) {
		let T = (m) => {
			let x = assignDefault(call(S, m), {
				min: -Infinity,
				max: Infinity
			});
			return [x.min, x.max];
		}, D = (m) => {
			let x = assignDefault(call(C, m), {
				min: -Infinity,
				max: Infinity
			});
			return [x.min, x.max];
		};
		return typeof S != "function" && typeof C != "function" ? [T(), D()] : (m) => [T(m), D(m)];
	},
	threshold(m, x, S) {
		return this.lockDirection = S.axis === "lock", V.toVector(m, this.lockDirection ? [.1, 3] : 0);
	},
	modifierKey(m) {
		return m === void 0 ? "ctrlKey" : m;
	},
	pinchOnWheel(m = !0) {
		return m;
	}
});
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, { mouseOnly: (m = !0) => m }), _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, { mouseOnly: (m = !0) => m });
var EngineMap = /* @__PURE__ */ new Map(), ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(m) {
	EngineMap.set(m.key, m.engine), ConfigResolverMap.set(m.key, m.resolver);
}
var pinchAction = {
	key: "pinch",
	engine: PinchEngine,
	resolver: pinchConfigResolver
};
function _objectWithoutPropertiesLoose(m, x) {
	if (m == null) return {};
	var S = {}, C = Object.keys(m), T, D;
	for (D = 0; D < C.length; D++) T = C[D], !(x.indexOf(T) >= 0) && (S[T] = m[T]);
	return S;
}
function _objectWithoutProperties(m, x) {
	if (m == null) return {};
	var S = _objectWithoutPropertiesLoose(m, x), C, T;
	if (Object.getOwnPropertySymbols) {
		var D = Object.getOwnPropertySymbols(m);
		for (T = 0; T < D.length; T++) C = D[T], !(x.indexOf(C) >= 0) && Object.prototype.propertyIsEnumerable.call(m, C) && (S[C] = m[C]);
	}
	return S;
}
var sharedConfigResolver = {
	target(m) {
		if (m) return () => "current" in m ? m.current : m;
	},
	enabled(m = !0) {
		return m;
	},
	window(m = SUPPORT.isBrowser ? window : void 0) {
		return m;
	},
	eventOptions({ passive: m = !0, capture: x = !1 } = {}) {
		return {
			passive: m,
			capture: x
		};
	},
	transform(m) {
		return m;
	}
}, _excluded = [
	"target",
	"eventOptions",
	"window",
	"enabled",
	"transform"
];
function resolveWith(m = {}, x) {
	let S = {};
	for (let [C, T] of Object.entries(x)) switch (typeof T) {
		case "function":
			if (process.env.NODE_ENV === "development") {
				let x = T.call(S, m[C], C, m);
				Number.isNaN(x) || (S[C] = x);
			} else S[C] = T.call(S, m[C], C, m);
			break;
		case "object":
			S[C] = resolveWith(m[C], T);
			break;
		case "boolean":
			T && (S[C] = m[C]);
			break;
	}
	return S;
}
function parse(m, x, S = {}) {
	let C = m, { target: T, eventOptions: D, window: O, enabled: k, transform: A } = C, j = _objectWithoutProperties(C, _excluded);
	if (S.shared = resolveWith({
		target: T,
		eventOptions: D,
		window: O,
		enabled: k,
		transform: A
	}, sharedConfigResolver), x) {
		let m = ConfigResolverMap.get(x);
		S[x] = resolveWith(_objectSpread2({ shared: S.shared }, j), m);
	} else for (let m in j) {
		let x = ConfigResolverMap.get(m);
		if (x) S[m] = resolveWith(_objectSpread2({ shared: S.shared }, j[m]), x);
		else if (process.env.NODE_ENV === "development" && ![
			"drag",
			"pinch",
			"scroll",
			"wheel",
			"move",
			"hover"
		].includes(m)) {
			if (m === "domTarget") throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
			console.warn(`[@use-gesture]: Unknown config key \`${m}\` was used. Please read the documentation for further information.`);
		}
	}
	return S;
}
var EventStore = class {
	constructor(m, x) {
		_defineProperty(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = m, this._gestureKey = x;
	}
	add(m, x, S, C, T) {
		let D = this._listeners, O = toDomEventType(x, S), k = _objectSpread2(_objectSpread2({}, this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}), T);
		m.addEventListener(O, C, k);
		let A = () => {
			m.removeEventListener(O, C, k), D.delete(A);
		};
		return D.add(A), A;
	}
	clean() {
		this._listeners.forEach((m) => m()), this._listeners.clear();
	}
}, TimeoutStore = class {
	constructor() {
		_defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
	}
	add(m, x, S = 140, ...C) {
		this.remove(m), this._timeouts.set(m, window.setTimeout(x, S, ...C));
	}
	remove(m) {
		let x = this._timeouts.get(m);
		x && window.clearTimeout(x);
	}
	clean() {
		this._timeouts.forEach((m) => void window.clearTimeout(m)), this._timeouts.clear();
	}
}, Controller = class {
	constructor(m) {
		_defineProperty(this, "gestures", /* @__PURE__ */ new Set()), _defineProperty(this, "_targetEventStore", new EventStore(this)), _defineProperty(this, "gestureEventStores", {}), _defineProperty(this, "gestureTimeoutStores", {}), _defineProperty(this, "handlers", {}), _defineProperty(this, "config", {}), _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set()), _defineProperty(this, "touchIds", /* @__PURE__ */ new Set()), _defineProperty(this, "state", { shared: {
			shiftKey: !1,
			metaKey: !1,
			ctrlKey: !1,
			altKey: !1
		} }), resolveGestures(this, m);
	}
	setEventIds(m) {
		if (isTouch(m)) return this.touchIds = new Set(touchIds(m)), this.touchIds;
		if ("pointerId" in m) return m.type === "pointerup" || m.type === "pointercancel" ? this.pointerIds.delete(m.pointerId) : m.type === "pointerdown" && this.pointerIds.add(m.pointerId), this.pointerIds;
	}
	applyHandlers(m, x) {
		this.handlers = m, this.nativeHandlers = x;
	}
	applyConfig(m, x) {
		this.config = parse(m, x, this.config);
	}
	clean() {
		this._targetEventStore.clean();
		for (let m of this.gestures) this.gestureEventStores[m].clean(), this.gestureTimeoutStores[m].clean();
	}
	effect() {
		return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
	}
	bind(...m) {
		let x = this.config.shared, S = {}, C;
		if (!(x.target && (C = x.target(), !C))) {
			if (x.enabled) {
				for (let x of this.gestures) {
					let T = this.config[x], D = bindToProps(S, T.eventOptions, !!C);
					T.enabled && new (EngineMap.get(x))(this, m, x).bind(D);
				}
				let T = bindToProps(S, x.eventOptions, !!C);
				for (let x in this.nativeHandlers) T(x, "", (S) => this.nativeHandlers[x](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
					event: S,
					args: m
				})), void 0, !0);
			}
			for (let m in S) S[m] = chain(...S[m]);
			if (!C) return S;
			for (let m in S) {
				let { device: x, capture: T, passive: D } = parseProp(m);
				this._targetEventStore.add(C, x, "", S[m], {
					capture: T,
					passive: D
				});
			}
		}
	}
};
function setupGesture(m, x) {
	m.gestures.add(x), m.gestureEventStores[x] = new EventStore(m, x), m.gestureTimeoutStores[x] = new TimeoutStore();
}
function resolveGestures(m, x) {
	x.drag && setupGesture(m, "drag"), x.wheel && setupGesture(m, "wheel"), x.scroll && setupGesture(m, "scroll"), x.move && setupGesture(m, "move"), x.pinch && setupGesture(m, "pinch"), x.hover && setupGesture(m, "hover");
}
var bindToProps = (m, x, S) => (C, T, D, O = {}, k = !1) => {
	let A = O.capture ?? x.capture, j = O.passive ?? x.passive, M = k ? C : toHandlerProp(C, T, A);
	S && j && (M += "Passive"), m[M] = m[M] || [], m[M].push(D);
};
function useRecognizers(m, S = {}, C, T) {
	let D = React.useMemo(() => new Controller(m), []);
	if (D.applyHandlers(m, T), D.applyConfig(S, C), React.useEffect(D.effect.bind(D)), React.useEffect(() => D.clean.bind(D), []), S.target === void 0) return D.bind.bind(D);
}
function usePinch(m, x) {
	return registerAction(pinchAction), useRecognizers({ pinch: m }, x || {}, "pinch");
}
function usePlotStatus(m) {
	let { plotStatusList: x } = useMainModuleResult();
	if (Array.isArray(x)) return x.find((x) => x.name.toLowerCase() == m?.toLowerCase());
}
const useProjectArea = () => {
	let { measurementSystem: m } = useMainModuleResult(), x = m === "metric" ? "m" : "sqft";
	return {
		unit: x,
		prepareArea: (m) => m == null || m == 0 ? "N/A" : `${m} ${x ?? ""}`
	};
};
function BedroomIcon({ width: m = "1.5625rem", className: x }) {
	return /* @__PURE__ */ jsxs("svg", {
		style: { width: m },
		className: x,
		viewBox: "0 0 25 25",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		children: [
			/* @__PURE__ */ jsx("path", {
				d: "M22.8734 16.0297V9.55908C22.8734 8.45451 21.978 7.55908 20.8734 7.55908H11.2379C10.5692 7.55908 9.94472 7.89328 9.57379 8.44968L8.75576 9.67673L8.68311 9.5501",
				stroke: "currentColor",
				strokeWidth: "2"
			}),
			/* @__PURE__ */ jsx("path", {
				d: "M1.69678 3.32397V16.0299M1.69678 23.0887V16.0299M1.69678 19.5593H22.8732M22.8732 23.0887V14.9122C22.8732 14.3599 22.4255 13.9122 21.8732 13.9122H5.88549C4.55941 13.9122 3.28764 14.439 2.34996 15.3767L1.69678 16.0299",
				stroke: "currentColor",
				strokeWidth: "2",
				strokeLinecap: "round"
			}),
			/* @__PURE__ */ jsx("circle", {
				cx: "5.93224",
				cy: "10.3827",
				r: "2.52941",
				stroke: "currentColor",
				strokeWidth: "2"
			})
		]
	});
}
function RulerIcon({ className: m, width: x }) {
	return /* @__PURE__ */ jsx("svg", {
		style: { width: x },
		className: m,
		viewBox: "0 0 16 16",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		children: /* @__PURE__ */ jsx("g", {
			clipPath: "url(#clip0_679_1033)",
			children: /* @__PURE__ */ jsx("path", {
				d: "M9.66666 3.66667L10.6667 4.66667M7.66666 5.66667L8.66666 6.66667M5.66666 7.66667L6.66666 8.66667M3.66666 9.66667L4.66666 10.6667M1.71043 11.7105L4.28951 14.2896C4.42152 14.4216 4.48752 14.4876 4.56363 14.5123C4.63058 14.5341 4.70269 14.5341 4.76964 14.5123C4.84575 14.4876 4.91175 14.4216 5.04376 14.2896L14.2895 5.04382C14.4215 4.91182 14.4875 4.84581 14.5123 4.7697C14.534 4.70276 14.534 4.63064 14.5123 4.56369C14.4875 4.48758 14.4215 4.42158 14.2895 4.28957L11.7104 1.71049C11.5784 1.57848 11.5124 1.51248 11.4363 1.48775C11.3694 1.466 11.2972 1.466 11.2303 1.48775C11.1542 1.51248 11.0882 1.57848 10.9562 1.71049L1.71043 10.9562C1.57842 11.0882 1.51242 11.1542 1.48769 11.2304C1.46594 11.2973 1.46594 11.3694 1.48769 11.4364C1.51242 11.5125 1.57842 11.5785 1.71043 11.7105Z",
				stroke: "currentColor",
				strokeWidth: "1.5",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			})
		})
	});
}
function BathroomIcon({ width: m = "1.5625rem" }) {
	return /* @__PURE__ */ jsxs("svg", {
		style: { width: m },
		height: "25",
		viewBox: "0 0 25 25",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		children: [
			/* @__PURE__ */ jsx("path", {
				d: "M9.88428 11.95V11.35M12.9897 11.1024V10.75",
				stroke: "#50555F",
				strokeWidth: "2",
				strokeLinecap: "round",
				strokeLinejoin: "round"
			}),
			/* @__PURE__ */ jsx("path", {
				d: "M22.166 16.0437H3.10596L3.10615 16.9564C3.10671 19.5713 5.22663 21.6908 7.84149 21.6908H17.6269C20.1338 21.6908 22.166 19.6585 22.166 17.1517V16.0437Z",
				stroke: "currentColor",
				strokeWidth: "2",
				strokeLinejoin: "round"
			}),
			/* @__PURE__ */ jsx("path", {
				d: "M20.754 23.8085L18.6364 21.6908H7.34226L5.22461 23.8085M5.22461 16.0438V4.1594M5.22461 4.04378V4.1594M5.22461 4.1594V4.1594C5.22461 2.80095 6.32585 1.69971 7.6843 1.69971H10.084C10.6363 1.69971 11.084 2.14742 11.084 2.69971V3.88906M11.084 3.88906C10.1616 4.08596 9.22808 5.39148 8.04814 7.57307H14.4011C13.7302 6.14195 13.1391 5.14968 12.5847 4.55384C12.0639 3.994 11.5755 3.78414 11.084 3.88906Z",
				stroke: "currentColor",
				strokeWidth: "2",
				strokeLinecap: "round"
			})
		]
	});
}
var use_isomorphic_layout_effect_default = typeof window < "u" ? useLayoutEffect : useEffect;
function useEventListener(m, x, S, C) {
	let T = useRef(x);
	use_isomorphic_layout_effect_default(() => {
		T.current = x;
	}, [x]), useEffect(() => {
		let x = S?.current ?? window;
		if (!(x && x.addEventListener)) return;
		let D = (m) => T.current(m);
		return x.addEventListener(m, D, C), () => {
			x.removeEventListener(m, D, C);
		};
	}, [
		m,
		S,
		C
	]);
}
var use_event_listener_default = useEventListener;
function useOnClickOutside(m, x, S = "mousedown", C = []) {
	use_event_listener_default(S, (S) => {
		let T = m?.current;
		if (!(!T || T.contains(S.target))) {
			for (let m of C) {
				let x = document.querySelector(m);
				if (x && x.contains(S.target)) return;
			}
			S.target.tagName !== "HTML" && x(S);
		}
	});
}
var use_on_click_outside_default = useOnClickOutside;
function PlanViewPopup({ canvas: m, obj: x, item: S, onClickOutside: C }) {
	let { t: T } = useTranslation(), D = useRef(null), [O, k] = useState([1, 1]), { showPrice: A, currency: j, clientName: M, projectName: N, country: F, city: I, district: L } = useMainModuleResult(), R = usePlotStatus(S.plotInfo?.statusName ?? "available"), z = useRef(!1), { prepareArea: U } = useProjectArea();
	use_on_click_outside_default(D, (m) => {
		m.preventDefault(), C();
	}, "mousedown"), use_on_click_outside_default(D, (m) => {
		m.preventDefault(), z.current = !0;
	}, "touchmove"), use_on_click_outside_default(D, (m) => {
		m.preventDefault(), z.current ? z.current = !1 : C();
	}, "touchend");
	let W = (m, S) => {
		let C = m.getZoom(), T = m.getWidth(), O = m.getHeight(), k = x.label.getBoundingRect(), A = k.top + k.height / 2, j = k.left + k.width / 2;
		return {
			canvasTop: 0,
			canvasLeft: 0,
			canvasRight: T,
			canvasBottom: O,
			objectTop: A - 10,
			objectLeft: j - 10,
			popupWidth: D.current?.offsetWidth ?? 0,
			popupHeight: D.current?.offsetHeight ?? 0,
			zoom: C
		};
	}, q = () => {
		if (D.current == null) return;
		let S = W(m, x), C = [1, 1], T = S?.objectLeft ?? 0, O = (S?.objectTop ?? 0) - S.popupHeight;
		T + S.popupWidth > S.canvasRight && (T = S?.objectLeft - S.popupWidth, C[0] = -1), O - S.popupHeight < S.canvasTop && (O = S?.objectTop, C[1] = -1);
		let [A, j] = J(C[0], C[1]);
		k(C), D.current.style.left = T + A + "px", D.current.style.top = O + j + "px";
	}, J = (m, x) => m > 0 && x > 0 ? [10, -20] : m > 0 && x < 0 ? [20, 40] : m < 0 && x > 0 ? [20, -20] : m < 0 && x < 0 ? [10, 40] : [0], Y = (m, x) => m > 0 && x > 0 ? "triangle-bottom-left" : m > 0 && x < 0 ? "triangle-top-left" : m < 0 && x > 0 ? "triangle-bottom-right" : "triangle-top-right";
	useEffect(() => {
		q(), m.on("before:render", () => {
			q();
		});
	}, []);
	let X = R?.name.toLowerCase() == "sold" ? T("web.availability.status.Sold") : formatCurrency(S.plotInfo?.price ?? 0, null, A, j, document.documentElement.lang);
	return /* @__PURE__ */ jsxs("div", {
		ref: D,
		onClick: async () => {
			let m = PlanItemTypeEnum[x?.itemType ?? ""], C = "/availability/site-plan", T = document.documentElement.lang;
			if (m === PlanItemTypeEnum.PlotContainer) C = T === "en" ? "" : `/${T}/availability/site-plan/plot-container/${x?.itemId}`, window.location.href = C;
			else if (m === PlanItemTypeEnum.Plot) {
				let m = await generatePlotUrl(x.itemId.toString(), M, N, F, I, L, S.plotInfo?.name, S.plotInfo?.bedrooms);
				window.location.href = m;
			}
		},
		className: "cursor-pointer mobile:text-[0.8rem] absolute p-4 bg-thirdLayer text-bodyContentColor touch-none",
		style: { scale: 1 },
		children: [
			/* @__PURE__ */ jsxs("div", {
				className: "text-[1em] leading-[1.375em] font-bold flex justify-between",
				children: [/* @__PURE__ */ jsx("div", { children: S.plotInfo?.typeName }), /* @__PURE__ */ jsxs("div", {
					className: "flex items-center gap-1 text-[0.8125em] leading-[1.375em]",
					children: [/* @__PURE__ */ jsx("span", {
						style: { color: R?.color },
						children: T(`${R?.name}`)
					}), /* @__PURE__ */ jsx("svg", {
						width: "16",
						height: "16",
						className: "rtl:rotate-180",
						viewBox: "0 0 16 16",
						fill: "none",
						xmlns: "http://www.w3.org/2000/svg",
						children: /* @__PURE__ */ jsx("path", {
							d: "M11.3546 8.00004C11.3546 7.75416 11.2606 7.54444 11.0726 7.35642L5.43193 1.83868C5.27283 1.67958 5.07758 1.60004 4.84616 1.60004C4.37611 1.60004 4.00006 1.96162 4.00006 2.43168C4.00006 2.66309 4.09407 2.8728 4.25317 3.03913L9.34424 8.00004L4.25317 12.9609C4.1013 13.12 4.00006 13.3298 4.00006 13.5612C4.00006 14.0385 4.37611 14.4 4.84616 14.4C5.07758 14.4 5.27283 14.3205 5.43193 14.1614L11.0726 8.64365C11.2679 8.45563 11.3546 8.24591 11.3546 8.00004Z",
							fill: R?.color
						})
					})]
				})]
			}),
			/* @__PURE__ */ jsx("div", {
				className: "text-xs leading-[1.375em] text-inActiveBodyContentColor mb-4",
				children: S.plotInfo?.name
			}),
			/* @__PURE__ */ jsxs("div", {
				className: "flex grid grid-cols-2 gap-[0.7081rem] mobile:gap-[2.125em] whitespace-pre text-[0.75rem]",
				children: [
					A && /* @__PURE__ */ jsxs("div", {
						style: { color: R?.color },
						className: "flex flex-[1] gap-[0.25em] items-center",
						children: [/* @__PURE__ */ jsxs("svg", {
							width: "16",
							height: "16",
							viewBox: "0 0 16 16",
							fill: "none",
							xmlns: "http://www.w3.org/2000/svg",
							children: [/* @__PURE__ */ jsx("g", {
								clipPath: "url(#clip0_679_1027)",
								children: /* @__PURE__ */ jsx("path", {
									d: "M9.01964 5.56788C8.63803 5.83995 8.17103 5.99998 7.66665 5.99998C6.37798 5.99998 5.33331 4.95531 5.33331 3.66665C5.33331 2.37798 6.37798 1.33331 7.66665 1.33331C8.50197 1.33331 9.23478 1.77226 9.64698 2.43207M3.99998 13.3914H5.74017C5.96706 13.3914 6.19257 13.4184 6.41252 13.4724L8.25124 13.9192C8.65021 14.0164 9.06583 14.0259 9.46896 13.9476L11.502 13.5521C12.039 13.4474 12.533 13.1903 12.9202 12.8136L14.3586 11.4145C14.7693 11.0156 14.7693 10.3683 14.3586 9.96869C13.9887 9.60894 13.4031 9.56844 12.9847 9.87352L11.3084 11.0965C11.0683 11.272 10.7762 11.3665 10.4757 11.3665H8.85698L9.88736 11.3665C10.4681 11.3665 10.9386 10.9089 10.9386 10.3439V10.1394C10.9386 9.67031 10.6104 9.26129 10.1427 9.14789L8.55238 8.76114C8.29357 8.69837 8.02851 8.66665 7.76207 8.66665C7.11887 8.66665 5.95458 9.19919 5.95458 9.19919L3.99998 10.0166M13.3333 4.33331C13.3333 5.62198 12.2886 6.66665 11 6.66665C9.71132 6.66665 8.66665 5.62198 8.66665 4.33331C8.66665 3.04465 9.71132 1.99998 11 1.99998C12.2886 1.99998 13.3333 3.04465 13.3333 4.33331ZM1.33331 9.73331L1.33331 13.6C1.33331 13.9733 1.33331 14.16 1.40598 14.3026C1.46989 14.4281 1.57188 14.5301 1.69732 14.594C1.83993 14.6666 2.02661 14.6666 2.39998 14.6666H2.93331C3.30668 14.6666 3.49337 14.6666 3.63597 14.594C3.76141 14.5301 3.8634 14.4281 3.92732 14.3026C3.99998 14.16 3.99998 13.9733 3.99998 13.6V9.73331C3.99998 9.35995 3.99998 9.17326 3.92732 9.03065C3.8634 8.90521 3.76141 8.80323 3.63597 8.73931C3.49337 8.66665 3.30668 8.66665 2.93331 8.66665L2.39998 8.66665C2.02661 8.66665 1.83993 8.66665 1.69732 8.73931C1.57188 8.80322 1.46989 8.90521 1.40598 9.03065C1.33331 9.17326 1.33331 9.35994 1.33331 9.73331Z",
									stroke: "currentColor",
									strokeWidth: "1.5",
									strokeLinecap: "round",
									strokeLinejoin: "round"
								})
							}), /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", {
								id: "clip0_679_1027",
								children: /* @__PURE__ */ jsx("rect", {
									width: "16",
									height: "16",
									fill: "white"
								})
							}) })]
						}), /* @__PURE__ */ jsx("span", {
							className: "text-bodyContentColor",
							children: X
						})]
					}),
					/* @__PURE__ */ jsxs("div", {
						style: { color: R?.color },
						className: "flex gap-[0.25em] items-center",
						children: [/* @__PURE__ */ jsx(BedroomIcon, {
							className: "stroke-footerTextColor",
							width: "1rem"
						}), /* @__PURE__ */ jsx("span", {
							className: "text-bodyContentColor",
							children: S.plotInfo?.bedrooms + ` ${T("web.unit_detail.bedroom")}`
						})]
					}),
					/* @__PURE__ */ jsxs("div", {
						style: { color: R?.color },
						className: "mobile:-mt-[1.625em] flex gap-[0.25em] items-center",
						children: [/* @__PURE__ */ jsx(RulerIcon, { className: "w-4 h-4" }), /* @__PURE__ */ jsx("span", {
							className: "text-bodyContentColor",
							children: U(S.plotInfo?.metricArea ?? 0)
						})]
					}),
					/* @__PURE__ */ jsxs("div", {
						style: { color: R?.color },
						className: "mobile:-mt-[1.625em] flex gap-[0.25em] items-center",
						children: [/* @__PURE__ */ jsx(BathroomIcon, {
							className: "stroke-footerTextColor",
							width: "1rem"
						}), /* @__PURE__ */ jsx("span", {
							className: "text-bodyContentColor",
							children: S.plotInfo?.bathrooms + ` ${T("web.unit_detail.bathrooms").toLowerCase()}`
						})]
					})
				]
			}),
			/* @__PURE__ */ jsx("div", { className: `absolute w-0 h-0 ${Y(O[0], O[1])} ` })
		]
	});
}
function ContainerPlanPopup({ canvas: m, obj: x, item: S, onClickOutside: C, onNavigate: T, formatCurrency: D = (m) => `${m.toLocaleString()}`, t: O = (m) => m, showPrice: k = !0 }) {
	let A = useRef(null), [j, M] = useState([1, 1]), N = useRef(!1), F = (m) => {
		A.current && !A.current.contains(m.target) && (m.type === "mousedown" ? (m.preventDefault(), C()) : m.type === "touchmove" ? (m.preventDefault(), N.current = !0) : m.type === "touchend" && (m.preventDefault(), N.current ? N.current = !1 : C()));
	};
	useEffect(() => (document.addEventListener("mousedown", F), document.addEventListener("touchmove", F), document.addEventListener("touchend", F), () => {
		document.removeEventListener("mousedown", F), document.removeEventListener("touchmove", F), document.removeEventListener("touchend", F);
	}), []);
	let I = (m, S) => {
		let C = m.getZoom(), T = m.getWidth(), D = m.getHeight(), O = x.label.getBoundingRect();
		return {
			canvasTop: 0,
			canvasLeft: 0,
			canvasRight: T,
			canvasBottom: D,
			objectTop: O.top + O.height / 2,
			objectLeft: O.left + O.width / 2,
			popupWidth: A.current?.offsetWidth ?? 0,
			popupHeight: A.current?.offsetHeight ?? 0,
			zoom: C
		};
	}, L = () => {
		if (A.current == null) return;
		let S = I(m, x), C = [1, 1], T = S?.objectLeft ?? 0, D = (S?.objectTop ?? 0) - S.popupHeight;
		T + S.popupWidth > S.canvasRight && (T = S?.objectLeft - S.popupWidth, C[0] = -1), D - S.popupHeight < S.canvasTop && (D = S?.objectTop, C[1] = -1);
		let [O, k] = R(C[0], C[1]);
		M(C), A.current.style.left = T + O + "px", A.current.style.top = D + k + "px";
	}, R = (m, x) => m > 0 && x > 0 ? [10, -20] : m > 0 && x < 0 ? [20, 40] : m < 0 && x > 0 ? [20, -20] : m < 0 && x < 0 ? [10, 40] : [0, 0];
	return useEffect(() => {
		L(), m.on("before:render", () => {
			L();
		});
	}, []), /* @__PURE__ */ jsxs("div", {
		ref: A,
		onClick: async () => {
			let m = "/availability/site-plan";
			m = `/availability/site-plan/container/${x?.itemId}`, T && T(m);
		},
		className: "cursor-pointer mobile:text-[0.8rem] absolute p-4 bg-thirdLayer text-bodyContentColor touch-none",
		style: { scale: 1 },
		children: [
			/* @__PURE__ */ jsxs("div", {
				className: "mb-[0.875em] text-[1em] leading-[1.375em] font-bold flex justify-between",
				children: [/* @__PURE__ */ jsx("div", { children: S.plotContainerInfo?.name }), /* @__PURE__ */ jsx("div", {
					className: "flex items-center gap-1 text-[0.8125em] leading-[1.375em]",
					children: /* @__PURE__ */ jsx("svg", {
						width: "16",
						height: "16",
						className: "rtl:rotate-180",
						viewBox: "0 0 16 16",
						fill: "none",
						xmlns: "http://www.w3.org/2000/svg",
						children: /* @__PURE__ */ jsx("path", {
							d: "M11.3546 8.00004C11.3546 7.75416 11.2606 7.54444 11.0726 7.35642L5.43193 1.83868C5.27283 1.67958 5.07758 1.60004 4.84616 1.60004C4.37611 1.60004 4.00006 1.96162 4.00006 2.43168C4.00006 2.66309 4.09407 2.8728 4.25317 3.03913L9.34424 8.00004L4.25317 12.9609C4.1013 13.12 4.00006 13.3298 4.00006 13.5612C4.00006 14.0385 4.37611 14.4 4.84616 14.4C5.07758 14.4 5.27283 14.3205 5.43193 14.1614L11.0726 8.64365C11.2679 8.45563 11.3546 8.24591 11.3546 8.00004Z",
							fill: "currentColor"
						})
					})
				})]
			}),
			/* @__PURE__ */ jsxs("div", {
				className: "grid grid-cols-1 whitespace-pre",
				children: [
					k && /* @__PURE__ */ jsxs("div", {
						className: "col-span-1 flex gap-[0.5em] items-center",
						children: [/* @__PURE__ */ jsxs("svg", {
							width: "16",
							height: "16",
							viewBox: "0 0 16 16",
							fill: "none",
							xmlns: "http://www.w3.org/2000/svg",
							children: [/* @__PURE__ */ jsx("g", {
								clipPath: "url(#clip0_679_1027)",
								children: /* @__PURE__ */ jsx("path", {
									d: "M9.01964 5.56788C8.63803 5.83995 8.17103 5.99998 7.66665 5.99998C6.37798 5.99998 5.33331 4.95531 5.33331 3.66665C5.33331 2.37798 6.37798 1.33331 7.66665 1.33331C8.50197 1.33331 9.23478 1.77226 9.64698 2.43207M3.99998 13.3914H5.74017C5.96706 13.3914 6.19257 13.4184 6.41252 13.4724L8.25124 13.9192C8.65021 14.0164 9.06583 14.0259 9.46896 13.9476L11.502 13.5521C12.039 13.4474 12.533 13.1903 12.9202 12.8136L14.3586 11.4145C14.7693 11.0156 14.7693 10.3683 14.3586 9.96869C13.9887 9.60894 13.4031 9.56844 12.9847 9.87352L11.3084 11.0965C11.0683 11.272 10.7762 11.3665 10.4757 11.3665H8.85698L9.88736 11.3665C10.4681 11.3665 10.9386 10.9089 10.9386 10.3439V10.1394C10.9386 9.67031 10.6104 9.26129 10.1427 9.14789L8.55238 8.76114C8.29357 8.69837 8.02851 8.66665 7.76207 8.66665C7.11887 8.66665 5.95458 9.19919 5.95458 9.19919L3.99998 10.0166M13.3333 4.33331C13.3333 5.62198 12.2886 6.66665 11 6.66665C9.71132 6.66665 8.66665 5.62198 8.66665 4.33331C8.66665 3.04465 9.71132 1.99998 11 1.99998C12.2886 1.99998 13.3333 3.04465 13.3333 4.33331ZM1.33331 9.73331L1.33331 13.6C1.33331 13.9733 1.33331 14.16 1.40598 14.3026C1.46989 14.4281 1.57188 14.5301 1.69732 14.594C1.83993 14.6666 2.02661 14.6666 2.39998 14.6666H2.93331C3.30668 14.6666 3.49337 14.6666 3.63597 14.594C3.76141 14.5301 3.8634 14.4281 3.92732 14.3026C3.99998 14.16 3.99998 13.9733 3.99998 13.6V9.73331C3.99998 9.35995 3.99998 9.17326 3.92732 9.03065C3.8634 8.90521 3.76141 8.80323 3.63597 8.73931C3.49337 8.66665 3.30668 8.66665 2.93331 8.66665L2.39998 8.66665C2.02661 8.66665 1.83993 8.66665 1.69732 8.73931C1.57188 8.80322 1.46989 8.90521 1.40598 9.03065C1.33331 9.17326 1.33331 9.35994 1.33331 9.73331Z",
									stroke: "currentColor",
									strokeWidth: "1.5",
									strokeLinecap: "round",
									strokeLinejoin: "round"
								})
							}), /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("clipPath", {
								id: "clip0_679_1027",
								children: /* @__PURE__ */ jsx("rect", {
									width: "16",
									height: "16",
									fill: "white"
								})
							}) })]
						}), /* @__PURE__ */ jsx("div", {
							className: "text-bodyContentColor",
							children: `${D(S.plotContainerInfo?.priceMin ?? 0)} - ${D(S.plotContainerInfo?.priceMax ?? 0)}`
						})]
					}),
					/* @__PURE__ */ jsx("div", {
						className: "col-span-1 flex gap-[0.5em] items-center",
						children: /* @__PURE__ */ jsx("div", {
							className: "text-bodyContentColor",
							children: `${S.plotContainerInfo?.bedroomsMin} ${O("web.unit_detail.bedroom")} - ${S.plotContainerInfo?.bedroomsMax} ${O("web.unit_detail.bedroom")}`
						})
					}),
					/* @__PURE__ */ jsx("div", {
						className: "col-span-1 flex gap-[0.5em] items-center",
						children: /* @__PURE__ */ jsx("div", {
							className: "text-bodyContentColor",
							children: `${S.plotContainerInfo?.areaMin} ${O(S.plotContainerInfo?.areaUnit ?? "")} - ${S.plotContainerInfo?.areaMax} ${O(S.plotContainerInfo?.areaUnit ?? "")}`
						})
					})
				]
			}),
			/* @__PURE__ */ jsx("div", { className: `absolute w-0 h-0 ${((m, x) => m > 0 && x > 0 ? "triangle-bottom-left" : m > 0 && x < 0 ? "triangle-top-left" : m < 0 && x > 0 ? "triangle-bottom-right" : "triangle-top-right")(j[0], j[1])}` })
		]
	});
}
var FloorViewPopup = React.forwardRef(({ canvas: m, obj: x, item: S, onClickOutside: C, onNavigate: T, measurementSystem: D = "metric" }, O) => {
	let k = useRef(null), [A, j] = useState([1, 1]), M = useRef(!1), N = (m) => {
		k.current && !k.current.contains(m.target) && (m.type === "mousedown" ? (m.preventDefault(), C()) : m.type === "touchmove" ? (m.preventDefault(), M.current = !0) : m.type === "touchend" && (m.preventDefault(), M.current ? M.current = !1 : C()));
	};
	useEffect(() => (document.addEventListener("mousedown", N), document.addEventListener("touchmove", N), document.addEventListener("touchend", N), () => {
		document.removeEventListener("mousedown", N), document.removeEventListener("touchmove", N), document.removeEventListener("touchend", N);
	}), []);
	let F = (m) => {
		let S = m.getZoom(), C = m.getWidth(), T = m.getHeight(), D = x.label.getBoundingRect();
		return {
			canvasTop: 0,
			canvasLeft: 0,
			canvasRight: C,
			canvasBottom: T,
			objectTop: D.top + D.height / 2,
			objectLeft: D.left + D.width / 2,
			popupWidth: k.current?.offsetWidth ?? 0,
			popupHeight: k.current?.offsetHeight ?? 0,
			zoom: S
		};
	}, I = (m, x) => m > 0 && x > 0 ? [10, -20] : m > 0 && x < 0 ? [20, 40] : m < 0 && x > 0 ? [20, -20] : m < 0 && x < 0 ? [10, 40] : [0, 0], L = (m, x) => m > 0 && x > 0 ? "triangle-bottom-left" : m > 0 && x < 0 ? "triangle-top-left" : m < 0 && x > 0 ? "triangle-bottom-right" : "triangle-top-right";
	useEffect(() => {
		let x = () => {
			if (k.current == null) return;
			let x = F(m), S = [1, 1], C = x?.objectLeft ?? 0, T = (x?.objectTop ?? 0) - x.popupHeight;
			C + x.popupWidth > x.canvasRight && (C = x?.objectLeft - x.popupWidth, S[0] = -1), T - x.popupHeight < x.canvasTop && (T = x?.objectTop, S[1] = -1);
			let [D, O] = I(S[0], S[1]);
			j(S), k.current && (k.current.style.left = C + D + "px", k.current.style.top = T + O + "px");
		};
		return x(), m.on("before:render", x), () => {
			m.off("before:render", x);
		};
	}, [x, m]);
	let R = D === "metric" ? S.informations?.[0] : S.informations?.[1];
	return /* @__PURE__ */ jsxs("div", {
		ref: (m) => {
			k.current = m, typeof O == "function" ? O(m) : O && (O.current = m);
		},
		onClick: async () => {
			let m = "/availability/site-plan";
			m = `/availability/site-plan/container/${x?.itemId}`, T && T(m);
		},
		className: "cursor-pointer mobile:text-[0.8rem] absolute p-4 bg-thirdLayer text-bodyContentColor touch-none",
		style: { scale: 1 },
		children: [
			/* @__PURE__ */ jsx("div", {
				className: "mb-[0.875em] text-[1em] leading-[1.375em] font-bold flex justify-between",
				children: /* @__PURE__ */ jsx("div", { children: S.name })
			}),
			/* @__PURE__ */ jsx("div", {
				className: "grid grid-cols-1 whitespace-pre",
				children: R ?? ""
			}),
			/* @__PURE__ */ jsx("div", { className: `absolute w-0 h-0 ${L(A[0], A[1])}` })
		]
	});
});
FloorViewPopup.displayName = "FloorViewPopup";
var floor_view_popup_default = FloorViewPopup, import_fabric = require_fabric();
function PlanView({ planId: m, objects: x, items: S, background: C, color: T, canvasSubject: D, useHalfWidth: O, onNavigate: k, formatCurrency: A, t: j, showPrice: N, measurementSystem: F }) {
	let I = useRef(null), L = useRef(null), R = useRef(null), z = useRef(null), U = useRef(null), W = useRef(null), q = useRef(null), J = useRef(0), X = useRef(0), Z = useRef(!1), sH = useRef(!1), Q = useRef(0), cH = useRef(1), lH = useRef(new PlanItemController(S)), uH = useRef(new PlanObjectController(x)), dH = useRef(x), fH = useRef(""), pH = useRef(null), mH = useRef(0), hH = useRef(0), gH = useRef(0), $ = useRef(null), [_H, vH] = useState([]), yH = useRef(null), bH = () => {
		let m = yH.current;
		m && q.current.setDimensions({
			width: m.clientWidth,
			height: m.clientHeight
		});
	}, xH = () => {
		bH();
		let m = 1;
		if (L.current?.width !== 0 || L.current?.height !== 0) {
			let x = q.current.getWidth() / (O ? 2 : 1), S = L.current.width, C = L.current.height, T = q.current.getHeight(), D = x / S, k = T / C;
			m = Math.min(D, k), q.current.setZoom(m), q.current.absolutePan(new import_fabric.fabric.Point((S * m - x) / 2, (C * m - T) / 2)), cH.current = m;
		}
		q.current.renderAll(), pH.current = q.current?.viewportTransform;
	};
	useEffect(() => {
		let m = (m) => m.preventDefault(), x = yH.current ?? document, S = document?.getElementById("puck-canvas-root");
		x.addEventListener("gesturestart", m), x.addEventListener("gesturechange", m), x.addEventListener("gestureend", m);
		let C = null;
		return S && (C = new ResizeObserver(() => {
			xH();
		}), C.observe(S)), () => {
			x.removeEventListener("gesturestart", m), x.removeEventListener("gesturechange", m), x.removeEventListener("gestureend", m), C && S && (C.unobserve(S), C.disconnect());
		};
	}, [yH]), usePinch((m) => {
		let { da: x } = m;
		m.event.preventDefault(), Q.current == 0 && (Q.current = x[0]);
		let S = x[0] / Q.current * q.current.getZoom();
		S > 20 && (S = 20), S < cH.current && (S = cH.current), q.current.setZoom(S), MH(), Q.current = x[0], q.current.renderAll();
	}, { target: $ }), useEffect(() => {
		q.current && D && D.attach(() => {
			xH();
		}, "onFit");
	}, [D, q.current]), useEffect(() => {
		if (!C?.objectUrl) return;
		let m = typeof window < "u" ? window.document : document;
		return m.addEventListener("gesturestart", (m) => m.preventDefault()), m.addEventListener("gesturechange", (m) => m.preventDefault()), SH(), () => {
			try {
				q.current && (q.current?.dispose(), L.current?.dispose());
			} catch (m) {
				console.error(m);
			}
		};
	}, [C]), useEffect(() => {
		let C = m == fH.current;
		if (q.current && C) q.current.remove(...q.current.getObjects()), uH.current.deleteObjects(), lH.current = new PlanItemController(S), uH.current = new PlanObjectController(x), uH.current.initContainerObjects(R.current), uH.current.containerObjects.forEach((m) => {
			let x = lH.current.getItem(m.itemId);
			x && (m.assign(x), q.current.add(m, m.label));
		}), q.current?.requestRenderAll();
		else if (q.current && !C) try {
			q.current && (q.current.remove(...q.current.getObjects()), L.current?.dispose(), uH.current.deleteObjects(), lH.current = new PlanItemController(S), uH.current = new PlanObjectController(x), SH());
		} catch (m) {
			console.error(m);
		}
		dH.current = x, fH.current = m;
	}, [x]);
	let SH = () => {
		import_fabric.fabric.Image.fromURL(C.objectUrl ?? "", (m) => {
			m.setOptions({
				stroke: "#333333",
				strokeWidth: 0,
				opacity: 1,
				hasBorders: !1
			}), L.current = m, R.current = new import_fabric.fabric.Point(L.current.width ?? 0, L.current.height ?? 0), TH(), jH(L.current?.width ?? 0, L.current?.height ?? 0), xH();
		});
	}, CH = (m) => {
		if (m.target instanceof PlanRectangleObject || m.target instanceof PlanCircleObject || m.target instanceof PlanPolygonObject) {
			let x = m.target, S = getPlanItemTypeEnum(lH.current.getItem(x.itemId)?.type ?? "");
			S == PlanItemTypeEnum.Room && (W.current = S, DH(x));
		}
	}, wH = (m) => {
		if ((m.target instanceof PlanRectangleObject || m.target instanceof PlanCircleObject || m.target instanceof PlanPolygonObject) && W.current == PlanItemTypeEnum.Room) {
			let x = z.current?.getBoundingClientRect(), { clientX: S, clientY: C } = m.e;
			if (S >= Math.round((x?.left ?? 0) - 10) && S <= Math.round((x?.right ?? 0) + 10) && C >= Math.round((x?.top ?? 0) - 10) && C <= Math.round((x?.bottom ?? 0) + 10)) return;
			OH();
		}
	}, TH = () => {
		L.current && (q.current, q.current = new import_fabric.fabric.Canvas(I.current, {
			hoverCursor: "move",
			selection: !0,
			selectionBorderColor: "blue",
			backgroundColor: "#cccccc",
			renderOnAddRemove: !1,
			objectCaching: !1,
			backgroundImage: L.current
		}), q.current.backgroundColor = T ?? "#ff00", q.current.selection = !1, q.current.defaultCursor = "grab", q.current.on("mouse:wheel", function(m) {
			let x = m.e.deltaY, S = q.current.getZoom(), C = new import_fabric.fabric.Point(q.current.getWidth() / 2, q.current.getHeight() / 2);
			S *= .999 ** x, S > 20 && (S = 20), S < cH.current && (S = cH.current);
			let T = q.current.getPointer(m.e), D = new import_fabric.fabric.Point(T.x, T.y), O = import_fabric.fabric.util.transformPoint(D, q.current.viewportTransform);
			q.current.zoomToPoint(C, S);
			let k = import_fabric.fabric.util.transformPoint(D, q.current.viewportTransform), A = new import_fabric.fabric.Point(O.x - k.x, O.y - k.y);
			q.current.relativePan(A), MH(), q.current.renderAll(), m.e.preventDefault(), m.e.stopPropagation();
		}), q.current.on("mouse:move", function(m) {
			Z.current && (m.e.type == "mousemove" ? PH(m.e.clientX, m.e.clientY) : m.e.touches && m.e.touches.length > 1 || PH(m.e.touches[0].clientX, m.e.touches[0].clientY));
		}), q.current.on("mouse:up", AH), q.current.on("mouse:down", kH), q.current.on("mouse:over", CH), q.current.on("mouse:out", wH), uH.current.initContainerObjects(R.current), uH.current.containerObjects.forEach((m) => {
			let x = lH.current.getItem(m.itemId);
			if (x) if (m.itemType == "Room") {
				x && m.assign(x);
				let S = m.fill;
				m.fill = "#ff00", m.label = new PlanLabelObject(x.name, S ?? "0x000000", m.left ?? 0, m.top ?? 0, m.width ?? 0, m.height ?? 0, 1, 56), m.label.hideBackground(), m.label.addStroke(), q.current.add(m, m.label);
			} else x && m.assign(x), q.current.add(m, m.label);
		}), q.current.on("mouse:mouseup", (m) => {
			(m.target instanceof PlanRectangleObject || m.target instanceof PlanCircleObject || m.target instanceof PlanPolygonObject) && (DH(m.target), q.current?.requestRenderAll());
		}), q.current.requestRenderAll(), sH.current = !0);
	}, EH = async (m) => {
		let x = getPlanItemTypeEnum(m?.itemType ?? ""), S = "/availability/site-plan";
		x === PlanItemTypeEnum.PlotContainer ? (S = `/availability/site-plan/plot-container/${m?.itemId}`, k && k(S)) : x === PlanItemTypeEnum.Plot && (S = `/plot/${m?.itemId}`, k && k(S));
	}, DH = (m) => {
		let x = lH.current.getItem(m.itemId), S = getPlanItemTypeEnum(x?.type ?? "");
		switch (W.current = S, S) {
			case PlanItemTypeEnum.Plot:
				vH([/* @__PURE__ */ jsx(PlanViewPopup, {
					canvas: q.current,
					obj: m,
					item: x,
					onClickOutside: () => {
						OH();
					}
				}, "container_element")]);
				break;
			case PlanItemTypeEnum.PlotContainer:
				vH([/* @__PURE__ */ jsx(ContainerPlanPopup, {
					canvas: q.current,
					obj: m,
					item: x,
					onClickOutside: () => {
						OH();
					},
					onNavigate: k,
					formatCurrency: A,
					t: j,
					showPrice: N
				}, "container_element")]);
				break;
			case PlanItemTypeEnum.Room:
				vH([/* @__PURE__ */ jsx(floor_view_popup_default, {
					ref: z,
					canvas: q.current,
					obj: m,
					item: x,
					onClickOutside: () => {
						OH();
					},
					onNavigate: k,
					measurementSystem: F
				}, "container_element")]);
				break;
		}
	}, OH = useCallback(() => {
		W.current = null, vH([]), U.current = null;
	}, [_H]), kH = (m) => {
		Z.current = !0, m.e.type.includes("mouse") && (J.current = m.e.clientX, X.current = m.e.clientY), m.e.type.includes("touch") && (J.current = m.e.touches[0].clientX, X.current = m.e.touches[0].clientY), (m.target instanceof PlanRectangleObject || m.target instanceof PlanCircleObject || m.target instanceof PlanPolygonObject) && U.current && U.current.itemId == m.target.itemId ? EH(U.current) : (m.target instanceof PlanRectangleObject || m.target instanceof PlanCircleObject || m.target instanceof PlanPolygonObject) && setTimeout(() => {
			DH(m.target), q.current?.requestRenderAll();
		}, 150);
	}, AH = (m) => {
		Z.current = !1, q.current?.fire("canvas:dragEnd"), Q.current = 0;
	}, jH = (m, x) => {
		mH.current = m, hH.current = x;
	}, MH = () => {
		Date.now() - gH.current < 8 || (gH.current = Date.now(), NH(), q.current?.requestRenderAll());
	}, NH = () => {
		if (mH.current === 0 || hH.current === 0 || !q.current?.viewportTransform) return;
		let m = q.current?.viewportTransform, x = q.current?.getZoom(), S = q.current?.getWidth(), C = mH.current, T = hH.current, D = q.current?.getHeight(), O = pH.current[4], k = pH.current[5];
		m[4] >= pH.current[4] ? q.current.viewportTransform[4] = pH.current[4] : m[4] < S - C * x - O && (q.current.viewportTransform[4] = S - C * x - O), m[5] >= pH.current[5] ? q.current.viewportTransform[5] = pH.current[5] : m[5] < D - T * x - k && (q.current.viewportTransform[5] = D - T * x - k);
	}, PH = (m, x) => {
		if (q.current?.getZoom() == cH.current) return;
		let S = new import_fabric.fabric.Point(m - J.current, x - X.current);
		q.current.relativePan(S), MH(), q.current?.requestRenderAll(), J.current = m, X.current = x;
	};
	return /* @__PURE__ */ jsx("div", {
		className: "w-full xl:h-[600px] h-[300px] overflow-hidden",
		ref: yH,
		children: /* @__PURE__ */ jsxs("div", {
			ref: $,
			className: "relative",
			children: [_H.map((m) => createPortal(m, $.current)), /* @__PURE__ */ jsx("canvas", { ref: I })]
		})
	});
}
var CanvasSubject = class {
	constructor() {
		this.events = ["onFit"], this.observers = { onFit: [] };
	}
	attach(m, x) {
		this.observers[x].push(m);
	}
	detach(m, x) {
		this.observers[x] = this.observers[x].filter((x) => m !== x);
	}
	notify(m) {
		this.observers[m].forEach((m) => m());
	}
};
function PlanViewWrapper(m) {
	let { planId: x, objects: S, items: C, background: T, color: D, elementId: O = "canvas_container", useHalfWidth: k = !1, showPrice: A = !0, measurementSystem: j = "metric" } = m, M = [], N = [], P = null;
	try {
		M = typeof S == "string" ? S ? JSON.parse(S) : [] : S || [], N = typeof C == "string" ? C ? JSON.parse(C) : [] : C || [], P = typeof T == "string" ? T ? JSON.parse(T) : null : T;
	} catch (m) {
		return console.error("Error parsing PlanView props:", m), /* @__PURE__ */ jsx("div", {
			className: "p-4 text-red-600",
			children: "Error: Invalid JSON data for PlanView component"
		});
	}
	return !P || !x ? /* @__PURE__ */ jsx("div", {
		className: "w-full h-[600px] flex items-center justify-center p-4",
		children: /* @__PURE__ */ jsx("div", { className: "w-8 h-8 border-4 border-gray-200 border-t-[#5ec6d3] rounded-full animate-spin" })
	}) : /* @__PURE__ */ jsx(PlanView, {
		planId: x,
		objects: M,
		items: N,
		background: P,
		color: D,
		elementId: O,
		useHalfWidth: k,
		showPrice: A,
		measurementSystem: j
	});
}
export { CanvasSubject, ColorPickerField, ContainerPlanPopup, ContentSection, ContentSectionWrapper, floor_view_popup_default as FloorViewPopup, GridSection, GridSectionWrapper, HeaderSection, HeaderSectionWrapper, HomeFirstSection, HomeFirstSectionWrapper, HomePageContent, HomePageContentWrapper, ItemSlider, PlanCircleObject, PlanItemController, PlanItemTypeEnum, PlanLabelObject, PlanObjectController, PlanObjectTypeEnum, PlanPolygonObject, PlanRectangleObject, PlanView, PlanViewPopup, PlanViewWrapper, PlotThumbCard, PlotThumbCardBody, PlotThumbCardImage, PlotThumbCardRoot, PlotsShowcase, PlotsShowcaseWrapper, Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue, SkyscrapperHomeFirstSection, SkyscrapperHomeFirstSectionWrapper, SkyscrapperHomesSecondSection, SkyscrapperHomesSecondSectionWrapper, SkyscrapperPlotThumbCard, SkyscrapperPlotThumbCardBody, SkyscrapperPlotThumbCardImage, SkyscrapperPlotThumbCardRoot, SkyscrapperPlotsShowcase, SkyscrapperPlotsShowcaseWrapper, SkyscrapperShowcaseCard, UiToolkitProvider, VoodvaleHomeFirstSection, VoodvaleHomeFirstSectionWrapper, VoodvaleHomeSecondSection, VoodvaleHomeSecondSectionWrapper, VoodvalePlotThumbCard, VoodvalePlotThumbCardBody, VoodvalePlotThumbCardImage, VoodvalePlotThumbCardRoot, VoodvalePlotsShowcase, VoodvalePlotsShowcaseWrapper, VoodvaleSection, colorPickerField, createPlotRepository, plotRepository, useMainModuleResult, usePlotRepository, useTranslation, useUiToolkitConfig, useUiToolkitConfigOptional };
